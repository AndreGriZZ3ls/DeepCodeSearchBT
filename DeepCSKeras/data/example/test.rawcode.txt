public boolean containsKey ( Name key ) { return containsKey ( "" + key ) ; } 
public final void store ( OutputStream stream , char [ ] password ) throws KeyStoreException , IOException , NoSuchAlgorithmException , CertificateException { if ( ! isInit ) { throwNotInitialized ( ) ; } implSpi . engineStore ( stream , password ) ; } 
@ SuppressWarnings ( "unchecked" ) public RegistryContext ( String host , int port , Hashtable < ? , ? > env ) throws NamingException { environment = ( env == null ) ? new Hashtable < String , Object > ( 5 ) : ( Hashtable < String , Object > ) env ; if ( environment . get ( SECURITY_MGR ) != null ) { installSecurityMgr ( ) ; } if ( ( host != null ) && ( host . charAt ( 0 ) == '[' ) ) { host = host . substring ( 1 , host . length ( ) - 1 ) ; } RMIClientSocketFactory socketFactory = ( RMIClientSocketFactory ) environment . get ( SOCKET_FACTORY ) ; registry = getRegistry ( host , port , socketFactory ) ; this . host = host ; this . port = port ; } 
public int singleNumberWithMap ( int [ ] nums ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i : nums ) { if ( map . containsKey ( i ) ) { map . put ( i , map . get ( i ) + 1 ) ; } else { map . put ( i , 1 ) ; } } for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) < 3 ) { return entry . getKey ( ) ; } } for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { if ( entry . getValue ( ) < 3 ) { return entry . getKey ( ) ; } } for ( Object o : map . entrySet ( ) ) { Map . Entry entry = ( Map . Entry ) o ; if ( ( Integer ) entry . getValue ( ) == 1 ) { return ( Integer ) entry . getKey ( ) ; } } return 0 ; } 
public void setActions ( Action [ ] actions ) { this . actions = ( actions == null ) ? null : actions . clone ( ) ; } 
public void pauseProcessing ( final double time ) { Vector < Core > cores = this . getCores ( ) ; Iterator < Core > iter = cores . iterator ( ) ; while ( iter . hasNext ( ) ) { Core core = iter . next ( ) ; core . pauseProcessing ( time ) ; } } 
public float bottom ( float margin ) { return pageSize . bottom ( marginBottom + margin ) ; } 
public Icon getIconForButton ( String buttonName ) { String fileName = ( String ) BUTTON_NAMES . get ( buttonName ) ; if ( fileName == null ) return null ; ImageIcon icon = ( ImageIcon ) BUTTON_CACHE . get ( fileName ) ; if ( icon == NULL ) return null ; if ( icon != null ) return icon ; try { String retrieveName ; if ( UISettings . SMALL_ICONS . getValue ( ) ) retrieveName = fileName + "_small" ; else retrieveName = fileName + "_large" ; icon = ResourceManager . getThemeImage ( retrieveName ) ; BUTTON_CACHE . put ( fileName , icon ) ; } catch ( MissingResourceException mre ) { try { icon = ResourceManager . getThemeImage ( fileName ) ; BUTTON_CACHE . put ( fileName , icon ) ; } catch ( MissingResourceException mre2 ) { BUTTON_CACHE . put ( fileName , NULL ) ; } } return icon ; } 
public static String encodeObject ( java . io . Serializable serializableObject ) { return encodeObject ( serializableObject , NO_OPTIONS ) ; } 
public void unparsedEntityDecl ( String name , XMLResourceIdentifier identifier , String notation , Augmentations augs ) throws XNIException { if ( fValidation ) { fNDataDeclNotations . put ( name , notation ) ; } if ( fDTDGrammar != null ) fDTDGrammar . unparsedEntityDecl ( name , identifier , notation , augs ) ; if ( fDTDHandler != null ) { fDTDHandler . unparsedEntityDecl ( name , identifier , notation , augs ) ; } } 
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( decoder != null ) { decoder . reset ( ) ; } decoder = null ; if ( in != null ) { in . close ( ) ; in = null ; } } } 
public RGBColor toGreyScale ( ) { return new RGBColor ( 0.30 * getRed ( ) + 0.59 * getGreen ( ) + 0.11 * getBlue ( ) ) ; } 
public Builder before ( Animator anim ) { Node node = mNodeMap . get ( anim ) ; if ( node == null ) { node = new Node ( anim ) ; mNodeMap . put ( anim , node ) ; mNodes . add ( node ) ; } Dependency dependency = new Dependency ( mCurrentNode , Dependency . AFTER ) ; node . addDependency ( dependency ) ; return this ; } 
final void runWorker ( Worker w ) { Thread wt = Thread . currentThread ( ) ; Runnable task = w . firstTask ; w . firstTask = null ; w . unlock ( ) ; boolean completedAbruptly = true ; try { while ( task != null || ( task = getTask ( ) ) != null ) { w . lock ( ) ; if ( ( runStateAtLeast ( ctl . get ( ) , STOP ) || ( Thread . interrupted ( ) && runStateAtLeast ( ctl . get ( ) , STOP ) ) ) && ! wt . isInterrupted ( ) ) wt . interrupt ( ) ; try { beforeExecute ( wt , task ) ; Throwable thrown = null ; try { runTask ( task ) ; } catch ( RuntimeException x ) { thrown = x ; throw x ; } catch ( Error x ) { thrown = x ; throw x ; } catch ( Throwable x ) { thrown = x ; throw new Error ( x ) ; } finally { afterExecute ( task , thrown ) ; } } finally { task = null ; w . completedTasks ++ ; w . unlock ( ) ; } } completedAbruptly = false ; } finally { processWorkerExit ( w , completedAbruptly ) ; } } 
public Package getPackage ( ) { return Package . getPackage ( this ) ; } 
public void doPostSubmitCall ( Item submitItem , HtmlForm form ) { if ( form == null ) { return ; } StringBuffer sb = new StringBuffer ( ) ; Hashtable elements = form . getFormElements ( this . formListener , submitItem ) ; Enumeration enumeration = elements . keys ( ) ; while ( enumeration . hasMoreElements ( ) ) { String name = ( String ) enumeration . nextElement ( ) ; String value = ( String ) elements . get ( name ) ; value = TextUtil . encodeUrl ( value ) ; sb . append ( name ) . append ( '=' ) . append ( value ) ; if ( enumeration . hasMoreElements ( ) ) { sb . append ( '&' ) ; } } this . browser . go ( this . browser . makeAbsoluteURL ( form . getAction ( ) ) , sb . toString ( ) ) ; } 
public static String getNextTag ( String xmlData , int position ) { String nextTag = null ; if ( xmlData != null && ! xmlData . isEmpty ( ) && position < xmlData . length ( ) && xmlData . substring ( position ) . contains ( "<" ) ) { while ( xmlData . charAt ( position ) != '<' ) { position ++ ; } int startIndex = position ; if ( xmlData . substring ( position ) . contains ( ">" ) ) { while ( xmlData . charAt ( position ) != '>' ) { position ++ ; } nextTag = xmlData . substring ( startIndex , position + 1 ) ; } } return nextTag ; } 
public Date engineGetCreationDate ( String alias ) { KeyEntry entry = entries . get ( alias . toLowerCase ( ) ) ; if ( entry != null ) { return new Date ( entry . date . getTime ( ) ) ; } else { return null ; } } 
public static String encode ( String p ) { if ( p == null ) { return "" ; } if ( ! "1.0" . equals ( outVersion ) ) { return p ; } try { String p1 = URLEncoder . encode ( p , CHAR_SET ) ; return p1 ; } catch ( UnsupportedEncodingException e ) { log . warn ( "System-doesn't-support-" + CHAR_SET , e ) ; return p ; } } 
public double dotProduct ( OpenMapRealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; boolean thisIsSmaller = entries . size ( ) < v . entries . size ( ) ; Iterator iter = thisIsSmaller ? entries . iterator ( ) : v . entries . iterator ( ) ; OpenIntToDoubleHashMap larger = thisIsSmaller ? v . entries : entries ; double d = 0 ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; d += iter . value ( ) * larger . get ( iter . key ( ) ) ; } return d ; } 
public void addClientSocketListener ( ClientSocketListener listener ) { if ( listener == null ) throw new NullPointerException ( ) ; listeners . add ( listener ) ; } 
public static void addURL ( URL u ) throws IOException { ClassloaderUtil clu = new ClassloaderUtil ( ) ; URLClassLoader sysLoader = ( URLClassLoader ) clu . getClass ( ) . getClassLoader ( ) ; URL urls [ ] = sysLoader . getURLs ( ) ; for ( URL url : urls ) { if ( url . toString ( ) . toLowerCase ( ) . equals ( u . toString ( ) . toLowerCase ( ) ) ) { System . err . println ( "URL-" + u + "-is-already-in-the-CLASSPATH" ) ; return ; } } Class < ? > sysclass = URLClassLoader . class ; try { Method method = sysclass . getDeclaredMethod ( "addURL" , parameters ) ; method . setAccessible ( true ) ; method . invoke ( sysLoader , new Object [ ] { u } ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; throw new IOException ( "Error,-could-not-add-URL-to-system-classloader" ) ; } } 
final void addProcessToGcListLocked ( ProcessRecord proc ) { boolean added = false ; for ( int i = mProcessesToGc . size ( ) - 1 ; i >= 0 ; i -- ) { if ( mProcessesToGc . get ( i ) . lastRequestedGc < proc . lastRequestedGc ) { added = true ; mProcessesToGc . add ( i + 1 , proc ) ; break ; } } if ( ! added ) { mProcessesToGc . add ( 0 , proc ) ; } } 
public static void snapshot ( ) { Dimension dim = getInstance ( ) . component . getPreferredSize ( ) ; java . awt . Rectangle rect = new java . awt . Rectangle ( 0 , 0 , dim . width , dim . height ) ; BufferedImage image = new BufferedImage ( rect . width , rect . height , BufferedImage . TYPE_INT_RGB ) ; Graphics g = image . getGraphics ( ) ; g . setColor ( java . awt . Color . WHITE ) ; g . fillRect ( 0 , 0 , rect . width , rect . height ) ; g . setColor ( java . awt . Color . BLACK ) ; getInstance ( ) . component . paintComponent ( g ) ; float factor = 0.8f ; float base = 255f * ( 1f - factor ) ; RescaleOp op = new RescaleOp ( factor , base , null ) ; BufferedImage filteredImage = new BufferedImage ( image . getWidth ( ) , image . getHeight ( ) , image . getType ( ) ) ; op . filter ( image , filteredImage ) ; getInstance ( ) . background = filteredImage ; getInstance ( ) . component . repaint ( ) ; } 
public static SecureRandom getInstance ( String algorithm ) throws NoSuchAlgorithmException { if ( algorithm == null ) { throw new NullPointerException ( ) ; } synchronized ( engine ) { engine . getInstance ( algorithm , null ) ; return new SecureRandom ( ( SecureRandomSpi ) engine . spi , engine . provider , algorithm ) ; } } 
static Class findProviderClass ( String className , ClassLoader cl , boolean doFallback ) throws ClassNotFoundException , ConfigurationError { SecurityManager security = System . getSecurityManager ( ) ; try { if ( security != null ) { final int lastDot = className . lastIndexOf ( "." ) ; String packageName = className ; if ( lastDot != - 1 ) packageName = className . substring ( 0 , lastDot ) ; security . checkPackageAccess ( packageName ) ; } } catch ( SecurityException e ) { throw e ; } Class providerClass ; if ( cl == null ) { providerClass = Class . forName ( className ) ; } else { try { providerClass = cl . loadClass ( className ) ; } catch ( ClassNotFoundException x ) { if ( doFallback ) { ClassLoader current = ObjectFactory . class . getClassLoader ( ) ; if ( current == null ) { providerClass = Class . forName ( className ) ; } else if ( cl != current ) { cl = current ; providerClass = cl . loadClass ( className ) ; } else { throw x ; } } else { throw x ; } } } return providerClass ; } 
@ Override public java . lang . String getProjetoTag ( ) { return _template . getProjetoTag ( ) ; } 
@ Override public XMLEventReader createXMLEventReader ( Source source ) throws XMLStreamException { try { if ( source instanceof StreamSource ) { StreamSource ss = ( StreamSource ) source ; return new WbXmlEventReader ( ss . getInputStream ( ) , ( WbXmlDefinition ) props . get ( DEFINITION_PROPERTY ) ) ; } else { throw new XMLStreamException ( "WBXML-only-support-StreamSource-with-InputStream!" ) ; } } catch ( IOException e ) { throw new XMLStreamException ( e ) ; } } 
private void sendError ( String status , String msg ) throws InterruptedException { sendResponse ( status , MIME_PLAINTEXT , null , new ByteArrayInputStream ( msg . getBytes ( ) ) ) ; throw new InterruptedException ( ) ; } 
protected java . util . Vector _getLinks ( ) { java . util . Vector links = new java . util . Vector ( ) ; return links ; } 
public void saveOffsets ( Context context ) { String str = "" ; for ( Map . Entry < Integer , Long > entry : _monitor . getOffsets ( ) . entrySet ( ) ) str += entry . getKey ( ) + "-" + entry . getValue ( ) + "," ; Utils . saveString ( PREF_OFFSETS , str , context ) ; } 
public static String createGetUsersResponse ( final List < User > userList , final String nonce , final ICryptoUtils cryptoUtils ) throws ParserConfigurationException , TransformerException { final Document xmlResponse = DocumentBuilderFactory . newInstance ( ) . newDocumentBuilder ( ) . newDocument ( ) ; Element root = null ; Element users = null ; Element user = null ; Element leaf = null ; User userObject = null ; xmlResponse . setXmlStandalone ( true ) ; root = xmlResponse . createElementNS ( NS_URI , PREFIX + RESPONSE ) ; xmlResponse . appendChild ( root ) ; users = xmlResponse . createElement ( PREFIX + USERS ) ; root . appendChild ( users ) ; if ( userList != null ) { for ( int i = 0 ; i < userList . size ( ) ; i ++ ) { userObject = userList . get ( i ) ; user = xmlResponse . createElement ( PREFIX + USER ) ; users . appendChild ( user ) ; leaf = xmlResponse . createElement ( PREFIX + USER_ID ) ; leaf . setTextContent ( cryptoUtils . encodeBase64 ( userObject . getUserID ( ) ) ) ; user . appendChild ( leaf ) ; leaf = xmlResponse . createElement ( PREFIX + EMAIL ) ; leaf . setTextContent ( userObject . getEmailAddress ( ) ) ; user . appendChild ( leaf ) ; } } leaf = xmlResponse . createElement ( PREFIX + NONCE ) ; leaf . setTextContent ( nonce ) ; root . appendChild ( leaf ) ; xmlResponse . normalizeDocument ( ) ; return convertDomToString ( new DOMSource ( xmlResponse ) ) ; } 
public T createElement ( String token ) throws IOException , IllegalArgumentException , JFugueException , ParserError { return createElement ( new PushbackReader ( new StringReader ( token ) ) , Environment . getInstance ( ) ) ; } 
public boolean isFocused ( ) { if ( m_Control == null ) return false ; return m_Control . isFocusControl ( ) ; } 
private static void notifyUserDataHandlers ( short operation , Node source , NodeImpl destination ) { if ( ! ( source instanceof NodeImpl ) ) { return ; } NodeImpl srcImpl = ( NodeImpl ) source ; if ( srcImpl . document == null ) { return ; } for ( Map . Entry < String , UserData > entry : srcImpl . document . getUserDataMapForRead ( srcImpl ) . entrySet ( ) ) { UserData userData = entry . getValue ( ) ; if ( userData . handler != null ) { userData . handler . handle ( operation , entry . getKey ( ) , userData . value , source , destination ) ; } } } 
public static long getFreeDiskSpace ( boolean checkInternal ) { String status = Environment . getExternalStorageState ( ) ; long freeSpace = 0 ; if ( status . equals ( Environment . MEDIA_MOUNTED ) ) { freeSpace = freeSpaceCalculation ( Environment . getExternalStorageDirectory ( ) . getPath ( ) ) ; } else if ( checkInternal ) { freeSpace = freeSpaceCalculation ( "/" ) ; } else { return - 1 ; } return freeSpace ; } 
public synchronized void setLocaleProvider ( LocaleProvider provider ) { if ( provider != this . localeProvider ) { this . localeProvider = provider ; localeCollectorCache . clear ( ) ; } } 
public void removePropertyChangeListener ( String name , PropertyChangeListener pcl ) { m_bcSupport . removePropertyChangeListener ( name , pcl ) ; } 
public void setMaximumPoolSize ( int maximumPoolSize ) { if ( maximumPoolSize <= 0 || maximumPoolSize < corePoolSize ) throw new IllegalArgumentException ( ) ; final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { int extra = this . maximumPoolSize - maximumPoolSize ; this . maximumPoolSize = maximumPoolSize ; if ( extra > 0 && poolSize > maximumPoolSize ) { Iterator < Worker > it = workers . iterator ( ) ; while ( it . hasNext ( ) && extra > 0 && poolSize > maximumPoolSize ) { it . next ( ) . interruptIfIdle ( ) ; -- extra ; } } } finally { mainLock . unlock ( ) ; } } 
public void incDfsUsed ( long value ) { used . addAndGet ( value ) ; } 
public Object getValue ( ) { loadFromStore ( ) ; return super . getValue ( ) ; } 
public static boolean hasRotated ( Location first , Location second ) { return first . getPitch ( ) != second . getPitch ( ) || first . getYaw ( ) != second . getYaw ( ) ; } 
public static double [ ] copyOfRange ( double [ ] original , int from , int to ) { int newLength = to - from ; if ( newLength < 0 ) throw new IllegalArgumentException ( from + "->-" + to ) ; double [ ] copy = new double [ newLength ] ; System . arraycopy ( original , from , copy , 0 , Math . min ( original . length - from , newLength ) ) ; return copy ; } 
protected void registerTypeface ( String family , File file ) { try { Method method = Typeface . class . getMethod ( "registerTypeface" , String . class , File . class ) ; method . invoke ( null , family , file ) ; } catch ( NoSuchMethodException e ) { Log . i ( TAG , "registerTypeface-is-not-available-on-non-Spot-Labs-devices." ) ; } catch ( InvocationTargetException e ) { Log . w ( TAG , "Error-registering-typeface" , e ) ; } catch ( IllegalAccessException e ) { Log . w ( TAG , "Error-registering-typeface" , e ) ; } } 
private static String translate ( final String s , final Locale locale ) { try { ResourceBundle bundle = ResourceBundle . getBundle ( "org.apache.commons.math.MessagesResources" , locale ) ; if ( bundle . getLocale ( ) . getLanguage ( ) . equals ( locale . getLanguage ( ) ) ) { return bundle . getString ( s ) ; } } catch ( MissingResourceException mre ) { } return s ; } 
public static String getProperty ( String name ) { if ( manager == null ) { synchronized ( managerLock ) { if ( manager == null ) { manager = new PropertyManager ( propsName ) ; } } } String props = manager . getProp ( name ) ; if ( props == null ) return null ; try { props = new String ( props . getBytes ( "ISO-8859-1" ) ) ; } catch ( Exception e ) { } return props ; } 
public String getGameState ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( mazeIndex + "," + totalTime + "," + score + "," + currentLevelTime + "," + levelCount + "," + pacman . currentNodeIndex + "," + pacman . lastMoveMade + "," + pacman . numberOfLivesRemaining + "," + pacman . hasReceivedExtraLife + "," ) ; for ( Ghost ghost : ghosts . values ( ) ) sb . append ( ghost . currentNodeIndex + "," + ghost . edibleTime + "," + ghost . lairTime + "," + ghost . lastMoveMade + "," ) ; for ( int i = 0 ; i < currentMaze . pillIndices . length ; i ++ ) if ( pills . get ( i ) ) sb . append ( "1" ) ; else sb . append ( "0" ) ; sb . append ( "," ) ; for ( int i = 0 ; i < currentMaze . powerPillIndices . length ; i ++ ) if ( powerPills . get ( i ) ) sb . append ( "1" ) ; else sb . append ( "0" ) ; sb . append ( "," ) ; sb . append ( timeOfLastGlobalReversal ) ; sb . append ( "," ) ; sb . append ( pacmanWasEaten ) ; sb . append ( "," ) ; for ( GHOST ghost : GHOST . values ( ) ) { sb . append ( ghostsEaten . get ( ghost ) ) ; sb . append ( "," ) ; } sb . append ( pillWasEaten ) ; sb . append ( "," ) ; sb . append ( powerPillWasEaten ) ; return sb . toString ( ) ; } 
public static float [ ] trimToCapacity ( float [ ] array , int maxCapacity ) { if ( array . length > maxCapacity ) { float [ ] oldArray = array ; array = new float [ maxCapacity ] ; System . arraycopy ( oldArray , 0 , array , 0 , maxCapacity ) ; } return array ; } 
public void removeElements ( List elements ) { if ( elements . size ( ) > 0 ) { fElements . removeAll ( elements ) ; if ( fTable != null ) { fTable . remove ( elements . toArray ( ) ) ; } dialogFieldChanged ( ) ; } } 
public Accessible getAccessibleChild ( JComponent a , int b ) { Accessible returnValue = ( ( ComponentUI ) ( uis . elementAt ( 0 ) ) ) . getAccessibleChild ( a , b ) ; for ( int i = 1 ; i < uis . size ( ) ; i ++ ) { ( ( ComponentUI ) ( uis . elementAt ( i ) ) ) . getAccessibleChild ( a , b ) ; } return returnValue ; } 
public static boolean equals ( Locator lhs , Locator rhs ) { return lhs . getLineNumber ( ) == rhs . getLineNumber ( ) && lhs . getColumnNumber ( ) == rhs . getColumnNumber ( ) && equals ( lhs . getSystemId ( ) , rhs . getSystemId ( ) ) && equals ( lhs . getPublicId ( ) , rhs . getPublicId ( ) ) ; } 
public boolean setError ( ) { boolean result = errorState . compareAndSet ( 0 , 1 ) ; if ( result ) { Wrapper wrapper = getRequest ( ) . getWrapper ( ) ; if ( wrapper != null ) { wrapper . incrementErrorCount ( ) ; } } return result ; } 
public void reset ( ) { mDisabled = ! Log . isLoggable ( mTag , Log . VERBOSE ) ; if ( mDisabled ) return ; if ( mSplits == null ) { mSplits = new ArrayList < Long > ( ) ; mSplitLabels = new ArrayList < String > ( ) ; } else { mSplits . clear ( ) ; mSplitLabels . clear ( ) ; } addSplit ( null ) ; } 
public java . sql . ResultSetMetaData getMetaData ( ) throws java . sql . SQLException { checkClosed ( ) ; return new com . mysql . jdbc . ResultSetMetaData ( fields ) ; } 
public static List < Integer > getSubListIndex ( Object [ ] tofind , Object [ ] tokens ) { if ( tofind . length > tokens . length ) return null ; List < Integer > allIndices = new ArrayList < Integer > ( ) ; boolean matched = false ; int index = - 1 ; int lastUnmatchedIndex = 0 ; for ( int i = 0 ; i < tokens . length ; ) { for ( int j = 0 ; j < tofind . length ; ) { if ( tofind [ j ] . equals ( tokens [ i ] ) ) { index = i ; i ++ ; j ++ ; if ( j == tofind . length ) { matched = true ; break ; } } else { j = 0 ; i = lastUnmatchedIndex + 1 ; lastUnmatchedIndex = i ; index = - 1 ; if ( lastUnmatchedIndex == tokens . length ) break ; } if ( i >= tokens . length ) { index = - 1 ; break ; } } if ( i == tokens . length || matched ) { if ( index >= 0 ) allIndices . add ( index - tofind . length + 1 ) ; matched = false ; lastUnmatchedIndex = index ; } } return allIndices ; } 
public final void wait ( long timeout , int nanos ) throws InterruptedException { if ( timeout < 0 ) { throw new IllegalArgumentException ( "timeout-value-is-negative" ) ; } if ( nanos < 0 || nanos > 999999 ) { throw new IllegalArgumentException ( "nanosecond-timeout-value-out-of-range" ) ; } if ( nanos > 0 ) { timeout ++ ; } wait ( timeout ) ; } 
private static void warning ( String string ) { Log . warning . println ( string ) ; Log . warning . println ( "Unexpected-behavior-may-follow!" ) ; if ( ! java . awt . GraphicsEnvironment . isHeadless ( ) && System . getProperty ( "no.beast.popup" ) == null ) { JOptionPane . showMessageDialog ( null , string + "-Unexpected-behavior-may-follow!" ) ; } } 
@ XmlElementDecl ( namespace = "http://docs.oasis-open.org/wsn/b-2" , name = "NoCurrentMessageOnTopicFault" ) public JAXBElement < NoCurrentMessageOnTopicFaultType > createNoCurrentMessageOnTopicFault ( NoCurrentMessageOnTopicFaultType value ) { return new JAXBElement < NoCurrentMessageOnTopicFaultType > ( _NoCurrentMessageOnTopicFault_QNAME , NoCurrentMessageOnTopicFaultType . class , null , value ) ; } 
public int getPartIndex ( PduPart part ) { return mParts . indexOf ( part ) ; } 
ListDecor ( final Object obj ) throws DecorException { if ( obj == null || obj instanceof Collection ) { this . list = Collection . class . cast ( obj ) ; } else if ( obj instanceof Object [ ] ) { this . list = Arrays . asList ( ( Object [ ] ) obj ) ; } else { throw new DecorException ( String . format ( "Collection-or-array-required,-while-%s-provided" , obj . getClass ( ) . getName ( ) ) ) ; } } 
public DbfFile ( String file , Charset charset ) throws java . io . IOException , DbfFileException { this . charset = charset ; if ( DEBUG ) { System . out . println ( "---->uk.ac.leeds.ccg.dbffile.DbfFile-constructed.-Will-identify-itself-as-DbFi>" ) ; } InputStream in = new FileInputStream ( file ) ; EndianDataInputStream sfile = new EndianDataInputStream ( in ) ; rFile = new RandomAccessFile ( new File ( file ) , "r" ) ; if ( DEBUG ) { System . out . println ( "Dbf-file-has-initinalized" ) ; } init ( sfile ) ; } 
public Values values ( ) { if ( values1 == null ) { values1 = new Values ( this ) ; values2 = new Values ( this ) ; } if ( ! values1 . valid ) { values1 . reset ( ) ; values1 . valid = true ; values2 . valid = false ; return values1 ; } values2 . reset ( ) ; values2 . valid = true ; values1 . valid = false ; return values2 ; } 
private boolean canOwnInitializer ( Symbol sym ) { return ( sym . kind & ( VAR | TYP ) ) != 0 || ( sym . kind == MTH && ( sym . flags ( ) & BLOCK ) != 0 ) ; } 
protected final SerializerFactory findSerializerFactory ( ) { SerializerFactory factory = _serializerFactory ; if ( factory == null ) { factory = SerializerFactory . createDefault ( ) ; _defaultSerializerFactory = factory ; _serializerFactory = factory ; } return factory ; } 
public void xor ( OpenBitSet other ) { int newLen = Math . max ( wlen , other . wlen ) ; ensureCapacityWords ( newLen ) ; assert ( numBits = Math . max ( other . numBits , numBits ) ) >= 0 ; long [ ] thisArr = this . bits ; long [ ] otherArr = other . bits ; int pos = Math . min ( wlen , other . wlen ) ; while ( -- pos >= 0 ) { thisArr [ pos ] ^= otherArr [ pos ] ; } if ( this . wlen < newLen ) { System . arraycopy ( otherArr , this . wlen , thisArr , this . wlen , newLen - this . wlen ) ; } this . wlen = newLen ; } 
public void agregarReserva ( Reserva reserva ) { reservas . add ( reserva ) ; } 
public String getStepLocalName ( int opPosOfStep ) { int argLenOfStep = getArgLengthOfStep ( opPosOfStep ) ; int index ; switch ( argLenOfStep ) { case 0 : index = OpCodes . EMPTY ; break ; case 1 : index = OpCodes . ELEMWILDCARD ; break ; case 2 : index = m_opMap . elementAt ( opPosOfStep + 4 ) ; break ; case 3 : index = m_opMap . elementAt ( opPosOfStep + 5 ) ; break ; default : index = OpCodes . EMPTY ; break ; } if ( index >= 0 ) return ( String ) m_tokenQueue . elementAt ( index ) . toString ( ) ; else if ( OpCodes . ELEMWILDCARD == index ) return NodeTest . WILD ; else return null ; } 
protected static String [ ] stripFROMKeyword ( String query ) throws OdaException { char [ ] chars = query . toCharArray ( ) ; List < Integer > indiceList = new ArrayList < Integer > ( ) ; boolean inQuote = false ; boolean isEscaped = false ; LookAheadMacher matcher = new LookAheadMacher ( "FROM-" , "-" , true ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == '"' ) { if ( ! isEscaped ) inQuote = ! inQuote ; else isEscaped = ! isEscaped ; } else if ( chars [ i ] == '|' ) { isEscaped = ! isEscaped ; } else if ( inQuote ) { continue ; } else { if ( matcher . match ( chars , i ) ) { indiceList . add ( i - 1 ) ; } } } String [ ] result = new String [ 2 ] ; if ( indiceList . size ( ) > 0 ) { int splitInd = indiceList . get ( indiceList . size ( ) - 1 ) ; result [ 0 ] = query . substring ( 0 , splitInd ) ; result [ 1 ] = getUnQuotedName ( query . substring ( splitInd + matcher . getPatternLength ( ) ) ) ; } else throw new OdaException ( Messages . getString ( "query_COMMAND_NOT_VALID" ) ) ; return result ; } 
public void set ( int row , int col , Number value ) { if ( value == null ) { synchronized ( data ) { data [ row ] [ col ] = - 99 ; } } else { synchronized ( data ) { data [ row ] [ col ] = value . shortValue ( ) ; } } } 
public static String eclipseUrlToVm ( String url ) { if ( url == null ) { return null ; } if ( url . startsWith ( ECLIPSE_FORMAT ) ) { URI uri = URI . create ( url ) ; url = uri . getScheme ( ) + "://" + uri . getPath ( ) ; } return url ; } 
public void addXTextLabel ( double x , String text ) { mXTextLabels . put ( x , text ) ; } 
private String readString ( ) { final byte [ ] stream_ = this . stream ; int parenLevel = 0 ; final StringBuffer sb = new StringBuffer ( ) ; for ( int to = stream_ . length ; loc < to ; ) { int c = stream_ [ loc ++ ] ; if ( c == ')' ) { if ( parenLevel -- == 0 ) { break ; } } else if ( c == '(' ) { parenLevel ++ ; } else if ( c == '|' ) { c = stream_ [ loc ++ ] ; if ( c >= '0' && c < '8' ) { int val = 0 ; for ( int count = 0 ; c >= '0' && c < '8' && count < 3 ; ++ count ) { val = ( val << 3 ) + c - '0' ; c = stream_ [ loc ++ ] ; } loc -- ; c = val ; } else if ( c == 'n' ) { c = '|n' ; } else if ( c == 'r' ) { c = '|r' ; } else if ( c == 't' ) { c = '|t' ; } else if ( c == 'b' ) { c = '|b' ; } else if ( c == 'f' ) { c = '|f' ; } } sb . append ( ( char ) c ) ; } return sb . toString ( ) ; } 
private void writeQName ( javax . xml . namespace . QName qname , javax . xml . stream . XMLStreamWriter xmlWriter ) throws javax . xml . stream . XMLStreamException { java . lang . String namespaceURI = qname . getNamespaceURI ( ) ; if ( namespaceURI != null ) { java . lang . String prefix = xmlWriter . getPrefix ( namespaceURI ) ; if ( prefix == null ) { prefix = generatePrefix ( namespaceURI ) ; xmlWriter . writeNamespace ( prefix , namespaceURI ) ; xmlWriter . setPrefix ( prefix , namespaceURI ) ; } if ( prefix . trim ( ) . length ( ) > 0 ) { xmlWriter . writeCharacters ( prefix + ":" + org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } else { xmlWriter . writeCharacters ( org . apache . axis2 . databinding . utils . ConverterUtil . convertToString ( qname ) ) ; } } 
public static String asHex ( byte hash [ ] ) { char buf [ ] = new char [ hash . length * 2 ] ; for ( int i = 0 , x = 0 ; i < hash . length ; i ++ ) { buf [ x ++ ] = HEX_CHARS [ ( hash [ i ] >>> 4 ) & 0xf ] ; buf [ x ++ ] = HEX_CHARS [ hash [ i ] & 0xf ] ; } return new String ( buf ) ; } 
public String getToolTipText ( MouseEvent evt ) { if ( highlights != null ) return highlights . getToolTipText ( evt ) ; else return null ; } 
public void arcTo ( float left , float top , float right , float bottom , float startAngle , float sweepAngle , boolean forceMoveTo ) { isSimplePath = false ; native_arcTo ( mNativePath , left , top , right , bottom , startAngle , sweepAngle , forceMoveTo ) ; } 
public void set ( int index , E e ) { if ( index >= data . length ) { grow ( index * 2 ) ; } size = index + 1 ; data [ index ] = e ; } 
public boolean remove ( Object e ) { if ( e == null ) return false ; Class eClass = e . getClass ( ) ; if ( eClass != elementType && eClass . getSuperclass ( ) != elementType ) return false ; long oldElements = elements ; elements &= ~ ( 1L << ( ( Enum ) e ) . ordinal ( ) ) ; return elements != oldElements ; } 
protected static EventListener removeInternal ( EventListener l , EventListener oldl ) { if ( l == oldl || l == null ) { return null ; } else if ( l instanceof AWTEventMulticaster ) { return ( ( AWTEventMulticaster ) l ) . remove ( oldl ) ; } else { return l ; } } 
protected void checkLocked ( ) { if ( isLocked ( ) ) { throw new UnsupportedOperationException ( "Cannot-modify-a-FixedOrderComparator-after-a-comparison" ) ; } } 
public void addPEPListener ( PEPListener pepListener ) { synchronized ( pepListeners ) { if ( ! pepListeners . contains ( pepListener ) ) { pepListeners . add ( pepListener ) ; } } } 
public void jsxSet_borderTopStyle ( final String borderTopStyle ) { setStyleAttribute ( "borderTopStyle" , borderTopStyle ) ; } 
public void fixupVariables ( java . util . Vector vars , int globalsSize ) { super . fixupVariables ( vars , globalsSize ) ; if ( null != m_arg2 ) m_arg2 . fixupVariables ( vars , globalsSize ) ; } 
public String getCanonicalPath ( ) throws IOException { return realpath ( getAbsolutePath ( ) ) ; } 
public void dispatchMessage ( Message msg ) { if ( msg . callback != null ) { handleCallback ( msg ) ; } else { if ( mCallback != null ) { if ( mCallback . handleMessage ( msg ) ) { return ; } } handleMessage ( msg ) ; } } 
public static boolean isFileExist ( String filePath ) { if ( StringUtils . isBlank ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return ( file . exists ( ) && file . isFile ( ) ) ; } 
public void finishedPaintingChildren ( JSplitPane pane , Graphics g ) { Iterator iterator = uis . iterator ( ) ; while ( iterator . hasNext ( ) ) { SplitPaneUI ui = ( SplitPaneUI ) iterator . next ( ) ; ui . finishedPaintingChildren ( pane , g ) ; } } 
public void addLine ( String line ) { int index = line . indexOf ( ":" , 1 ) ; if ( index != - 1 ) { addLenient ( line . substring ( 0 , index ) , line . substring ( index + 1 ) ) ; } else if ( line . startsWith ( ":" ) ) { addLenient ( "" , line . substring ( 1 ) ) ; } else { addLenient ( "" , line ) ; } } 
public static DynamicMessage parseFrom ( Descriptor type , CodedInputStream input ) throws IOException { return newBuilder ( type ) . mergeFrom ( input ) . buildParsed ( ) ; } 
public void uninstallUI ( JComponent c ) { editor . removePropertyChangeListener ( updateHandler ) ; editor . getDocument ( ) . removeDocumentListener ( updateHandler ) ; painted = false ; uninstallDefaults ( ) ; rootView . setView ( null ) ; c . removeAll ( ) ; LayoutManager lm = c . getLayout ( ) ; if ( lm instanceof UIResource ) { c . setLayout ( null ) ; } uninstallKeyboardActions ( ) ; uninstallListeners ( ) ; editor = null ; } 
public long search ( int from , int to ) { result . set ( 0 ) ; countDown = new CountDownLatch ( threadCounter ) ; threadPool = Executors . newCachedThreadPool ( ) ; for ( Range range : splitter . split ( new Range ( from , to ) , threadCounter ) ) threadPool . execute ( new Search ( range ) ) ; try { countDown . await ( ) ; } catch ( InterruptedException e ) { } threadPool . shutdown ( ) ; return result . get ( ) ; } 
public static String buildQueryString ( Map < String , Object > queryParams ) { StringBuffer buf = new StringBuffer ( ) ; boolean firstParam = true ; try { for ( Map . Entry < String , Object > entry : queryParams . entrySet ( ) ) { if ( entry . getValue ( ) == null ) continue ; if ( entry . getValue ( ) instanceof List < ? > ) { List < ? > values = ( List < ? > ) entry . getValue ( ) ; for ( Object value : values ) { if ( ! firstParam ) { buf . append ( '&' ) ; } buf . append ( entry . getKey ( ) ) ; buf . append ( '=' ) ; buf . append ( java . net . URLEncoder . encode ( value . toString ( ) , "utf-8" ) ) ; firstParam = false ; } } else { if ( ! firstParam ) { buf . append ( '&' ) ; } buf . append ( entry . getKey ( ) ) ; buf . append ( '=' ) ; buf . append ( java . net . URLEncoder . encode ( entry . getValue ( ) . toString ( ) , "utf-8" ) ) ; firstParam = false ; } } } catch ( UnsupportedEncodingException ex ) { ex . printStackTrace ( ) ; } return buf . toString ( ) ; } 
public static final NumberFormat getInstance ( ) { return getNumberInstance ( ) ; } 
public static Deque < Float > toDeque ( float ... array ) { PreCon . notNull ( array ) ; Deque < Float > result = new ArrayDeque < > ( array . length ) ; for ( float b : array ) { result . add ( b ) ; } return result ; } 
public void setInsertDate_FromTo ( java . util . Date fromDatetime , java . util . Date toDatetime , FromToOption fromToOption ) { regFTQ ( ( fromDatetime != null ? new java . sql . Timestamp ( fromDatetime . getTime ( ) ) : null ) , ( toDatetime != null ? new java . sql . Timestamp ( toDatetime . getTime ( ) ) : null ) , getCValueInsertDate ( ) , "INSERTDATE" , fromToOption ) ; } 
public double nextCauchy ( double median , double scale ) { return delegate . nextCauchy ( median , scale ) ; } 
public int executeUpdate ( String sql , int autoGeneratedKeys ) throws SQLException { throw Util . notSupported ( ) ; } 
public void print ( ) { String result = "" ; for ( Path p = this ; p != null ; p = p . next ) { result += p . word + "," ; } if ( result . endsWith ( "," ) ) result = result . substring ( 0 , result . length ( ) - 1 ) ; System . out . println ( result ) ; } 
protected void onAttachedToWindow ( ) { if ( ( mPrivateFlags & REQUEST_TRANSPARENT_REGIONS ) != 0 ) { mParent . requestTransparentRegion ( this ) ; } if ( ( mPrivateFlags & AWAKEN_SCROLL_BARS_ON_ATTACH ) != 0 ) { initialAwakenScrollBars ( ) ; mPrivateFlags &= ~ AWAKEN_SCROLL_BARS_ON_ATTACH ; } jumpDrawablesToCurrentState ( ) ; resolveLayoutDirection ( ) ; resolvePadding ( ) ; resolveTextDirection ( ) ; resolveTextAlignment ( ) ; clearAccessibilityFocus ( ) ; if ( isFocused ( ) ) { InputMethodManager imm = InputMethodManager . peekInstance ( ) ; imm . focusIn ( this ) ; } if ( mAttachInfo != null && mDisplayList != null ) { mAttachInfo . mViewRootImpl . dequeueDisplayList ( mDisplayList ) ; } } 
public byte [ ] toBinary ( ) { int maxIndex = 1 << BITS_PER_INDEX ; byte [ ] bin1 = ArrayEncoder . encodeModQ ( ones , maxIndex ) ; byte [ ] bin2 = ArrayEncoder . encodeModQ ( negOnes , maxIndex ) ; byte [ ] bin = Arrays . copyOf ( bin1 , bin1 . length + bin2 . length ) ; System . arraycopy ( bin2 , 0 , bin , bin1 . length , bin2 . length ) ; return bin ; } 

