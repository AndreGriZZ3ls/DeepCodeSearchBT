########################## 1 #################################
-('private InputStream StringToInputStream ( String in ) { byte [ ] bytes = null ; try { bytes = in . getBytes ( IConstants . UTF8_ENCODING ) ; } catch ( UnsupportedEncodingException e ) { LogUtil . logError ( OperationsPlugin . PLUGIN_ID , e ) ; } return new ByteArrayInputStream ( bytes ) ; } \n', 0.42285228654247814)

+('private String convertStreamToString ( InputStream is , String encoding ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 512 ] ; Reader reader = null ; try { InputStreamReader isReader = encoding != null ? new InputStreamReader ( is , encoding ) : new InputStreamReader ( is ) ; reader = new BufferedReader ( isReader ) ; int n ; while ( ( n = reader . read ( buffer ) ) > 0 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42284607808892616)

+('public static String convertStreamToString ( InputStream is , String encoding ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 512 ] ; Reader reader = null ; try { InputStreamReader isReader = encoding != null ? new InputStreamReader ( is , encoding ) : new InputStreamReader ( is ) ; reader = new BufferedReader ( isReader ) ; int n ; while ( ( n = reader . read ( buffer ) ) > 0 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42284607808892616)

+('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42189944410094926)

-('public static InputStream toInputStream ( String input , String encoding ) throws IOException { byte [ ] bytes = encoding != null ? input . getBytes ( encoding ) : input . getBytes ( UTF_8 ) ; return new ByteArrayInputStream ( bytes ) ; } \n', 0.41938391001987496)

-('protected InputStream stringToInputStream ( String input , String encoding ) throws UnsupportedEncodingException { if ( encoding == null || encoding . trim ( ) . length ( ) == 0 ) { encoding = Constants . DEFAULT_ENCODING ; } return new ByteArrayInputStream ( input . getBytes ( encoding ) ) ; } \n', 0.419226961657291)

-('public static InputStream toInputStream ( final String input , final String encoding ) throws IOException { final byte [ ] bytes = encoding != null ? input . getBytes ( encoding ) : input . getBytes ( ) ; return new ByteArrayInputStream ( bytes ) ; } \n', 0.4191815003957003)

+('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

-('public static InputStream toInputStream ( String input , Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; } \n', 0.41595540790817354)

-('public static InputStream toInputStream ( final String input , final Charset encoding ) { return new ByteArrayInputStream ( input . getBytes ( Charsets . toCharset ( encoding ) ) ) ; } \n', 0.41595540790817354)

FRank: 2  | P@1: 0  | P@5: 3  | P@10: 4

########################## 2 #################################
+('static public ArrayList createArrayList ( Object [ ] a ) { ArrayList al = new ArrayList ( a . length ) ; for ( int i = 0 ; i < a . length ; i ++ ) al . add ( a [ i ] ) ; return al ; } \n', 0.4137767382002263)

-('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final int initialCapacity ) { return Util . makeArrayList ( initialCapacity ) ; } \n', 0.41296845214140654)

+('public static List createArrayList ( Object [ ] values ) { List ret = new ArrayList ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) { ret . add ( values [ i ] ) ; } return ret ; } \n', 0.4099763289026346)

+('public static < E > ArrayList < E > newArrayList ( E ... elements ) { int capacity = computeArrayListCapacity ( elements . length ) ; ArrayList < E > list = new ArrayList < E > ( capacity ) ; Collections . addAll ( list , elements ) ; return list ; } \n', 0.4094124345634059)

+('public static < E > ArrayList < E > newArrayList ( @ SuppressWarnings ( "unchecked" ) E ... elements ) { int capacity = computeArrayListCapacity ( elements . length ) ; ArrayList < E > list = new ArrayList < E > ( capacity ) ; Collections . addAll ( list , elements ) ; return list ; } \n', 0.40857612050473163)

+('@ SafeVarargs public static < E > ArrayList < E > newArrayList ( E ... elements ) { int capacity = ( elements . length * 110 ) / 100 + 5 ; ArrayList < E > list = new ArrayList < > ( capacity ) ; Collections . addAll ( list , elements ) ; return list ; } \n', 0.40596466873285364)

-('public static ArrayList < Void > createArrayListVoid ( ) { ArrayList < Void > list = new ArrayList < Void > ( ) ; list . add ( null ) ; list . add ( null ) ; return list ; } \n', 0.4020467013025921)

+('public static ArrayList makeListFromArray ( Object [ ] obj ) { ArrayList li = new ArrayList ( ) ; for ( int i = 0 ; i < obj . length ; i ++ ) { li . add ( obj [ i ] ) ; } return li ; } \n', 0.396799157553532)

+('private static < E > ArrayList < E > newArrayList ( E ... elements ) { ArrayList < E > list = new ArrayList < E > ( ) ; Collections . addAll ( list , elements ) ; return list ; } \n', 0.3900169162074504)

-('public static < T > ArrayList < T > arrayList ( int initialCapacity ) { return new ArrayList < T > ( initialCapacity ) ; } \n', 0.3892778720758593)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 7

########################## 3 #################################
+('public HashMap < String , Word > iterateMap ( HashMap < String , Word > localDictionary , HashMap < String , Word > incomingHash ) { HashMap < String , Word > output = new HashMap < String , Word > ( ) ; for ( Word h : incomingHash . values ( ) ) { output . putAll ( iterateWord ( localDictionary , h ) ) ; } return output ; } \n', 0.4002496321063599)

-('public QueuedMap ( int size ) throws IllegalArgumentException { if ( size <= 0 ) { throw new IllegalArgumentException ( "Size-can-only-be-a-+ive-Integer" ) ; } if ( size > QueuedMap . MAX_SIZE ) throw new IllegalArgumentException ( "Size-cannot-be-more-than-" + QueuedMap . MAX_SIZE ) ; this . size = size ; this . values = new HashMap < K , V > ( this . size ) ; this . keys = new LinkedList < K > ( ) ; } \n', 0.3911195162876043)

+('public static Iterator < Map . Entry < Object , PropertyDefinition >> getPropertyDefinitionEntryIterator ( ) { return SUPPORTED_DOCUMENT_PROPERTIES . entrySet ( ) . iterator ( ) ; } \n', 0.3911139992047282)

-('public static < T , X , E extends Throwable > Collection < X > flatMap ( Iterable < T > coll , AFunction1 < ? super T , ? extends Iterable < X > , E > f ) throws E { final List < X > result = new ArrayList < > ( ) ; for ( T o : coll ) { for ( X el : f . apply ( o ) ) { result . add ( el ) ; } } return result ; } \n', 0.390253192032775)

+('@ Override public Iterable < MetaProperty < ? >> metaPropertyIterable ( ) { return metaPropertyMap . values ( ) ; } \n', 0.39005120624112016)

-('@ Deprecated public static < K , V > Map < K , V > collectEntries ( Collection < ? > self , Closure < ? > transform ) { return collectEntries ( ( Iterable ) self , new LinkedHashMap < K , V > ( ) , transform ) ; } \n', 0.3886451652671652)

-('private MapIterator ( ) { if ( sequenceIndexOfMapInRam != INVALID_SEQUENCE_INDEX ) referenceIndices . add ( sequenceIndexOfMapInRam ) ; referenceIndexIterator = referenceIndices . iterator ( ) ; advanceToNextNonEmptyReferenceIndex ( ) ; } \n', 0.3881687498279527)

-('public static < T , X , E extends Throwable > List < X > flatMapList ( Iterable < T > coll , AFunction1 < ? super T , ? extends Iterable < X > , E > f ) throws E { final List < X > result = new ArrayList < > ( ) ; for ( T o : coll ) { for ( X el : f . apply ( o ) ) { result . add ( el ) ; } } return result ; } \n', 0.38743772576507346)

+('protected BidiOrderedMapIterator ( AbstractDualBidiMap < K , V > parent ) { super ( ) ; this . parent = parent ; iterator = new ArrayList < Map . Entry < K , V >> ( parent . entrySet ( ) ) . listIterator ( ) ; } \n', 0.38692192130537983)

+('protected BidiOrderedMapIterator ( final AbstractDualBidiMap < K , V > parent ) { super ( ) ; this . parent = parent ; iterator = new ArrayList < Map . Entry < K , V >> ( parent . entrySet ( ) ) . listIterator ( ) ; } \n', 0.38692192130537983)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 5

########################## 4 #################################
+('public static int getRandomInRange ( int min , int max ) throws IllegalArgumentException { if ( min > max ) { throw new IllegalArgumentException ( "Minimum-cannot-be-larger-than-maximum" ) ; } if ( min == max ) { return min ; } int ret = new Random ( ) . nextInt ( max + 1 - min ) + min ; if ( ret < min || ret > max ) { throw new IllegalStateException ( "Programmer-messed-up:-Value-" + ret + "is-not-within-range-of-" + min + "-and-" + max ) ; } return ret ; } \n', 0.44109220995939147)

+('private QueryInterval [ ] generateRandomIntervals ( final int numReferences , final int count , final Random generator ) { final QueryInterval [ ] intervals = new QueryInterval [ count ] ; final int maxCoordinate = 10000000 ; for ( int i = 0 ; i < count ; i ++ ) { final int referenceIndex = generator . nextInt ( numReferences ) ; final int coord1 = generator . nextInt ( maxCoordinate + 1 ) ; final int coord2 = generator . nextInt ( maxCoordinate + 1 ) ; final int startPos = Math . min ( coord1 , coord2 ) ; final int endPos = Math . max ( coord1 , coord2 ) ; intervals [ i ] = new QueryInterval ( referenceIndex , startPos , endPos ) ; } return intervals ; } \n', 0.437937625810701)

+('public static String getRandomString ( int numberOfLetters , char [ ] alphabet , boolean includeNumbers ) { StringBuilder builder = new StringBuilder ( ) ; int upperRange = alphabet . length - 1 ; builder . append ( alphabet [ generator . nextInt ( upperRange ) ] ) ; if ( includeNumbers ) { upperRange += NUMBERS . length ; } for ( int i = 1 ; i < numberOfLetters ; i ++ ) { int letterIndex = generator . nextInt ( upperRange ) ; if ( letterIndex > alphabet . length - 1 ) { builder . append ( NUMBERS [ letterIndex - alphabet . length ] ) ; } else { builder . append ( alphabet [ letterIndex ] ) ; } } return builder . toString ( ) ; } \n', 0.43109270821991674)

+('public static int randomRangeBound ( int minDigits , int maxDigits ) { int digitBoundDiff = maxDigits - minDigits + 1 ; int i = rn . nextInt ( ) % digitBoundDiff ; if ( i < 0 ) { i = - i ; } return minDigits + i ; } \n', 0.4307830677491995)

-('protected OutOfBoundsRandomValue ( final OutOfBoundsRandomValue < T > outOfBounds ) { super ( outOfBounds ) ; this . value = outOfBounds . value . copy ( ) ; this . minValue = outOfBounds . minValue ; this . maxValue = outOfBounds . maxValue ; this . range = outOfBounds . range ; this . rnd = new Random ( ) ; } \n', 0.4293264727925863)

+('public static int [ ] getRandomInRange ( int integerRange , int required ) { ArrayList < Integer > array = new ArrayList < > ( ) ; int [ ] numbersPicked = new int [ required ] ; for ( int j = 0 ; j < integerRange ; j ++ ) { array . add ( j ) ; } Collections . shuffle ( array ) ; for ( int j = 0 ; j < required ; j ++ ) { numbersPicked [ j ] = array . get ( j ) ; } return numbersPicked ; } \n', 0.4292935034684725)

-('double randomInRange ( double min , double max ) { Random random = new Random ( ) ; double range = max - min ; double scaled = random . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.4260948867782801)

-('private static List < Interval < Integer , Integer >> randomIntervals ( int range , int increment , int count ) { List < Integer > a = random ( range , increment , count ) ; List < Integer > b = random ( range , increment , count ) ; List < Interval < Integer , Integer >> r = new ArrayList < > ( ) ; for ( int i = 0 ; i < count ; i ++ ) { r . add ( a . get ( i ) < b . get ( i ) ? Interval . create ( a . get ( i ) , b . get ( i ) , i ) : Interval . create ( b . get ( i ) , a . get ( i ) , i ) ) ; } return r ; } \n', 0.42441282759705123)

-('public static double randomDoubleInRange ( double rangeMin , double rangeMax ) { Random r = new Random ( ) ; double doubleInRange = rangeMin + ( rangeMax - rangeMin ) * r . nextDouble ( ) ; return doubleInRange ; } \n', 0.42378763477641407)

-('private int [ ] generateMutationPositions ( int seqLength ) { Random n = new Random ( ) ; int [ ] positions = new int [ 2 ] ; double [ ] tempprobs = new double [ seqLength ] ; int maxIndex = getMutationProbs ( ) . length - 1 ; for ( int i = 1 ; i <= seqLength ; i ++ ) { int index = Math . min ( i - 1 , maxIndex ) ; double mutProb = getMutationProbs ( ) [ index ] - n . nextDouble ( ) ; if ( mutProb >= 0 ) { tempprobs [ i - 1 ] = mutProb ; } else { tempprobs [ i - 1 ] = 0 ; } } double highest = 0 ; double second = 0 ; for ( int j = 0 ; j < tempprobs . length ; j ++ ) { double current = tempprobs [ j ] ; if ( current > second ) { if ( current > highest ) { positions [ 0 ] = positions [ 1 ] ; second = highest ; positions [ 1 ] = j + 1 ; highest = current ; } else { second = current ; positions [ 0 ] = j + 1 ; } } } if ( positions [ 0 ] > positions [ 1 ] ) { int temp = positions [ 0 ] ; positions [ 0 ] = positions [ 1 ] ; positions [ 1 ] = temp ; } return positions ; } \n', 0.42320925017224476)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 5

########################## 5 #################################
+('public Integer convertStringToInteger ( String value ) { Integer result ; try { result = Integer . valueOf ( value ) ; } catch ( NumberFormatException e ) { result = DEFAULT_INT_VALUE ; } return result ; } \n', 0.45664081378898785)

+('private Integer convertStringToInteger ( final String string ) { if ( string == null ) { return null ; } return Integer . valueOf ( string ) ; } \n', 0.45356001418004277)

+('public Integer convertStringToInteger ( String s ) { return Integer . valueOf ( s ) ; } \n', 0.45356001418004277)

+('public static int convertStringToInteger ( String number ) { int i = 0 ; try { i = Integer . valueOf ( number ) ; } catch ( Exception ex ) { } return i ; } \n', 0.44935041135899767)

+('public static Integer convertirStringToInteger ( String value ) { Integer intValue ; try { intValue = Integer . valueOf ( value ) ; } catch ( Exception e ) { return null ; } return intValue ; } \n', 0.4488489710826206)

-('public static String convertIntToStrOfLength ( int value , int length ) { String intStr = new Integer ( value ) . toString ( ) ; int lenDiff = length - intStr . length ( ) ; for ( int i = 0 ; i < lenDiff ; i ++ ) { intStr = "0" + intStr ; } return intStr ; } \n', 0.4439970319394574)

-('public String convertIntegerToString ( Integer value ) { if ( value == null ) { return null ; } return value . toString ( ) ; } \n', 0.440589435444195)

-('public String convertIntegerToString ( Integer integerValue ) { String strValue = null ; if ( integerValue != null ) { strValue = integerValue . toString ( ) ; } return strValue ; } \n', 0.43955677208200167)

+('public static int BinStringToInt ( String binaryString ) { return ( Integer . valueOf ( binaryString , 2 ) . intValue ( ) ) ; } \n', 0.43819450678143745)

-("long binaryStrToInt ( String sBinary ) { long digit , iResult = 0 ; int iLen = sBinary . length ( ) ; for ( int i = iLen - 1 ; i >= 0 ; i -- ) { if ( sBinary . charAt ( i ) == '1' ) digit = 1 ; else digit = 0 ; iResult += ( digit << ( iLen - i - 1 ) ) ; } return ( iResult ) ; } \n", 0.4364234538363476)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 6

########################## 6 #################################
-('private void initializeArray ( BufferedReader in ) throws IOException { int [ ] vec = null ; int n = 0 ; boolean FirstLine = true ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "#" ) || line . startsWith ( "%" ) ) { } else { StringTokenizer st = new StringTokenizer ( line ) ; n = st . countTokens ( ) ; if ( FirstLine ) { vec = new int [ n + 100 ] ; FirstLine = false ; } vec [ n ] ++ ; } } this . r = vec [ this . c ] ; for ( int i = 0 ; i < vec . length ; i ++ ) { if ( vec [ i ] > this . r ) { this . r = vec [ i ] ; this . c = i + 1 ; } } this . c = this . c - 1 ; this . data = new double [ this . r ] [ this . c ] ; } \n', 0.46105403735219797)

-('private void initializeArray ( BufferedReader in , int Col ) throws IOException { int [ ] vec = null ; int n = 0 ; boolean FirstLine = true ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . startsWith ( "#" ) || line . startsWith ( "%" ) ) { } else { StringTokenizer st = new StringTokenizer ( line ) ; n = st . countTokens ( ) ; if ( FirstLine ) { vec = new int [ n + 100 ] ; FirstLine = false ; } vec [ n ] ++ ; } } this . r = vec [ Col ] ; this . c = Col ; this . data = new double [ this . r ] [ this . c ] ; } \n', 0.45775973385309743)

+('public void initLineMask ( LineData [ ] lines ) { if ( myLineMask == null ) { myLineMask = new int [ myLinesArray != null ? Math . max ( lines . length , myLinesArray . length ) : lines . length ] ; Arrays . fill ( myLineMask , 0 ) ; if ( myLinesArray != null ) { for ( int i = 0 ; i < myLinesArray . length ; i ++ ) { final LineData data = myLinesArray [ i ] ; if ( data != null ) { myLineMask [ i ] = data . getHits ( ) ; } } } } else { if ( myLineMask . length < lines . length ) { int [ ] lineMask = new int [ lines . length ] ; System . arraycopy ( myLineMask , 0 , lineMask , 0 , myLineMask . length ) ; myLineMask = lineMask ; } for ( int i = 0 ; i < lines . length ; i ++ ) { if ( lines [ i ] != null ) { myLineMask [ i ] += lines [ i ] . getHits ( ) ; } } } } \n', 0.4282154101777743)

-('public static String [ ] initialize ( String [ ] args ) { int idx = 0 ; for ( ; idx < args . length ; ++ idx ) { if ( args [ idx ] . equals ( "--dpj-foreach-split" ) ) { checkIdx ( "--dpj-foreach-split" , idx , args . length ) ; dpjForeachSplit = Integer . parseInt ( args [ ++ idx ] ) ; if ( dpjForeachSplit < 1 ) { error ( "DPJ-foreach-split-must-be-greater-than-0;-" + dpjForeachSplit + "-is-not-valid" ) ; } } else if ( args [ idx ] . equals ( "--dpj-foreach-cutoff" ) ) { checkIdx ( "--dpj-foreach-cutoff" , idx , args . length ) ; dpjForeachCutoff = Integer . parseInt ( args [ ++ idx ] ) ; } else if ( args [ idx ] . equals ( "--dpj-num-threads" ) ) { checkIdx ( "--dpj-num-threads" , idx , args . length ) ; dpjNumThreads = Integer . parseInt ( args [ ++ idx ] ) ; if ( dpjNumThreads < 1 ) { error ( "DPJ-num-threads-must-be-greater-than-0;-" + dpjNumThreads + "is-not-valid" ) ; } } else { break ; } } String [ ] newArgs = new String [ args . length - idx ] ; System . arraycopy ( args , idx , newArgs , 0 , newArgs . length ) ; return newArgs ; } \n', 0.4141681690724626)

-("public void initializeScanner ( char [ ] translationUnitSource ) { scanner . setSource ( translationUnitSource ) ; scannerEndPosition = translationUnitSource . length ; scanner . resetTo ( 0 , scannerEndPosition ) ; edits = new OptimizedReplaceEdit [ INITIAL_SIZE ] ; lineOffsets = new int [ 200 ] ; numLines = 0 ; lineOffsets [ numLines ++ ] = 0 ; for ( int i = 0 ; i < translationUnitSource . length ; i ++ ) { if ( translationUnitSource [ i ] == '|n' ) { int len = lineOffsets . length ; if ( numLines >= len ) System . arraycopy ( lineOffsets , 0 , lineOffsets = new int [ len + ( len + 1 ) / 2 ] , 0 , len ) ; lineOffsets [ numLines ++ ] = i + 1 ; } } } \n", 0.4119421149134893)

-('public static double [ ] InitializeVector ( String line ) { double [ ] v = new double [ DIMENSIONS_OF_VECTORS ] ; StringTokenizer token = new StringTokenizer ( line , "," ) ; while ( token . hasMoreTokens ( ) ) { for ( int i = 0 ; i < DIMENSIONS_OF_VECTORS ; i ++ ) { String t = token . nextToken ( ) . toString ( ) ; v [ i ] = Double . parseDouble ( t ) ; } } return v ; } \n', 0.40499811724536433)

-('public static String [ ] [ ] [ ] initFive ( String [ ] parts ) { if ( parts . length != 6 ) { System . err . println ( "Problem.-Size-of-input-array-should-be-5." ) ; System . exit ( 0 ) ; } StringTokenizer st ; st = new StringTokenizer ( parts [ 0 ] , "-" ) ; int count = st . countTokens ( ) ; String [ ] [ ] [ ] parseData = new String [ count ] [ 6 ] [ ] ; for ( int p = 0 ; p < 6 ; p ++ ) { String [ ] series = parts [ p ] . split ( "-||||-" ) ; for ( int j = 0 ; j < count ; j ++ ) parseData [ j ] [ p ] = new String [ series . length ] ; for ( int s = 0 ; s < series . length ; s ++ ) { st = new StringTokenizer ( series [ s ] , "-" ) ; if ( st . countTokens ( ) != count ) { System . err . println ( "Problem.-Count-of-line-" + p + "-(" + st . countTokens ( ) + ")-not-equal-to-zeroth-line-(" + count + ")." ) ; System . exit ( 0 ) ; } for ( int j = 0 ; j < count ; j ++ ) { parseData [ j ] [ p ] [ s ] = st . nextToken ( ) . intern ( ) ; } } } return parseData ; } \n', 0.4025146559657977)

+('public void initialize ( ) { StringBuffer sb = new StringBuffer ( ) ; char [ ] exclusion = excludedCharacters . toString ( ) . toCharArray ( ) ; Arrays . sort ( exclusion ) ; for ( int i = 0 ; i < arabic_phonetic_array . length ; i ++ ) { char c = arabic_phonetic_array [ i ] ; if ( Arrays . binarySearch ( exclusion , c ) < 0 ) { sb . append ( c ) ; } } arabic_phonetic_array = sb . toString ( ) . toCharArray ( ) ; Arrays . sort ( arabic_phonetic_array ) ; } \n', 0.40113882350839036)

-('protected void initializeCharProbs ( ) { m_charProbs . put ( 65 , .0625 ) ; m_charProbs . put ( 66 , .02083 ) ; m_charProbs . put ( 67 , .02083 ) ; m_charProbs . put ( 68 , .03125 ) ; m_charProbs . put ( 69 , .11458 ) ; m_charProbs . put ( 70 , .02083 ) ; m_charProbs . put ( 71 , .02083 ) ; m_charProbs . put ( 72 , .05208 ) ; m_charProbs . put ( 73 , .0625 ) ; m_charProbs . put ( 74 , .01042 ) ; m_charProbs . put ( 75 , .01042 ) ; m_charProbs . put ( 76 , .04167 ) ; m_charProbs . put ( 77 , .02083 ) ; m_charProbs . put ( 78 , .0625 ) ; m_charProbs . put ( 79 , .07292 ) ; m_charProbs . put ( 80 , .02083 ) ; m_charProbs . put ( 81 , .01042 ) ; m_charProbs . put ( 82 , .05208 ) ; m_charProbs . put ( 83 , .0625 ) ; m_charProbs . put ( 84 , .09375 ) ; m_charProbs . put ( 85 , .03125 ) ; m_charProbs . put ( 86 , .02083 ) ; m_charProbs . put ( 87 , .03125 ) ; m_charProbs . put ( 88 , .01042 ) ; m_charProbs . put ( 89 , .03125 ) ; m_charProbs . put ( 90 , .01042 ) ; } \n', 0.3990293494529179)

-('private void initialiseMazeLines ( ) { vertical = new LinkedList < Line2D > ( ) ; horizontal = new LinkedList < Line2D > ( ) ; for ( int i = 0 ; i <= size ; i ++ ) { horizontal . add ( new Line2D . Double ( new Point2D . Double ( 0 , i ) , new Point2D . Double ( size , i ) ) ) ; vertical . add ( new Line2D . Double ( new Point2D . Double ( i , 0 ) , new Point2D . Double ( i , size ) ) ) ; } } \n', 0.39763715753003637)

FRank: 3  | P@1: 0  | P@5: 1  | P@10: 2

########################## 7 #################################
-('public static void checkNullAndPutValuesToArray ( int [ ] array , Object obj ) { if ( obj == null ) { throw new RuntimeException ( "Test-failed.-The-array-obtained-via-reflection-is-" + obj ) ; } for ( int i = 0 ; i < Array . getLength ( obj ) ; i ++ ) { System . out . println ( "Test-(Reflection):-" + Array . getInt ( obj , i ) ) ; array [ i ] = Array . getInt ( obj , i ) ; } } \n', 0.3834224945669291)

+('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

+('boolean hasNulls ( Object value ) { for ( int c = 0 , sz = Array . getLength ( value ) ; c < sz ; ++ c ) { if ( Array . get ( value , c ) == null ) return true ; } return false ; } \n', 0.3617053700518835)

+('private static boolean containsCheckOnDoubleArray ( double [ ] array , Double compareTest ) { double test = compareTest . doubleValue ( ) ; for ( double d : array ) if ( d == test ) return true ; return false ; } \n', 0.3602336326876485)

-('public boolean isSorted ( ) { boolean sorted = true ; for ( int i = 1 ; i < list . length && sorted == true ; i ++ ) { String thisValue = list [ i ] ; String lastValue = list [ i - 1 ] ; if ( thisValue . compareTo ( lastValue ) < 0 ) { sorted = false ; } } return sorted ; } \n', 0.3570899024410865)

-('public boolean containsAll ( Array arr ) { int sz = ( arr == null ) ? 0 : arr . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { if ( ! containsValue ( arr . get ( i ) ) ) { return false ; } } return true ; } \n', 0.35464258138657134)

-('public static < A extends AbstractAssert > A hasPksValues ( A assertion , WritableAssertionInfo info , Change change , Object ... values ) { List < Value > pksValueList = change . getPksValueList ( ) ; Value [ ] pksValues = pksValueList . toArray ( new Value [ pksValueList . size ( ) ] ) ; if ( values . length != pksValues . length ) { Object [ ] representationsValues = Values . getRepresentationsFromValuesInFrontOfExpected ( pksValues , values ) ; throw failures . failure ( info , shouldHavePksValues ( representationsValues , values ) ) ; } int index = 0 ; for ( Value pkValue : pksValueList ) { Object value = values [ index ] ; if ( ! Values . areEqual ( pkValue , value ) ) { Object [ ] representationsValues = Values . getRepresentationsFromValuesInFrontOfExpected ( pksValues , values ) ; throw failures . failure ( info , shouldHavePksValues ( representationsValues , values ) ) ; } index ++ ; } return assertion ; } \n', 0.35339659674872564)

-('public static boolean isSorted ( final float [ ] array ) { if ( array == null || array . length < 2 ) { return true ; } float previous = array [ 0 ] ; final int n = array . length ; for ( int i = 1 ; i < n ; i ++ ) { final float current = array [ i ] ; if ( Float . compare ( previous , current ) > 0 ) { return false ; } previous = current ; } return true ; } \n', 0.3533544803430768)

-('public static boolean containsValue ( Collection < PrismPropertyValue > collection , PrismPropertyValue value , Comparator comparator ) { for ( PrismPropertyValue < ? > colVal : collection ) { if ( comparator . compare ( colVal , value ) == 0 ) { return true ; } } return false ; } \n', 0.352738845967841)

+('public static boolean arrContains ( String [ ] strArray , String value ) { if ( ( strArray != null ) && ( value != null ) ) return Arrays . asList ( strArray ) . contains ( value ) ; return false ; } \n', 0.35241011243361187)

FRank: 2  | P@1: 0  | P@5: 3  | P@10: 4

########################## 8 #################################
-('public String lookupEnumString ( int e ) { String result = map . get ( e ) ; return ( result == null ) ? "Unknown-enum-value=" + e : result ; } \n', 0.4212740360120386)

+('public static < T extends Enum < T >> T getEnumFromString ( Class < T > c , String string ) throws IllegalArgumentException { if ( c != null && string != null ) { return Enum . valueOf ( c , string . trim ( ) ) ; } throw new IllegalArgumentException ( "Parameters-may-not-be-null" ) ; } \n', 0.4067414529984487)

+('public static < T extends Enum < T >> T resolveEnum ( Class < T > enumClass , String value , T defaultValue ) { if ( value == null ) { return defaultValue ; } try { return Enum . valueOf ( enumClass , value ) ; } catch ( Exception exc ) { return defaultValue ; } } \n', 0.4067031445504873)

+('public static < T extends Enum < T >> T getEnumFromString ( Class < T > enumType , String value ) { if ( value == null ) { return null ; } return Enum . valueOf ( enumType , value ) ; } \n', 0.40244945528512543)

+('public < T extends Enum < T >> T resolve ( Class < T > type ) { return Enum . valueOf ( type , value ) ; } \n', 0.3986361511770119)

+('public static < T extends Enum < T >> T getEnumFromStringCaseSensitive ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.3949518100211045)

-('protected Object findValueWithStringRepInIterator ( Iterator it , Map repToValueMap , String rep , RepSource repSource ) { while ( it . hasNext ( ) ) { Object sourceValue = it . next ( ) ; if ( sourceValue == null ) continue ; String sourceRep = repSource . getStringRep ( sourceValue ) ; repToValueMap . put ( sourceRep , sourceValue ) ; if ( rep . equals ( sourceRep ) ) return sourceValue ; } return null ; } \n', 0.3945996473258128)

-('protected Object readResolve ( ) throws ObjectStreamException { try { return getObject ( getClass ( ) , getValue ( ) ) ; } catch ( IOException e ) { return this ; } } \n', 0.39453530219885546)

+('public static < T extends Enum < T >> T readEnum ( JSONObject json , String key , T defaultValue , Class < T > enumClass ) throws JSONException { String name = json . optString ( key ) ; return ( name != null && name . length ( ) > 0 ) ? Enum . valueOf ( enumClass , name ) : defaultValue ; } \n', 0.3942844800100882)

+('public static < T extends Enum < T >> T getEnumFromString ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string . trim ( ) ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.3937211407735509)

FRank: 2  | P@1: 0  | P@5: 4  | P@10: 7

########################## 9 #################################
-('private List < QuasiImportPackage > wrapImportPackageSpecifications ( ImportPackageSpecification [ ] importPackageSpecifications ) { List < QuasiImportPackage > quasiImportPackages = new ArrayList < QuasiImportPackage > ( ) ; for ( ImportPackageSpecification importPackageSpecification : importPackageSpecifications ) { quasiImportPackages . add ( new StandardQuasiImportPackage ( importPackageSpecification , this ) ) ; } return Collections . unmodifiableList ( quasiImportPackages ) ; } \n', 0.40216841439515905)

-('@ SuppressWarnings ( "unused" ) public static void emitUnionOfRule1 ( final LinkedList < BoundVariable > variablesInList , final StringBuilder returnString , final HashMap < String , TemplateRule > templateRulemap ) { returnString . append ( "-(*-#cls-uni-*)" ) ; final String listName = variablesInList . get ( 0 ) . getPartOfList ( ) ; for ( final BoundVariable b : variablesInList ) { returnString . append ( "Forall-?y-(-" + "?y[rdf:type->" + listName + "]-:--And(-" ) ; returnString . append ( "?y[rdf:type->" + b . getOriginalString ( ) + "]-))-" ) ; } InferenceRulesGenerator . rulesEmitted ++ ; } \n', 0.3925589087575292)

-('@ SuppressWarnings ( "unused" ) public static void emitUnionOfRule2 ( final LinkedList < BoundVariable > variablesInList , final StringBuilder returnString , final HashMap < String , TemplateRule > templateRulemap ) { returnString . append ( "-(*-#scm-uni-*)" ) ; final String listName = variablesInList . get ( 0 ) . getPartOfList ( ) ; for ( final BoundVariable b : variablesInList ) { returnString . append ( b . getOriginalString ( ) + "[rdf:subClassOf->" + listName + "]-" ) ; } InferenceRulesGenerator . rulesEmitted ++ ; } \n', 0.3925589087575292)

-('private void buildPackages ( ) throws IOException { final Set < PackageDoc > packages = new HashSet < PackageDoc > ( ) ; for ( final ClassDoc classDoc : root . classes ( ) ) { final PackageDoc packageDoc = classDoc . containingPackage ( ) ; if ( ! packages . contains ( packageDoc ) ) { packages . add ( packageDoc ) ; generatePackage ( packageDoc ) ; } } } \n', 0.3862259269360871)

-('private TabularData convertExportedPackages ( ExportedPackage [ ] exportedPackages ) { if ( null == exportedPackages ) { return null ; } TabularData tabularData = new TabularDataSupport ( PackageAdminMBeanConstants . EXPORTED_PACKAGES_TYPE ) ; for ( ExportedPackage exportedPackage : exportedPackages ) { tabularData . put ( this . convertExportedPackage ( exportedPackage ) ) ; } return tabularData ; } \n', 0.3830291775722102)

-('private String produceEquivalentAlternation ( String source ) { int len = countChars ( source , 0 , 1 ) ; if ( source . length ( ) == len ) return source ; String base = source . substring ( 0 , len ) ; String combiningMarks = source . substring ( len ) ; String [ ] perms = producePermutations ( combiningMarks ) ; StringBuilder result = new StringBuilder ( source ) ; for ( int x = 0 ; x < perms . length ; x ++ ) { String next = base + perms [ x ] ; if ( x > 0 ) result . append ( "|" + next ) ; next = composeOneStep ( next ) ; if ( next != null ) result . append ( "|" + produceEquivalentAlternation ( next ) ) ; } return result . toString ( ) ; } \n', 0.379765616298814)

-('protected void convertAndroidBuildLibraries ( File buildDir , Writer buildOut ) { try { BufferedReader reader = new BufferedReader ( new FileReader ( new File ( buildDir , "project.properties" ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . trim ( ) . startsWith ( "android.library.reference." ) ) { String path = line . substring ( line . indexOf ( "=" ) + 1 ) . trim ( ) ; convertAndroidBuildDirectoryToLibrary ( buildDir , path , buildOut ) ; } } } catch ( IOException e ) { try { buildOut . write ( "Error-reading-project.properties:-" + e . getMessage ( ) ) ; } catch ( IOException e1 ) { } } } \n', 0.3780835322407141)

-('public String buildPatchClasspathBasedOnCurrentClassLoader ( Logger logger ) { URL [ ] urLs = ( ( URLClassLoader ) AbstractGrinderClassPathProcessor . class . getClassLoader ( ) ) . getURLs ( ) ; StringBuilder builder = new StringBuilder ( ) ; for ( URL each : urLs ) { builder . append ( each . getFile ( ) ) . append ( File . pathSeparator ) ; } return filterPatchClassPath ( builder . toString ( ) , logger ) ; } \n', 0.37770884512631886)

-('private void importNamed ( DiagnosticPosition pos , final Symbol tsym , Env < AttrContext > env , JCImport imp ) { if ( tsym . kind == TYP ) imp . importScope = env . toplevel . namedImportScope . importType ( tsym . owner . members ( ) , tsym . owner . members ( ) , tsym ) ; } \n', 0.377682353687645)

-('public String androidClasspath ( ) { return expandDirs ( substituteVars ( string ( "anasoot.android-classpath" ) ) ) ; } \n', 0.37692766907023467)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 10 #################################
+('public static Object [ ] addToArrayFront ( Object [ ] in , Object addTo ) { Class inClass = in . getClass ( ) ; if ( ! inClass . isArray ( ) ) throw new IllegalArgumentException ( "must-pass-array" ) ; int InSize = Array . getLength ( in ) ; Object [ ] ret = ( Object [ ] ) Array . newInstance ( inClass . getComponentType ( ) , InSize + 1 ) ; System . arraycopy ( in , 0 , ret , 1 , InSize ) ; Array . set ( ret , 0 , addTo ) ; return ( ret ) ; } \n', 0.35209403180629245)

-('private static int [ ] addArrays ( final int [ ] a , final int [ ] b ) { int [ ] result = Arrays . copyOf ( a , a . length ) ; for ( int i = 0 ; i < result . length ; ++ i ) { result [ i ] += b [ i ] ; } return result ; } \n', 0.35163174701309463)

-('public void fromArray ( int [ ] members ) { if ( this . members . length != members . length ) { throw new IllegalArgumentException ( "invalid-subset-length" ) ; } memberSet . clear ( ) ; for ( int i = 0 ; i < members . length ; i ++ ) { this . members [ i ] = members [ i ] ; memberSet . add ( members [ i ] ) ; } validate ( ) ; } \n', 0.3483703389247874)

+('public void addNewArray ( ) { objectArrayList . add ( new Object [ allocationSize ] ) ; maxCount += allocationSize ; } \n', 0.3483606731454827)

-('public static Object addArray ( Object list , Object [ ] array ) { for ( int i = 0 ; array != null && i < array . length ; i ++ ) { list = LazyList . add ( list , array [ i ] ) ; } return list ; } \n', 0.34792155853246454)

-('private void extend ( int i ) { int sz = base . length ; int nsz = Math . max ( i + 0xFFFF , ( int ) ( sz * 1.5 ) ) ; base = Arrays . copyOf ( base , nsz ) ; Arrays . fill ( base , sz , nsz , BASE_EMPTY ) ; check = Arrays . copyOf ( check , nsz ) ; Arrays . fill ( check , sz , nsz , - 1 * Unsafe . ARRAY_INT_INDEX_SCALE ) ; } \n', 0.3447674241704033)

+('public void addAll ( char [ ] [ ] newElements ) { if ( this . size + newElements . length >= this . maxSize ) { this . maxSize = this . size + newElements . length ; System . arraycopy ( this . elements , 0 , ( this . elements = new char [ this . maxSize ] [ ] ) , 0 , this . size ) ; } System . arraycopy ( newElements , 0 , this . elements , this . size , newElements . length ) ; this . size += newElements . length ; } \n', 0.34466344512116426)

+('public void addAll ( char [ ] [ ] [ ] newElements ) { if ( size + newElements . length >= maxSize ) { maxSize = size + newElements . length ; System . arraycopy ( elements , 0 , ( elements = new char [ maxSize ] [ ] [ ] ) , 0 , size ) ; } System . arraycopy ( newElements , 0 , elements , size , newElements . length ) ; size += newElements . length ; } \n', 0.34466344512116426)

+('public void addAll ( char [ ] [ ] [ ] newElements ) { if ( this . size + newElements . length >= this . maxSize ) { this . maxSize = this . size + newElements . length ; System . arraycopy ( this . elements , 0 , ( this . elements = new char [ this . maxSize ] [ ] [ ] ) , 0 , this . size ) ; } System . arraycopy ( newElements , 0 , this . elements , this . size , newElements . length ) ; this . size += newElements . length ; } \n', 0.34466344512116426)

-('public static void addArray ( Collection < Object > col , Object [ ] add ) { if ( ( add == null ) || ( add . length == 0 ) ) return ; col . addAll ( Arrays . asList ( add ) ) ; } \n', 0.3444046747480611)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 5

########################## 11 #################################
+('private String getRandomString ( ) { return Long . toString ( rand . nextLong ( ) ) ; } \n', 0.4543420333834416)

+('protected static String getRandomString ( ) { return new BigInteger ( 64 , new Random ( ) ) . toString ( 16 ) ; } \n', 0.44780025287175945)

-('public static String getRandomString ( int maxLength , boolean fixedTextLength ) { Random r = new Random ( ) ; int length ; if ( ! fixedTextLength ) { length = ( int ) ( ( r . nextDouble ( ) * ( double ) maxLength ) + 1.0 ) ; } else { length = maxLength ; } String random = "" ; for ( int i = 0 ; i < length ; i ++ ) { random += getRandomChar ( ) ; } return random ; } \n', 0.44463312362721785)

+("public static String getRandomString ( int size , Random random ) { StringBuilder sb = new StringBuilder ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { sb . append ( ( char ) ( random . nextInt ( 26 ) + 'A' ) ) ; } return sb . toString ( ) ; } \n", 0.4430738701274294)

+('static public String getRandomString ( int size ) { StringBuilder builder = new StringBuilder ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { char c = ( char ) ( random . nextInt ( 126 - 33 ) + 33 ) ; builder . append ( c ) ; } return builder . toString ( ) ; } \n', 0.44305921492703665)

+("static String getRandomString ( int n , Random rnd ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { sb . append ( ( char ) ( 'a' + rnd . nextInt ( 3 ) ) ) ; } return sb . toString ( ) ; } \n", 0.4429671034767481)

+('private static String randomString ( ) { return Long . toString ( RANDOM_GEN . nextLong ( ) , 36 ) ; } \n', 0.44179609032462563)

+('public static String getRandomString ( int length ) { String base = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ; Random random = new Random ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } \n', 0.44176318188136526)

+('public static String randomString ( final int bits ) { return new BigInteger ( bits , new Random ( ) ) . toString ( 32 ) ; } \n', 0.44105319888279787)

+('String getRandomStr ( ) { String base = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" ; Random random = new Random ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < 16 ; i ++ ) { int number = random . nextInt ( base . length ( ) ) ; sb . append ( base . charAt ( number ) ) ; } return sb . toString ( ) ; } \n', 0.44101767457202296)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 9

########################## 12 #################################
-('public static String printArray ( byte [ ] array ) { return printArray ( array , false ) ; } \n', 0.34633338623158627)

+('private void printClassDefs ( ) { int index = 0 ; for ( ClassDef classDef : dex . classDefs ( ) ) { System . out . println ( "class-def-" + index + ":-" + classDef ) ; index ++ ; } } \n', 0.34378227178594567)

+('public void printBitArrays ( ) { for ( ArrayList < Integer > bitArray : bitArrays ) { for ( Integer bit : bitArray ) { System . out . print ( bit . intValue ( ) ) ; } System . out . println ( ) ; } } \n', 0.33993759585503436)

-('public static final String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

-('public static String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

+('public static < T > void printArray ( T [ ] entries ) { System . out . println ( Arrays . asList ( entries ) ) ; } \n', 0.3311205566380241)

-('public static final String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

-('public static String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

-('private void printArrayProperty ( final StringBuffer sb , final String prefix , final Object array ) { final int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i ++ ) { final Object obj = Array . get ( array , i ) ; printProperty ( sb , String . format ( "%s[%s]" , prefix , i ) , obj ) ; } } \n', 0.3253721760862642)

+('protected void printObjectArrayContents ( Object objectArrayToPrint ) { Object [ ] arrayToPrint = ( Object [ ] ) objectArrayToPrint ; System . out . print ( "-RESULT:-" ) ; for ( int i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( i > 0 ) { System . out . print ( ",-" ) ; } System . out . print ( arrayToPrint [ i ] ) ; } System . out . println ( "-" ) ; } \n', 0.3253158161385643)

FRank: 2  | P@1: 0  | P@5: 2  | P@10: 4

########################## 13 #################################
+('public static < K , V extends Comparable < V >> Map < K , V > sortMapByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.47019823717805165)

+('private static Map sortMapByValues ( Map map ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( ( Map . Entry ) ( o2 ) ) . getValue ( ) == ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ? ( ( Comparable ) ( ( Map . Entry ) ( o1 ) ) . getKey ( ) ) . compareTo ( ( ( Map . Entry ) ( o2 ) ) . getKey ( ) ) : ( ( Comparable ) ( ( Map . Entry ) ( o2 ) ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ; } } ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46917912357463765)

+('public static Map < Long , Float > sortMapByValue ( Map < Long , Float > map ) { List < Map . Entry < Long , Float >> list = new LinkedList < Entry < Long , Float >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Long , Float >> ( ) { @ Override public int compare ( Map . Entry < Long , Float > o1 , Map . Entry < Long , Float > o2 ) { if ( o1 . getValue ( ) <= o2 . getValue ( ) ) { return 1 ; } else { return - 1 ; } } } ) ; Map < Long , Float > result = new LinkedHashMap < Long , Float > ( ) ; for ( Iterator < Entry < Long , Float >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Long , Float > entry = it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } \n', 0.4682754856723419)

+('public static < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k1 ) . compareTo ( map . get ( k2 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return new LinkedHashMap < K , V > ( sortedByValues ) ; } \n', 0.46806062228012674)

+('public static HashMap sortMapByValues ( HashMap map ) { List < Map . Entry > list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new MapValueSorter ( ) ) ; HashMap sortedHashMap = new LinkedHashMap ( ) ; for ( Map . Entry e : list ) { sortedHashMap . put ( e . getKey ( ) , e . getValue ( ) ) ; } return sortedHashMap ; } \n', 0.46781194072755194)

+('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46680150576087603)

+('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

+('static public < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

+('public < K extends Comparable < K > , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) { return k1 . compareTo ( k2 ) ; } else { return compare ; } } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

+('private < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int res = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( res == 0 ) return 1 ; else return res ; } } ; Map < K , V > sortedMap = new TreeMap < K , V > ( valueComparator ) ; sortedMap . putAll ( map ) ; return sortedMap ; } \n', 0.4655879162870542)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 14 #################################
-('private double normalizeRotationalSpeed ( double value ) { double maxIncrementValueY = 0.05 ; if ( lastRotationalSpeed < 0.3 && lastRotationalSpeed > - 0.3 ) { lastRotationalSpeed = ( value > 0 ) ? Math . min ( value , 0.3 ) : Math . max ( value , - 0.3 ) ; return lastRotationalSpeed ; } if ( ( value - lastRotationalSpeed ) > maxIncrementValueY ) { lastRotationalSpeed += maxIncrementValueY ; return lastRotationalSpeed ; } else if ( ( lastRotationalSpeed - value ) > maxIncrementValueY ) { lastRotationalSpeed -= maxIncrementValueY ; return lastRotationalSpeed ; } return lastRotationalSpeed ; } \n', 0.3604027240720582)

-('private double normalizeLinearSpeed ( double value ) { double slowIncrementValueX = 0.02 ; double delta = value - lastLinearSpeed ; if ( delta <= 0 ) { lastLinearSpeed = value ; return value ; } else { if ( lastLinearSpeed >= 0 && lastLinearSpeed < 0.25 ) lastLinearSpeed = Math . min ( value , 0.25 ) ; else lastLinearSpeed += Math . min ( delta , slowIncrementValueX ) ; return lastLinearSpeed ; } } \n', 0.3531116922450248)

-('public static double normalizeAngle ( double a , double center ) { return a - PI2 * Math . floor ( ( a + PI - center ) / PI2 ) ; } \n', 0.3467983333506492)

-('public static double normalizeAngle ( double a , double center ) { return a - TWO_PI * Math . floor ( ( a + Math . PI - center ) / TWO_PI ) ; } \n', 0.3457326782386032)

-('public static double normalizeAngle ( final double a , final double center ) { return a - TWO_PI * Math . floor ( ( a + Math . PI - center ) / TWO_PI ) ; } \n', 0.34573267823860315)

-('public static double [ ] [ ] normalizeSamples ( double [ ] [ ] samples_to_normalize ) { double [ ] [ ] normalized_samples = new double [ samples_to_normalize . length ] [ samples_to_normalize [ 0 ] . length ] ; for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) normalized_samples [ chan ] [ samp ] = samples_to_normalize [ chan ] [ samp ] ; double max_sample_value = 0.0 ; for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) if ( Math . abs ( normalized_samples [ chan ] [ samp ] ) > max_sample_value ) max_sample_value = Math . abs ( normalized_samples [ chan ] [ samp ] ) ; if ( max_sample_value != 0.0 ) for ( int chan = 0 ; chan < normalized_samples . length ; chan ++ ) for ( int samp = 0 ; samp < normalized_samples [ chan ] . length ; samp ++ ) normalized_samples [ chan ] [ samp ] /= max_sample_value ; return normalized_samples ; } \n', 0.3439415049131098)

-('public static double normalizeLongitude ( double lonValue ) { if ( lonValue == lonValue ) { while ( ( lonValue < - 180. ) || ( lonValue > 180. ) ) { lonValue = Math . IEEEremainder ( lonValue , 360.0 ) ; } } return lonValue ; } \n', 0.343030423424636)

-('public static final double trunc ( double value ) { return ( value < 0 ) ? Math . ceil ( value ) : Math . floor ( value ) ; } \n', 0.3426703671857977)

-('public static double trunc ( Number n ) { if ( n == null ) { return 0 ; } return Math . floor ( n . doubleValue ( ) ) ; } \n', 0.34232143120573866)

-('public static Node normalize ( Node v ) { double length = Math . sqrt ( Math . pow ( v . getX ( ) , 2 ) + Math . pow ( v . getY ( ) , 2 ) ) ; return VectorHelper . multiply ( v , 1 / length ) ; } \n', 0.3416769049666232)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 15 #################################
+('protected static Class [ ] combineClassArrays ( Class [ ] ... classArrays ) { int combinedArrayLength = 0 ; for ( Class [ ] classArray : classArrays ) { combinedArrayLength += classArray . length ; } Class [ ] returnArray = new Class [ combinedArrayLength ] ; int copyPos = 0 ; for ( Class [ ] classArray : classArrays ) { System . arraycopy ( classArray , 0 , returnArray , copyPos , classArray . length ) ; copyPos += classArray . length ; } return returnArray ; } \n', 0.38913050927947385)

+('public static short [ ] concatShort ( short [ ] A , short [ ] B ) { short [ ] C = new short [ A . length + B . length ] ; System . arraycopy ( A , 0 , C , 0 , A . length ) ; System . arraycopy ( B , 0 , C , A . length , B . length ) ; return C ; } \n', 0.37483368529184946)

-('public static String dup ( char c , int num ) { if ( c == 0 || num < 1 ) return "" ; StringBuilder sb = new StringBuilder ( num ) ; for ( int i = 0 ; i < num ; i ++ ) sb . append ( c ) ; return sb . toString ( ) ; } \n', 0.37316931295730305)

-('public int [ ] bubbleSortVector ( ) { int [ ] sortVector = new int [ vector . length ] ; System . arraycopy ( vector , 0 , sortVector , 0 , vector . length ) ; for ( int i = 1 ; i <= sortVector . length - 1 ; i ++ ) { for ( int j = 1 ; j <= sortVector . length - i ; j ++ ) { if ( sortVector [ j ] < sortVector [ j - 1 ] ) { int temp = sortVector [ j ] ; sortVector [ j ] = sortVector [ j - 1 ] ; sortVector [ j - 1 ] = temp ; } } } return sortVector ; } \n', 0.369740611001387)

-('public ListTaskDefinitionsRequest withSort ( SortOrder sort ) { this . sort = sort . toString ( ) ; return this ; } \n', 0.36777437307211)

-('public DescribeMLModelsRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.36746743497762957)

-('public DescribeEvaluationsRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.36746743497762957)

-('public DescribeDataSourcesRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.36746743497762957)

-('public DescribeBatchPredictionsRequest withSortOrder ( SortOrder sortOrder ) { this . sortOrder = sortOrder . toString ( ) ; return this ; } \n', 0.36746743497762957)

+('public static int [ ] arrayConcatInt ( final int [ ] original , final int [ ] appender ) { final int [ ] result = Arrays . copyOf ( original , original . length + appender . length ) ; System . arraycopy ( appender , 0 , result , original . length , appender . length ) ; return result ; } \n', 0.3651376615915112)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 3

########################## 16 #################################
-('public AsciiFileReader ( String filename ) throws FileNotFoundException , IllegalArgumentException { if ( filename == null || filename . isEmpty ( ) ) { throw new IllegalArgumentException ( ) ; } if ( ! ( new File ( filename ) ) . exists ( ) ) { throw new FileNotFoundException ( ) ; } this . __filename = ( new File ( filename ) . getAbsolutePath ( ) ) ; this . __reading = false ; } \n', 0.39923545991366777)

-('public static File resourceCopy ( Object object , String resource , String outPath ) { String path = outPath . trim ( ) ; if ( ! path . endsWith ( File . separator ) ) path += File . separator ; int i = resource . lastIndexOf ( "/" ) + 1 ; File outFile = new File ( path + resource . substring ( i ) ) ; BufferedInputStream in = null ; BufferedOutputStream out = null ; if ( copy ( object . getClass ( ) . getResourceAsStream ( resource ) , outFile ) ) return outFile ; else return null ; } \n', 0.3893207591925572)

-("private static void createAndStoreFormatter ( String line ) throws BuildException { String formatterClassName = null ; File formatterFile = null ; int pos = line . indexOf ( ',' ) ; if ( pos == - 1 ) formatterClassName = line ; else { formatterClassName = line . substring ( 0 , pos ) ; formatterFile = new File ( line . substring ( pos + 1 ) ) ; } fgFromCmdLine . addElement ( createFormatter ( formatterClassName , formatterFile ) ) ; } \n", 0.3877618471970625)

-('public StringTokenizer ( String inputFileName ) throws FileNotFoundException { try { InputStream is = this . getClass ( ) . getResource ( inputFileName ) . openStream ( ) ; _fileReader = new BufferedReader ( new InputStreamReader ( is ) ) ; } catch ( Exception e ) { System . err . println ( "StringTokenizer-error-opening-file:-" + e ) ; e . printStackTrace ( ) ; } _st = new StreamTokenizer ( _fileReader ) ; _st . eolIsSignificant ( true ) ; _st . wordChars ( 33 , 125 ) ; } \n', 0.38425051408827793)

+('public static String utf8FileDescriptor2String ( FileDescriptor fileDescriptor ) { return new String ( getBytes ( fileDescriptor ) , Charset . forName ( "UTF-8" ) ) ; } \n', 0.3795922315562468)

-('public static void createStringJar ( String out , Map entries ) throws IOException { Manifest manifest = getManifest ( ) ; for ( Iterator iter = entries . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String key = ( String ) iter . next ( ) ; manifest . getEntries ( ) . put ( key , new Attributes ( ) ) ; } JarOutputStream jar = new JarOutputStream ( new FileOutputStream ( out ) , manifest ) ; for ( Iterator iter = entries . keySet ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { String key = ( String ) iter . next ( ) ; String contents = ( String ) entries . get ( key ) ; JarEntry entry = new JarEntry ( key ) ; jar . putNextEntry ( entry ) ; StreamUtil . copy ( new ReaderInputStream ( new StringReader ( contents ) ) , jar ) ; jar . closeEntry ( ) ; } jar . finish ( ) ; jar . close ( ) ; } \n', 0.3793342609938469)

+('public static Object fileToText ( Object file , Object encoding ) throws Throwable { Charset charset = null ; if ( encoding instanceof String ) { charset = Charset . forName ( ( String ) encoding ) ; } else if ( encoding instanceof Charset ) { charset = ( Charset ) encoding ; } else { throw new IllegalArgumentException ( "encoding-must-be-either-a-string-or-a-charset-instance" ) ; } return new String ( Files . readAllBytes ( pathFrom ( file ) ) , charset ) ; } \n', 0.3749535979793397)

+('protected void createTextFile ( String infile , Charset charsetInfile , String toDir , String outfile , Map < String , String > variables ) throws NullPointerException , IOException { String infileResource = infile . replace ( \'|\' , \'/\' ) ; InputStream is = getClass ( ) . getClassLoader ( ) . getResourceAsStream ( infileResource ) ; InputStreamReader inRead = new InputStreamReader ( is , charsetInfile ) ; BufferedReader bufRead = new BufferedReader ( inRead ) ; StringBuffer skelFile = new StringBuffer ( ) ; String line ; Pattern var = Pattern . compile ( "|{(.*)|}" ) ; while ( ( line = bufRead . readLine ( ) ) != null ) { line = line . replaceFirst ( "-" , LINE_SEP ) ; if ( variables != null ) { Matcher match = var . matcher ( line ) ; if ( match . find ( ) ) { line = match . replaceFirst ( variables . get ( match . group ( 1 ) ) ) ; } } skelFile . append ( line + LINE_SEP ) ; } bufRead . close ( ) ; inRead . close ( ) ; is . close ( ) ; backupFile ( toDir , outfile ) ; FileOutputStream fout = new FileOutputStream ( toDir + File . separator + outfile , false ) ; OutputStreamWriter outWrite = new OutputStreamWriter ( fout , VeriniceCharset . CHARSET_DEFAULT ) ; outWrite . write ( skelFile . toString ( ) ) ; outWrite . close ( ) ; fout . close ( ) ; } \n', 0.3745064331761446)

-('public ArchiveReader getArchiveReader ( final String url ) throws Exception { final int delim = url . indexOf ( \':\' ) ; if ( delim < 0 ) throw new Exception ( "Missing-prefix-in-URL-" + url ) ; final String prefix = url . substring ( 0 , delim ) ; final ArchiveReaderFactory factory = reader_factories . get ( prefix ) ; if ( factory == null ) throw new Exception ( "Unknown-archive-reader-URL-" + url ) ; return factory . getArchiveReader ( url ) ; } \n', 0.3724777865491602)

-('public File createFileFromURL ( URL resource ) { LOGGER . info ( "Resource-is-{}." , resource . getPath ( ) ) ; String [ ] arr = resource . getPath ( ) . split ( "/" ) ; String filenameWithoutPath = arr [ arr . length - 1 ] ; File configFile = null ; try { String fileContent = Resources . toString ( resource , Charset . defaultCharset ( ) ) ; configFile = createFileFromString ( fileContent , filenameWithoutPath ) ; } catch ( IOException e ) { LOGGER . error ( "Error-reading-resource-{}." , resource . getPath ( ) , e ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.37207679938316557)

FRank: 5  | P@1: 0  | P@5: 1  | P@10: 3

########################## 17 #################################
+('public static StringBuilder transformStackTrace ( StackTraceElement [ ] elements ) { StringBuilder sb = new StringBuilder ( ) ; for ( StackTraceElement element : elements ) { sb . append ( element . toString ( ) ) . append ( "-" ) ; } return sb ; } \n', 0.45468857498635107)

+('@ NotNull public static String convertExceptionStackToString ( @ NotNull final Throwable ex ) { final StringBuilder sb = new StringBuilder ( ) ; for ( @ NotNull final StackTraceElement element : ex . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } if ( ex instanceof UmbrellaException ) { sb . append ( "Unwrapping-UmbrellaException-" ) ; final UmbrellaException umbrellaException = ( UmbrellaException ) ex ; for ( @ NotNull final Throwable throwable : umbrellaException . getCauses ( ) ) { for ( @ NotNull final StackTraceElement element : throwable . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } } } return sb . toString ( ) ; } \n', 0.44490724544019167)

+('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

+('public static String getStackTraceXml ( final Throwable e ) { final StringBuilder result = new StringBuilder ( "-<stack-trace><![CDATA[-" ) ; final StackTraceElement [ ] elements = e . getStackTrace ( ) ; for ( final StackTraceElement element : elements ) { result . append ( "-" ) ; result . append ( element ) ; result . append ( \'|n\' ) ; } result . append ( "]]></stack-trace>-" ) ; return result . toString ( ) ; } \n', 0.43629131415761624)

+('static String convertStackTrace ( Throwable t , boolean appendOutputError ) { StackTraceWriter writer = new StackTraceWriter ( appendOutputError ) ; t . printStackTrace ( new PrintWriter ( writer ) ) ; return writer . toString ( ) . replaceAll ( "%" , "%%" ) ; } \n', 0.43406566344828357)

+('public static String writeStackTrace ( Throwable cause ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( cause ) ; sb . append ( "-" ) ; StackTraceElement [ ] trace = cause . getStackTrace ( ) ; for ( int i = 0 ; i < trace . length ; i ++ ) { String traceString = trace [ i ] . toString ( ) ; if ( ! ( traceString . startsWith ( "sun.reflect." ) && i > 1 ) ) { sb . append ( "-at-" ) ; sb . append ( traceString ) ; sb . append ( "-" ) ; } } return sb . toString ( ) ; } \n', 0.43287102920966625)

+('private static String stackTraceToString ( Throwable t ) { final StringBuilder sb = new StringBuilder ( ) ; final String indent = "-at-" ; for ( StackTraceElement frame : t . getStackTrace ( ) ) { sb . append ( indent ) ; sb . append ( frame . toString ( ) ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } \n', 0.4279314670430304)

+("public String getStackTraceString ( ) { StringBuilder result = new StringBuilder ( ) ; for ( StackTraceElement element : _stackTrace ) { if ( result . length ( ) > 0 ) { result . append ( '|n' ) ; } result . append ( element . toString ( ) ) ; } return result . toString ( ) ; } \n", 0.4275966547927845)

+('public String getStringFromStackTrace ( StackTraceElement [ ] stackTrace ) { StringBuilder builder = new StringBuilder ( ) ; for ( StackTraceElement e : stackTrace ) { builder . append ( e . toString ( ) ) ; } return builder . toString ( ) ; } \n', 0.4265108452317233)

+('protected String getPartialServletStackTrace ( Throwable t ) { StringBuilder trace = new StringBuilder ( ) ; trace . append ( t . toString ( ) ) . append ( \'|n\' ) ; StackTraceElement [ ] elements = t . getStackTrace ( ) ; int pos = elements . length ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core.ApplicationFilterChain" ) ) && ( elements [ i ] . getMethodName ( ) . equals ( "internalDoFilter" ) ) ) { pos = i ; } } for ( int i = 0 ; i < pos ; i ++ ) { if ( ! ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core." ) ) ) { trace . append ( \'|t\' ) . append ( elements [ i ] . toString ( ) ) . append ( \'|n\' ) ; } } return trace . toString ( ) ; } \n', 0.4264014403405637)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 18 #################################
+('private static int compareHandlesNulls ( CstString a , CstString b ) { if ( a == b ) { return 0 ; } else if ( a == null ) { return - 1 ; } else if ( b == null ) { return 1 ; } else { return a . compareTo ( b ) ; } } \n', 0.3923304797017047)

+('private static int compareHandlesNulls ( CstUtf8 a , CstUtf8 b ) { if ( a == b ) { return 0 ; } else if ( a == null ) { return - 1 ; } else if ( b == null ) { return 1 ; } else { return a . compareTo ( b ) ; } } \n', 0.3923304797017047)

+('private static int compareHandlesNulls ( CstString a , CstString b ) { if ( a == b ) { return 0 ; } else if ( a == null ) { return - 1 ; } else if ( b == null ) { return 1 ; } else { return a . compareTo ( b ) ; } } \n', 0.3803823788367683)

+('private static int compareHandlesNulls ( CstUtf8 a , CstUtf8 b ) { if ( a == b ) { return 0 ; } else if ( a == null ) { return - 1 ; } else if ( b == null ) { return 1 ; } else { return a . compareTo ( b ) ; } } \n', 0.3803823788367683)

+('public static boolean sameProperNounClass ( String noun1 , String noun2 ) { if ( ( noun1 . equals ( "NNP" ) || noun1 . equals ( "NNPS" ) ) && ( noun2 . equals ( "NNP" ) || noun2 . equals ( "NNPS" ) ) ) return true ; return false ; } \n', 0.3794286342597216)

-('@ Override public int compare ( MatchResult o1 , MatchResult o2 ) { return collator . compare ( o1 . getLocale ( ) . getDisplayLanguage ( locale ) , o2 . getLocale ( ) . getDisplayLanguage ( locale ) ) ; } \n', 0.378892594748272)

+('public int compare ( Object objectA , Object objectB ) { Character aAsCharacter = ( Character ) objectA ; Character bAsCharacter = ( Character ) objectB ; this . initializeCollator ( ) ; return collator . compare ( Character . toString ( aAsCharacter . charValue ( ) ) , Character . toString ( bAsCharacter . charValue ( ) ) ) ; } \n', 0.3768090421838024)

+('private boolean sameJavaClass ( String one , String two ) { int index1 = one . indexOf ( "[" ) ; int index2 = two . indexOf ( "[" ) ; if ( index1 > 0 ) { one = one . substring ( 0 , index1 ) ; } if ( index2 > 0 ) { two = two . substring ( 0 , index2 ) ; } return one . equals ( two ) ; } \n', 0.3766992637256818)

+('boolean sameClass ( String cfn ) { String s = cfn ; int i = s . lastIndexOf ( ".class" ) ; if ( i > 0 ) { s = s . substring ( 0 , i ) ; } if ( s . compareTo ( toString ( ) ) == 0 ) return true ; return false ; } \n', 0.3766257978192921)

+('public int compare ( Object object1 , Object object2 ) { return compare ( ( String ) object1 , ( String ) object2 ) ; } \n', 0.3732264507775638)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 9

########################## 19 #################################
+('public static List < String > split ( final String string , final String regex ) { final String trimmedString = string == null ? "" : string . trim ( ) ; return Arrays . asList ( trimmedString . length ( ) == 0 ? EMPTY_ARRAY : trimmedString . split ( regex ) ) ; } \n', 0.42211951430628075)

+('public static String [ ] splitCSV ( String str ) { String [ ] tempAr = new String [ str . length ( ) ] ; int aIndex = 0 ; String currString = new String ( ) ; char ch ; boolean inQuote = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ch = str . charAt ( i ) ; if ( inQuote ) { if ( ch == \'|"\' && ( i + 1 ) < str . length ( ) && str . charAt ( i + 1 ) == \'|"\' ) { i ++ ; currString = currString + ch ; } else if ( ch == \'|"\' && ( i + 1 ) < str . length ( ) && str . charAt ( i + 1 ) == \',\' ) { inQuote = false ; tempAr [ aIndex ] = currString ; aIndex ++ ; currString = new String ( ) ; i ++ ; } else if ( ch != \'|"\' ) { currString = currString + ch ; } } else if ( ch == \',\' ) { tempAr [ aIndex ] = currString ; aIndex ++ ; currString = new String ( ) ; } else if ( ch == \'|"\' ) { inQuote = true ; } else { currString = currString + ch ; } } tempAr [ aIndex ++ ] = currString ; String [ ] array = new String [ aIndex ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = tempAr [ i ] ; } return array ; } \n', 0.4180849012934124)

+('public static String [ ] splitWithSQLDelimiter ( String resource ) { if ( resource . startsWith ( SQL_DELIMITER_COMMENT_PREFIX ) ) { try { String scripts = resource . substring ( SQL_DELIMITER_COMMENT_PREFIX . length ( ) ) ; int endOfDelimIndex = scripts . indexOf ( SQL_DELIMITER_COMMENT_SUFFIX ) ; String delim = scripts . substring ( 0 , endOfDelimIndex ) . trim ( ) ; scripts = scripts . substring ( endOfDelimIndex + 2 ) . trim ( ) ; return scripts . split ( delim ) ; } catch ( IndexOutOfBoundsException e ) { LOG . warn ( "Error-of-parse-SQL-script-file.-Invalid-DELIMITER-configuration.-Valid-format-is-\'" + SQL_DELIMITER_COMMENT_PREFIX + "XXX*/\'-at-begin-of-the-SQL-script-file,-where-XXX---DELIMITER-string." + "-Spaces-will-be-trimed.-" , e ) ; LOG . info ( "Using-DELIMITER:[" + SQL_DELIMITER + "]" ) ; return resource . split ( SQL_DELIMITER ) ; } } else { return resource . split ( SQL_DELIMITER ) ; } } \n', 0.4168539417312331)

+('public static String [ ] safeSplit ( String regex , Object o ) { if ( o == null ) return EMPTY_STRING_ARRAY ; String s = o . toString ( ) ; if ( "" . equals ( s ) ) return EMPTY_STRING_ARRAY ; return s . split ( regex ) ; } \n', 0.41559971653137806)

+('public static String [ ] splitLongString ( String str , char separator , char quote ) { int len ; if ( str == null || ( len = str . length ( ) ) == 0 ) { return ArrayUtils . EMPTY_STRING_ARRAY ; } int oldPos = 0 ; ArrayList list = new ArrayList ( ) ; for ( int pos = 0 ; pos < len ; oldPos = ++ pos ) { while ( ( pos < len ) && ( str . charAt ( pos ) == quote ) ) { pos = str . indexOf ( quote , pos + 1 ) + 1 ; if ( pos == 0 ) { throw new IllegalArgumentException ( "Closing-quote-missing-in-string-\'" + str + "\'" ) ; } } boolean quoted ; if ( pos != oldPos ) { quoted = true ; if ( ( pos < len ) && ( str . charAt ( pos ) != separator ) ) { throw new IllegalArgumentException ( "Separator-must-follow-closing-quote-in-string-\'" + str + "\'" ) ; } } else { quoted = false ; pos = str . indexOf ( separator , pos ) ; if ( pos < 0 ) { pos = len ; } } list . add ( quoted ? dequote ( str , oldPos + 1 , pos - 1 , quote ) : substring ( str , oldPos , pos ) ) ; } return ( String [ ] ) list . toArray ( ArrayUtils . EMPTY_STRING_ARRAY ) ; } \n', 0.4143852494666307)

+('public static String [ ] split ( String string , String separator , String escapeCharacter ) { String doubleEscapeCharacter = escapeCharacter + escapeCharacter ; String escapeCharacterSeparator = escapeCharacter + separator ; String regex = "(?<!" + Pattern . quote ( escapeCharacter ) + ")" + Pattern . quote ( separator ) ; ArrayList < String > strs = new ArrayList < String > ( ) ; for ( String s : string . split ( regex ) ) { String temp = StringUtils . replace ( s , escapeCharacterSeparator , separator ) ; temp = StringUtils . replace ( temp , doubleEscapeCharacter , escapeCharacter ) ; strs . add ( temp ) ; } return strs . toArray ( new String [ strs . size ( ) ] ) ; } \n', 0.4143567239695791)

+('public static List split ( final String s , final String pattern , final boolean includePattern ) { final List result = new LinkedList ( ) ; int pos = 0 ; while ( true ) { if ( pos == s . length ( ) ) { break ; } final int index = s . indexOf ( pattern , pos ) ; if ( index == - 1 ) { result . add ( s . substring ( pos , s . length ( ) ) ) ; break ; } else { result . add ( s . substring ( pos , index ) ) ; if ( includePattern ) { result . add ( s . substring ( index , index + pattern . length ( ) ) ) ; } pos = index + pattern . length ( ) ; } } return result ; } \n', 0.4142122140181519)

+('public static String [ ] split ( String src , char delim ) { if ( src == null ) { return EMPTY_STRING_ARRAY ; } if ( src . length ( ) == 0 ) { return new String [ ] { ZERO_LENGTH_STRING } ; } ArrayList result = new ArrayList ( ) ; int idx = src . indexOf ( delim ) ; int lastIdx = 0 ; while ( idx != - 1 ) { result . add ( src . substring ( lastIdx , idx ) ) ; lastIdx = idx + 1 ; if ( lastIdx == src . length ( ) ) { idx = - 1 ; } else { idx = src . indexOf ( delim , lastIdx ) ; } } if ( lastIdx < src . length ( ) ) { result . add ( src . substring ( lastIdx ) ) ; } String [ ] resultArray = ( String [ ] ) result . toArray ( new String [ result . size ( ) ] ) ; boolean allEmpty = true ; for ( int i = 0 ; i < resultArray . length && allEmpty ; i ++ ) { if ( resultArray [ i ] . length ( ) > 0 ) { allEmpty = false ; } } if ( allEmpty ) { return EMPTY_STRING_ARRAY ; } return resultArray ; } \n', 0.41395044371390427)

+('public static List < String > splitLanguageString ( String str ) { int count , index , begin ; List < String > strParts ; index = begin = 0 ; count = 0 ; strParts = new ArrayList < String > ( ) ; while ( index < str . length ( ) ) { char character ; character = str . charAt ( index ) ; if ( character == \'(\' ) { if ( count == 0 && begin < index ) { strParts . add ( str . substring ( begin , index ) ) ; begin = index ; } count ++ ; } if ( character == \')\' ) { count -- ; if ( count == 0 && begin < index ) { strParts . add ( str . substring ( begin , index + 1 ) ) ; begin = index + 1 ; } } if ( character == \'*\' && count == 0 ) { int max ; if ( begin < index ) strParts . add ( str . substring ( begin , index ) ) ; max = strParts . size ( ) - 1 ; if ( max >= 0 ) strParts . set ( max , strParts . get ( max ) + "*" ) ; else throw new IllegalArgumentException ( ) ; begin = index + 1 ; } index ++ ; } if ( begin < index ) strParts . add ( str . substring ( begin , index ) ) ; return strParts ; } \n', 0.41307098233658496)

+('public static List < String > split ( String str , String regex ) { return ( Arrays . asList ( str . split ( regex ) ) ) ; } \n', 0.4128187192382976)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 20 #################################
-('public HdfsFileWriter ( FileSystem fileSystem , Path path ) throws IOException { LOG . debug ( "Creating-writer-on-{}" , path ) ; this . path = path ; Configuration conf = fileSystem . getConf ( ) ; outputStream = fileSystem . create ( path ) ; } \n', 0.38694100014668437)

-('public static final ObjectOutputStream createObjectOutputWriter ( final File file ) throws IOException { if ( file == null ) return null ; if ( file . exists ( ) ) file . delete ( ) ; final FileOutputStream outFile = new FileOutputStream ( file ) ; final FileChannel outChannel = outFile . getChannel ( ) ; return new ObjectOutputStream ( Channels . newOutputStream ( outChannel ) ) ; } \n', 0.38330727550555693)

-('private DeferredFileOutputStream ( int threshold , File outputFile , String prefix , String suffix , File directory ) { super ( threshold ) ; this . outputFile = outputFile ; memoryOutputStream = new ByteArrayOutputStream ( ) ; currentOutputStream = memoryOutputStream ; this . prefix = prefix ; this . suffix = suffix ; this . directory = directory ; } \n', 0.3817940589118861)

-('private DeferredFileOutputStream ( final int threshold , final File outputFile , final String prefix , final String suffix , final File directory ) { super ( threshold ) ; this . outputFile = outputFile ; memoryOutputStream = new ByteArrayOutputStream ( ) ; currentOutputStream = memoryOutputStream ; this . prefix = prefix ; this . suffix = suffix ; this . directory = directory ; } \n', 0.3817940589118861)

-('private FileCacheWriteStream ( File tempTarget ) throws FileNotFoundException , SecurityException { super ( new BufferedOutputStream ( new FileOutputStream ( tempTarget ) ) ) ; this . temp = tempTarget ; } \n', 0.38033796661553165)

-('public OutputStream openFileForWrite ( File file ) throws FileNotFoundException { FileOutputStream fout = new FileOutputStream ( file ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout ) ; return bout ; } \n', 0.3752735043298275)

-('static final void fileWrite ( int fd , byte [ ] buffer , int [ ] offArr , int len , boolean isNonBlocking ) throws IOException { int off = offArr [ 0 ] ; if ( ( off | len ) < 0 || buffer . length - off < len ) throw new ArrayIndexOutOfBoundsException ( ) ; if ( len > 0 && ( ! isNonBlocking || fileSelect0 ( fd , 1 ) != 0 ) ) { int remain = len ; if ( ! isNonBlocking ) checkThreadInterrupted ( ) ; do { if ( isNonBlocking || ! preventBlocking || fileSelect0 ( fd , 1 ) != 0 ) { int res = fileWrite0 ( buffer , off , remain , fd ) ; if ( res > 0 ) { off += res ; offArr [ 0 ] = off ; if ( ( remain -= res ) <= 0 ) break ; } else { if ( res == 0 ) throw new IOException ( "no-space-left-on-device" ) ; if ( isIOErrorInterrupted0 ( res ) == 0 ) checkIOResCode ( res ) ; } if ( isNonBlocking ) break ; } threadYield ( ) ; if ( remain == len ) checkThreadInterrupted ( ) ; } while ( true ) ; if ( remain < 0 ) throw new InternalError ( "write()-fault" ) ; } } \n', 0.37131327671466025)

-('public ObjectPlusFilesOutputStream ( OutputStream out , File topDirectory ) throws IOException { super ( out ) ; auxiliaryDirectoryStack . addFirst ( topDirectory ) ; } \n', 0.36759049574665553)

-('private void createLocalKeyStoreFile ( ) throws GeneralSecurityException , IOException { if ( ! mLocalTrustStoreFile . exists ( ) ) { FileOutputStream out = null ; try { out = new FileOutputStream ( mLocalTrustStoreFile ) ; KeyStore localTrustStore = KeyStore . getInstance ( "BKS" ) ; localTrustStore . load ( null , BuildConfig . DB_SECRET . toCharArray ( ) ) ; localTrustStore . store ( out , BuildConfig . DB_SECRET . toCharArray ( ) ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IOException e ) { AppLog . e ( T . UTILS , e ) ; } } } } } \n', 0.3656250825408104)

-('private static void createWritableFile ( File file ) throws IOException { file . createNewFile ( ) ; file . setWritable ( true , false ) ; } \n', 0.3633462029306474)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 21 #################################
-('void initMap ( ) { this . map = new LinkedHashMap < String , Object > ( ) ; this . typeList = new ArrayList < HashMap < String , Object >> ( ) ; this . typeNames = new HashSet < String > ( ) ; this . resourceMap = new HashMap < String , Object > ( ) ; this . fkMap = new HashMap < String , String > ( ) ; this . map . put ( "localQueryComparisonOptions" , "caseInsensitiveSQL" ) ; this . map . put ( "structuralTypes" , typeList ) ; this . map . put ( "resourceEntityTypeMap" , resourceMap ) ; this . map . put ( FK_MAP , fkMap ) ; } \n', 0.4093199707477896)

-('private Set < ArtifactDescriptorT > initDescriptorsMapEntry ( IArtifactKey key ) { Set < ArtifactDescriptorT > mapEntry = descriptorsMap . get ( key ) ; if ( mapEntry == null ) { mapEntry = new HashSet < ArtifactDescriptorT > ( ) ; descriptorsMap . put ( key , mapEntry ) ; } return mapEntry ; } \n', 0.4089270265833373)

-('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

-('@ Override @ SuppressWarnings ( "unchecked" ) public void init ( Serializable value ) throws PropertyException { if ( value == null ) { return ; } Map < String , Serializable > map = ( Map < String , Serializable > ) value ; for ( Entry < String , Serializable > entry : map . entrySet ( ) ) { Property property = get ( entry . getKey ( ) ) ; property . init ( entry . getValue ( ) ) ; } removePhantomFlag ( ) ; } \n', 0.4037845929050131)

-('private static void initMapping ( ) { codeToSpecificMapping = new HashMap < Generic , Map < Integer , Specific >> ( ) ; for ( Specific s : values ( ) ) { if ( ! codeToSpecificMapping . containsKey ( s . genericDeviceClass ) ) codeToSpecificMapping . put ( s . genericDeviceClass , new HashMap < Integer , Specific > ( ) ) ; codeToSpecificMapping . get ( s . genericDeviceClass ) . put ( s . key , s ) ; } } \n', 0.400665662991015)

-('public synchronized void initAppCategoryMapWithStore ( String storeName ) { if ( appCategoryMap . get ( storeName ) == null ) { appCategoryMap . put ( storeName , new ConcurrentHashMap < String , Integer > ( ) ) ; } } \n', 0.4005128592672663)

-('private void initConfMap ( ) { confMap = new HashMap < String , ConfTreeResource > ( ) ; confMap . put ( "internal" , internal ) ; confMap . put ( "resources" , resources ) ; confMap . put ( "appConf" , appConf ) ; } \n', 0.400045978437247)

-('private void initMappings ( ) throws Exception { checkClient ( ) ; if ( mappings != null && mappings . length > 0 ) { Map < String , Collection < String >> indexes = new HashMap < > ( ) ; for ( int i = 0 ; i < mappings . length ; i ++ ) { String indexmapping = mappings [ i ] ; String [ ] indexmappingsplitted = indexmapping . split ( "/" ) ; String index = indexmappingsplitted [ 0 ] ; if ( index == null ) throw new Exception ( "Can-not-read-index-in-[" + indexmapping + "].-Check-that-mappings-contains-only-indexname/mappingname-elements." ) ; if ( ! indexes . containsKey ( index ) ) { indexes . put ( index , new ArrayList < String > ( ) ) ; } if ( indexmappingsplitted . length > 1 ) { String mapping = indexmappingsplitted [ 1 ] ; indexes . get ( index ) . add ( mapping ) ; } } for ( String index : indexes . keySet ( ) ) { createIndex ( client , classpathRoot , index ) ; if ( mergeSettings ) { updateSettings ( client , classpathRoot , index ) ; } Collection < String > mappings = indexes . get ( index ) ; for ( Iterator < String > iterator = mappings . iterator ( ) ; iterator . hasNext ( ) ; ) { String type = iterator . next ( ) ; createMapping ( client , classpathRoot , index , type , mergeMapping , forceMapping ) ; } } } } \n', 0.39948416997342673)

-('private void initMappings ( ) throws Exception { if ( mappings != null && mappings . length > 0 ) { Map < String , Collection < String >> indexes = new HashMap < String , Collection < String >> ( ) ; for ( int i = 0 ; i < mappings . length ; i ++ ) { String indexmapping = mappings [ i ] ; String [ ] indexmappingsplitted = indexmapping . split ( "/" ) ; String index = indexmappingsplitted [ 0 ] ; logger . info ( "index:" + index + ",-mapping:" + indexmapping ) ; if ( index == null ) { throw new Exception ( "Can-not-read-index-in-[" + indexmapping + "].-Check-that-mappings-contains-only-indexname/mappingname-elements." ) ; } if ( ! indexes . containsKey ( index ) ) { indexes . put ( index , new ArrayList < String > ( ) ) ; } if ( indexmappingsplitted . length > 1 ) { String mapping = indexmappingsplitted [ 1 ] ; indexes . get ( index ) . add ( mapping ) ; } } for ( String index : indexes . keySet ( ) ) { if ( ! isIndexExist ( index ) ) { createIndex ( index ) ; } else { if ( mergeSettings ) { mergeIndexSettings ( index ) ; } } Collection < String > mappings = indexes . get ( index ) ; for ( Iterator < String > iterator = mappings . iterator ( ) ; iterator . hasNext ( ) ; ) { String type = iterator . next ( ) ; pushMapping ( index , type , rebuildMapping , mergeMapping ) ; logger . info ( "create-mapping-ok.-index=" + index + ",-type=" + type ) ; } } } } \n', 0.399459968429366)

-('private void initializeJavaAssertionMaps ( ) { classAssertionStatus = new HashMap < > ( ) ; packageAssertionStatus = new HashMap < > ( ) ; AssertionStatusDirectives directives = retrieveDirectives ( ) ; for ( int i = 0 ; i < directives . classes . length ; i ++ ) classAssertionStatus . put ( directives . classes [ i ] , directives . classEnabled [ i ] ) ; for ( int i = 0 ; i < directives . packages . length ; i ++ ) packageAssertionStatus . put ( directives . packages [ i ] , directives . packageEnabled [ i ] ) ; defaultAssertionStatus = directives . deflt ; } \n', 0.3994092602370087)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 22 #################################
('final boolean popIfNext ( ForkJoinTask < ? > t ) { int s ; ForkJoinTask < ? > [ ] q = queue ; if ( t != null && q != null && casSlotNull ( q , ( q . length - 1 ) & ( s = sp - 1 ) , t ) ) { setSp ( s ) ; return true ; } return false ; } \n', 0.42554242701403777)

('public void failNextJpeg ( ) { final ReentrantLock lock = this . mLock ; lock . lock ( ) ; try { CaptureHolder h1 = mJpegCaptureQueue . peek ( ) ; CaptureHolder h2 = mJpegProduceQueue . peek ( ) ; CaptureHolder h = ( h1 == null ) ? h2 : ( ( h2 == null ) ? h1 : ( ( h1 . compareTo ( h2 ) <= 0 ) ? h1 : h2 ) ) ; if ( h != null ) { mJpegCaptureQueue . remove ( h ) ; mJpegProduceQueue . remove ( h ) ; mActiveRequests . remove ( h ) ; h . setJpegFailed ( ) ; } } finally { lock . unlock ( ) ; } } \n', 0.417859486713658)

('public boolean retainAll ( Collection coll ) { try { wr_ . acquire ( ) ; try { return c_ . retainAll ( coll ) ; } finally { wr_ . release ( ) ; } } catch ( InterruptedException ex ) { Thread . currentThread ( ) . interrupt ( ) ; throw new UnsupportedOperationException ( ) ; } } \n', 0.4175099888541878)

('public List < R > popFinishedResults ( ) throws ExecutionException , InterruptedException { List < R > finished = new ArrayList < R > ( ) ; Future < R > f ; while ( ( f = poll ( ) ) != null ) { finished . add ( f . get ( ) ) ; } return finished ; } \n', 0.4167022928775569)

('protected final boolean tryRelease ( int releases ) { if ( ! isHeldExclusively ( ) ) throw new IllegalMonitorStateException ( ) ; int nextc = getState ( ) - releases ; boolean free = exclusiveCount ( nextc ) == 0 ; if ( free ) setExclusiveOwnerThread ( null ) ; setState ( nextc ) ; return free ; } \n', 0.41221714536354276)

('boolean takeIndexWrapped ( ) { if ( isDetached ( ) ) return true ; if ( itrs . cycles - prevCycles > 1 ) { shutdown ( ) ; return true ; } return false ; } \n', 0.4041432959286734)

('private void completeCommits ( long previousCommitIndex , long commitIndex ) { for ( long i = previousCommitIndex + 1 ; i <= commitIndex ; i ++ ) { CompletableFuture < Long > future = appendFutures . remove ( i ) ; if ( future != null ) { future . complete ( i ) ; } } } \n', 0.4030121121191004)

('public final void helpComplete ( int maxTasks ) { Thread t ; ForkJoinWorkerThread wt ; if ( maxTasks > 0 && status >= 0 ) { if ( ( t = Thread . currentThread ( ) ) instanceof ForkJoinWorkerThread ) ( wt = ( ForkJoinWorkerThread ) t ) . pool . helpComplete ( wt . workQueue , this , maxTasks ) ; else ForkJoinPool . common . externalHelpComplete ( this , maxTasks ) ; } } \n', 0.4005120148848811)

('public void failNextPreview ( ) { final ReentrantLock lock = this . mLock ; lock . lock ( ) ; try { CaptureHolder h1 = mPreviewCaptureQueue . peek ( ) ; CaptureHolder h2 = mPreviewProduceQueue . peek ( ) ; CaptureHolder h = ( h1 == null ) ? h2 : ( ( h2 == null ) ? h1 : ( ( h1 . compareTo ( h2 ) <= 0 ) ? h1 : h2 ) ) ; if ( h != null ) { mPreviewCaptureQueue . remove ( h ) ; mPreviewProduceQueue . remove ( h ) ; mActiveRequests . remove ( h ) ; h . setPreviewFailed ( ) ; } } finally { lock . unlock ( ) ; } } \n', 0.400308853077054)

('@ Override protected void selectorIterationComplete ( ) throws IOException { TNonblockingTransport newClient ; while ( ( newClient = newConnections . poll ( ) ) != null ) { SelectionKey clientKey = newClient . registerSelector ( selector , SelectionKey . OP_READ ) ; clientKey . attach ( new Message ( newClient , clientKey , thriftFactories , useHeapBasedAllocation , alwaysReallocateBuffers ) ) ; } } \n', 0.39587907287151014)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('public static MessageDigest buildMd5 ( ) { try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; return digest ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( "Could-not-find-md5-algorithm" , e ) ; } } \n', 0.44545234346248797)

('private byte [ ] generateMD5 ( InputStream in ) throws NoSuchAlgorithmException , IOException { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; byte [ ] bytebuffer = new byte [ 1024 ] ; int numRead = 0 ; while ( ( numRead = in . read ( bytebuffer ) ) > 0 ) { digest . update ( bytebuffer , 0 , numRead ) ; } byte [ ] hashValue = digest . digest ( ) ; in . close ( ) ; return hashValue ; } \n', 0.4440021345488699)

('public static String generateMD5 ( String input ) { try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . reset ( ) ; md . update ( input . getBytes ( ) ) ; byte [ ] digest = md . digest ( ) ; BigInteger bigInt = new BigInteger ( 1 , digest ) ; String result = bigInt . toString ( 16 ) ; while ( result . length ( ) < 32 ) { result = "0" + result ; } return result ; } catch ( Exception e ) { return null ; } } \n', 0.4348676132606358)

('public static String generateMD5 ( String input ) { String md5 = null ; try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( input . getBytes ( ) , 0 , input . length ( ) ) ; md5 = new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return md5 ; } \n', 0.4341411781467084)

('public static String generateMD5 ( String unhashed ) { String generated_md5 = null ; if ( unhashed == null ) return null ; try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( unhashed . getBytes ( ) , 0 , unhashed . length ( ) ) ; generated_md5 = new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return generated_md5 ; } \n', 0.4331418272446791)

('public static String generateMd5 ( String value ) { try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( value . getBytes ( ) , 0 , value . length ( ) ) ; return new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { throw new UnhandledException ( "MD5-ist-not-available:-" , e ) ; } } \n', 0.4297560038231704)

('public static SaltAndHash saltAndHash ( String password ) { byte [ ] salt = new byte [ 16 ] ; random . nextBytes ( salt ) ; return hashFromSaltPassword ( password , Base64 . getEncoder ( ) . encodeToString ( salt ) ) ; } \n', 0.42902318604718287)

('public static String generateMD5 ( String text ) throws NoSuchAlgorithmException { MessageDigest m = MessageDigest . getInstance ( "MD5" ) ; m . update ( text . getBytes ( ) , 0 , text . length ( ) ) ; return new BigInteger ( 1 , m . digest ( ) ) . toString ( 16 ) ; } \n', 0.42881988880537686)

('public static String generateMD5 ( String aToken ) { MessageDigest aMessageDigest = null ; try { aMessageDigest = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { System . out . println ( "Algoritmo-solicitado-nÃ£o-encontrado." ) ; } BigInteger hash = new BigInteger ( 1 , aMessageDigest . digest ( aToken . getBytes ( ) ) ) ; String aMD5 = hash . toString ( 16 ) ; return aMD5 ; } \n', 0.42880152081697065)

('private static byte [ ] generateKeyFromPasswordSaltWithMD5 ( byte [ ] password , byte [ ] salt , int keyLen ) throws IOException { if ( salt . length < 8 ) throw new IllegalArgumentException ( "Salt-needs-to-be-at-least-8-bytes-for-key-generation." ) ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "VM-does-not-support-MD5" , e ) ; } byte [ ] key = new byte [ keyLen ] ; byte [ ] tmp = new byte [ md5 . getDigestLength ( ) ] ; while ( true ) { md5 . update ( password , 0 , password . length ) ; md5 . update ( salt , 0 , 8 ) ; int copy = ( keyLen < tmp . length ) ? keyLen : tmp . length ; try { md5 . digest ( tmp , 0 , tmp . length ) ; } catch ( DigestException e ) { IOException ex = new IOException ( "could-not-digest-password" ) ; ex . initCause ( e ) ; throw ex ; } System . arraycopy ( tmp , 0 , key , key . length - keyLen , copy ) ; keyLen -= copy ; if ( keyLen == 0 ) return key ; md5 . update ( tmp , 0 , tmp . length ) ; } } \n', 0.4277104097002139)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('public static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] ; } \n', 0.4429996253804881)

('private static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4429996253804881)

('public String getStackTrace ( ) { return getStackTrace ( this . throwable ) ; } \n', 0.44285188799114733)

('private static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('protected String getPartialServletStackTrace ( Throwable t ) { StringBuilder trace = new StringBuilder ( ) ; trace . append ( t . toString ( ) ) . append ( \'|n\' ) ; StackTraceElement [ ] elements = t . getStackTrace ( ) ; int pos = elements . length ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core.ApplicationFilterChain" ) ) && ( elements [ i ] . getMethodName ( ) . equals ( "internalDoFilter" ) ) ) { pos = i ; } } for ( int i = 0 ; i < pos ; i ++ ) { if ( ! ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core." ) ) ) { trace . append ( \'|t\' ) . append ( elements [ i ] . toString ( ) ) . append ( \'|n\' ) ; } } return trace . toString ( ) ; } \n', 0.44118865561056253)

('private StackTraceElement [ ] getInternalStackTrace ( ) { if ( stackTrace == null ) { stackTrace = getStackTraceImpl ( ) ; } return stackTrace ; } \n', 0.4411772637485003)

('public StackTraceElement [ ] getStackTrace ( ) { if ( stackTrace == null ) { stackTrace = constructJavaStackTrace ( this ) ; } return stackTrace ; } \n', 0.4390150820637422)

('public static final String getBriefStackTrace ( Throwable t ) { return formatStackTrace ( null , t , ">>" , 6 ) . toString ( ) ; } \n', 0.43848245578733636)

('public static String getStackTrace ( Exception exception ) { return getStackTrace ( ( Throwable ) exception ) ; } \n', 0.43762904330370306)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static List < IFeature > sortFeatures ( Collection < IFeature > features ) { List < IFeature > result = new ArrayList < IFeature > ( features ) ; Collections . sort ( result ) ; return result ; } \n', 0.43808639493842644)

('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

('public void sortProperties ( ) { ArrayList < DeployBeanProperty > list = new ArrayList < DeployBeanProperty > ( ) ; list . addAll ( propMap . values ( ) ) ; Collections . sort ( list , PROP_ORDER ) ; propMap = new LinkedHashMap < String , DeployBeanProperty > ( list . size ( ) ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { addBeanProperty ( list . get ( i ) ) ; } } \n', 0.43478187603899243)

('private static void sortDefinitions ( IWorldTree root ) { Collection < PropertyDef > definitions = root . definitions ( ) ; List < PropertyDef > orderedDefinitions = new ArrayList < PropertyDef > ( ) ; for ( Hierarchy level : Hierarchy . values ( ) ) { List < Property > levelOrderedProperties = new ArrayList < Property > ( ) ; resolvePropertyOrder ( hierarchicalDependencyMap . get ( level ) , null , null , levelOrderedProperties ) ; for ( Property property : levelOrderedProperties ) { Map < Property , PropertyDef > localDefMap = hierarchicalDefMap . get ( level ) ; orderedDefinitions . add ( localDefMap . get ( property ) ) ; } } assert ( definitions . size ( ) == orderedDefinitions . size ( ) && definitions . containsAll ( orderedDefinitions ) ) : "definitions-and-orderedDefinitions-are-not-equivalent!-" ; root . setDefinitions ( orderedDefinitions ) ; } \n', 0.4299758606367783)

('@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) public static < T extends Object > List < T > sort ( Collection < T > collection , String sortSpecification ) throws Exception { if ( collection == null ) { return null ; } List ret = new ArrayList ( collection ) ; if ( sortSpecification == null || sortSpecification . equalsIgnoreCase ( "asc" ) ) { Collections . sort ( ret ) ; } else if ( sortSpecification . equalsIgnoreCase ( "desc" ) ) { Collections . sort ( ret , Collections . reverseOrder ( ) ) ; } else { BeanPropertyComparator comparator = new BeanPropertyComparator ( sortSpecification ) ; Collections . sort ( ret , comparator ) ; } return ret ; } \n', 0.4282653014677018)

('public void sortFeatureMutualInfo ( ) { Collections . sort ( featureClassMutualInfoList ) ; } \n', 0.42673433504282743)

('private void sortPropertyDescriptors ( final Object o , List < IItemPropertyDescriptor > itemPropertyDescriptors ) { Collections . sort ( itemPropertyDescriptors , new Comparator < IItemPropertyDescriptor > ( ) { @ Override public int compare ( IItemPropertyDescriptor pd1 , IItemPropertyDescriptor pd2 ) { String c1 = pd1 . getCategory ( o ) ; String c2 = pd2 . getCategory ( o ) ; if ( c1 == null && c2 == null ) { return 0 ; } else if ( c1 == null ) { return - 1 ; } else if ( c2 == null ) { return 1 ; } return c1 . compareTo ( c2 ) ; } } ) ; } \n', 0.42248704220463024)

('public static Object [ ] sortOnProperty ( Object [ ] data , String PropName ) { Class ArrayClass = data . getClass ( ) . getComponentType ( ) ; ClassProperty TheProp = ClassAnalyzer . getClassProperty ( ArrayClass , PropName ) ; Method getMethod = TheProp . getGetMethod ( ) ; Object [ ] testData = ( Object [ ] ) Array . newInstance ( getMethod . getReturnType ( ) , data . length ) ; try { for ( int i = 0 ; i < data . length ; i ++ ) { Object Added = getMethod . invoke ( data [ i ] , EMPTY_OBJECT_ARRAY ) ; testData [ i ] = Added ; } } catch ( IllegalAccessException ex ) { throw new IllegalArgumentException ( "IllegalAccessException-getter-for-" + PropName + "-not-found" ) ; } catch ( InvocationTargetException ex ) { throw new IllegalArgumentException ( "InvokationTargetException-getter-for-" + PropName + "-not-found" ) ; } int [ ] order = getSortOrder ( testData ) ; if ( true ) throw new UnsupportedOperationException ( "Fix-This" ) ; Object [ ] ret = null ; for ( int i = 0 ; i < order . length ; i ++ ) ret [ i ] = data [ order [ i ] ] ; return ( ret ) ; } \n', 0.4152134705390136)

('public Collection sort ( Object object , String property ) { List properties = new ArrayList ( 1 ) ; properties . add ( property ) ; if ( object instanceof Collection ) { return sort ( ( Collection ) object , properties ) ; } else if ( object instanceof Object [ ] ) { return sort ( ( Object [ ] ) object , properties ) ; } else if ( object instanceof Map ) { return sort ( ( Map ) object , properties ) ; } return null ; } \n', 0.41263685074800294)

('private void sortProperties ( Property [ ] properties ) { Arrays . sort ( properties ) ; } \n', 0.4111116867002739)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('public static double roundToDecimalPlaces ( final double val , final int decimalPlaces ) { String zeros = "1" ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { zeros += "0" ; } int decimal = Integer . valueOf ( zeros ) . intValue ( ) ; if ( ! isNullOrZero ( val ) ) { return ( double ) Math . round ( val * decimal ) / decimal ; } return val ; } \n', 0.47474848012569243)

('public static double ceilToHalfInt ( double x ) { return Math . ceil ( x + 0.5 ) - 0.5 ; } \n', 0.4727329230563135)

('public static Double roundToDecimalPlaces ( final Double val , final int decimalPlaces ) { if ( ! isNullOrZero ( val ) ) { return Double . valueOf ( roundToDecimalPlaces ( val . doubleValue ( ) , decimalPlaces ) ) ; } return val ; } \n', 0.4708190755488689)

('public static float roundDecimal ( float value , double places ) { double multiplier = Math . pow ( 10 , places ) ; value *= multiplier ; return ( float ) ( Math . round ( value ) / multiplier ) ; } \n', 0.46927089065622263)

('public static Double roundToNDecimalPlaces ( Double toBeFormatted , int nDecimalPlaces ) { double decPlacesFact = Math . pow ( 10 , nDecimalPlaces ) ; return ( double ) Math . round ( toBeFormatted * decPlacesFact ) / decPlacesFact ; } \n', 0.46764733215472787)

('public static double roundToDecimalsCeil ( double val , int dec ) { double pow = Math . pow ( 10 , dec ) ; double temp = ( int ) Math . ceil ( val * pow ) ; return temp / pow ; } \n', 0.4641904540665735)

('public static float roundFloat ( float number , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( String . valueOf ( number ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } catch ( Exception e ) { logger . error ( e ) ; return number ; } } \n', 0.46368390074375193)

('public double round ( double val , int places ) { return Util . round ( val , places ) ; } \n', 0.4629896911742747)

('protected double roundToDecimalPlaces ( double number , int decimalPlace , boolean place ) { int temp = 1 ; for ( int i = 0 ; i < decimalPlace ; i ++ ) { temp = temp * 10 ; } if ( place ) { number = number / temp ; number = Math . round ( number ) ; number = number * temp ; } else { number = number * temp ; number = Math . round ( number ) ; number = number / temp ; } return number ; } \n', 0.462814356628056)

('public static double [ ] round ( final double [ ] vs , final int decimals ) { for ( int i = 0 ; i < vs . length ; i ++ ) { vs [ i ] = round ( vs [ i ] , decimals ) ; } return vs ; } \n', 0.4625068539745365)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
("static public final String zeroPad ( final int i , final int n_digits ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( i ) ; int len = sb . length ( ) ; while ( len < n_digits ) { sb . insert ( 0 , '0' ) ; len ++ ; } return sb . toString ( ) ; } \n", 0.4161426531480492)

('final static public void leftPad ( StringBuilder buf , String s , int desiredLength ) { int actualLen = 0 ; if ( s != null ) { actualLen = s . length ( ) ; } if ( actualLen < desiredLength ) { spacePad ( buf , desiredLength - actualLen ) ; } if ( s != null ) { buf . append ( s ) ; } } \n', 0.41591699153365136)

('public static final String leftPad ( String string , int size , char padChar ) { final StringBuilder result = new StringBuilder ( ) ; result . append ( string ) ; for ( int i = 0 ; i < size - string . length ( ) ; ++ i ) result . insert ( 0 , padChar ) ; return result . toString ( ) ; } \n', 0.41207031626999435)

('@ Deprecated final static public void leftPad ( StringBuffer buf , String s , int desiredLength ) { int actualLen = 0 ; if ( s != null ) { actualLen = s . length ( ) ; } if ( actualLen < desiredLength ) { spacePad ( buf , desiredLength - actualLen ) ; } if ( s != null ) { buf . append ( s ) ; } } \n', 0.41005239823984974)

('public static void leftPad ( long value , char padChar , int maxDigits , StringBuilder buf ) { int digits = ( value == 0 ) ? 1 : ( int ) Math . log10 ( value ) + 1 ; for ( int i = 0 ; i < maxDigits - digits ; i ++ ) { buf . append ( padChar ) ; } buf . append ( value ) ; } \n', 0.40835708931432024)

('private byte [ ] truncateOrPad ( byte [ ] source , int length ) { byte [ ] result = new byte [ length ] ; System . arraycopy ( source , 0 , result , 0 , Math . min ( length , source . length ) ) ; if ( length > source . length ) { for ( int i = source . length ; i < length ; i ++ ) { result [ i ] = 0 ; } } return result ; } \n', 0.4079633310655623)

('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

('@ NonNull public static String leftPadWithZeros ( @ Nullable final String toPad , final int finalSize ) { final StringBuilder temp = new StringBuilder ( ) ; if ( CoreLibConstants . IS_PARAMETER_CHECKING_ENABLED ) { if ( finalSize < 0 ) { throw new IllegalArgumentException ( "finalSize-cannot-be-negative" ) ; } } if ( null != toPad ) { temp . append ( toPad ) ; } if ( temp . length ( ) < finalSize ) { do { temp . insert ( 0 , \'0\' ) ; } while ( finalSize != temp . length ( ) ) ; } return temp . toString ( ) ; } \n', 0.4060354117236279)

('public static String leftPad ( String input , int length , char pad ) { if ( input . length ( ) < length ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 , len = length - input . length ( ) ; i < len ; i ++ ) { sb . append ( pad ) ; } sb . append ( input ) ; return sb . toString ( ) ; } return input ; } \n', 0.40544681800255356)

('protected static byte [ ] truncateOrPad ( byte [ ] source , int length ) { byte [ ] result = new byte [ length ] ; System . arraycopy ( source , 0 , result , 0 , Math . min ( length , source . length ) ) ; if ( length > source . length ) { for ( int i = source . length ; i < length ; i ++ ) { result [ i ] = 0 ; } } return result ; } \n', 0.4037978924079052)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public static Array createDoubleArray ( String name , Double [ ] values , StatMLSerializer ser ) throws StatMLSerializationException , IOException { Array array = new Array ( ) ; array . setDimensions ( String . valueOf ( values . length ) ) ; array . setName ( name ) ; array . setType ( "java.lang.Double" ) ; String encoded = ser . serialize ( null , values ) ; array . setBase64Value ( encoded ) ; return array ; } \n', 0.39682953240456487)

('private Class < ? > makeArrayIfNecessary ( Class < ? > clazz ) { if ( this . dimensions != 0 ) { for ( int i = 0 ; i < this . dimensions ; i ++ ) { Object array = Array . newInstance ( clazz , 0 ) ; clazz = array . getClass ( ) ; } } return clazz ; } \n', 0.39517098599024786)

('private Object createArray ( final Class < ? > arrayClass , final PropertyState propertyState ) { final Object value = getObject ( arrayClass , null , propertyState ) ; final Object array = Array . newInstance ( arrayClass , 1 ) ; Array . set ( array , 0 , value ) ; return array ; } \n', 0.3888965904884659)

('private static MBeanConstructorInfo [ ] createMBeanConstructors ( OpenMBeanConstructorInfo [ ] constructors ) throws ArrayStoreException { if ( constructors == null ) return null ; MBeanConstructorInfo [ ] constInfo = new MBeanConstructorInfo [ constructors . length ] ; System . arraycopy ( constructors , 0 , constInfo , 0 , constInfo . length ) ; return constInfo ; } \n', 0.3879997520253966)

('@ SuppressWarnings ( "unchecked" ) private static Object [ ] [ ] newBigArray ( Class < ? > componentType , final long length ) { if ( length == 0 && componentType == Object [ ] . class ) return EMPTY_BIG_ARRAY ; final int baseLength = ( int ) ( ( length + SEGMENT_MASK ) / SEGMENT_SIZE ) ; Object [ ] [ ] base = ( Object [ ] [ ] ) java . lang . reflect . Array . newInstance ( componentType , baseLength ) ; final int residual = ( int ) ( length & SEGMENT_MASK ) ; if ( residual != 0 ) { for ( int i = 0 ; i < baseLength - 1 ; i ++ ) base [ i ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , SEGMENT_SIZE ) ; base [ baseLength - 1 ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , residual ) ; } else for ( int i = 0 ; i < baseLength ; i ++ ) base [ i ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , SEGMENT_SIZE ) ; return base ; } \n', 0.3873194952677791)

('private static Object [ ] [ ] newBigArray ( Class < ? > componentType , final long length ) { if ( length == 0 && componentType == Object [ ] . class ) return EMPTY_BIG_ARRAY ; final int baseLength = ( int ) ( ( length + SEGMENT_MASK ) / SEGMENT_SIZE ) ; Object [ ] [ ] base = ( Object [ ] [ ] ) java . lang . reflect . Array . newInstance ( componentType , baseLength ) ; final int residual = ( int ) ( length & SEGMENT_MASK ) ; if ( residual != 0 ) { for ( int i = 0 ; i < baseLength - 1 ; i ++ ) base [ i ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , SEGMENT_SIZE ) ; base [ baseLength - 1 ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , residual ) ; } else for ( int i = 0 ; i < baseLength ; i ++ ) base [ i ] = ( Object [ ] ) java . lang . reflect . Array . newInstance ( componentType . getComponentType ( ) , SEGMENT_SIZE ) ; return base ; } \n', 0.3873194952677791)

('public static char [ ] createDynamicArraySignature ( char [ ] type ) { char [ ] ret = new char [ 1 + type . length ] ; ret [ 0 ] = C_DYNAMIC_ARRAY ; System . arraycopy ( type , 0 , ret , 1 , type . length ) ; return ret ; } \n', 0.3835552138156655)

('public static IArray createDoubleArray ( double [ ] javaArray , final int [ ] shape ) { return createArray ( Double . TYPE , shape , javaArray ) ; } \n', 0.38275134705345243)

('public static Object instantiateWrapperArray ( Class < ? > type , String [ ] values ) { validateParams ( type , values ) ; boolean condition = ( isWrapperArray ( type ) || hasOneArgStringConstructor ( type . getComponentType ( ) ) ) ; checkArgument ( condition , type . getName ( ) + "-is-neither-awrapper-type-nor-has-a-1-arg-String-constructor-defined." ) ; Class < ? > componentType = type . getComponentType ( ) ; Object arrayToReturn = Array . newInstance ( componentType , values . length ) ; for ( int i = 0 ; i < values . length ; i ++ ) { try { Array . set ( arrayToReturn , i , componentType . getConstructor ( String . class ) . newInstance ( values [ i ] ) ) ; } catch ( ArrayIndexOutOfBoundsException | IllegalArgumentException | InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | SecurityException e ) { throw new ReflectionException ( e ) ; } } return arrayToReturn ; } \n', 0.3805221651977695)

('public static char [ ] createStaticArraySignature ( char [ ] type , char [ ] dimension ) { int dimensionLength = dimension . length ; int dimensionLengthStringLength = lenghtOfLengthToString ( dimension ) ; char [ ] ret = new char [ 3 + type . length + dimensionLengthStringLength + dimensionLength ] ; ret [ 0 ] = C_STATIC_ARRAY ; System . arraycopy ( type , 0 , ret , 1 , type . length ) ; ret [ type . length + 1 ] = C_STATIC_ARRAY2 ; copyNumber ( dimensionLength , dimensionLengthStringLength , ret , 2 + type . length ) ; ret [ 2 + type . length + dimensionLengthStringLength ] = C_STATIC_ARRAY ; System . arraycopy ( dimension , 0 , ret , 3 + type . length + dimensionLengthStringLength , dimensionLength ) ; return ret ; } \n', 0.3796523149638734)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('public static List < String > readTextFileAsStringList ( String filePath ) { BufferedReader reader ; List < String > lineList = new ArrayList < String > ( ) ; try { reader = new BufferedReader ( new FileReader ( filePath ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { lineList . add ( line ) ; line = reader . readLine ( ) ; } reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return lineList ; } \n', 0.4280808360647729)

('public static String readTextFile ( File file ) throws IOException { if ( Locale . getDefault ( ) . getLanguage ( ) . equals ( "en" ) == false ) { return readI18NFile ( file ) ; } FileReader in = new FileReader ( file ) ; int size = ( int ) file . length ( ) ; char [ ] data = new char [ size ] ; int chars_read = 0 ; while ( chars_read < size ) { chars_read += in . read ( data , chars_read , size - chars_read ) ; } return new String ( data ) ; } \n', 0.4254513574659099)

('public static List < String > loadTextFile ( final String location , final List < String > list ) throws IOException { final BufferedReader reader = new BufferedReader ( getReader ( location ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { list . add ( line ) ; line = reader . readLine ( ) ; } return list ; } \n', 0.42468146728707046)

('public static void readTextFile ( String _fileName , ArrayList < String > _strings ) throws java . io . IOException { BufferedReader reader = new BufferedReader ( new FileReader ( _fileName ) ) ; StreamTokenizer st = new StreamTokenizer ( reader ) ; for ( int token = st . nextToken ( ) ; token != StreamTokenizer . TT_EOF ; token = st . nextToken ( ) ) { switch ( token ) { case StreamTokenizer . TT_WORD : _strings . add ( _strings . size ( ) , st . sval ) ; break ; default : break ; } } reader . close ( ) ; return ; } \n', 0.42275865097102977)

('public void loadTextFile ( String path ) throws IOException { BufferedReader input = new BufferedReader ( new InputStreamReader ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( path ) ) ) ; String line ; while ( input . ready ( ) ) { line = input . readLine ( ) ; StringBuffer word = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ( ) ; ++ i ) { char c = line . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { continue ; } word . append ( c ) ; } if ( word . length ( ) < 1 ) { continue ; } add ( word . toString ( ) ) ; } input . close ( ) ; } \n', 0.42202302827444793)

('public static String readTextFile ( File inputFile ) throws IOException { FileInputStream fis = new FileInputStream ( inputFile ) ; Charset charset = Charset . forName ( "UTF-8" ) ; InputStreamReader isr = new InputStreamReader ( fis , charset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuffer contents = new StringBuffer ( ) ; String line ; String separator = System . getProperty ( "line.separator" ) ; while ( ( line = reader . readLine ( ) ) != null ) { contents . append ( line ) . append ( separator ) ; } fis . close ( ) ; isr . close ( ) ; return contents . toString ( ) ; } \n', 0.41996497953351564)

('public static int [ ] readIntsFromTextFile ( String file ) { String [ ] strings = readTextFile ( file ) ; if ( strings == null ) return null ; int [ ] ints = new int [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) ints [ i ] = Integer . parseInt ( strings [ i ] ) ; return ints ; } \n', 0.41965661505699475)

('protected String readFileToString ( File file ) throws IOException { StringBuilder text = new StringBuilder ( ) ; String EOL = System . getProperty ( "line.separator" ) ; Scanner scanner = new Scanner ( new FileInputStream ( file ) ) ; try { while ( scanner . hasNextLine ( ) ) { text . append ( scanner . nextLine ( ) + EOL ) ; } } finally { scanner . close ( ) ; } return text . toString ( ) ; } \n', 0.4192417885142407)

('private Hashtable readProgramListFromTextFile ( ) throws IOException { final Hashtable result = new Hashtable ( ) ; final InputStream is = getClass ( ) . getResourceAsStream ( "/programs/programs.txt" ) ; int c = 0 ; while ( c >= 0 ) { final StringBuffer line = new StringBuffer ( ) ; while ( ( c = is . read ( ) ) > 0 && c != \'|n\' && c != \'|r\' ) { line . append ( ( char ) c ) ; } if ( ! line . toString ( ) . startsWith ( "#" ) && line . length ( ) > 0 ) { result . put ( line . toString ( ) , "/programs/" + line . toString ( ) ) ; } } return result ; } \n', 0.4191684070453872)

('public static String readTextFile ( File file ) { Scanner s = null ; try { s = new Scanner ( file ) . useDelimiter ( "" ) ; } catch ( FileNotFoundException ex ) { ChatterBox . error ( "utilities.BitStylus" , "splitTextFile" , "Not-a-valid-text-file" ) ; } String text = "" ; while ( s . hasNext ( ) ) { text = text + s . next ( ) ; } return text ; } \n', 0.4184221904598358)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('void invokeIORInterceptors ( POAImpl poaImpl ) { if ( enabled ) { IORInfoImpl info = new IORInfoImpl ( orb , poaImpl ) ; IORInterceptor [ ] iorInterceptors = ( IORInterceptor [ ] ) interceptorList . getInterceptors ( InterceptorList . INTERCEPTOR_TYPE_IOR ) ; int size = iorInterceptors . length ; for ( int i = ( size - 1 ) ; i >= 0 ; i -- ) { IORInterceptor interceptor = iorInterceptors [ i ] ; try { interceptor . establish_components ( info ) ; } catch ( Exception e ) { } } } } \n', 0.4037760204291455)

('public static < T > T traverseCauseHierarchy ( Throwable e , ExceptionEvaluator < T > evaluator ) { LinkedList < Throwable > exceptions = new LinkedList < Throwable > ( ) ; exceptions . add ( e ) ; while ( e . getCause ( ) != null && ! e . getCause ( ) . equals ( e ) ) { exceptions . addFirst ( e . getCause ( ) ) ; e = e . getCause ( ) ; } for ( Throwable exception : exceptions ) { T value = evaluator . evaluate ( exception ) ; if ( value != null ) { return value ; } } return null ; } \n', 0.4033813378864524)

('public void updateEffectiveTargetIOR ( IOR newIOR ) { contactInfoList . setEffectiveTargetIOR ( newIOR ) ; ( ( CorbaInvocationInfo ) orb . getInvocationInfo ( ) ) . setContactInfoListIterator ( contactInfoList . iterator ( ) ) ; } \n', 0.39098562111581703)

('public void visitAnnotationArrayInit ( GroovySourceAST t , int visit ) { Iterator itr = itr ( visit ) ; while ( itr . hasNext ( ) ) { ( ( Visitor ) itr . next ( ) ) . visitAnnotationArrayInit ( t , visit ) ; } } \n', 0.3908316411974906)

('public static FluentIterable < Class < ? >> getClosureOfInterfaces ( Class < ? > clazz ) { Preconditions . checkNotNull ( clazz ) ; Queue < Class < ? >> interfacesToProcess = Queues . newArrayDeque ( ) ; Collections . addAll ( interfacesToProcess , clazz . getInterfaces ( ) ) ; LinkedHashSet < Class < ? >> interfaces = new LinkedHashSet < > ( ) ; while ( ! interfacesToProcess . isEmpty ( ) ) { Class < ? > current = interfacesToProcess . remove ( ) ; if ( interfaces . add ( current ) ) { Collections . addAll ( interfacesToProcess , current . getInterfaces ( ) ) ; } } return FluentIterable . from ( interfaces ) ; } \n', 0.38990776704399743)

('protected void invokeJsonMappingCompletedMethods ( Object object ) throws IllegalArgumentException , IllegalAccessException , InvocationTargetException { for ( Method method : findMethodsWithAnnotation ( object . getClass ( ) , JsonMappingCompleted . class ) ) { method . setAccessible ( true ) ; if ( method . getParameterTypes ( ) . length == 0 ) method . invoke ( object ) ; else if ( method . getParameterTypes ( ) . length == 1 && JsonMapper . class . equals ( method . getParameterTypes ( ) [ 0 ] ) ) method . invoke ( object , this ) ; else throw new FacebookJsonMappingException ( format ( "Methods-annotated-with-@%s-must-take-0-parameters-or-a-single-%s-parameter.-Your-method-was-%s" , JsonMappingCompleted . class . getSimpleName ( ) , JsonMapper . class . getSimpleName ( ) , method ) ) ; } } \n', 0.38882991104573245)

('public static Collection < ? super Object > resolveCollectionType ( Class < ? > collectionType , Collection < ? super Object > defaultValue ) { Collection < ? super Object > retValue = null ; if ( null != defaultValue && ( defaultValue . getClass ( ) . getModifiers ( ) & Modifier . PRIVATE ) == 0 ) { retValue = defaultValue ; } else { if ( Queue . class . isAssignableFrom ( collectionType ) ) { if ( collectionType . isAssignableFrom ( LinkedList . class ) ) { retValue = new LinkedList < Object > ( ) ; } } else if ( Set . class . isAssignableFrom ( collectionType ) ) { if ( collectionType . isAssignableFrom ( HashSet . class ) ) { retValue = new HashSet < Object > ( ) ; } } else { if ( collectionType . isAssignableFrom ( ArrayList . class ) ) { retValue = new ArrayList < Object > ( ) ; } } if ( null != retValue && null != defaultValue ) { retValue . addAll ( defaultValue ) ; } } return retValue ; } \n', 0.3872366241960007)

('@ SuppressWarnings ( { "unchecked" } ) public static < T > Collection < T > invokeAndCastCollection ( T returnType , Method m , Object obj , Object ... args ) { try { return ( Collection < T > ) m . invoke ( obj , args ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } \n', 0.38621095797944804)

('DependencyCheck ( Iterable < String > typeNames ) { this . typeNames = FluentIterable . from ( typeNames ) ; } \n', 0.38594235665534776)

('private void processEnumsInCollections ( @ SuppressWarnings ( "rawtypes" ) List list , Object [ ] cValues , IDecisionVariable dc ) { @ SuppressWarnings ( "rawtypes" ) Class classType = dc . getDeclaration ( ) . getType ( ) . getTypeClass ( ) ; if ( classType . equals ( Sequence . class ) ) { Container container = ( Container ) dc . getDeclaration ( ) . getType ( ) ; if ( container . getContainedType ( ) . isAssignableFrom ( Enum . TYPE ) ) { Enum en = ( Enum ) container . getContainedType ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { cValues [ i ] = en . getLiteralByOrdinal ( ( Integer ) list . get ( i ) ) ; } } if ( container . getContainedType ( ) . isAssignableFrom ( OrderedEnum . TYPE ) ) { OrderedEnum en = ( OrderedEnum ) container . getContainedType ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { cValues [ i ] = en . getLiteralByOrdinal ( ( Integer ) list . get ( i ) ) ; } } } } \n', 0.38573480756099837)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public boolean isSkipVerify ( ) { return skipPhases . contains ( TestExecutionPhase . VERIFY ) ; } \n', 0.41393100504370417)

('private void checkInvariants ( ) throws IllegalStateException { if ( start . after ( end ) ) throw new IllegalStateException ( start + "-after-" + end ) ; } \n', 0.4112168477886227)

('public synchronized boolean isOKAndEqualOrAfter ( State afterThis ) { if ( afterThis == null ) { return false ; } if ( ! this . isOKState ( ) ) { return false ; } final String afterThisString = afterThis . getState ( ) ; if ( ! testOKState ( afterThisString ) ) { return false ; } if ( this . equals ( afterThis ) ) { return true ; } int afterThisIndex = - 1 ; for ( int i = 0 ; i < OK_STATES . length ; i ++ ) { if ( OK_STATES [ i ] . equals ( afterThisString ) ) { afterThisIndex = i ; break ; } } int thisIndex = - 1 ; for ( int i = 0 ; i < OK_STATES . length ; i ++ ) { if ( OK_STATES [ i ] . equals ( this . state ) ) { thisIndex = i ; break ; } } final int runningIndex = 3 ; final int pausedIndex = 4 ; if ( thisIndex == pausedIndex ) { thisIndex = runningIndex ; } if ( afterThisIndex == pausedIndex ) { afterThisIndex = runningIndex ; } if ( thisIndex < 0 || afterThisIndex < 0 ) { return false ; } return thisIndex >= afterThisIndex ; } \n', 0.41105471236478)

('@ Override public boolean isValid ( ) { if ( ! super . isValid ( ) ) { return false ; } if ( this . featureGenerator == null ) { return false ; } if ( this . startStateGenerator == null ) { return false ; } if ( this . epsilon < 0 || Double . isNaN ( this . epsilon ) ) { return false ; } if ( this . maxIterations <= 0 ) { return false ; } if ( this . policyCount <= 0 ) { return false ; } return true ; } \n', 0.40542277863359194)

('boolean isValid ( ) { return this . min_value < this . max_value && ! Double . isNaN ( min_value ) && ! Double . isNaN ( max_value ) ; } \n', 0.4044432109731551)

('protected boolean hasMovedEnough ( MouseEvent e ) { int dx = e . x - xAnchor ; int dy = e . y - yAnchor ; if ( Math . abs ( dx ) < HYSTERESIS && Math . abs ( dy ) < HYSTERESIS ) { return false ; } else { return true ; } } \n', 0.40386595713052376)

('protected boolean checkWithinRange ( double [ ] input , double tolerance ) { double min = Double . POSITIVE_INFINITY ; double max = Double . NEGATIVE_INFINITY ; for ( double x : input ) { if ( x < min ) min = x ; if ( x > max ) max = x ; } double diff = ( Math . abs ( min - max ) / ( ( min + max ) / 2 ) ) ; if ( diff > tolerance ) { return false ; } else { return true ; } } \n', 0.4026507901060421)

('@ Override public boolean shouldSearchContinue ( Vertex origin , Vertex target , State current , ShortestPathTree spt , RoutingRequest traverseOptions ) { final double traveledDistance = current . getWalkDistance ( ) ; if ( Math . abs ( traveledDistance ) >= this . maxDistance ) { return false ; } return this . end . size ( ) != 0 ; } \n', 0.40017826285446306)

('public boolean isValidSuccessor ( ProcessState predecessor ) { return predecessor == this || predecessors . contains ( predecessor ) ; } \n', 0.39899734481151616)

('public static boolean isValid ( double value ) { return Double . compare ( value , 0.0 ) != 0 ; } \n', 0.3988949180079333)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('public static Integer convertirStringToInteger ( String value ) { Integer intValue ; try { intValue = Integer . valueOf ( value ) ; } catch ( Exception e ) { return null ; } return intValue ; } \n', 0.4400905798676506)

('public Integer convertStringToInteger ( String value ) { Integer result ; try { result = Integer . valueOf ( value ) ; } catch ( NumberFormatException e ) { result = DEFAULT_INT_VALUE ; } return result ; } \n', 0.43655453213297707)

('public Integer convertStringToInteger ( String s ) { return Integer . valueOf ( s ) ; } \n', 0.43408325044095675)

('private Integer convertStringToInteger ( final String string ) { if ( string == null ) { return null ; } return Integer . valueOf ( string ) ; } \n', 0.43408325044095675)

('public static int convertStringToInteger ( String number ) { int i = 0 ; try { i = Integer . valueOf ( number ) ; } catch ( Exception ex ) { } return i ; } \n', 0.43237133150740953)

('public static int [ ] convertStringToInt ( String [ ] numbers ) { int [ ] intArr = new int [ numbers . length ] ; for ( int index = 0 ; index < numbers . length ; index ++ ) { int number = Integer . parseInt ( numbers [ index ] ) ; intArr [ index ] = number ; } return intArr ; } \n', 0.4321338389732564)

('public static Integer safeStringToInteger ( String inString ) { Integer wkIntVal = Integer . valueOf ( 0 ) ; if ( null == inString ) return wkIntVal ; inString = inString . trim ( ) ; if ( 0 == inString . length ( ) ) return wkIntVal ; try { wkIntVal = Integer . valueOf ( inString ) ; } catch ( NumberFormatException nfe ) { } return wkIntVal ; } \n', 0.43098105443510054)

('@ Validate public static short fromStringToInt16 ( @ NotNull final String value ) { return Short . parseShort ( value , 10 ) ; } \n', 0.43037015624714936)

('@ Validate public static int fromStringToInt32 ( @ NotNull final String value ) { return Integer . parseInt ( value , 10 ) ; } \n', 0.4297234678270203)

('public static Integer stringToInteger ( final String str ) { if ( ( str != null ) && ( str . length ( ) > 0 ) ) { return Integer . valueOf ( str ) ; } else { return null ; } } \n', 0.42969043929345024)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
("public static short javaStringToInt ( java . lang . String str ) { StringCharacterIterator i = new StringCharacterIterator ( str ) ; i . first ( ) ; boolean neg = false ; if ( i . current ( ) == '-' ) { neg = true ; i . next ( ) ; } int value = 0 ; for ( ; i . current ( ) != CharacterIterator . DONE ; i . next ( ) ) { char c = i . current ( ) ; if ( i . current ( ) < '0' || c > '9' ) break ; value = value * 10 + ( c - '0' ) ; } if ( neg ) { return ( short ) - value ; } else { return ( short ) value ; } } \n", 0.4097863904555822)

('public static byte [ ] toByteArrayFromString ( String value , int radix ) { assert 16 == radix : "Specified-string-to-byte-array-conversion-not-supported-yet" ; assert ( value . length ( ) % 2 ) == 0 : "Hex-binary-string-must-contain-even-number-of-characters" ; byte [ ] ret = new byte [ value . length ( ) / 2 ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { int digit1 = Character . digit ( value . charAt ( i * 2 ) , radix ) ; int digit2 = Character . digit ( value . charAt ( ( i * 2 ) + 1 ) , radix ) ; assert ( digit1 != - 1 ) && ( digit2 != - 1 ) : "String-could-not-be-converted-to-byte-array" ; ret [ i ] = ( byte ) ( ( digit1 * radix ) + digit2 ) ; } return ret ; } \n', 0.39908941056209274)

('public Object convertFromString ( Class < ? > cls , String str ) { if ( str . length ( ) != 1 ) { throw new IllegalArgumentException ( "Character-value-must-be-a-string-length-1" ) ; } return new Character ( str . charAt ( 0 ) ) ; } \n', 0.38993108252726016)

('@ Override public Object convertFromString ( Class < ? > cls , String str ) { if ( str . length ( ) != 1 ) { throw new IllegalArgumentException ( "Character-value-must-be-a-string-length-1" ) ; } return new Character ( str . charAt ( 0 ) ) ; } \n', 0.38993108252726016)

('public static int binaryStringToInt ( String value ) { int result = value . charAt ( 0 ) - 48 ; for ( int i = 1 ; i < value . length ( ) ; i ++ ) { result = ( result << 1 ) | ( value . charAt ( i ) - 48 ) ; } return result ; } \n', 0.3897022876937256)

('public static long binaryStringToLong ( String value ) { long result = value . charAt ( 0 ) - 48 ; for ( int i = 1 ; i < value . length ( ) ; i ++ ) { result = ( result << 1 ) | ( value . charAt ( i ) - 48 ) ; } return result ; } \n', 0.3866028177496816)

('public static short toShort ( String hexStr ) { short result = 0 ; String hex = hexStr . toUpperCase ( ) ; for ( int i = 0 ; i < hex . length ( ) ; i ++ ) { char c = hex . charAt ( hex . length ( ) - i - 1 ) ; byte b = toByte ( c ) ; result |= ( b & 0x0f ) << ( i * 4 ) ; } return result ; } \n', 0.3853263258711612)

('public long toLong ( final String value ) { final int len = value . length ( ) ; if ( len > MAX_LEN ) { throw new IllegalArgumentException ( "Maximum-length-is:-" + MAX_LEN + "-value:-"" + value + """ ) ; } final String cased = lower ? value . toLowerCase ( ) : value . toUpperCase ( ) ; final char [ ] chars = cased . toCharArray ( ) ; long v = 0 ; for ( int i = 0 ; i < chars . length ; i ++ ) { v = v * RADIX + indexOf ( chars [ i ] ) ; } return v ; } \n', 0.3852049397779763)

('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

('public static long fromUnicodeStringToLong ( String s , int numBits ) throws NumberFormatException { if ( s . length ( ) * 16 > numBits ) throw new NumberFormatException ( "value-won\'t-fit-in-the-given-bits" ) ; long result = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) result = ( result << 16 ) + s . codePointAt ( i ) ; return result ; } \n', 0.38191435247907174)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('private void checkIfLocalFileExistsAndCanRead ( ) throws FileTransferException { if ( ! localFile . exists ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , new FileNotFoundException ( localFile . getAbsolutePath ( ) ) , true ) ; } if ( ! localFile . canRead ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , "File-exists-but-cannot-be-read" , true ) ; } } \n', 0.4041461995914023)

('protected boolean checkFileForAndroidRes ( File file ) { String name = file . getName ( ) ; int pos = name . lastIndexOf ( \'.\' ) ; String extension = "" ; if ( pos != - 1 ) { extension = name . substring ( pos + 1 ) ; } return ! ( name . charAt ( 0 ) == \'.\' || name . charAt ( name . length ( ) - 1 ) == \'~\' ) && ! "scc" . equalsIgnoreCase ( extension ) && ! "swp" . equalsIgnoreCase ( extension ) && ! "thumbs.db" . equalsIgnoreCase ( name ) && ! "picasa.ini" . equalsIgnoreCase ( name ) ; } \n', 0.39822685804625035)

('private boolean isValidFile ( String name , Set < JavaFileObject . Kind > fileKinds ) { int dot = name . lastIndexOf ( "." ) ; JavaFileObject . Kind kind = getKind ( dot == - 1 ? name : name . substring ( dot ) ) ; return fileKinds . contains ( kind ) ; } \n', 0.3942632211339955)

('private boolean isValidFileDescriptor ( int fd ) { return fd >= 0 && fd < _descriptors . size ( ) && _descriptors . get ( fd ) != null ; } \n', 0.39216277982070147)

('public static boolean isJavaFile ( File file ) { return file . isFile ( ) && file . getName ( ) . endsWith ( ".java" ) ; } \n', 0.3920559149155468)

('private static boolean shouldUnpack ( final File file ) { final String name = file . getName ( ) ; if ( name . endsWith ( ".ear" ) || name . endsWith ( ".rar" ) || name . endsWith ( ".rar" ) ) { return true ; } JarFile jarFile = null ; try { jarFile = new JarFile ( file ) ; if ( jarFile . getEntry ( "META-INF/application.xml" ) != null ) { return true ; } if ( jarFile . getEntry ( "META-INF/ra.xml" ) != null ) { return true ; } if ( jarFile . getEntry ( "WEB-INF/web.xml" ) != null ) { return true ; } } catch ( final IOException e ) { } finally { if ( jarFile != null ) { try { jarFile . close ( ) ; } catch ( final IOException ignored ) { } } } return false ; } \n', 0.39155655485498025)

('private static boolean shouldExtractFile ( String fileName ) { if ( fileName . equals ( Capsule . class . getName ( ) . replace ( \'.\' , \'/\' ) + ".class" ) || ( fileName . startsWith ( Capsule . class . getName ( ) . replace ( \'.\' , \'/\' ) + "$" ) && fileName . endsWith ( ".class" ) ) ) return false ; if ( fileName . endsWith ( ".class" ) ) return false ; if ( fileName . startsWith ( "capsule/" ) ) return false ; if ( fileName . startsWith ( "META-INF/" ) ) return false ; return true ; } \n', 0.39094707168118087)

('public boolean hasLocalJarFile ( ) { File jar = getLocalJarFile ( ) ; System . out . println ( "jar-file:-" + jar ) ; if ( jar == null ) return false ; return jar . isFile ( ) && jar . canRead ( ) ; } \n', 0.39055755060018127)

('@ Override public boolean isWriteable ( Class < ? > type , Type genericType , Annotation [ ] annotations , MediaType mediaType ) { LOG . info ( "called-isWriteable-method" ) ; if ( type == null ) { return false ; } if ( type . isAssignableFrom ( GenericFile . class ) ) { LOG . debug ( "-isWriteable-true" ) ; return true ; } return false ; } \n', 0.38886060586432153)

('File findValidFile ( final String fileName , final File curDir ) { if ( fileName == null || curDir == null || ! isValid ( curDir , true ) ) { throw new IllegalArgumentException ( "ConstMetaData.findValidFile(String,File)" ) ; } File file = new File ( curDir , fileName ) ; if ( ! file . exists ( ) ) { invalidReason = fileName + "-does-not-exist-in-" + curDir . getAbsolutePath ( ) ; return null ; } if ( ! file . canRead ( ) ) { invalidReason = "Can\'t-read-" + fileName ; return null ; } return curDir ; } \n', 0.3872791577270325)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('public static Date convertBirthdayStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( birthdayFormat ) ; try { DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.43949680460688345)

('public static String ConvertDateToISO8601String ( Date date ) { SimpleDateFormat format = new SimpleDateFormat ( ISO8061_PATTERN ) ; return format . format ( date ) ; } \n', 0.43783374840941697)

('protected synchronized String convertDateToCompatibleString ( Date date ) { if ( date == null ) { return null ; } return compatibleDateFormat . format ( date ) ; } \n', 0.4360069111752919)

('private static void convertDateString ( String str ) { try { Date date = Utils . dateFromString ( str ) ; display ( "Date-to-millis:-" + date . getTime ( ) ) ; } catch ( Exception e ) { } } \n', 0.43311623744253447)

('public static Date convertStringToDate ( String dateString ) throws ParseException { String defaultDateFormat = "MM/dd/yyyy" ; if ( isNullOrEmpty ( dateString ) ) { return null ; } return convertStringToDate ( dateString , defaultDateFormat ) ; } \n', 0.4308422371033347)

('public static Date convertStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( inputFormat ) ; DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } \n', 0.4303287069352944)

('protected String convertDateToString ( Date value ) { return format . format ( value ) ; } \n', 0.430124860356443)

('public static Timestamp convertStringDateTimeOldFormatToTimestamp ( String DateTime ) throws ParseException { Timestamp ts = new Timestamp ( getOutDatetimeFormat ( ) . parse ( DateTime ) . getTime ( ) ) ; return ts ; } \n', 0.42995812365051395)

('public static String dateStringToShortLocaleString ( String dateString , String formatString ) throws ParseException { SimpleDateFormat defaultSdf = new SimpleDateFormat ( UtilDateTime . getDateTimeFormat ( Locale . getDefault ( ) ) ) ; SimpleDateFormat sdf = new SimpleDateFormat ( formatString ) ; return defaultSdf . format ( sdf . parse ( dateString ) ) ; } \n', 0.429811752769706)

('public java . sql . Date convertStringToSqlDateFormat ( String strDate ) { java . sql . Date retSqlDate = null ; SimpleDateFormat sdfInput = null ; SimpleDateFormat sdfOutput = null ; java . util . Date utilDate = null ; String tempSqlDate = null ; String inputFormat = "MM/dd/yyyy" ; String outputFormat = "yyyy-MM-dd" ; sdfInput = new SimpleDateFormat ( inputFormat ) ; sdfOutput = new SimpleDateFormat ( outputFormat ) ; try { if ( strDate != null ) { utilDate = sdfInput . parse ( strDate ) ; tempSqlDate = sdfOutput . format ( utilDate ) ; retSqlDate = java . sql . Date . valueOf ( tempSqlDate ) ; } } catch ( Exception e ) { System . out . println ( e . getLocalizedMessage ( ) ) ; e . printStackTrace ( ) ; } return retSqlDate ; } \n', 0.42933124296196745)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('public static byte [ ] readBytesToNull ( InputStream inStream ) throws IOException { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; int b ; while ( inStream . available ( ) > 0 && ( b = inStream . read ( ) ) != 0 ) { outStream . write ( b ) ; } return outStream . toByteArray ( ) ; } \n', 0.41523948719849085)

('public static Object byteArrayToObject ( byte [ ] byteArray ) throws IOException , ClassNotFoundException { ByteArrayInputStream bis = new ByteArrayInputStream ( byteArray ) ; Object tmpObj = null ; try ( ObjectInput in = new ObjectInputStream ( bis ) ) { tmpObj = in . readObject ( ) ; bis . close ( ) ; } return tmpObj ; } \n', 0.4092816412123664)

('private InputStream convertByteArrayToInputStream ( byte [ ] byteArray ) { return new ByteArrayInputStream ( byteArray ) ; } \n', 0.4087355582778591)

('public static int [ ] deserializeVIntArray ( byte [ ] b ) { ByteArrayInputStream bytesIn = new ByteArrayInputStream ( b ) ; DataInputStream in = new DataInputStream ( bytesIn ) ; try { int length = WritableUtils . readVInt ( in ) ; return deserializeVIntArray ( in , length ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } } \n', 0.4060949057793044)

('private static ByteArrayInputStream convertToByteArrayInputStream ( InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; return byteArrayInputStream ; } \n', 0.4039060814012379)

('@ NonNull private static ByteArrayInputStream convertToByteArrayInputStream ( @ NonNull InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } return new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; } \n', 0.4039000299514178)

('public static byte [ ] inputStreamToByteArray ( InputStream paramInputStream ) throws IOException { ByteArrayOutputStream localByteArrayOutputStream = new ByteArrayOutputStream ( ) ; inputStreamToOutputStream ( paramInputStream , localByteArrayOutputStream ) ; return localByteArrayOutputStream . toByteArray ( ) ; } \n', 0.4032888860828461)

('public static byte [ ] inputStreamToByteArray ( InputStream is ) { try { final ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; copyStream ( new BufferedInputStream ( is ) , os ) ; os . close ( ) ; return os . toByteArray ( ) ; } catch ( Exception e ) { throw new OXFException ( e ) ; } } \n', 0.4026550447391033)

('public static byte [ ] convertStreamToBytes ( InputStream stream ) throws IOException { if ( stream == null ) { return null ; } ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; copyStream ( stream , output ) ; return output . toByteArray ( ) ; } \n', 0.4017717341597527)

('public static byte [ ] readToBytes ( InputStream inputStream , boolean close ) throws IOException { if ( inputStream == null ) return null ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; StreamHelper . copy ( inputStream , outputStream , close ) ; return outputStream . toByteArray ( ) ; } \n', 0.40087824797102056)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('private static final boolean isNumeric ( final char formatChar , final int count ) { int i = NUMERIC_FORMAT_CHARS . indexOf ( formatChar ) ; return ( i > 0 || ( i == 0 && count < 3 ) ) ; } \n', 0.4319100778826536)

('public boolean isValidNumeric ( String value ) { String numericPattern = "[0-9]+?" ; boolean result ; value = value . trim ( ) ; result = value . matches ( numericPattern ) && value . length ( ) > 0 ; return result ; } \n', 0.4265075056048275)

("public static final boolean isInt ( String s ) { boolean ret = false ; String ss = s . trim ( ) ; int len = ss . length ( ) ; int firstIndex = 0 ; if ( len > 0 ) { char first = ss . charAt ( firstIndex ) ; if ( first == '+' || first == '-' ) { if ( len == 1 ) return false ; firstIndex ++ ; } for ( int i = firstIndex ; i < len ; i ++ ) { if ( ! Character . isDigit ( ss . charAt ( i ) ) ) return false ; } ret = true ; } return ret ; } \n", 0.426505062339363)

("boolean isValidDouble ( String s ) { if ( s == null || s . length ( ) == 0 ) return false ; boolean foundDecimal = false ; char [ ] chars = s . toCharArray ( ) ; int start = ( chars [ 0 ] == '+' || chars [ 0 ] == '-' ) ? 1 : 0 ; for ( int i = start ; i < chars . length ; i ++ ) { if ( Character . isDigit ( chars [ i ] ) ) continue ; if ( ( chars [ i ] == '.' ) && ( ! foundDecimal ) ) { foundDecimal = true ; continue ; } return false ; } return true ; } \n", 0.42493030203337856)

("public static boolean isDecimal ( String value ) { if ( value == null ) { return false ; } boolean dotFound = false ; char [ ] array = value . toCharArray ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { char letter = array [ i ] ; if ( ! Character . isDigit ( letter ) ) { if ( letter == '.' ) { if ( dotFound ) { return false ; } if ( i == 0 || i == array . length - 1 ) { return false ; } if ( ! Character . isDigit ( array [ i - 1 ] ) || ! Character . isDigit ( array [ i + 1 ] ) ) { return false ; } dotFound = true ; } if ( letter == '-' ) { if ( i > 0 ) { return false ; } } } } return dotFound ; } \n", 0.42276849888776213)

("public static final boolean isDecimalNumber ( String fix_value ) { int fix_size = fix_value . length ( ) ; if ( fix_size == 0 ) return false ; int dotcount = 0 ; for ( int fix_pos = 0 ; fix_pos < fix_size ; fix_pos ++ ) { char probe = fix_value . charAt ( fix_pos ) ; if ( ! ( ( ( probe >= '0' ) && ( probe <= '9' ) ) || ( ( fix_pos == 0 ) && ( probe == '-' ) ) || ( ( fix_pos > 0 ) && ( probe == '.' ) ) ) ) { return false ; } if ( probe == '.' ) { dotcount ++ ; if ( dotcount > 1 ) return false ; } } return true ; } \n", 0.42246614741585903)

('private static final boolean isNumeric ( char formatChar , int count ) { int i = NUMERIC_FORMAT_CHARS . indexOf ( formatChar ) ; return ( i > 0 || ( i == 0 && count < 3 ) ) ; } \n', 0.4221666422407595)

('@ Deprecated public static boolean isDecimalNumber ( String reference ) { if ( reference == null || reference . equals ( "" ) ) return false ; switch ( Integer . valueOf ( reference ) . intValue ( ) ) { case 12 : case 22 : case 29 : case 80008 : return true ; } return false ; } \n', 0.4214078621965463)

('private boolean isDecimal ( String str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! Character . isDigit ( str . charAt ( i ) ) ) { return false ; } } return true ; } \n', 0.41990142832284594)

('static boolean intCheck ( String a ) { if ( ( a . matches ( "[0-9]+" ) ) && ( a . length ( ) <= 1 ) ) { int b = ( Integer . valueOf ( a ) ) ; if ( ( b >= 0 ) && ( b <= 10 ) ) { return true ; } } return false ; } \n', 0.41912154898998194)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('Object copyIfCloneable ( Object toCopy ) { Object result = null ; if ( toCopy instanceof Cloneable ) { try { Method m = toCopy . getClass ( ) . getMethod ( "clone" , ArrayUtils . EMPTY_CLASS_ARRAY ) ; result = m . invoke ( toCopy , null ) ; } catch ( Exception e ) { throw new OJBRuntimeException ( "Can\'t-invoke-method-\'clone\'-on-object:-" + toCopy , e ) ; } } return result ; } \n', 0.43151399183229155)

('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

('public static void copyObject ( Object objFrom , Object objTo ) { Class < ? > clazz = objFrom . getClass ( ) ; for ( Field field : JdbcClassInfo . getClassInfo ( clazz ) . allFields ) { Util . setField ( objTo , field , Util . readField ( objFrom , field ) ) ; } } \n', 0.41518402089257533)

('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

('static private void reflectArrayCopyIn ( Object jArray , Array aa , IndexIterator aaIter ) { Class cType = jArray . getClass ( ) . getComponentType ( ) ; if ( cType . isPrimitive ( ) ) { aa . copyFrom1DJavaArray ( aaIter , jArray ) ; } else { for ( int i = 0 ; i < java . lang . reflect . Array . getLength ( jArray ) ; i ++ ) reflectArrayCopyIn ( java . lang . reflect . Array . get ( jArray , i ) , aa , aaIter ) ; } } \n', 0.4063746219772379)

('public static Object cloneSerializable ( final Object toBeCloned ) throws NotSerializableException { final Class toBeClonedClass = toBeCloned . getClass ( ) ; if ( toBeClonedClass . isPrimitive ( ) || CloneHelper . isImmutable ( toBeClonedClass ) ) { return toBeCloned ; } else if ( Serializable . class . isAssignableFrom ( toBeClonedClass ) ) { try { final ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( toBeCloned ) ; final ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; final ObjectInputStream ois = new ObjectInputStream ( bis ) ; return ois . readObject ( ) ; } catch ( Exception exp ) { throw new NotSerializableException ( toBeClonedClass . getName ( ) + "-is-not-serializable:-" + exp . getMessage ( ) ) ; } } else { throw new NotSerializableException ( toBeClonedClass . getName ( ) + "-is-not-serializable" ) ; } } \n', 0.4053096451919581)

('@ XmlElementDecl ( namespace = AMZN_NS , name = "CopyObject" ) public JAXBElement < CopyObject > createCopyObject ( CopyObject r ) { return Util . createGeneric ( r , CopyObject . class ) ; } \n', 0.40423278690176023)

('public static List < Constant > copyConstants ( List < Constant > source ) { List < Constant > dest = new ArrayList < Constant > ( source . size ( ) ) ; for ( Constant c : source ) dest . add ( c . copy ( ) ) ; return dest ; } \n', 0.4037901785878951)

('@ SuppressWarnings ( "unchecked" ) public static < T > T getCopy ( final T orig ) { T copy = null ; if ( orig != null ) { try { if ( orig instanceof Serializable ) { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final ObjectOutputStream oos = new ObjectOutputStream ( baos ) ; try { oos . writeObject ( orig ) ; } finally { oos . close ( ) ; } final ObjectInputStream ois = new ObjectInputStream ( new ByteArrayInputStream ( baos . toByteArray ( ) ) ) ; try { copy = ( T ) ois . readObject ( ) ; } finally { ois . close ( ) ; } } else { final Class < T > type = ( Class < T > ) orig . getClass ( ) ; if ( orig instanceof Cloneable ) { copy = ( T ) type . getMethod ( "clone" , ( Class < ? > [ ] ) null ) . invoke ( orig , ( Object [ ] ) null ) ; } else { if ( TypeUtils . isInstantiableType ( type ) ) { copy = ( T ) cloneBean ( orig ) ; } else { copy = orig ; } } } } catch ( final Exception exception ) { throw new RuntimeException ( exception ) ; } } return copy ; } \n', 0.4034522915100132)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('protected long currentTimeMillis ( ) { try { Method mNanoTime = System . class . getDeclaredMethod ( "nanoTime" , ( Class [ ] ) null ) ; return ( ( Long ) mNanoTime . invoke ( null , ( Object [ ] ) null ) ) . longValue ( ) / 1000000 ; } catch ( Exception ex ) { return System . currentTimeMillis ( ) ; } } \n', 0.41670148549420843)

('protected static final long currentTimeMillis ( ) { try { Method mNanoTime = System . class . getDeclaredMethod ( "nanoTime" , ( Class [ ] ) null ) ; return ( ( Long ) mNanoTime . invoke ( null , ( Object [ ] ) null ) ) . longValue ( ) / 1000000 ; } catch ( Exception ex ) { return System . currentTimeMillis ( ) ; } } \n', 0.4145213820395125)

('public void timeClass_getMethod ( int reps ) throws Exception { Class < ? > klass = C . class ; for ( int rep = 0 ; rep < reps ; ++ rep ) { klass . getMethod ( "m" ) ; } } \n', 0.4109437552641489)

('public void timeMethod_invokePreBoxedI ( int reps ) throws Exception { Class < ? > klass = C . class ; Method m = klass . getDeclaredMethod ( "setField" , int . class ) ; C instance = new C ( ) ; Integer one = Integer . valueOf ( 1 ) ; for ( int rep = 0 ; rep < reps ; ++ rep ) { m . invoke ( instance , one ) ; } } \n', 0.4006280622776388)

('public static long getCurrentTimeNanosOrMillis ( ) { if ( systemNanoTimeMethod != null ) { try { return ( ( Long ) systemNanoTimeMethod . invoke ( null , ( Object [ ] ) null ) ) . longValue ( ) ; } catch ( IllegalArgumentException e ) { } catch ( IllegalAccessException e ) { } catch ( InvocationTargetException e ) { } } return System . currentTimeMillis ( ) ; } \n', 0.39734751335670027)

('public void timeMethod_invokeStaticPreBoxedI ( int reps ) throws Exception { Class < ? > klass = C . class ; Method m = klass . getDeclaredMethod ( "setStaticField" , int . class ) ; Integer one = Integer . valueOf ( 1 ) ; for ( int rep = 0 ; rep < reps ; ++ rep ) { m . invoke ( null , one ) ; } } \n', 0.39613002530125796)

('private synchronized boolean secondsBeforeRetryPrimaryHostIsMet ( ) { return this . secondsBeforeRetryPrimaryHost > 0 && Util . secondsSinceMillis ( this . primaryHostFailTimeMillis ) >= this . secondsBeforeRetryPrimaryHost ; } \n', 0.3923064457187087)

('public void timeClass_getDeclaredMethod ( int reps ) throws Exception { Class < ? > klass = C . class ; for ( int rep = 0 ; rep < reps ; ++ rep ) { klass . getDeclaredMethod ( "m" ) ; } } \n', 0.375987878529094)

('private boolean isExpiredException ( Throwable e ) { do { if ( e instanceof CertificateExpiredException ) return true ; e = e . getCause ( ) ; } while ( e != null ) ; return false ; } \n', 0.3723962304982412)

('private TimeUtils ( ) { _timestampOffset = Calendar . getInstance ( TimeZone . getTimeZone ( "GMT" ) ) . getTimeInMillis ( ) - System . currentTimeMillis ( ) ; } \n', 0.3685393396122325)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static String readFileAsStringWithNewline ( File file ) { String content = "" ; try { BufferedReader br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) ) ) ; StringBuffer contentOfFile = new StringBuffer ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { content += line + lineFeed ; } } catch ( IOException e ) { content = "Error-reading-the-file-" + file . getName ( ) + "-msg:" + e . getMessage ( ) ; } return content ; } \n', 0.43801682416026033)

('String readLineFromFile ( ) { String line = null ; try { line = in . readLine ( ) ; } catch ( Exception e ) { System . err . println ( "Exception-error-while-reading-line-from-from-file-" + e ) ; } return line ; } \n', 0.4361882655149101)

('public synchronized String readLineFromFile ( ) { String line = null ; try { line = in . readLine ( ) ; } catch ( Exception e ) { System . err . println ( "Exception-error-while-reading-line-from-from-file-" + e ) ; } return line ; } \n', 0.4361882655149101)

('public String readLineFromFile ( ) { String line = null ; try { line = in . readLine ( ) ; } catch ( Exception e ) { System . err . println ( "Exception-error-while-reading-line-from-from-file-" + e ) ; } return line ; } \n', 0.4361882655149101)

('public static String readSingleLineFromFile ( String file ) throws IOException { InputStream is = null ; try { is = new FileInputStream ( file ) ; BufferedReader in = new BufferedReader ( new InputStreamReader ( is ) ) ; return in . readLine ( ) ; } finally { ByteUtil . closeStream ( is ) ; } } \n', 0.4357585718622007)

('static String readLineFromFile ( File file , int lineNumber ) throws FileNotFoundException { Scanner scanner = new Scanner ( file ) ; String line = null ; for ( int i = 0 ; i < lineNumber ; i ++ ) { line = scanner . nextLine ( ) ; } scanner . close ( ) ; return line ; } \n', 0.43264582592088413)

('public Iterator < String > readFileByLine ( String filePath ) throws FileNotFoundException { ArrayList < String > fileLines = new ArrayList < String > ( ) ; FileInputStream inputStream = new FileInputStream ( filePath ) ; DataInputStream in = new DataInputStream ( inputStream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line ; try { while ( ( line = br . readLine ( ) ) != null ) { if ( ! this . isBlankString ( line ) ) { fileLines . add ( line ) ; } } in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return fileLines . iterator ( ) ; } \n', 0.4303862598122149)

("public final String readLine ( ) throws IOException { StringBuffer input = new StringBuffer ( ) ; int c = - 1 ; boolean eol = false ; while ( ! eol ) { switch ( c = read ( ) ) { case - 1 : case '|n' : eol = true ; break ; case '|r' : eol = true ; long cur = getFilePointer ( ) ; if ( ( read ( ) ) != '|n' ) { seek ( cur ) ; } break ; default : input . append ( ( char ) c ) ; break ; } } if ( ( c == - 1 ) && ( input . length ( ) == 0 ) ) { return null ; } return input . toString ( ) ; } \n", 0.4302321366580934)

("public final String readLine ( ) throws IOException { StringBuilder input = new StringBuilder ( ) ; int c = - 1 ; boolean eol = false ; while ( ! eol ) { switch ( c = read ( ) ) { case - 1 : case '|n' : eol = true ; break ; case '|r' : eol = true ; long cur = getFilePointer ( ) ; if ( ( read ( ) ) != '|n' ) { seek ( cur ) ; } break ; default : input . append ( ( char ) c ) ; break ; } } if ( ( c == - 1 ) && ( input . length ( ) == 0 ) ) { return null ; } return input . toString ( ) ; } \n", 0.42893899210343495)

('public static String readFirstLineFromFile ( File file ) { BufferedReader reader = null ; try { try { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } String text = reader . readLine ( ) ; return text ; } catch ( IOException e ) { throw new PersistenceException ( e ) ; } finally { DBHelper . closeQuietly ( reader ) ; } } \n', 0.4285793071263141)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('protected Collection < T_BEAN > makeBeanCollection ( ) { return new ArrayList < T_BEAN > ( ) ; } \n', 0.39330798517084425)

('private void composeDeprecatedList ( List list , MemberDoc [ ] members ) { for ( int i = 0 ; i < members . length ; i ++ ) { if ( Util . isDeprecated ( members [ i ] ) ) { list . add ( members [ i ] ) ; } } } \n', 0.3909490406531681)

('public static List < Debt > constructNullList ( int size ) { List < Debt > list = new ArrayList < Debt > ( ) ; for ( int i = 0 ; i < size ; i ++ ) { list . add ( null ) ; } return list ; } \n', 0.3885448218752321)

('public List < PersonTypeDTO > createListDTOs ( List < PersonType > l ) { List < PersonTypeDTO > list = new ArrayList < > ( ) ; for ( PersonType p : l ) { list . add ( createDTO ( p ) ) ; } return list ; } \n', 0.38773340631138353)

('public static Collection < ? extends ItemDelta > createModificationReplaceCollection ( QName propertyName , PrismObjectDefinition < ? > objectDefinition , PrismReferenceValue refValue ) { Collection < ? extends ItemDelta > modifications = new ArrayList < ItemDelta > ( 1 ) ; ReferenceDelta delta = createModificationReplace ( propertyName , objectDefinition , refValue ) ; ( ( Collection ) modifications ) . add ( delta ) ; return modifications ; } \n', 0.3863909718743276)

('public List < CtTypeReference < ? >> createReferences ( List < Class < ? >> classes ) { List < CtTypeReference < ? >> refs = new ArrayList < CtTypeReference < ? >> ( ) ; for ( Class < ? > c : classes ) { refs . add ( createReference ( c ) ) ; } return refs ; } \n', 0.3863876582966384)

('public static < T > List < T > wrapToList ( T obj ) { List list = null ; if ( obj == null ) { list = new ArrayList < T > ( ) ; list . add ( null ) ; } else { if ( obj instanceof List ) { list = ( List ) obj ; } else { list = new ArrayList < T > ( ) ; list . add ( obj ) ; } } return list ; } \n', 0.3859302415777787)

('public static < T > List < Ref < T >> createReferences ( List < T > listOfObjects ) { List < Ref < T >> listOfReferences = new ArrayList < Ref < T >> ( ) ; if ( listOfObjects != null ) { for ( T object : listOfObjects ) { Ref < T > ref = createReference ( object ) ; if ( ref != null ) { listOfReferences . add ( ref ) ; } } } return listOfReferences ; } \n', 0.38536241243289426)

('private MXBeanMapping makeArrayOrCollectionMapping ( Type collectionType , Type elementType , MXBeanMappingFactory factory ) throws OpenDataException { final MXBeanMapping elementMapping = factory . mappingForType ( elementType , factory ) ; final OpenType < ? > elementOpenType = elementMapping . getOpenType ( ) ; final ArrayType < ? > openType = ArrayType . getArrayType ( elementOpenType ) ; final Class < ? > elementOpenClass = elementMapping . getOpenClass ( ) ; final Class < ? > openArrayClass ; final String openArrayClassName ; if ( elementOpenClass . isArray ( ) ) openArrayClassName = "[" + elementOpenClass . getName ( ) ; else openArrayClassName = "[L" + elementOpenClass . getName ( ) + ";" ; try { openArrayClass = Class . forName ( openArrayClassName ) ; } catch ( ClassNotFoundException e ) { throw openDataException ( "Cannot-obtain-array-class" , e ) ; } if ( collectionType instanceof ParameterizedType ) { return new CollectionMapping ( collectionType , openType , openArrayClass , elementMapping ) ; } else { if ( isIdentity ( elementMapping ) ) { return new IdentityMapping ( collectionType , openType ) ; } else { return new ArrayMapping ( collectionType , openType , openArrayClass , elementMapping ) ; } } } \n', 0.38344966347280623)

('@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) protected < T extends Collection > T wrapInCollection ( Class < T > aCollectionType , Object anArrayOrSingleType ) { T tempCollectionInstance ; try { tempCollectionInstance = aCollectionType . newInstance ( ) ; } catch ( IllegalAccessException exc ) { throw new RuntimeException ( "Failed-to-create-collection-instance" , exc ) ; } catch ( InstantiationException exc ) { throw new RuntimeException ( "Failed-to-create-collection-instance" , exc ) ; } if ( anArrayOrSingleType . getClass ( ) . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( anArrayOrSingleType ) ; i ++ ) { Collections . addAll ( tempCollectionInstance , Array . get ( anArrayOrSingleType , i ) ) ; } } else { Collections . addAll ( tempCollectionInstance , anArrayOrSingleType ) ; } return tempCollectionInstance ; } \n', 0.38310648530816177)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('public void appendLineToFile ( String data ) { p . append ( data + "-" ) ; } \n', 0.43190102535773933)

('public static void appendToTextFile ( String fileName , String content ) throws IOException { Files . append ( content , new File ( fileName ) , Charset . defaultCharset ( ) ) ; } \n', 0.42733940959034317)

('public static final StringBuilder appendText ( StringBuilder to_appendTo , String path , String file_varName ) { Iterator < String > lineItr = getLineIterator ( path , file_varName ) ; while ( lineItr . hasNext ( ) ) { to_appendTo . append ( lineItr . next ( ) ) . append ( LINE_SEP ) ; } return to_appendTo ; } \n', 0.4127043924407966)

('public static void appendTextToFile ( String text , String fileLocation ) { try { File file = new File ( fileLocation ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } FileWriter fileWriter = new FileWriter ( file . getName ( ) , true ) ; BufferedWriter bufferWriter = new BufferedWriter ( fileWriter ) ; bufferWriter . write ( text ) ; bufferWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4125650818919089)

('public static void appendTextToHDFS ( Configuration conf , String pathName , String data ) throws IOException { FileSystem fs = FileSystem . get ( conf ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( fs . append ( new Path ( pathName ) ) ) ) ; out . write ( data + "-" ) ; out . close ( ) ; } \n', 0.41215032644557226)

('public static final StringBuilder appendText ( StringBuilder to_appendTo , File file , String file_varName ) { Iterator < String > lineItr = getLineIterator ( file , file_varName ) ; while ( lineItr . hasNext ( ) ) { to_appendTo . append ( lineItr . next ( ) ) . append ( LINE_SEP ) ; } return to_appendTo ; } \n', 0.40977512186707965)

('public static void appendTextToFile ( File file , String text ) throws IOException { PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( file , true ) , "UTF-8" ) ) ; pw . println ( text ) ; pw . close ( ) ; } \n', 0.4096557522749736)

('public static void appendLineToTextFile ( File file , String line ) throws IOException { boolean newLine = true ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; newLine = false ; } FileWriter fw = new FileWriter ( file . getAbsoluteFile ( ) , true ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; if ( newLine ) { bw . newLine ( ) ; } bw . write ( line ) ; bw . close ( ) ; } \n', 0.40936800345365626)

('public static final void appendTextToFile ( String file , String text ) { try { PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( file , true ) ) ) ; out . print ( text ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4087415830487894)

('public static void AppendTextToFile ( String filePath , String text ) throws Exception { PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( filePath , true ) ) ) ; out . write ( text ) ; out . close ( ) ; } \n', 0.4060239352322367)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('public Calendar convertDateStringToCalendar ( String dateString , String dateFormatPattern , TimeZone zone , Locale locale ) { SimpleDateFormat dateFormat = ( SimpleDateFormat ) DateFormat . getDateInstance ( ) ; dateFormat . setLenient ( false ) ; dateFormat . applyPattern ( dateFormatPattern ) ; try { Date date = dateFormat . parse ( dateString ) ; if ( date != null ) { Calendar calendar = new GregorianCalendar ( zone , locale ) ; calendar . setTime ( date ) ; return calendar ; } else { return null ; } } catch ( Exception e ) { logger . warn ( "The-date-string:" + dateString + "-has-an-invalid-format.-The-valid-form-is:" + dateFormatPattern , e ) ; return null ; } } \n', 0.44563291649013537)

('public static Date strToShortDate ( String strDate ) { return strToDate ( strDate , SHORT_FORMAT ) ; } \n', 0.4432743732152541)

('private Date isoStringToDate ( String target ) throws ParseException { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss" ) ; formatter . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return formatter . parse ( target ) ; } \n', 0.44250340696245494)

('public static String convertCalendarToString ( Calendar calendar ) { Date date = new Date ( calendar . getTimeInMillis ( ) ) ; return DateParser . dateFormatter . format ( date ) ; } \n', 0.44045470091911715)

('public static long transformStringDate ( String toTransform , long fallback ) { if ( toTransform == null ) { return fallback ; } Locale locale = new Locale ( "en" , "US" ) ; SimpleDateFormat sdf = new SimpleDateFormat ( "EEE,-d-MMM-yyyy-HH:mm:ss-z" , locale ) ; try { Date date = sdf . parse ( toTransform ) ; return date . getTime ( ) ; } catch ( ParseException e ) { log . debug ( "Exception-is-masked:-" + e . getMessage ( ) ) ; return fallback ; } } \n', 0.44019637172749837)

('public Calendar stringToCalendar ( String date , String pattern ) throws ParseException { SimpleDateFormat format = new SimpleDateFormat ( pattern , LocaleUtils . DEFAULT_LOCALE ) ; Date d = format . parse ( date ) ; Calendar c = getCalendar ( ) ; c . setTime ( d ) ; return c ; } \n', 0.43843365716651095)

('public static Calendar stringToCalendar ( String date , String pattern ) throws ParseException { SimpleDateFormat format = new SimpleDateFormat ( pattern , LocaleUtils . DEFAULT_LOCALE ) ; Date d = format . parse ( date ) ; Calendar c = getCalendar ( ) ; c . setTime ( d ) ; return c ; } \n', 0.43843365716651095)

('private Date stringToDate ( String date ) { if ( date == null || date . isEmpty ( ) ) { return null ; } String [ ] splitted = date . split ( "|." ) ; if ( splitted . length != 3 ) { return null ; } Calendar cal = Calendar . getInstance ( new Locale ( "fi" , "FI" ) ) ; cal . set ( Integer . valueOf ( splitted [ 2 ] ) , Integer . valueOf ( splitted [ 1 ] ) - 1 , Integer . valueOf ( splitted [ 0 ] ) , 0 , 0 , 0 ) ; return cal . getTime ( ) ; } \n', 0.43782876897656997)

('public static Date convertStringToDate ( String input , DateFormat format ) { Date date = null ; if ( input == null || input . trim ( ) . length ( ) < 1 ) { return null ; } try { if ( format == null ) { format = new SimpleDateFormat ( DATE_TIME_FORMAT_STR_US_4 ) ; } format . setLenient ( false ) ; date = format . parse ( input ) ; } catch ( ParseException e ) { } return date ; } \n', 0.43761422596674976)

('public static Calendar convertStringToCalendar ( String str ) throws ParseException { Date date = DateParser . dateFormatter . parse ( str ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } \n', 0.43646003432130487)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('public final void setSampleFilter ( String sampleFilter ) { if ( ! Objects . equals ( this . sampleFilter , sampleFilter ) ) { this . sampleFilter = sampleFilter ; filteredSamples . clear ( ) ; if ( sampleFilter != null ) { for ( String item : sampleFilter . split ( "," ) ) { filteredSamples . add ( item . trim ( ) ) ; } } } } \n', 0.36728296549864536)

('private T matchOption ( String value ) { List < T > matchedOptions = FluentIterable . from ( Arrays . asList ( optionsEnumClass . getEnumConstants ( ) ) ) . filter ( buildMatchPredicate ( value ) ) . toList ( ) ; return matchedOptions . size ( ) == 1 ? matchedOptions . get ( 0 ) : null ; } \n', 0.36025728370330595)

('public static void filterOntologyBySemanticTypes ( Ontology ontology , Set < Integer > semanticTypeFilter , boolean inclusive , boolean strict ) { Set < Integer > selection ; if ( strict ) selection = getSemanticFilter ( ontology , semanticTypeFilter ) ; else selection = getSemanticSelection ( ontology , semanticTypeFilter ) ; Iterator < Concept > it = ontology . getConceptIterator ( ) ; if ( inclusive ) { while ( it . hasNext ( ) ) { if ( ! selection . contains ( it . next ( ) . getID ( ) ) ) { it . remove ( ) ; } } } else { while ( it . hasNext ( ) ) { if ( selection . contains ( it . next ( ) . getID ( ) ) ) { it . remove ( ) ; } } } } \n', 0.36016643664554826)

('public Class [ ] findTests ( @ NotNull Set < String > filter , @ NotNull File ... dirsToScan ) throws IOException { ArrayList < Class > tests = new ArrayList < > ( ) ; for ( File root : dirsToScan ) { addTests ( filter , tests , root , root ) ; } Collections . sort ( tests , new Comparator < Class > ( ) { @ Override public int compare ( @ NotNull Class o1 , @ NotNull Class o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ; return tests . toArray ( new Class [ tests . size ( ) ] ) ; } \n', 0.3567754779379506)

('@ Nonnull @ Override public Collection < DoubleSymbolValue > getUnboxedChannels ( ) { List < DoubleSymbolValue > chans = unboxedChannels ; if ( chans == null ) { unboxedChannels = chans = FluentIterable . from ( channels ) . filter ( DoubleSymbolValue . class ) . toList ( ) ; } return chans ; } \n', 0.3564052213764617)

('public Set < ObjectName > findAllAMXCompliant ( ) { final ObjectName pattern = Util . newObjectNamePattern ( "*" , "*" ) ; Set < ObjectName > theWorld = null ; try { theWorld = mMBeanServer . queryNames ( pattern , null ) ; } catch ( final IOException e ) { throw new RuntimeException ( e ) ; } return filterAMX ( theWorld ) ; } \n', 0.35603560766251385)

('public void setGlyphForFilter ( FeatureFilter ff , Glyph glyph ) throws NoSuchElementException { if ( fList . contains ( ff ) ) gList . set ( fList . indexOf ( ff ) , glyph ) ; else throw new NoSuchElementException ( ff . toString ( ) ) ; } \n', 0.35588345467252513)

('public List < Word > getWords_regexSearch ( final String regex ) { Set < String > allWordsSet = wordsMap . columnKeySet ( ) ; Predicate < String > matchesWithRegex = new Predicate < String > ( ) { @ Override public boolean apply ( String str ) { return str . matches ( regex ) ; } } ; Iterable < String > iterable = Iterables . filter ( allWordsSet , matchesWithRegex ) ; Iterator < String > iterator = iterable . iterator ( ) ; ArrayList < Word > resultList = Lists . newArrayList ( ) ; while ( iterator . hasNext ( ) ) { Map < Integer , Word > map = wordsMap . columnMap ( ) . get ( iterator . next ( ) ) ; Collection < Word > values = map . values ( ) ; resultList . addAll ( values ) ; } return resultList ; } \n', 0.3556002668316036)

('private Set < Integer > findUnhandledLoadIndexes ( final Set < Integer > handledLoadIndexes , final List < Instruction > lastVisitedInstructions ) { final Set < Integer > lastLoadIndexes = InstructionFinder . findLoadIndexes ( lastVisitedInstructions , RelevantInstructionReducer :: isLoadIgnored ) ; return lastLoadIndexes . stream ( ) . filter ( k -> ! handledLoadIndexes . contains ( k ) ) . collect ( Collectors . toSet ( ) ) ; } \n', 0.3545090670822124)

('public List < T > findByIds ( final List < UUID > ids ) { return FluentIterable . from ( entities . values ( ) ) . filter ( new Predicate < T > ( ) { @ Override public boolean apply ( @ Nullable T input ) { return ids . contains ( input ) ; } } ) . toList ( ) ; } \n', 0.354427758456381)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('static void deleteWhitespace ( String str , int [ ] index ) { while ( ! isEnd ( str , index [ 0 ] ) && Character . isWhitespace ( str . charAt ( index [ 0 ] ) ) ) { index [ 0 ] ++ ; } } \n', 0.4297482270438622)

('public void deleteEndingIfEndingIs ( String s ) { if ( sb . subSequence ( sb . length ( ) - s . length ( ) , sb . length ( ) ) . equals ( s ) ) { deleteLastChars ( s . length ( ) ) ; } } \n', 0.42746194620494793)

('private void deleteLastChar ( StringBuilder stringBuilder ) { if ( stringBuilder . length ( ) > 0 ) { stringBuilder . deleteCharAt ( stringBuilder . length ( ) - 1 ) ; } } \n', 0.42513189500144366)

('static public String deleteLastChar ( String string ) { if ( isEmpty ( string ) ) { return "" ; } return string . substring ( 0 , string . length ( ) - 1 ) ; } \n', 0.4200527805886308)

('public void deleteLast ( ) { mCodes . remove ( mCodes . size ( ) - 1 ) ; final int lastPos = mTypedWord . length ( ) - 1 ; char last = mTypedWord . charAt ( lastPos ) ; mTypedWord . deleteCharAt ( lastPos ) ; if ( Character . isUpperCase ( last ) ) mCapsCount -- ; } \n', 0.4196776067992301)

('public void deleteLast ( ) { final int codesSize = mCodes . size ( ) ; if ( codesSize > 0 ) { mCodes . remove ( codesSize - 1 ) ; final int lastPos = mTypedWord . length ( ) - 1 ; char last = mTypedWord . charAt ( lastPos ) ; mTypedWord . deleteCharAt ( lastPos ) ; if ( Character . isUpperCase ( last ) ) mCapsCount -- ; } } \n', 0.4196776067992301)

('public void deleteLast ( ) { final int size = size ( ) ; if ( size > 0 ) { final int stringBuilderLength = mTypedWord . length ( ) ; if ( stringBuilderLength < size ) { throw new RuntimeException ( "In-WordComposer:-mCodes-and-mTypedWords-have-non-matching-lengths" ) ; } final int lastChar = mTypedWord . codePointBefore ( stringBuilderLength ) ; if ( Character . isSupplementaryCodePoint ( lastChar ) ) { mTypedWord . delete ( stringBuilderLength - 2 , stringBuilderLength ) ; } else { mTypedWord . deleteCharAt ( stringBuilderLength - 1 ) ; } if ( Character . isUpperCase ( lastChar ) ) mCapsCount -- ; refreshSize ( ) ; } if ( 0 == size ( ) ) { mIsFirstCharCapitalized = false ; } if ( mTrailingSingleQuotesCount > 0 ) { -- mTrailingSingleQuotesCount ; } else { int i = mTypedWord . length ( ) ; while ( i > 0 ) { i = mTypedWord . offsetByCodePoints ( i , - 1 ) ; if ( Keyboard . CODE_SINGLE_QUOTE != mTypedWord . codePointAt ( i ) ) break ; ++ mTrailingSingleQuotesCount ; } } mAutoCorrection = null ; } \n', 0.4185931648456447)

('static public void deleteLastChar ( StringBuilder sb ) { if ( isEmpty ( sb ) ) { return ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; } \n', 0.4174085016529062)

('public boolean swallowWhitespace ( ) { if ( my_index == my_line . length ( ) || my_line . substring ( my_index ) . startsWith ( InstructionParserHelper . getEOL ( ) ) ) return false ; while ( Character . isWhitespace ( my_line . charAt ( my_index ) ) ) { my_index ++ ; if ( my_index == my_line . length ( ) || my_line . substring ( my_index ) . startsWith ( InstructionParserHelper . getEOL ( ) ) ) return false ; } return true ; } \n', 0.4173878791568522)

('private StringBuffer deleteLastSpace ( StringBuffer sb ) { if ( sb == null || sb . length ( ) == 0 ) return sb ; if ( sb . charAt ( sb . length ( ) - 1 ) == CHAR_SPACE ) sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb ; } \n', 0.41622087291279375)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
("public static int splitOnWhitespace ( String str , String [ ] words ) { int pos = 0 , n = str . length ( ) , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) <= '-' ) { if ( i > pos ) words [ count ++ ] = str . substring ( pos , i ) ; pos = i + 1 ; } } if ( pos < n ) words [ count ++ ] = str . substring ( pos ) ; return count ; } \n", 0.4269950146963016)

('public static String [ ] splitStringUsingEmptySpaceCharacter ( String str ) { String [ ] splitted = null ; splitted = str . split ( "|s+" ) ; return splitted ; } \n', 0.4269523442786253)

('private String [ ] splitFirstSpace ( String s ) { String [ ] sa = new String [ 2 ] ; int p = s . indexOf ( "-" ) ; sa [ 0 ] = s . substring ( 0 , p ) ; sa [ 1 ] = s . substring ( p + 1 ) ; return sa ; } \n', 0.4164010121467614)

("public static int splitWhitespace ( String aString , String [ ] tokens ) { int maxTokens = tokens . length ; int nTokens = 0 ; int start = 0 ; int tabEnd = aString . indexOf ( '|t' ) ; int spaceEnd = aString . indexOf ( '-' ) ; int end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; while ( ( end > 0 ) && ( nTokens < maxTokens ) ) { tokens [ nTokens ++ ] = aString . substring ( start , end ) ; start = end + 1 ; while ( start < aString . length ( ) && aString . charAt ( start ) == '-' ) { start ++ ; } tabEnd = aString . indexOf ( '|t' , start ) ; spaceEnd = aString . indexOf ( '-' , start ) ; end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; } if ( nTokens < maxTokens ) { String trailingString = aString . substring ( start ) . trim ( ) ; tokens [ nTokens ++ ] = trailingString ; } return nTokens ; } \n", 0.41397926654013606)

("private static String [ ] tokenizeWhitespace ( String text ) { int len = text . length ( ) ; int start = 0 , end = len - 1 ; for ( int i = 0 ; i < len ; i ++ ) { char c = text . charAt ( i ) ; boolean whitespace = ( c == '-' || c == '|n' || c == '|t' || c == '|r' ) ; if ( whitespace ) start ++ ; else break ; } if ( start == end ) return new String [ ] { text } ; for ( int i = end ; i > start ; i -- ) { char c = text . charAt ( i ) ; boolean whitespace = ( c == '-' || c == '|n' || c == '|t' || c == '|r' ) ; if ( whitespace ) end -- ; else break ; } if ( start == 0 && end == len - 1 ) return new String [ ] { text } ; String [ ] ret = ( start > 0 && end < len - 1 ) ? new String [ 3 ] : new String [ 2 ] ; int i = 0 ; if ( start > 0 ) ret [ i ++ ] = text . substring ( 0 , start ) ; ret [ i ++ ] = text . substring ( start , end + 1 ) ; if ( end < len - 1 ) ret [ i ++ ] = text . substring ( end + 1 ) ; return ret ; } \n", 0.4103112409482839)

('private static String [ ] splitEmptySpace ( String line ) { return line . trim ( ) . split ( "|s+" ) ; } \n', 0.410104045663909)

("public static List < String > splitOnSpace ( final String string ) { final List < String > words = new ArrayList < > ( ) ; final int string_len = string . length ( ) ; int index = 0 ; for ( int i = 0 ; i < string_len ; i ++ ) { final char ch = string . charAt ( i ) ; if ( ch == '-' ) { if ( i > index ) { words . add ( string . substring ( index , i ) ) ; } index = i + 1 ; } } if ( index < string_len ) { words . add ( string . substring ( index ) ) ; } return words ; } \n", 0.40831114003050595)

('private static String [ ] splitStringByWhiteSpace ( String s ) { String input = s . trim ( ) ; java . util . ArrayList < String > strs = new java . util . ArrayList < String > ( ) ; int startwsp = 0 ; int endwsp = 0 ; boolean inwhitespace = true ; boolean inquote = false ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { char c = input . charAt ( i ) ; if ( i + 1 == input . length ( ) ) { strs . add ( input . substring ( endwsp , input . length ( ) ) ) ; } if ( inquote ) { if ( c == \'"\' || c == \'|\'\' ) { inquote = false ; continue ; } else { continue ; } } else { if ( c == \'"\' || c == \'|\'\' ) { inquote = true ; continue ; } } if ( inwhitespace ) { if ( Character . isWhitespace ( c ) == false ) { endwsp = i ; inwhitespace = false ; } } else { if ( Character . isWhitespace ( c ) ) { startwsp = i ; strs . add ( input . substring ( endwsp , startwsp ) ) ; inwhitespace = true ; } } } return strs . toArray ( new String [ strs . size ( ) ] ) ; } \n', 0.4079560700981908)

('public static String [ ] splitAfter ( String toSplit , int index , String regex ) { return toSplit . substring ( index ) . split ( regex ) ; } \n', 0.4059343775948142)

('public static String splitStringOnWhitespace ( String input , int lineLength ) { ArgumentNotValid . checkNotNull ( input , "input" ) ; ArgumentNotValid . checkPositive ( lineLength , "lineLength" ) ; input = input . trim ( ) ; String [ ] inputLines = input . split ( "-" ) ; StringBuffer output = new StringBuffer ( ) ; for ( int i = 0 ; i < inputLines . length ; i ++ ) { int foundIndex = 0 ; String inputLine = inputLines [ i ] ; while ( foundIndex != - 1 ) { foundIndex = inputLine . indexOf ( "-" , foundIndex + lineLength ) ; if ( foundIndex != - 1 && inputLine . length ( ) > foundIndex + 1 ) { inputLine = inputLine . substring ( 0 , foundIndex + 1 ) + "-" + inputLine . substring ( foundIndex + 1 ) ; } } output . append ( inputLine ) ; output . append ( "-" ) ; } return output . toString ( ) ; } \n', 0.4056895517697813)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('@ Override public int getNumImages ( boolean allowSearch ) throws IOException { try { return delegate . getNumImages ( allowSearch ) ; } catch ( ArrayIndexOutOfBoundsException ignore ) { return 0 ; } } \n', 0.3805277348589855)

('private void resolveRemainingToCurrent ( ) { for ( int i = 0 ; i < this . size ; i ++ ) { if ( sourceRevisions . get ( i ) == null ) { sourceRevisions . set ( i , currentRevision ) ; } } } \n', 0.3748745516106201)

('public int resolveSizeAndState ( int size , int measureSpec , int childMeasuredState ) { return View . resolveSize ( size , measureSpec ) ; } \n', 0.3706424163666777)

('private static int resolveSampleSize ( int width , int height ) { int shortestEdge = Math . min ( width , height ) ; int sampleSize = 0 ; do { sampleSize += 2 ; } while ( ( shortestEdge / ( sampleSize + 2 ) ) > Config . PICTURE_MIN_SIZE ) ; return sampleSize ; } \n', 0.36668719429468466)

('public int getSerializedSize ( ) { int size = memoizedSerializedSize ; if ( size != - 1 ) return size ; size = 0 ; if ( predicateFilter_ != null ) { size += com . google . protobuf . CodedOutputStream . computeMessageSize ( 1 , getPredicateFilter ( ) ) ; } if ( trueFilter_ != null ) { size += com . google . protobuf . CodedOutputStream . computeMessageSize ( 2 , getTrueFilter ( ) ) ; } if ( falseFilter_ != null ) { size += com . google . protobuf . CodedOutputStream . computeMessageSize ( 3 , getFalseFilter ( ) ) ; } memoizedSerializedSize = size ; return size ; } \n', 0.36105686134343445)

('private Size determineBestSize ( List < Size > sizes , int widthThreshold ) { Size bestSize = null ; Size size ; int numOfSizes = sizes . size ( ) ; for ( int i = 0 ; i < numOfSizes ; i ++ ) { size = sizes . get ( i ) ; boolean isDesireRatio = ( size . width / 4 ) == ( size . height / 3 ) ; boolean isBetterSize = ( bestSize == null ) || size . width > bestSize . width ; if ( isDesireRatio && isBetterSize ) { bestSize = size ; } } if ( bestSize == null ) { Log . d ( TAG , "cannot-find-the-best-camera-size" ) ; return sizes . get ( sizes . size ( ) - 1 ) ; } return bestSize ; } \n', 0.35958412336394674)

('public static int resolveSizeAndState ( int size , int measureSpec , int childMeasuredState ) { return View . resolveSizeAndState ( size , measureSpec , childMeasuredState ) ; } \n', 0.35323397847194016)

('@ Override public double computeEquivalentSampleSize ( BetaDistribution belief ) { double alpha = belief . getAlpha ( ) ; double beta = belief . getBeta ( ) ; return ( alpha + beta ) / this . getN ( ) + 1.0 ; } \n', 0.3514406174611721)

('private boolean findBestPreviewSize ( List < Size > supportedSizes , boolean need4To3 , boolean needSmaller ) { int pixelsDiff = DEFAULT_CAPTURE_PIXELS ; boolean hasFound = false ; for ( Size size : supportedSizes ) { int h = size . height ; int w = size . width ; int d = DEFAULT_CAPTURE_PIXELS - h * w ; if ( needSmaller && d < 0 ) { continue ; } if ( need4To3 && ( h * 4 != w * 3 ) ) { continue ; } d = Math . abs ( d ) ; if ( d < pixelsDiff ) { mPreviewWidth = w ; mPreviewHeight = h ; pixelsDiff = d ; hasFound = true ; } } return hasFound ; } \n', 0.3487544902986562)

('static int updateLimitForQuery ( int limit , Slices slices ) { if ( ! slices . hasLowerBound ( ) && ! slices . hasUpperBound ( ) ) return limit ; for ( Slice slice : slices ) { if ( limit == Integer . MAX_VALUE ) return limit ; if ( ! slice . start ( ) . isInclusive ( ) ) limit ++ ; if ( ! slice . end ( ) . isInclusive ( ) ) limit ++ ; } return limit ; } \n', 0.34831861583724083)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('@ Override public String alias ( Class < ? > clazz ) { if ( clazz . getPackage ( ) . getName ( ) . startsWith ( clientPackagePrefix ) ) return clazz . getName ( ) . replaceFirst ( clientPackagePrefix . replace ( "." , "|." ) , serverPackagePrefix ) ; return clazz . getName ( ) ; } \n', 0.34490704133025485)

('public Object invokeMethodByName ( String methodName , Object ... args ) { Class < ? extends ResourceManager > thisClass = this . getClass ( ) ; Method [ ] methods = thisClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( m . getName ( ) . equals ( methodName ) ) { try { return ( Object ) m . invoke ( this , args ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { Trace . error ( e . getMessage ( ) ) ; } } } return null ; } \n', 0.3422176104928403)

('private static String toSimpleName ( Type type ) { if ( type instanceof Class < ? > ) { return ( ( Class < ? > ) type ) . getSimpleName ( ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType pType = ( ParameterizedType ) type ; StringBuilder sBuilder = new StringBuilder ( ) ; sBuilder . append ( ( ( Class < ? > ) pType . getRawType ( ) ) . getSimpleName ( ) ) ; Type [ ] args = pType . getActualTypeArguments ( ) ; sBuilder . append ( "<" ) ; for ( Type t : args ) { sBuilder . append ( toSimpleName ( t ) ) ; sBuilder . append ( ",-" ) ; } sBuilder . deleteCharAt ( sBuilder . lastIndexOf ( "," ) ) ; sBuilder . deleteCharAt ( sBuilder . lastIndexOf ( "-" ) ) ; sBuilder . append ( ">" ) ; return sBuilder . toString ( ) ; } else { return type . toString ( ) ; } } \n', 0.341535813352022)

('public static Object invokeMethodByName ( Object o , String methodName , Object ... args ) throws MethodNotFoundException { assert o != null ; assert methodName != null ; for ( Method m : o . getClass ( ) . getMethods ( ) ) { if ( methodName . equals ( m . getName ( ) ) ) { try { return m . invoke ( o , args ) ; } catch ( IllegalArgumentException e ) { assertMethodArgs ( m , args ) ; throw e ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } } throw new MethodNotFoundException ( String . format ( "Method-%s-not-found-in-class-%s" , methodName , o . getClass ( ) ) ) ; } \n', 0.3404126629350881)

('public static String fqcn ( Class < ? > c ) { if ( c == null ) return null ; String cn = c . getName ( ) ; if ( c . isArray ( ) ) { int idx = cn . lastIndexOf ( "[" ) ; return idx + 2 < cn . length ( ) ? cn . substring ( idx + 2 ) : "" ; } return cn ; } \n', 0.33888935799829256)

('String renameMethodDesc ( String desc ) { if ( desc == null ) { return null ; } Type [ ] args = Type . getArgumentTypes ( desc ) ; StringBuilder sb = new StringBuilder ( "(" ) ; for ( Type arg : args ) { String name = renameType ( arg ) ; sb . append ( name ) ; } sb . append ( \')\' ) ; Type ret = Type . getReturnType ( desc ) ; String name = renameType ( ret ) ; sb . append ( name ) ; return sb . toString ( ) ; } \n', 0.3368529368869035)

('public static CommandThreadPolicy forName ( CharSequence name ) { if ( name == null || name . toString ( ) . trim ( ) . isEmpty ( ) ) throw new IllegalArgumentException ( "The-passed-name-was-null-or-empty" , new Throwable ( ) ) ; try { return CommandThreadPolicy . valueOf ( name . toString ( ) . trim ( ) . toUpperCase ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "The-passed-name-[" + name + "]-was-not-a-valid-CommandThreadPolicy" , new Throwable ( ) ) ; } } \n', 0.33626898765089414)

('public static String renameBeanParameter ( final String currentBean , final String currentParameterName , final String newParameterName ) { log . fine ( "Replacing-parameter-" + currentParameterName + "-with-" + newParameterName ) ; String regex = String . format ( REGEX_PATTERN , StringUtils . firstCharToUpper ( currentParameterName . trim ( ) ) ) ; String replaceStr = String . format ( "$1%s$2" , StringUtils . firstCharToUpper ( newParameterName . trim ( ) ) ) ; String newBean = currentBean ; String tempBean = "" ; while ( ! newBean . equals ( tempBean ) ) { tempBean = newBean ; newBean = newBean . replaceAll ( regex , replaceStr ) ; } return newBean ; } \n', 0.3344373630555912)

('public static String quoteMethodName ( String name ) { return Naming . quoteIfJavaKeyword ( name ) ; } \n', 0.3317813870746634)

('protected Object createProcessBean ( Name name ) { try { return classMap . get ( name . getLocalPart ( ) ) . newInstance ( ) ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } \n', 0.3312074079460498)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public static String getPlatformLineSeparator ( ) { return System . getProperty ( "line.separator" ) ; } \n', 0.40091865661075077)

('public static String GetLineEnding ( ) { return System . getProperty ( "line.separator" ) ; } \n', 0.3922235893498077)

('public int getMainWindowLeftVerticalSplitPosition ( ) { return prefs . getInt ( MAIN_WINDOW_LEFT_VERTICAL_SPLIT_POSITION , 300 ) ; } \n', 0.38871607230842553)

('private static String getExpectedNavigationText ( String navigationComment ) { int firstLineEnd = navigationComment . indexOf ( "-" ) ; String expectedNavigationText = navigationComment . substring ( firstLineEnd + 1 ) ; assertTrue ( String . format ( "Marker-%s-is-expected-before-navigation-data" , TARGETS_PREFIX ) , expectedNavigationText . startsWith ( TARGETS_PREFIX ) ) ; expectedNavigationText = expectedNavigationText . substring ( expectedNavigationText . indexOf ( "-" ) + 1 ) ; return expectedNavigationText ; } \n', 0.38132814433089457)

('public int getLettersInLine ( int line ) { return getLettersInLineIndex ( line - 1 ) ; } \n', 0.3719904878859045)

('public int getDescriptionDividerLocation ( ) { return split . getDividerLocation ( ) ; } \n', 0.3664017387707052)

('public float getLineSpacing ( ) { return StyleConstants . getLineSpacing ( paraStyle ) ; } \n', 0.364479404012765)

('public static String getOsLineSeparator ( ) { String result = System . getProperty ( "line.separator" ) ; return result != null ? result : "-" ; } \n', 0.3635728737518033)

('public static String getOSPathSeparator ( ) { if ( System . getProperty ( "os.name" ) . equalsIgnoreCase ( "linux" ) ) return "/" ; else return "|" ; } \n', 0.3625507689213412)

('private JSplitPane getInteractiveCenterSplitPane ( ) { if ( interactiveCenterSplitPane == null ) { interactiveCenterSplitPane = new JSplitPane ( ) ; interactiveCenterSplitPane . setDividerSize ( 6 ) ; interactiveCenterSplitPane . setLeftComponent ( getInteractiveCenterSouthPanel ( ) ) ; interactiveCenterSplitPane . setRightComponent ( getInteractiveCenterTopPanel ( ) ) ; interactiveCenterSplitPane . setDividerLocation ( 200 ) ; } return interactiveCenterSplitPane ; } \n', 0.3607782447935197)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public static < E > List < E > convertMapToList ( Map < ? , E > map ) { if ( ( map == null ) || ( map . size ( ) == 0 ) ) return new ArrayList < E > ( 0 ) ; List < E > list = new ArrayList < E > ( map . size ( ) ) ; for ( E e : map . values ( ) ) list . add ( e ) ; return list ; } \n', 0.45326748932659766)

('@ SuppressWarnings ( "unchecked" ) public static < K , V > Map < K , V > listToMap ( List < ? > entries , Class < ? > mapClass ) { try { Map < K , V > map = ( Map < K , V > ) mapClass . newInstance ( ) ; for ( Map . Entry < K , V > entry : ( List < Map . Entry < K , V >> ) entries ) { ( ( Map < K , V > ) map ) . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return map ; } catch ( InstantiationException e ) { throw new RuntimeException ( e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } } \n', 0.4496813304495011)

('public static < T extends Object > List < T > convertMapToList ( Map < String , T > map ) { List < T > list = new ArrayList < T > ( ) ; for ( T t : map . values ( ) ) { list . add ( t ) ; } return list ; } \n', 0.44733325735105767)

('private List < WarningUnit > convertMapToList ( final Map < Integer , WarningUnit > resultMap ) { List < WarningUnit > resultList = new ArrayList < WarningUnit > ( ) ; Collection < WarningUnit > col = resultMap . values ( ) ; resultList . addAll ( col ) ; return resultList ; } \n', 0.4472048636880249)

('public static < K , T > List < T > convertMapToList ( Map < K , T > map ) { if ( map == null ) return null ; return new ArrayList < T > ( map . values ( ) ) ; } \n', 0.44691073869822795)

('public static List < Object > convertMapToList ( Map < ? , ? > map ) { List < Object > list = new ArrayList < Object > ( map . size ( ) ) ; list . addAll ( map . values ( ) ) ; return list ; } \n', 0.44320932870569246)

('public static List < TypeAdvancedRs > listMapToObject ( List < String > listTypes ) { List < TypeAdvancedRs > types = new ArrayList < TypeAdvancedRs > ( ) ; if ( listTypes != null && listTypes . size ( ) > 0 ) { for ( String type : listTypes ) { TypeAdvancedRs adType = mapToObject ( type ) ; types . add ( adType ) ; } } return types ; } \n', 0.4396362811296366)

('public static < T > List < T > mapListToBeanList ( List < Map < String , Object >> mapList , Class < T > targetClass ) { List < T > list = new ArrayList < T > ( ) ; if ( mapList == null || targetClass == null ) return list ; for ( Map < String , Object > map : mapList ) { list . add ( BeanUtil . mapToBean ( map , targetClass ) ) ; } return list ; } \n', 0.43917899684307304)

('public static List < ReplicationDestinationRs > listMapToObject ( List < Map < String , String >> maps ) throws Exception { List < ReplicationDestinationRs > replicationDestinations = new ArrayList < ReplicationDestinationRs > ( ) ; if ( maps != null && maps . size ( ) > 0 ) { for ( Map < String , String > map : maps ) { ReplicationDestinationRs replicationDestination = mapToObject ( map ) ; replicationDestinations . add ( replicationDestination ) ; } } return replicationDestinations ; } \n', 0.4357610784892097)

('public static List < NetworkSlaveInterfaceRs > listMapToObject ( List < String > listIfaces ) { List < NetworkSlaveInterfaceRs > listSlaves = new ArrayList < NetworkSlaveInterfaceRs > ( ) ; if ( listIfaces != null && listIfaces . size ( ) > 0 ) { for ( String nameIface : listIfaces ) { NetworkSlaveInterfaceRs j = toObject ( nameIface ) ; listSlaves . add ( j ) ; } } return listSlaves ; } \n', 0.43405167517813775)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.4043