########################## 1 #################################
('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42189944410094926)

('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

('public String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4086881582715446)

('private static String convertReaderToString ( Reader reader ) throws IOException { if ( reader != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40778385592006827)

('private String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) { try { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } catch ( IOException e ) { throw new RuntimeException ( "Did-not-expect-this-one..." , e ) ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } \n', 0.4074249952540185)

('private static String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public static String convertStreamToString ( final InputStream is ) throws IOException { if ( is == null ) { throw new IOException ( "Empty-stream" ) ; } else { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } } \n', 0.40742241077751923)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('public static Integer [ ] createIntegerArrFromCollection ( List < Integer [ ] > integerArrList ) { if ( integerArrList == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; Iterator < Integer [ ] > iterator = integerArrList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer [ ] integerArr = iterator . next ( ) ; if ( integerArr != null && integerArr . length > 0 ) { for ( Integer integerValue : integerArr ) { if ( integerValue != null ) { integerList . add ( integerValue ) ; } } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.36514417254870113)

('protected static final < O extends Object > Interval < O > createFromList ( List < IntervalData < O >> intervals ) { Interval < O > newInterval = new Interval < O > ( ) ; if ( intervals . size ( ) == 1 ) { IntervalData < O > middle = intervals . get ( 0 ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; newInterval . add ( middle ) ; return newInterval ; } int half = intervals . size ( ) / 2 ; IntervalData < O > middle = intervals . get ( half ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; List < IntervalData < O >> leftIntervals = new ArrayList < IntervalData < O >> ( ) ; List < IntervalData < O >> rightIntervals = new ArrayList < IntervalData < O >> ( ) ; for ( IntervalData < O > interval : intervals ) { if ( interval . end < newInterval . center ) { leftIntervals . add ( interval ) ; } else if ( interval . start > newInterval . center ) { rightIntervals . add ( interval ) ; } else { newInterval . add ( interval ) ; } } if ( leftIntervals . size ( ) > 0 ) newInterval . left = createFromList ( leftIntervals ) ; if ( rightIntervals . size ( ) > 0 ) newInterval . right = createFromList ( rightIntervals ) ; return newInterval ; } \n', 0.337776059959168)

('public ArrayList < ArrayList < Double >> createTestList ( int num_points , boolean integers , boolean negative ) { ArrayList < ArrayList < Double >> test_list = new ArrayList ( ) ; for ( int i = 0 ; i < num_points ; i ++ ) { ArrayList < Double > temp_arraylist = new ArrayList ( ) ; double temp_val1 = Math . random ( ) * scale_x ; double temp_val2 = Math . random ( ) * scale_y ; if ( integers ) { temp_val1 = Math . floor ( temp_val1 ) ; temp_val2 = Math . floor ( temp_val2 ) ; } if ( negative ) { temp_val1 = temp_val1 * 2 - scale_x ; temp_val2 = temp_val2 * 2 - scale_y ; } temp_arraylist . add ( temp_val1 ) ; temp_arraylist . add ( temp_val2 ) ; test_list . add ( temp_arraylist ) ; } return test_list ; } \n', 0.32433913586832874)

('private static ArrayList < SmsMessage > createMessageListFromRawRecords ( List < SmsRawData > records ) { ArrayList < SmsMessage > messages = new ArrayList < SmsMessage > ( ) ; if ( records != null ) { int count = records . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SmsRawData data = records . get ( i ) ; if ( data != null ) { SmsMessage sms = SmsMessage . createFromEfRecord ( i + 1 , data . getBytes ( ) ) ; if ( sms != null ) { messages . add ( sms ) ; } } } } return messages ; } \n', 0.32180324625878154)

('public static List < Track > createListFromResultSet ( final ResultSet rs ) throws SQLException { final List < Track > tracks = new ArrayList < Track > ( ) ; while ( rs . next ( ) ) tracks . add ( Track . createFromResultSet ( rs ) ) ; return tracks ; } \n', 0.3149692570249006)

('public List createIntegerListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( BigInteger ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . INTEGER , item ) ) ; } return result ; } \n', 0.31496377986000623)

('private ArrayList < String > arrayToArrayList ( String [ ] array ) { ArrayList < String > arraylist = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { arraylist . add ( array [ i ] ) ; } return arraylist ; } \n', 0.31113449677079336)

('protected List < MusicIndex > createIndexesFromExpression ( String expr ) { List < MusicIndex > result = new ArrayList < MusicIndex > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( expr , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { MusicIndex index = createIndexFromExpression ( tokenizer . nextToken ( ) ) ; result . add ( index ) ; } return result ; } \n', 0.30197965752895306)

('public ArrayList < String > inferredOrthologsToArrayList ( final String seq_name , double threshold_orthologs ) { HashMap < String , Integer > o_hashmap = null ; String name = null ; double o = 0.0 ; final ArrayList < String > arraylist = new ArrayList < String > ( ) ; if ( _o_hash_maps == null ) { throw new IllegalStateException ( "Orthologs-have-not-been-calculated-(successfully)." ) ; } if ( threshold_orthologs < 0.0 ) { threshold_orthologs = 0.0 ; } else if ( threshold_orthologs > 100.0 ) { threshold_orthologs = 100.0 ; } o_hashmap = getInferredOrthologs ( seq_name ) ; if ( o_hashmap == null ) { throw new IllegalStateException ( "Orthologs-for-" + seq_name + "-were-not-established." ) ; } if ( _seq_names . length > 0 ) { I : for ( int i = 0 ; i < _seq_names . length ; ++ i ) { name = _seq_names [ i ] ; if ( name . equals ( seq_name ) ) { continue I ; } o = getBootstrapValueFromHash ( o_hashmap , name ) ; if ( o < threshold_orthologs ) { continue I ; } arraylist . add ( name ) ; } } return arraylist ; } \n', 0.29810528098606914)

('public List createDoubleListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( Double ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . DOUBLE , item ) ) ; } return result ; } \n', 0.2971617146950231)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('public < T extends Iterable < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList ( iterables . length ) ; for ( T iterable : iterables ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3500509165733183)

('public < T extends Iterable < ? extends Key >> JoinIterator ( Aggregator < Key , Value > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = new Comparator < Key > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public int compare ( Key o1 , Key o2 ) { return ( ( Comparable < Key > ) o1 ) . compareTo ( o2 ) ; } } ; for ( T iterable : iterables ) { final Entry entry = new Entry ( size ++ , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; } } \n', 0.34550463930287495)

('public final HashMap collectCachebyAccess ( int rate ) { HashMap resultmap = new HashMap ( ) ; int expectSize = maxSize * rate / 100 ; while ( size > expectSize ) { String key = null ; if ( accessList . getLast ( ) != null ) { key = ( String ) accessList . getLast ( ) . object ; } if ( key != null ) { resultmap . put ( key , hashmap . get ( key ) ) ; remove ( ( String ) accessList . getLast ( ) . object ) ; } else { remove ( ( String ) emptyList . getLast ( ) . object ) ; } } System . out . println ( "rate-is-:-" + size * 100 / maxSize ) ; return resultmap ; } \n', 0.3387688714683485)

('private Iterable < Tile > makeMapIteratorIterable ( final MapIterator m ) { return new Iterable < Tile > ( ) { public Iterator < Tile > iterator ( ) { return new Iterator < Tile > ( ) { public boolean hasNext ( ) { return m . hasNext ( ) ; } public Tile next ( ) { return getTile ( m . next ( ) ) ; } public void remove ( ) { m . remove ( ) ; } } ; } } ; } \n', 0.33329208623876416)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final Indexable indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('private Iterator < Annotation > getAnnotationIterator ( boolean cleanup , boolean recurse ) { Iterator < Annotation > iter = getAnnotationIterator ( cleanup ) ; if ( ! recurse || fAttachments . isEmpty ( ) ) return iter ; List < Iterator < Annotation >> iterators = new ArrayList < > ( fAttachments . size ( ) + 1 ) ; iterators . add ( iter ) ; Iterator < Object > it = fAttachments . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) iterators . add ( fAttachments . get ( it . next ( ) ) . getAnnotationIterator ( ) ) ; return new MetaIterator < > ( iterators . iterator ( ) ) ; } \n', 0.3319734088313099)

('public Iterable < ? extends Key > iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public Iterable < ? extends Key > iterate ( final Indexable indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public net . varkhan . base . containers . Iterable < ? extends Key > iterate ( final long [ ] indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('public double randomInRange ( double min , double max ) { double range = max - min ; double scaled = randomNumGenerator_ . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42066172439532096)

('public static Vector < Range > randomRangesWithOffsets ( int number , double offset , boolean isFixOffset , List < Double > values , Range boundary ) { Vector < Range > ranges = new Vector < Range > ( ) ; int size = values . size ( ) ; Random generator = new Random ( ) ; generator . setSeed ( System . nanoTime ( ) ) ; double _offset = 0.0 ; if ( isFixOffset ) { _offset = offset ; } else { _offset = generator . nextDouble ( ) * offset ; } for ( int i = 0 ; i < number ; i ++ ) { int r = generator . nextInt ( size ) ; double start , end ; start = Math . max ( boundary . getStart ( ) , values . get ( r ) - _offset ) ; end = Math . min ( boundary . getEnd ( ) , values . get ( r ) + _offset ) ; Range range = new Range ( start , end ) ; ranges . add ( range ) ; } return ranges ; } \n', 0.40823690872016083)

('public static int getRandomIntByRange ( int _iRangeLimit ) { return Math . abs ( g_randomObj . nextInt ( _iRangeLimit ) ) ; } \n', 0.40734959195999004)

('public static BigInteger createRandomInRange ( BigInteger min , BigInteger max , SecureRandom random ) { int cmp = min . compareTo ( max ) ; if ( cmp >= 0 ) { if ( cmp > 0 ) { throw new IllegalArgumentException ( "\'min\'-may-not-be-greater-than-\'max\'" ) ; } return min ; } if ( min . bitLength ( ) > max . bitLength ( ) / 2 ) { return createRandomInRange ( ZERO , max . subtract ( min ) , random ) . add ( min ) ; } for ( int i = 0 ; i < MAX_ITERATIONS ; ++ i ) { BigInteger x = new BigInteger ( max . bitLength ( ) , random ) ; if ( x . compareTo ( min ) >= 0 && x . compareTo ( max ) <= 0 ) { return x ; } } return new BigInteger ( max . subtract ( min ) . bitLength ( ) - 1 , random ) . add ( min ) ; } \n', 0.40213987034254695)

('public static int randomIntegerInRange ( final int min , final int max ) { return Utils . getRandomGenerator ( ) . nextInt ( max - min + 1 ) + min ; } \n', 0.3946602058890578)

('public static Double generateRandomDoubleInRange ( double low , double high ) { double percentage = Math . random ( ) ; double result = low + ( high - low ) * percentage ; return result ; } \n', 0.3875989747979697)

('private DataBag generateRandomSortedSamples ( int numSamples , int max ) throws Exception { Random rand = new Random ( 1000 ) ; List < Tuple > samples = new ArrayList < Tuple > ( ) ; for ( int i = 0 ; i < numSamples ; i ++ ) { Tuple t = tFact . newTuple ( 1 ) ; t . set ( 0 , rand . nextInt ( max ) ) ; samples . add ( t ) ; } Collections . sort ( samples ) ; return new NonSpillableDataBag ( samples ) ; } \n', 0.37559212601017566)

('static int [ ] randomIntArray ( final int length , final int range ) { final int [ ] array = new int [ length ] ; final Random generator = new Random ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = generator . nextInt ( range ) ; } return array ; } \n', 0.3680162602005158)

('public static int [ ] generateRandomTernary ( int N , int numOnes , int numNegOnes , SecureRandom random ) { Integer one = Integers . valueOf ( 1 ) ; Integer minusOne = Integers . valueOf ( - 1 ) ; Integer zero = Integers . valueOf ( 0 ) ; List list = new ArrayList ( ) ; for ( int i = 0 ; i < numOnes ; i ++ ) { list . add ( one ) ; } for ( int i = 0 ; i < numNegOnes ; i ++ ) { list . add ( minusOne ) ; } while ( list . size ( ) < N ) { list . add ( zero ) ; } Collections . shuffle ( list , random ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( ( Integer ) list . get ( i ) ) . intValue ( ) ; } return arr ; } \n', 0.35316886227906197)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.42556612403100647)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.4081503043985538)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.40780405246205736)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.40614039395713675)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.40470804593981363)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.4042160832634376)

('public static int convertToInt ( String str ) throws NumberFormatException { int s , e ; for ( s = 0 ; s < str . length ( ) ; s ++ ) if ( Character . isDigit ( str . charAt ( s ) ) ) break ; for ( e = str . length ( ) ; e > 0 ; e -- ) if ( Character . isDigit ( str . charAt ( e - 1 ) ) ) break ; if ( e > s ) { try { return Integer . parseInt ( str . substring ( s , e ) ) ; } catch ( NumberFormatException ex ) { Log . e ( "convertToInt" , ex ) ; throw new NumberFormatException ( ) ; } } else { throw new NumberFormatException ( ) ; } } \n', 0.3963696699535767)

('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; String commaFreeValue = thousandSeparator . matcher ( value ) . replaceAll ( "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( commaFreeValue ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( commaFreeValue ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( commaFreeValue ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( commaFreeValue ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( commaFreeValue ) ; } } catch ( NumberFormatException nfe ) { if ( expectedClz != double . class ) { String hexDigits = SQLParser . getDigitsFromHexLiteral ( value ) ; if ( hexDigits != null ) { try { return SQLParser . hexDigitsToLong ( hexDigits ) ; } catch ( SQLParser . Exception spe ) { } } } } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.38651770381897893)

('public static int convertToInteger ( String rawValue ) throws XMPException { try { if ( rawValue == null || rawValue . length ( ) == 0 ) { throw new XMPException ( "Empty-convert-string" , XMPError . BADVALUE ) ; } if ( rawValue . startsWith ( "0x" ) ) { return Integer . parseInt ( rawValue . substring ( 2 ) , 16 ) ; } else { return Integer . parseInt ( rawValue ) ; } } catch ( NumberFormatException e ) { throw new XMPException ( "Invalid-integer-string" , XMPError . BADVALUE ) ; } } \n', 0.3849569789478535)

('protected synchronized String convertNumberToCompatibleString ( Double number ) throws KettleValueException { if ( number == null ) { return null ; } return Double . toString ( number ) ; } \n', 0.38222353283087634)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('public List < String > initializeTexts ( ) { List < String > ret = new ArrayList < String > ( ) ; BufferedReader reader = null ; files = getJavaFiles ( ) ; try { for ( String oneFile : files ) { File file = new File ( oneFile ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; StringBuilder stringBuilder = new StringBuilder ( ) ; String ls = ExperimentDataUtil . EOL ; while ( ( line = reader . readLine ( ) ) != null ) { stringBuilder . append ( line ) ; stringBuilder . append ( ls ) ; } reader . close ( ) ; String data = stringBuilder . toString ( ) ; String name = oneFile . substring ( oneFile . indexOf ( SRC_TOKEN ) + SRC_TOKEN . length ( ) ) ; name = name . substring ( 0 , name . indexOf ( JAVA_FILE_TYPE ) ) ; name = name . replace ( "|" , "." ) ; fileNames . add ( name ) ; ret . add ( data ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return ret ; } \n', 0.3713574990046598)

('private static void initialize ( String filename ) throws IllegalInputException { params . clear ( ) ; paramPosition . clear ( ) ; paramValues . clear ( ) ; int counter = 0 ; try { String fileName = "" ; if ( ! filename . equals ( "" ) ) { fileName = filename ; } else { fileName = DEFAULT_CONFIG_FILE_NAME ; } BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . charAt ( 0 ) != \'#\' ) { String [ ] content = line . split ( ":" ) ; String name = content [ 0 ] ; String values = content [ 1 ] . trim ( ) ; if ( name . equals ( "number_of_runs" ) ) { number_of_runs = Integer . parseInt ( values ) ; } else { String [ ] valuesArray = values . split ( "-" ) ; params . put ( name , valuesArray ) ; paramPosition . put ( counter , name ) ; counter ++ ; paramValues . add ( valuesArray ) ; } } } reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } } \n', 0.3473700098880026)

('protected static Map < String , String [ ] > readAndInitializeFromInput ( String filePath ) { List < String > discMarkLines = new ArrayList < String > ( ) ; Map < String , String [ ] > discourseMarkers = new HashMap < String , String [ ] > ( ) ; try { discMarkLines = FileUtils . readLines ( new File ( filePath ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( String inputLine : discMarkLines ) { String [ ] markers = inputLine . split ( "||-" ) ; String key = markers [ 0 ] ; String [ ] values = markers [ 1 ] . split ( "-" ) ; discourseMarkers . put ( key , values ) ; System . out . println ( "" ) ; } return discourseMarkers ; } \n', 0.3439359290483235)

('private void initDict ( String file ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; String temp = null ; while ( ( temp = in . readLine ( ) ) != null ) { String [ ] wordlist = temp . split ( "-" ) ; for ( String word : wordlist ) { List < String > indexList = getSubStrings ( word ) ; for ( String oneIdx : indexList ) { if ( nwords . containsKey ( oneIdx ) ) { List < String > fullWords = nwords . get ( oneIdx ) ; if ( fullWords . contains ( word ) ) { continue ; } fullWords . add ( word ) ; nwords . put ( oneIdx , fullWords ) ; } else { List < String > entries = new ArrayList < String > ( ) ; entries . add ( word ) ; nwords . put ( oneIdx , entries ) ; } } } } } finally { if ( in != null ) in . close ( ) ; } } \n', 0.33988270310869273)

('private void initializeFromFile ( File masterFile ) throws Exception { try { List < String > lines = FileUtils . readLines ( masterFile , "UTF8" ) ; String tag = lines . get ( 0 ) ; LOG . info ( "Loading-from-persistent-master:-" + tag ) ; String line = new String ( Base64 . decodeBase64 ( lines . get ( 1 ) ) ) ; String [ ] parts = line . split ( "::" ) ; this . master = new String ( aes . decrypt ( Base64 . decodeBase64 ( parts [ 0 ] ) , Base64 . decodeBase64 ( parts [ 1 ] ) , Base64 . decodeBase64 ( parts [ 2 ] ) ) , "UTF8" ) . toCharArray ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; throw e ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw e ; } } \n', 0.33853994520503583)

('public void initRulesfromRuleset ( ) { try { BufferedReader in = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( fileContents . getBytes ( "UTF-8" ) ) ) ) ; String read ; while ( ( read = in . readLine ( ) ) != null ) { String name = null ; read = read . trim ( ) ; if ( read . startsWith ( "inv" ) ) { read = read . substring ( 4 ) ; int colonIndex = read . indexOf ( ":" ) ; name = read . substring ( 0 , colonIndex ) . trim ( ) ; } if ( name != null ) { OCLRule createdRule = OclRulesFactory . eINSTANCE . createOCLRule ( ) ; getRules ( ) . add ( createdRule ) ; createdRule . setName ( name ) ; } } in . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ; } \n', 0.3366497799175723)

('public void initFromFile ( File f ) { try { FileInputStream fstream = new FileInputStream ( f ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String strLine ; if ( ( strLine = br . readLine ( ) ) != null ) { number = Integer . valueOf ( strLine ) ; Util . n_bodies = number ; position_x = new double [ number ] ; position_y = new double [ number ] ; velocity_x = new double [ number ] ; velocity_y = new double [ number ] ; mass = new double [ number ] ; } else { System . err . println ( "File-is-empty" ) ; } int i = 0 ; while ( ( strLine = br . readLine ( ) ) != null ) { String [ ] values = strLine . split ( "-" ) ; position_x [ i ] = Double . valueOf ( values [ 0 ] ) ; position_y [ i ] = Double . valueOf ( values [ 1 ] ) ; velocity_x [ i ] = Double . valueOf ( values [ 2 ] ) ; velocity_y [ i ] = Double . valueOf ( values [ 3 ] ) ; mass [ i ] = Double . valueOf ( values [ 4 ] ) ; i ++ ; } in . close ( ) ; } catch ( Exception ex ) { System . err . println ( ex ) ; } this . initBody ( false ) ; } \n', 0.3365966090314737)

('public static void initialize ( ) throws Exception { if ( isInitialized ( ) ) return ; if ( ! JWNL . isInitialized ( ) ) { String file_properties = System . getProperty ( "jwnl.configuration" ) ; if ( file_properties == null ) throw new Exception ( "Required-property-\'jwnl.configuration\'-is-undefined" ) ; JWNL . initialize ( new FileInputStream ( file_properties ) ) ; } pUtils = PointerUtils . getInstance ( ) ; Properties properties = Properties . loadFromClassName ( WordNetAnswerTypeMapping . class . getName ( ) ) ; String wnAtypeMapFile = properties . getProperty ( "mapFile" ) ; if ( wnAtypeMapFile == null ) throw new RuntimeException ( "Required-parameter-mapFile-is-undefined" ) ; BufferedReader in = new BufferedReader ( new FileReader ( wnAtypeMapFile ) ) ; String line ; wnAtypeMap = new HashMap < String , String > ( ) ; wnAtypeMapKeys = new ArrayList < String > ( ) ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . matches ( "#.*" ) || line . matches ( "|s*" ) ) continue ; String [ ] strs = line . split ( "," ) ; wnAtypeMap . put ( strs [ 0 ] , strs [ 1 ] ) ; wnAtypeMapKeys . add ( strs [ 0 ] ) ; } in . close ( ) ; setInitialized ( true ) ; } \n', 0.33091813778874135)

('private void init ( BufferedReader br ) throws IOException { ArrayList paraTable = new ArrayList ( 300 ) ; String line = br . readLine ( ) ; String [ ] tableDefArr = SmartStringArray . split ( ":" , line ) ; center_id = Integer . parseInt ( tableDefArr [ 1 ] . trim ( ) ) ; paramter_table = Integer . parseInt ( tableDefArr [ 3 ] . trim ( ) ) ; int maxInd = 0 ; while ( ( line = br . readLine ( ) ) != null ) { int end = line . indexOf ( \':\' ) ; String indStr = line . substring ( 0 , end ) . trim ( ) ; int index = Integer . parseInt ( indStr ) ; maxInd = Math . max ( maxInd , index ) ; paraTable . add ( line ) ; } paramtable_opn = decodeParamters ( paraTable , maxInd ) ; } \n', 0.33075653169291885)

('private void init ( BufferedReader br ) throws IOException { List < String > paraTable = new ArrayList < String > ( 300 ) ; String line = br . readLine ( ) ; String [ ] tableDefArr = SmartStringArray . split ( ":" , line ) ; center_id = Integer . parseInt ( tableDefArr [ 1 ] . trim ( ) ) ; paramter_table = Integer . parseInt ( tableDefArr [ 3 ] . trim ( ) ) ; int maxInd = 0 ; while ( ( line = br . readLine ( ) ) != null ) { int end = line . indexOf ( \':\' ) ; String indStr = line . substring ( 0 , end ) . trim ( ) ; int index = Integer . parseInt ( indStr ) ; maxInd = Math . max ( maxInd , index ) ; paraTable . add ( line ) ; } paramtable_opn = decodeParamters ( paraTable , maxInd ) ; } \n', 0.3206252534668762)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

('void assertContainsExactly ( AssertionInfo info , Failures failures , Object actual , Object values ) { if ( commonChecks ( info , actual , values ) ) return ; assertNotNull ( info , actual ) ; assertIsArray ( info , actual ) ; assertIsArray ( info , values ) ; int actualSize = sizeOf ( actual ) ; int expectedSize = sizeOf ( values ) ; if ( actualSize != expectedSize ) throw failures . failure ( info , shouldHaveSameSize ( actual , values , actualSize , expectedSize , comparisonStrategy ) ) ; List < Object > actualWithoutDuplicates = asListWithoutDuplicatesAccordingToComparisonStrategy ( actual ) ; List < Object > notFound = containsOnly ( actualWithoutDuplicates , values ) ; if ( actualWithoutDuplicates . isEmpty ( ) && notFound . isEmpty ( ) ) { int arrayLength = sizeOf ( actual ) ; for ( int i = 0 ; i < arrayLength ; i ++ ) { Object actualElement = Array . get ( actual , i ) ; Object expectedElement = Array . get ( values , i ) ; if ( ! areEqual ( actualElement , expectedElement ) ) { throw failures . failure ( info , elementsDifferAtIndex ( actualElement , expectedElement , i , comparisonStrategy ) ) ; } } return ; } throw failures . failure ( info , shouldContainExactly ( actual , values , notFound , actualWithoutDuplicates , comparisonStrategy ) ) ; } \n', 0.3404522116788363)

('void assertContains ( AssertionInfo info , Failures failures , Object actual , Object values ) { if ( commonChecks ( info , actual , values ) ) return ; Set < Object > notFound = new LinkedHashSet < > ( ) ; int valueCount = sizeOf ( values ) ; for ( int i = 0 ; i < valueCount ; i ++ ) { Object value = Array . get ( values , i ) ; if ( ! arrayContains ( actual , value ) ) notFound . add ( value ) ; } if ( ! notFound . isEmpty ( ) ) throw failures . failure ( info , shouldContain ( actual , values , notFound , comparisonStrategy ) ) ; } \n', 0.32547915300509045)

('void assertContains ( Description description , Object array , Object values ) { checkIsNotNullAndNotEmpty ( values ) ; assertNotNull ( description , array ) ; assertNotEmpty ( description , array ) ; int valueCount = sizeOf ( values ) ; Set < Object > notFound = newLinkedHashSet ( ) ; for ( int i = 0 ; i < valueCount ; i ++ ) { Object value = Array . get ( values , i ) ; if ( ! arrayContains ( array , value ) ) { notFound . add ( value ) ; } } if ( notFound . isEmpty ( ) ) { return ; } throw failures . failure ( description , shouldContain ( array , values , notFound ) ) ; } \n', 0.31081210145570026)

('public static ValuesChecker matchesAll ( String ... expected ) { final List < Value > expectedValues = new ArrayList < > ( ) ; for ( String x : expected ) expectedValues . add ( Value . fromString ( x ) ) ; return new ValuesChecker ( ) { public void checkValues ( List < Value > values ) { if ( values . size ( ) != expectedValues . size ( ) || ! expectedValues . containsAll ( values ) ) throw new RuntimeException ( "Expected-" + new ListValue ( expectedValues ) + ",-but-got-" + values ) ; } } ; } \n', 0.29422008934799676)

('public static boolean valueContainsAtLeastOneValueInList ( String value , String commaSeparatedList ) { boolean match = false ; if ( ( commaSeparatedList == null || commaSeparatedList . trim ( ) . length ( ) == 0 ) || ( value == null || value . trim ( ) . length ( ) == 0 ) ) { return match ; } List < String > allValuesToCheck = Arrays . asList ( commaSeparatedList . split ( "," ) ) ; for ( String s : allValuesToCheck ) { if ( value . trim ( ) . toLowerCase ( ) . contains ( s . trim ( ) . toLowerCase ( ) ) ) { match = true ; break ; } } return match ; } \n', 0.2907577928128553)

('void assertContainsOnly ( Description description , Object array , Object values ) { checkIsNotNullAndNotEmpty ( values ) ; assertNotNull ( description , array ) ; Set < Object > notExpected = asSet ( array ) ; Set < Object > notFound = containsOnly ( notExpected , values ) ; if ( notExpected . isEmpty ( ) && notFound . isEmpty ( ) ) { return ; } throw failures . failure ( description , shouldContainOnly ( array , values , notFound , notExpected ) ) ; } \n', 0.28357820392758115)

('protected boolean isContainValue ( Object value , Object data ) { boolean result = false ; if ( data instanceof List ) { result = isContainValue ( value , ( List ) data ) ; } else if ( data instanceof String [ ] ) { result = isContainValue ( value , ( String [ ] ) data ) ; } return result ; } \n', 0.2832278600317153)

('protected boolean test ( final double [ ] values , final double [ ] weights , final int begin , final int length ) { if ( weights == null ) { throw new NullArgumentException ( LocalizedFormats . INPUT_ARRAY ) ; } if ( weights . length != values . length ) { throw new DimensionMismatchException ( weights . length , values . length ) ; } boolean containsPositiveWeight = false ; for ( int i = begin ; i < begin + length ; i ++ ) { if ( Double . isNaN ( weights [ i ] ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NAN_ELEMENT_AT_INDEX , i ) ; } if ( Double . isInfinite ( weights [ i ] ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . INFINITE_ARRAY_ELEMENT , weights [ i ] , i ) ; } if ( weights [ i ] < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NEGATIVE_ELEMENT_AT_INDEX , i , weights [ i ] ) ; } if ( ! containsPositiveWeight && weights [ i ] > 0.0 ) { containsPositiveWeight = true ; } } if ( ! containsPositiveWeight ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . WEIGHT_AT_LEAST_ONE_NON_ZERO ) ; } return test ( values , begin , length ) ; } \n', 0.28269135380751237)

('public static List checkForInitialValues ( Map containerMap ) { List initialValues = null ; if ( ( containerMap != null ) && ( containerMap . size ( ) > 0 ) ) { final String [ ] startingPoints = new String [ 3 ] ; Set keySet = containerMap . keySet ( ) ; Iterator itr = keySet . iterator ( ) ; NameValueBean nvb = ( NameValueBean ) itr . next ( ) ; startingPoints [ 0 ] = nvb . getValue ( ) ; final Map map1 = ( Map ) containerMap . get ( nvb ) ; keySet = map1 . keySet ( ) ; itr = keySet . iterator ( ) ; nvb = ( NameValueBean ) itr . next ( ) ; startingPoints [ 1 ] = nvb . getValue ( ) ; final List list = ( List ) map1 . get ( nvb ) ; nvb = ( NameValueBean ) list . get ( 0 ) ; startingPoints [ 2 ] = nvb . getValue ( ) ; logger . info ( "Starting-points[0]" + startingPoints [ 0 ] ) ; logger . info ( "Starting-points[1]" + startingPoints [ 1 ] ) ; logger . info ( "Starting-points[2]" + startingPoints [ 2 ] ) ; initialValues = new ArrayList ( ) ; initialValues . add ( startingPoints ) ; } return initialValues ; } \n', 0.2823738961400323)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public String convertFieldEnumValueToActualValue ( String fieldValue ) { String retval = "" ; if ( enumValues . containsKey ( fieldValue . toUpperCase ( ) ) ) { retval = enumValues . get ( fieldValue . toUpperCase ( ) ) . toString ( ) ; } return retval ; } \n', 0.3015494847685253)

('public String convertEnumNameToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.2977033782936944)

('private Object attemptToConvertStringToEnum ( Class < ? > requiredType , String trimmedValue , Object currentConvertedValue ) { Object convertedValue = currentConvertedValue ; if ( Enum . class == requiredType ) { int index = trimmedValue . lastIndexOf ( "." ) ; if ( index > - 1 ) { String enumType = trimmedValue . substring ( 0 , index ) ; String fieldName = trimmedValue . substring ( index + 1 ) ; ClassLoader cl = this . targetObject . getClass ( ) . getClassLoader ( ) ; try { Class < ? > enumValueType = ClassUtils . forName ( enumType , cl ) ; Field enumField = enumValueType . getField ( fieldName ) ; convertedValue = enumField . get ( null ) ; } catch ( ClassNotFoundException ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Enum-class-[" + enumType + "]-cannot-be-loaded" , ex ) ; } } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + fieldName + "]-isn\'t-an-enum-value-for-type-[" + enumType + "]" , ex ) ; } } } } if ( convertedValue == currentConvertedValue ) { try { Field enumField = requiredType . getField ( trimmedValue ) ; convertedValue = enumField . get ( null ) ; } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + convertedValue + "]-isn\'t-an-enum-value" , ex ) ; } } } return convertedValue ; } \n', 0.2931613188213217)

('public String convertNoLitEnumToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.29250256649747197)

('public String convertMyEnumToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.2923859437087598)

('private static < E extends Enum < E >> E convertToEnum ( Object object , Class < E > enumClass ) { String name = convertToString ( object ) ; return name == null ? null : Enum . valueOf ( enumClass , name . toUpperCase ( ) ) ; } \n', 0.29220749784582567)

('public String convertGeneratedEnumToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.29053194803232646)

('@ Override public Object convertObjectValueToDataValue ( Object attributeValue , Session session ) { if ( attributeValue == null ) { return super . convertObjectValueToDataValue ( null , session ) ; } else { return super . convertObjectValueToDataValue ( ( ( Enum ) attributeValue ) . name ( ) , session ) ; } } \n', 0.2900365174121511)

('public String convertEnumBugEnumToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.28721247963276764)

('@ SuppressWarnings ( "unchecked" ) public static final Enum < ? > coerceToEnum ( final ELContext ctx , final Object obj , @ SuppressWarnings ( "rawtypes" ) Class type ) { if ( ctx != null ) { boolean originalIsPropertyResolved = ctx . isPropertyResolved ( ) ; try { Object result = ctx . getELResolver ( ) . convertToType ( ctx , obj , type ) ; if ( ctx . isPropertyResolved ( ) ) { return ( Enum < ? > ) result ; } } finally { ctx . setPropertyResolved ( originalIsPropertyResolved ) ; } } if ( obj == null || "" . equals ( obj ) ) { return null ; } if ( type . isAssignableFrom ( obj . getClass ( ) ) ) { return ( Enum < ? > ) obj ; } if ( ! ( obj instanceof String ) ) { throw new ELException ( MessageFactory . get ( "error.convert" , obj , obj . getClass ( ) , type ) ) ; } Enum < ? > result ; try { result = Enum . valueOf ( type , ( String ) obj ) ; } catch ( IllegalArgumentException iae ) { throw new ELException ( MessageFactory . get ( "error.convert" , obj , obj . getClass ( ) , type ) ) ; } return result ; } \n', 0.2861129239854913)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('protected void recursiveNestedJoin ( EventBean lookupEvent , int nestingOrderIndex , EventBean [ ] currentPath , Collection < EventBean [ ] > result , ExprEvaluatorContext exprEvaluatorContext ) { List < EventBean [ ] > nestedResult = new LinkedList < EventBean [ ] > ( ) ; ExecNode nestedExecNode = childNodes . get ( nestingOrderIndex ) ; nestedExecNode . process ( lookupEvent , currentPath , nestedResult , exprEvaluatorContext ) ; boolean isLastStream = ( nestingOrderIndex == nestingOrderLength - 1 ) ; if ( ! isLastStream ) { for ( EventBean [ ] row : nestedResult ) { EventBean lookup = row [ nestedStreams [ nestingOrderIndex ] ] ; recursiveNestedJoin ( lookup , nestingOrderIndex + 1 , row , result , exprEvaluatorContext ) ; } return ; } for ( EventBean [ ] row : nestedResult ) { result . add ( row ) ; } } \n', 0.3494762225854692)

('public void visitForeachLoop ( JCEnhancedForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStat ( tree . var , loopEnv ) ; Type exprType = types . upperBound ( attribExpr ( tree . expr , loopEnv ) ) ; chk . checkNonVoid ( tree . pos ( ) , exprType ) ; Type elemtype = types . elemtype ( exprType ) ; if ( elemtype == null ) { Type base = types . asSuper ( exprType , syms . iterableType . tsym ) ; if ( base == null ) { log . error ( tree . expr . pos ( ) , "foreach.not.applicable.to.type" , exprType , diags . fragment ( "type.req.array.or.iterable" ) ) ; elemtype = types . createErrorType ( exprType ) ; } else { List < Type > iterableParams = base . allparams ( ) ; elemtype = iterableParams . isEmpty ( ) ? syms . objectType : types . upperBound ( iterableParams . head ) ; } } chk . checkType ( tree . expr . pos ( ) , elemtype , tree . var . sym . type ) ; loopEnv . tree = tree ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.31910015986070384)

('private NestedLoops ( final Vector2D [ ] loop ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; surrounded = new ArrayList < NestedLoops > ( ) ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( previous ) . getX ( ) , line . toSubSpace ( current ) . getX ( ) ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.3025557593544445)

('@ SuppressWarnings ( "serial" ) public void testNestedRuntimeExceptionWithRootCause ( ) { String myMessage = "mesg-for-this-exception" ; String rootCauseMesg = "this-is-the-obscure-message-of-the-root-cause" ; Exception rootCause = new Exception ( rootCauseMesg ) ; NestedRuntimeException nex = new NestedRuntimeException ( myMessage , rootCause ) { } ; assertEquals ( nex . getCause ( ) , rootCause ) ; assertTrue ( nex . getMessage ( ) . indexOf ( myMessage ) != - 1 ) ; assertTrue ( nex . getMessage ( ) . indexOf ( rootCauseMesg ) != - 1 ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pw = new PrintWriter ( baos ) ; nex . printStackTrace ( pw ) ; pw . flush ( ) ; String stackTrace = new String ( baos . toByteArray ( ) ) ; assertFalse ( stackTrace . indexOf ( rootCause . getClass ( ) . getName ( ) ) == - 1 ) ; assertFalse ( stackTrace . indexOf ( rootCauseMesg ) == - 1 ) ; } \n', 0.30085220317759176)

('public void visitWhileLoop ( JCWhileLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || ! tree . cond . type . isTrue ( ) ; } \n', 0.29932897137891834)

('public void visitForLoop ( JCForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStats ( tree . init , loopEnv ) ; if ( tree . cond != null ) attribExpr ( tree . cond , loopEnv , syms . booleanType ) ; loopEnv . tree = tree ; attribStats ( tree . step , loopEnv ) ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.2981734140170164)

('protected final int readUntilNestedIgnoreCase ( String endString ) { int index = Util . indexOfNestedIgnoreCase ( fStringSource , endString , fCurrentPosition ) ; if ( index != ( - 1 ) ) { fCurrentPosition = index + 2 + endString . length ( ) ; return 2 + endString . length ( ) ; } fCurrentPosition = fStringSource . length ( ) ; return 0 ; } \n', 0.2973384710464471)

('public void addNestedPos ( ExtractionPos loop ) { nested_loops . add ( loop ) ; } \n', 0.2955534288106427)

('private void removeLoopWithExitNode ( Map < CfgBlock , Set < CfgBlock >> loops , CfgBlock header , Set < CfgBlock > body , CfgBlock headerExitBlock ) { CfgBlock headerClone = null ; for ( CfgBlock b : new HashSet < CfgBlock > ( body ) ) { if ( method . containsEdge ( b , header ) ) { method . removeEdge ( method . getEdge ( b , header ) ) ; if ( headerClone == null ) { headerClone = header . deepCopy ( ) ; addBlockToLoops ( header , headerClone , loops ) ; method . addEdge ( headerClone , headerExitBlock ) ; } method . addEdge ( b , headerClone ) ; } } } \n', 0.29077522927152594)

('protected int incrementLoopExitRepeatition ( Stmt stmt ) { int value = this . getLoopExitRepeatition ( stmt ) ; this . loopExitToRepeatitionMap . put ( stmt , ++ value ) ; return value ; } \n', 0.2897714675806873)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('private void initObjectsFromArray ( ) { List < EngineObject > newObjects = new ArrayList < EngineObject > ( ) ; for ( int i = 0 ; i < this . objects . length ; i ++ ) { EngineObject obj = objects [ i ] ; if ( obj . placementMask == null ) { initObject ( obj , EngineObject . Placement . CENTER ) ; newObjects . add ( obj ) ; } else { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( obj . placementMask . get ( j ) ) { EngineObject clone = new EngineObject ( obj ) ; initObject ( clone , j ) ; newObjects . add ( clone ) ; } } } } this . originalObjects = new ArrayList < EngineObject > ( Arrays . asList ( objects ) ) ; this . objects = ( EngineObject [ ] ) newObjects . toArray ( new EngineObject [ newObjects . size ( ) ] ) ; } \n', 0.23205519869884597)

('private void initFromArray ( byte [ ] array ) { buffer = ByteBuffer . allocateDirect ( array . length ) ; buffer . put ( array ) ; initFromBuffer ( buffer ) ; } \n', 0.21149149308451026)

('public static Integer [ ] createIntegerArrFromCollection ( List < Integer [ ] > integerArrList ) { if ( integerArrList == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; Iterator < Integer [ ] > iterator = integerArrList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer [ ] integerArr = iterator . next ( ) ; if ( integerArr != null && integerArr . length > 0 ) { for ( Integer integerValue : integerArr ) { if ( integerValue != null ) { integerList . add ( integerValue ) ; } } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.20683059309728571)

('public Object [ ] createEStringArrayFromString ( EDataType eDataType , String initialValue ) { return ( Object [ ] ) super . createFromString ( initialValue ) ; } \n', 0.2007816090980968)

('private void registerORBInitializers ( Properties props ) { String orbInitPrefix = ORBConstants . PI_ORB_INITIALIZER_CLASS_PREFIX ; Enumeration propertyNames = props . propertyNames ( ) ; ArrayList initializerList = new ArrayList ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String propertyName = ( String ) propertyNames . nextElement ( ) ; if ( propertyName . startsWith ( orbInitPrefix ) ) { String initClassName = propertyName . substring ( orbInitPrefix . length ( ) ) ; try { Class initClass = ORBClassLoader . loadClass ( initClassName ) ; if ( ORBInitializer . class . isAssignableFrom ( initClass ) ) { if ( initClass != null ) { ORBInitializer initializer = ( ORBInitializer ) initClass . newInstance ( ) ; initializerList . add ( initializer ) ; } } } catch ( Exception e ) { } } } if ( initializerList . size ( ) > 0 ) { orbInitializers = ( ORBInitializer [ ] ) initializerList . toArray ( new ORBInitializer [ 0 ] ) ; } else { orbInitializers = null ; } } \n', 0.19424673362010497)

('private List constructResponseListForDefinedArray ( List definedArrayRequestMapList , String updateValue ) { final List responseList = new ArrayList ( ) ; DefinedArrayRequestBean definedArrayRequestBean = new DefinedArrayRequestBean ( ) ; final Iterator definedArrayRequestMapListItr = definedArrayRequestMapList . iterator ( ) ; int i = 0 ; while ( definedArrayRequestMapListItr . hasNext ( ) ) { final Map defineArrayMap = ( Map ) definedArrayRequestMapListItr . next ( ) ; final Set defineArraySet = defineArrayMap . keySet ( ) ; final Iterator defineArraySetItr = defineArraySet . iterator ( ) ; definedArrayRequestBean = ( DefinedArrayRequestBean ) defineArraySetItr . next ( ) ; final List arrayStatusCollec = definedArrayRequestBean . getArrayStatusList ( ) ; final List newStatusList = this . constructNewStatusList ( arrayStatusCollec ) ; if ( newStatusList . contains ( updateValue ) ) { newStatusList . remove ( updateValue ) ; newStatusList . add ( 0 , updateValue ) ; responseList . add ( i , newStatusList ) ; } else { responseList . add ( i , newStatusList ) ; } i ++ ; } return responseList ; } \n', 0.19046934013173072)

('private static void _sortBodyDeclarations ( List < BodyDeclaration > bodyDeclarations ) { int size = bodyDeclarations . size ( ) ; BodyDeclaration [ ] bodyArray = bodyDeclarations . toArray ( new BodyDeclaration [ size ] ) ; Arrays . sort ( bodyArray , new Comparator < BodyDeclaration > ( ) { public int compare ( BodyDeclaration bodyDeclaration1 , BodyDeclaration bodyDeclaration2 ) { if ( bodyDeclaration1 . getClass ( ) . isInstance ( bodyDeclaration2 ) ) { return 0 ; } Class [ ] classes = new Class [ ] { FieldDeclaration . class , TypeDeclaration . class , MethodDeclaration . class , Initializer . class } ; for ( int i = 0 ; i < classes . length ; i ++ ) { if ( classes [ i ] . isInstance ( bodyDeclaration1 ) ) { for ( int j = i + 1 ; j < classes . length ; j ++ ) { if ( classes [ j ] . isInstance ( bodyDeclaration2 ) ) { return - 1 ; } } } } return 1 ; } } ) ; bodyDeclarations . clear ( ) ; bodyDeclarations . addAll ( Arrays . asList ( bodyArray ) ) ; } \n', 0.18658904550940086)

('public Binding < ? > [ ] declareFrom ( Module ... modules ) { Set < Class < ? >> declared = new HashSet < Class < ? >> ( ) ; Set < Class < ? >> multimodals = new HashSet < Class < ? >> ( ) ; for ( Module m : modules ) { Class < ? extends Module > ns = m . getClass ( ) ; final boolean hasBeenDeclared = declared . contains ( ns ) ; if ( hasBeenDeclared ) { if ( ! metaclass ( ns ) . monomodal ( ) ) { multimodals . add ( ns ) ; } } if ( ! hasBeenDeclared || multimodals . contains ( ns ) ) { m . declare ( this ) ; declared . add ( ns ) ; } } return toArray ( ) ; } \n', 0.1862314689731998)

('public static < T > T [ ] createFrom ( T [ ] array ) { return createFrom ( array , array . length ) ; } \n', 0.18356675603556794)

('public static Integer [ ] createIntegerArrFromString ( String string ) { if ( string == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; String [ ] strArr = string . split ( "," ) ; for ( int i = 0 ; i < strArr . length ; i ++ ) { if ( strArr [ i ] != null ) { try { Integer intValue = Integer . valueOf ( strArr [ i ] ) ; integerList . add ( intValue ) ; } catch ( Exception e ) { } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.18268579169575544)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('private static String generateRandomString ( String algorithm ) { SecureRandom rand = new SecureRandom ( ) ; int random = rand . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; long id = Thread . currentThread ( ) . getId ( ) ; MessageDigest md = null ; String result = null ; try { md = MessageDigest . getInstance ( algorithm ) ; String input = random + time + id + SALT ; byte [ ] hashed = md . digest ( input . getBytes ( "UTF-8" ) ) ; result = new BigInteger ( 1 , hashed ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { log . error ( "cannot-generate-random-string" , e ) ; } catch ( UnsupportedEncodingException e ) { log . error ( "cannot-generate-random-string" , e ) ; } return result ; } \n', 0.3902267394527607)

('public static String generateRandomAlphaNumericString ( int length ) { return generateRandomAlphaNumericString ( length , new Random ( System . currentTimeMillis ( ) ) ) ; } \n', 0.3857432708010554)

('public static String generateRandomString ( int length , ValueType type ) { StringBuffer buffer = new StringBuffer ( ) ; String characters = "" ; switch ( type ) { case ALPHA : characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ; break ; case ALPHANUMERIC : characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890" ; break ; case NUMERIC : characters = "1234567890" ; break ; } int charactersLength = characters . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { double index = Math . random ( ) * charactersLength ; buffer . append ( characters . charAt ( ( int ) index ) ) ; } return buffer . toString ( ) ; } \n', 0.37378302583752554)

('public static String randomAlphaNumeric ( int length ) { StringBuffer buffer = new StringBuffer ( ) ; String characters = "abcdefghijklmnopqrstuvwxyz0123456789" ; int charactersLength = characters . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { double index = Math . random ( ) * charactersLength ; buffer . append ( characters . charAt ( ( int ) index ) ) ; } return buffer . toString ( ) ; } \n', 0.37275587373549524)

('public static String generateRandomNumericSet ( int columnSize , int rowSize , int max ) { String randomData = null ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int i = 1 ; i < columnSize + 1 ; i ++ ) { String numeric = "" ; for ( int j = 0 ; j < rowSize ; j ++ ) { Random random = new Random ( ) ; int x = random . nextInt ( max ) ; numeric += x + delimiter ; } randomData = "id-" + i + delimiter + numeric ; stringBuffer . append ( randomData . substring ( 0 , randomData . length ( ) - 1 ) ) ; if ( i != columnSize ) { stringBuffer . append ( "-" ) ; } } return stringBuffer . toString ( ) ; } \n', 0.3509512610555844)

('private Number generateRandomNumber ( final Number value ) throws BeanException { final double v = value . doubleValue ( ) ; final NumberFormat fmt ; if ( v == value . longValue ( ) ) { fmt = NumberFormat . getIntegerInstance ( Locale . US ) ; } else { fmt = NumberFormat . getNumberInstance ( Locale . US ) ; } final String format = fmt . format ( value ) ; final StringBuilder b = new StringBuilder ( format ) ; for ( int i = 0 ; i < b . length ( ) ; i += 1 ) { final char c = b . charAt ( i ) ; if ( Character . isDigit ( c ) ) { b . setCharAt ( i , ( char ) ( r . nextInt ( \'9\' - \'0\' ) + \'0\' ) ) ; } else { b . setCharAt ( i , c ) ; } } try { return fmt . parse ( b . toString ( ) ) ; } catch ( ParseException e ) { throw new BeanException ( "Failed-to-parse-text" , e ) ; } } \n', 0.34141154279289415)

('public static String getBase62RandomInt ( ) { int randomValue = Random . nextInt ( ) ; ByteBuffer byteBuffer = ByteBuffer . allocate ( 4 ) ; byteBuffer . putInt ( randomValue ) ; BigInteger bi = new BigInteger ( byteBuffer . array ( ) ) ; return convertToBase62String ( bi ) ; } \n', 0.33052886111952523)

('public static RandomGenerator createRandomGenerator ( final Random rng ) { return new RandomGenerator ( ) { public void setSeed ( int seed ) { rng . setSeed ( ( long ) seed ) ; } public void setSeed ( int [ ] seed ) { rng . setSeed ( convertToLong ( seed ) ) ; } public void setSeed ( long seed ) { rng . setSeed ( seed ) ; } public void nextBytes ( byte [ ] bytes ) { rng . nextBytes ( bytes ) ; } public int nextInt ( ) { return rng . nextInt ( ) ; } public int nextInt ( int n ) { if ( n <= 0 ) { throw new NotStrictlyPositiveException ( n ) ; } return rng . nextInt ( n ) ; } public long nextLong ( ) { return rng . nextLong ( ) ; } public boolean nextBoolean ( ) { return rng . nextBoolean ( ) ; } public float nextFloat ( ) { return rng . nextFloat ( ) ; } public double nextDouble ( ) { return rng . nextDouble ( ) ; } public double nextGaussian ( ) { return rng . nextGaussian ( ) ; } } ; } \n', 0.3066353631216712)

('public static String generatePresharedKey ( int numChars ) { Random r = new SecureRandom ( ) ; StringBuilder psk = new StringBuilder ( ) ; for ( int i = 0 ; i < numChars ; i ++ ) { psk . append ( generateAlphaNumeric ( r ) ) ; } return psk . toString ( ) ; } \n', 0.3056445582892284)

('public String generateNewSecureRandomKey ( ) { try { SecureRandom random = SecureRandom . getInstance ( "SHA1PRNG" , "SUN" ) ; String newKey = "" ; newKey = newKey . concat ( DatatypeConverter . printBase64Binary ( toByteArray ( random . nextLong ( ) ) ) . trim ( ) ) ; newKey = newKey . concat ( DatatypeConverter . printBase64Binary ( toByteArray ( random . nextLong ( ) ) ) . trim ( ) ) ; newKey = newKey . concat ( DatatypeConverter . printBase64Binary ( toByteArray ( random . nextLong ( ) ) ) . trim ( ) ) ; newKey = newKey . concat ( DatatypeConverter . printBase64Binary ( toByteArray ( random . nextLong ( ) ) ) . trim ( ) ) ; newKey = newKey . replaceAll ( "[|[!@#$%|^&*|(|)=|-+/]" , "" ) ; return newKey ; } catch ( NoSuchAlgorithmException | NoSuchProviderException e ) { log . error ( "Encountered-error-while-generating-API-Key." , e ) ; } log . error ( "API-Key-Generation-failed.-Make-sure-the-algorithm-is-supported." ) ; return null ; } \n', 0.3026189175727572)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('@ Override public PropertyDefinition [ ] getDeclaredPropertyDefinitions ( ) { if ( ! createdFromExistingDefinition && propertyDefinitionTemplates . isEmpty ( ) ) return null ; return propertyDefinitionTemplates . toArray ( new PropertyDefinition [ propertyDefinitionTemplates . size ( ) ] ) ; } \n', 0.24668626772152302)

('void printDefinitions ( BufferedWriter output , State [ ] consideredStates , String tab ) throws IOException { int i , j , length = consideredStates . length ; State result ; String [ ] lines = new String [ length * ( length + 1 ) / 2 ] ; int lCount = 0 ; for ( i = 0 ; i < length ; i ++ ) { for ( j = i ; j < length ; j ++ ) { StringBuffer line = new StringBuffer ( ) ; line . append ( tab ) ; line . append ( "//-" ) ; line . append ( consideredStates [ i ] . name ) ; line . append ( "-+-" ) ; line . append ( consideredStates [ j ] . name ) ; line . append ( "-=>-" ) ; line . append ( ( result = ( State ) getResult ( this . computedTransitions , consideredStates [ i ] , consideredStates [ j ] ) ) . name ) ; if ( ! result . symbolic || result != getResult ( this . initializedTransitions , consideredStates [ i ] , consideredStates [ j ] ) ) { line . append ( "-CHECK" ) ; } line . append ( \'|n\' ) ; lines [ lCount ++ ] = line . toString ( ) ; } } Arrays . sort ( lines ) ; for ( i = 0 ; i < lCount ; i ++ ) { output . write ( lines [ i ] ) ; } } \n', 0.24393170213139245)

('private void printOneClassInitWithSuper ( OutputContext oc , ObjHashSet clinitBeginSet ) { if ( ! isInterface ( ) && superClass != null && superClass . classInitializers != null ) { if ( clinitBeginSet . add ( this ) ) { oc . cPrint ( "JCGO_CLINIT_BEGIN(" + cname + "__class);" ) ; } superClass . printOneClassInitWithSuper ( oc , clinitBeginSet ) ; } printOneClassInit ( oc , null , null ) ; } \n', 0.24173127373843362)

('private static void printFleetFromString ( String createdFleet ) { String [ ] createdFleetArray = createdFleet . split ( "," ) ; for ( int i = 0 ; i < createdFleetArray . length ; i ++ ) { for ( int j = 0 ; j < Integer . parseInt ( createdFleetArray [ i ] ) ; j ++ ) { System . out . print ( \'#\' ) ; } System . out . println ( ) ; } } \n', 0.2403983932071229)

('public Object [ ] createEStringArrayFromString ( EDataType eDataType , String initialValue ) { return ( Object [ ] ) super . createFromString ( initialValue ) ; } \n', 0.2139862958641192)

('public void printInitials ( ) throws Exception { PersonB person = readPerson ( ) ; Method m = person . getClass ( ) . getDeclaredMethod ( "getInitials" ) ; m . setAccessible ( true ) ; String value = ( String ) m . invoke ( person ) ; System . out . println ( value ) ; } \n', 0.21335013972426162)

('void printErrors ( Map < String , Set < String >> map , String outputFile ) { PrintStream fout = UTOutput . createPrintBufferedFileStream ( outputFile ) ; List < String > keys = new ArrayList < String > ( map . keySet ( ) ) ; Collections . sort ( keys ) ; for ( String key : keys ) { fout . println ( key + "-" + map . get ( key ) . toString ( ) ) ; } fout . close ( ) ; } \n', 0.20829207555104462)

('private void printMap ( Map < String , Set < String >> map , String outFile ) { PrintStream fout = UTOutput . createPrintBufferedFileStream ( outFile ) ; List < String > rolesets = new ArrayList < String > ( map . keySet ( ) ) ; Collections . sort ( rolesets ) ; for ( String roleset : rolesets ) fout . printf ( "%20s:-%s-" , roleset , map . get ( roleset ) . toString ( ) ) ; fout . close ( ) ; } \n', 0.20804745311576073)

('private boolean printClassInitForSubclasses ( OutputContext oc , ObjHashSet processed , ObjHashSet clinitBeginSet ) { if ( classInitializers != null && processed . add ( this ) ) { if ( ! isInterface ( ) && superClass != null ) { boolean depend = false ; ClassDefinition sc = this ; do { Enumeration en = sc . classInitDepend . keys ( ) ; ClassDefinition cd ; while ( en . hasMoreElements ( ) ) { if ( ( cd = ( ClassDefinition ) en . nextElement ( ) ) != sc . superClass && cd . classInitializers != null ) { if ( cd . getSubclassDepth ( sc , null ) <= 0 ) { depend = true ; break ; } if ( sc == this ) return cd . printClassInitForSubclasses ( oc , processed , clinitBeginSet ) ; if ( cd != this && getSubclassDepth ( cd , null ) <= 0 ) { depend = true ; break ; } } } } while ( ! depend && ( sc = sc . superClass ) != null && sc . classInitializers != null ) ; if ( ! depend && superClass . classInitializers != null ) { printOneClassInitWithSuper ( oc , clinitBeginSet ) ; return true ; } } Enumeration en = classInitDepend . keys ( ) ; while ( en . hasMoreElements ( ) ) { if ( ( ( ClassDefinition ) en . nextElement ( ) ) . printClassInitForSubclasses ( oc , processed , clinitBeginSet ) ) return true ; } } return false ; } \n', 0.20761301720443764)

('private MemberActionInfo [ ] getInfosForMembersToBeCreatedInSubclassesOfDeclaringClass ( ) throws JavaModelException { MemberActionInfo [ ] abs = getAbstractMemberInfos ( ) ; MemberActionInfo [ ] nonabs = getAffectedMemberInfos ( ) ; List < MemberActionInfo > result = new ArrayList < > ( abs . length + nonabs . length ) ; result . addAll ( Arrays . asList ( abs ) ) ; result . addAll ( Arrays . asList ( nonabs ) ) ; return result . toArray ( new MemberActionInfo [ result . size ( ) ] ) ; } \n', 0.1952069496931873)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('public static < K , V extends Comparable < V >> Map < K , V > sortMapByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.47019823717805165)

('private static Map sortMapByValues ( Map map ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( ( Map . Entry ) ( o2 ) ) . getValue ( ) == ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ? ( ( Comparable ) ( ( Map . Entry ) ( o1 ) ) . getKey ( ) ) . compareTo ( ( ( Map . Entry ) ( o2 ) ) . getKey ( ) ) : ( ( Comparable ) ( ( Map . Entry ) ( o2 ) ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ; } } ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46917912357463765)

('public static Map < Long , Float > sortMapByValue ( Map < Long , Float > map ) { List < Map . Entry < Long , Float >> list = new LinkedList < Entry < Long , Float >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Long , Float >> ( ) { @ Override public int compare ( Map . Entry < Long , Float > o1 , Map . Entry < Long , Float > o2 ) { if ( o1 . getValue ( ) <= o2 . getValue ( ) ) { return 1 ; } else { return - 1 ; } } } ) ; Map < Long , Float > result = new LinkedHashMap < Long , Float > ( ) ; for ( Iterator < Entry < Long , Float >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Long , Float > entry = it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } \n', 0.4682754856723419)

('public static < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k1 ) . compareTo ( map . get ( k2 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return new LinkedHashMap < K , V > ( sortedByValues ) ; } \n', 0.46806062228012674)

('public static HashMap sortMapByValues ( HashMap map ) { List < Map . Entry > list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new MapValueSorter ( ) ) ; HashMap sortedHashMap = new LinkedHashMap ( ) ; for ( Map . Entry e : list ) { sortedHashMap . put ( e . getKey ( ) , e . getValue ( ) ) ; } return sortedHashMap ; } \n', 0.46781194072755194)

('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46680150576087603)

('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

('static public < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public < K extends Comparable < K > , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) { return k1 . compareTo ( k2 ) ; } else { return compare ; } } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public static < K , V extends Comparable < V >> TreeMap < K , V > sortByValues ( final TreeMap < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; TreeMap < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.46532808992763286)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('public Object subtract ( Object a , Object b , Type otherType ) { if ( a == null || b == null ) { return null ; } switch ( typeCode ) { case Types . SQL_REAL : case Types . SQL_FLOAT : case Types . SQL_DOUBLE : { double ad = ( ( Number ) a ) . doubleValue ( ) ; double bd = ( ( Number ) b ) . doubleValue ( ) ; return ValuePool . getDouble ( Double . doubleToLongBits ( ad - bd ) ) ; } case Types . SQL_NUMERIC : case Types . SQL_DECIMAL : { a = convertToDefaultType ( null , a ) ; b = convertToDefaultType ( null , b ) ; BigDecimal abd = ( BigDecimal ) a ; BigDecimal bbd = ( BigDecimal ) b ; return abd . subtract ( bbd ) ; } case Types . TINYINT : case Types . SQL_SMALLINT : case Types . SQL_INTEGER : { int ai = ( ( Number ) a ) . intValue ( ) ; int bi = ( ( Number ) b ) . intValue ( ) ; return ValuePool . getInt ( ai - bi ) ; } case Types . SQL_BIGINT : { long longa = ( ( Number ) a ) . longValue ( ) ; long longb = ( ( Number ) b ) . longValue ( ) ; return ValuePool . getLong ( longa - longb ) ; } default : } throw Error . runtimeError ( ErrorCode . U_S0500 , "NumberType" ) ; } \n', 0.24253322898613777)

('@ Override public Object subtract ( Object a , Object b , Type otherType ) { if ( a == null || b == null ) { return null ; } switch ( typeCode ) { case Types . SQL_REAL : case Types . SQL_FLOAT : case Types . SQL_DOUBLE : { double ad = ( ( Number ) a ) . doubleValue ( ) ; double bd = ( ( Number ) b ) . doubleValue ( ) ; return ValuePool . getDouble ( Double . doubleToLongBits ( ad - bd ) ) ; } case Types . SQL_NUMERIC : case Types . SQL_DECIMAL : { a = convertToDefaultType ( null , a ) ; b = convertToDefaultType ( null , b ) ; BigDecimal abd = ( BigDecimal ) a ; BigDecimal bbd = ( BigDecimal ) b ; return abd . subtract ( bbd ) ; } case Types . TINYINT : case Types . SQL_SMALLINT : case Types . SQL_INTEGER : { int ai = ( ( Number ) a ) . intValue ( ) ; int bi = ( ( Number ) b ) . intValue ( ) ; return ValuePool . getInt ( ai - bi ) ; } case Types . SQL_BIGINT : { long longa = ( ( Number ) a ) . longValue ( ) ; long longb = ( ( Number ) b ) . longValue ( ) ; return ValuePool . getLong ( longa - longb ) ; } default : } throw Error . runtimeError ( ErrorCode . U_S0500 , "NumberType" ) ; } \n', 0.24253322898613777)

('public static boolean implicitConvertible ( PrimitiveCategory from , PrimitiveCategory to ) { if ( from == to ) { return true ; } PrimitiveGrouping fromPg = PrimitiveObjectInspectorUtils . getPrimitiveGrouping ( from ) ; PrimitiveGrouping toPg = PrimitiveObjectInspectorUtils . getPrimitiveGrouping ( to ) ; if ( fromPg == PrimitiveGrouping . STRING_GROUP && to == PrimitiveCategory . DOUBLE ) { return true ; } if ( fromPg == PrimitiveGrouping . STRING_GROUP && to == PrimitiveCategory . DECIMAL ) { return true ; } if ( from == PrimitiveCategory . VOID ) { return true ; } if ( fromPg == PrimitiveGrouping . DATE_GROUP && toPg == PrimitiveGrouping . STRING_GROUP ) { return true ; } if ( fromPg == PrimitiveGrouping . NUMERIC_GROUP && toPg == PrimitiveGrouping . STRING_GROUP ) { return true ; } if ( fromPg == PrimitiveGrouping . STRING_GROUP && toPg == PrimitiveGrouping . STRING_GROUP ) { return true ; } Integer f = numericTypes . get ( from ) ; Integer t = numericTypes . get ( to ) ; if ( f == null || t == null ) { return false ; } if ( f . intValue ( ) > t . intValue ( ) ) { return false ; } return true ; } \n', 0.21082898002201736)

("public long getConvertedSpace ( String spaceStr ) { try { double multiplier = 1.0 ; char c ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < spaceStr . length ( ) ; i ++ ) { c = spaceStr . charAt ( i ) ; if ( ! Character . isDigit ( c ) && c != '.' ) { if ( c == 'm' || c == 'M' ) { multiplier = 1024.0 ; } else if ( c == 'g' || c == 'G' ) { multiplier = 1024.0 * 1024.0 ; } break ; } sb . append ( spaceStr . charAt ( i ) ) ; } return ( long ) Math . ceil ( Double . valueOf ( sb . toString ( ) ) * multiplier ) ; } catch ( Exception e ) { return - 1 ; } } \n", 0.20885357042379463)

("protected long getConvertedSpace ( String spaceStr ) { try { double multiplier = 1.0 ; char c ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < spaceStr . length ( ) ; i ++ ) { c = spaceStr . charAt ( i ) ; if ( ! Character . isDigit ( c ) && c != '.' ) { if ( c == 'm' || c == 'M' ) { multiplier = 1024.0 ; } else if ( c == 'g' || c == 'G' ) { multiplier = 1024.0 * 1024.0 ; } break ; } sb . append ( spaceStr . charAt ( i ) ) ; } return ( long ) Math . ceil ( Double . valueOf ( sb . toString ( ) ) * multiplier ) ; } catch ( Exception e ) { return - 1 ; } } \n", 0.20439603473036055)

('public static boolean implicitConvertable ( TypeInfo from , TypeInfo to ) { if ( from . equals ( to ) ) { return true ; } if ( from . equals ( TypeInfoFactory . stringTypeInfo ) && to . equals ( TypeInfoFactory . doubleTypeInfo ) ) { return true ; } if ( from . equals ( TypeInfoFactory . voidTypeInfo ) ) { return true ; } Integer f = numericTypes . get ( from ) ; Integer t = numericTypes . get ( to ) ; if ( f == null || t == null ) { return false ; } if ( f . intValue ( ) > t . intValue ( ) ) { return false ; } return true ; } \n', 0.18766453854678944)

('@ Override public Object multiply ( Object a , Object b ) { if ( a == null || b == null ) { return null ; } switch ( typeCode ) { case Types . SQL_REAL : case Types . SQL_FLOAT : case Types . SQL_DOUBLE : { double ad = ( ( Number ) a ) . doubleValue ( ) ; double bd = ( ( Number ) b ) . doubleValue ( ) ; return ValuePool . getDouble ( Double . doubleToLongBits ( ad * bd ) ) ; } case Types . SQL_NUMERIC : case Types . SQL_DECIMAL : { a = convertToDefaultType ( null , a ) ; b = convertToDefaultType ( null , b ) ; BigDecimal abd = ( BigDecimal ) a ; BigDecimal bbd = ( BigDecimal ) b ; return abd . multiply ( bbd ) ; } case Types . TINYINT : case Types . SQL_SMALLINT : case Types . SQL_INTEGER : { int ai = ( ( Number ) a ) . intValue ( ) ; int bi = ( ( Number ) b ) . intValue ( ) ; return ValuePool . getInt ( ai * bi ) ; } case Types . SQL_BIGINT : { long longa = ( ( Number ) a ) . longValue ( ) ; long longb = ( ( Number ) b ) . longValue ( ) ; return ValuePool . getLong ( longa * longb ) ; } default : throw Error . runtimeError ( ErrorCode . U_S0500 , "NumberType" ) ; } } \n', 0.1777813444227742)

('private boolean computeNewMeans ( ) { boolean changed = false ; double avg_delta = 0 ; for ( int i = 0 ; i < m_numClusters ; i ++ ) { long delta = 0 ; int sampleToCopyFrom = ( int ) Math . floor ( Math . random ( ) * m_initSamples . length ) ; if ( m_tmpClusterCount [ i ] == 0 ) { System . out . println ( "-Warning:-zero-sized-cluster" ) ; } for ( int j = 0 ; j < m_dimensions ; j ++ ) { int newValue = 0 ; if ( m_tmpClusterCount [ i ] != 0 ) { newValue = ( int ) Math . round ( ( float ) m_tmpClusterAccum [ i ] [ j ] / m_tmpClusterCount [ i ] ) ; } else { try { newValue = m_initSamples [ sampleToCopyFrom ] [ j ] ; } catch ( NullPointerException npe ) { int count = 0 ; do { sampleToCopyFrom = ( int ) Math . floor ( Math . random ( ) * m_initSamples . length ) ; count ++ ; if ( count == 50 ) { throw new RuntimeException ( ) ; } } while ( m_initSamples [ sampleToCopyFrom ] == null ) ; } } if ( ! changed ) { if ( newValue != m_clusters [ i ] [ j ] ) { changed = true ; } } delta += sqrLookup [ Math . abs ( newValue - m_clusters [ i ] [ j ] ) ] ; m_clusters [ i ] [ j ] = newValue ; } avg_delta += ( delta / m_dimensions ) ; } avg_delta /= m_numClusters ; return changed ; } \n', 0.1764128031220739)

("public static Float convertImpliedDecimalFormat ( String format , String toConvert ) { long decimalPlace = 1 ; int indexOf = format . indexOf ( 'V' ) ; if ( indexOf > - 1 ) { boolean isV = false ; for ( int i = 0 ; i < format . length ( ) ; i ++ ) { char charAt = format . charAt ( i ) ; if ( charAt == '9' && isV ) { decimalPlace = 10 * decimalPlace ; } else if ( charAt == 'V' ) { isV = true ; } } } BigDecimal decimal = new BigDecimal ( toConvert ) ; decimal = decimal . divide ( new BigDecimal ( decimalPlace ) ) ; return new Float ( decimal . doubleValue ( ) ) ; } \n", 0.17560444465998992)

('public static byte [ ] floatingStringToByteArray ( FPDataType dt , String valueString , int dataTypeBitCount ) throws NumberFormatException { valueString = valueString . trim ( ) . replaceAll ( "-" , "" ) ; if ( valueString . length ( ) != 0 ) { if ( dt == FPDataType . FLOAT || FPDataType . FLOAT . getBitsize ( ) == dataTypeBitCount ) { float floatValue = new Float ( valueString ) . floatValue ( ) ; floatValue = floatLimitCheck ( floatValue ) ; return rawFloatBitsToByteArray ( Float . floatToRawIntBits ( floatValue ) ) ; } if ( dt == FPDataType . DOUBLE || FPDataType . DOUBLE . getBitsize ( ) == dataTypeBitCount ) { double doubleValue = new Double ( valueString ) . doubleValue ( ) ; doubleValue = doubleLimitCheck ( doubleValue ) ; return rawDoubleBitsToByteArray ( Double . doubleToRawLongBits ( doubleValue ) ) ; } } return new byte [ 0 ] ; } \n', 0.1752755477830258)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
('public byte [ ] concatenateTwoByteArrays ( byte [ ] a , byte [ ] b ) { byte [ ] c = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } \n', 0.34917792092265965)

('private static < T > void concatenateArrays ( Iterable < T [ ] > arraysToConcatenate , T [ ] destination ) { int nextStartIndexToUse = 0 ; for ( T [ ] array : arraysToConcatenate ) { System . arraycopy ( array , 0 , destination , nextStartIndexToUse , array . length ) ; nextStartIndexToUse += array . length ; } } \n', 0.31076428099890496)

('public static java . lang . Object concatenateArrays ( Class < ? > resultClass , java . lang . Object arr1 , java . lang . Object arr2 ) throws ArrayStoreException { if ( arr1 == null ) { return arr2 ; } else if ( arr2 == null ) { return arr1 ; } java . lang . Object newArray = Array . newInstance ( resultClass , Array . getLength ( arr1 ) + Array . getLength ( arr2 ) ) ; System . arraycopy ( arr1 , 0 , newArray , 0 , Array . getLength ( arr1 ) ) ; System . arraycopy ( arr2 , 0 , newArray , Array . getLength ( arr1 ) , Array . getLength ( arr2 ) ) ; return newArray ; } \n', 0.30608763426169416)

('public static Object [ ] concatenateArray ( Object [ ] srcOne , Object [ ] srcTwo ) { Object [ ] result = new Object [ srcOne . length + srcTwo . length ] ; System . arraycopy ( srcOne , 0 , result , 0 , srcOne . length ) ; System . arraycopy ( srcTwo , 0 , result , srcOne . length , srcTwo . length ) ; return result ; } \n', 0.2870876651143617)

('@ SuppressWarnings ( "unchecked" ) public < T > List < T > concatenateIntoList ( List < T > list , Object ... values ) throws ClientException { if ( list == null ) { throw new ClientException ( "First-parameter-must-not-be-null" ) ; } for ( Object value : values ) { if ( value == null ) { continue ; } if ( value instanceof Object [ ] ) { for ( Object subValue : ( Object [ ] ) value ) { if ( subValue != null ) { list . add ( ( T ) subValue ) ; } } continue ; } if ( value instanceof Collection ) { for ( Object subValue : ( Collection < Object > ) value ) { if ( subValue != null ) { list . add ( ( T ) subValue ) ; } } continue ; } list . add ( ( T ) value ) ; } return list ; } \n', 0.27467004508092807)

('byte [ ] concatenateByteArrays ( byte [ ] ... byteArrays ) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; for ( byte [ ] array : byteArrays ) { outputStream . write ( array ) ; } return outputStream . toByteArray ( ) ; } \n', 0.2741833885580569)

('public static boolean seeIfTwoIntArrayCanConstructSameTree ( Integer [ ] one , Integer [ ] two ) { ArrayList < Integer > arrOne = new ArrayList < Integer > ( Arrays . asList ( one ) ) ; ArrayList < Integer > arrTwo = new ArrayList < Integer > ( Arrays . asList ( two ) ) ; return seeIfTwoIntArrayCanConstructSameTree ( arrOne , arrTwo ) ; } \n', 0.27017652024332106)

('public static byte [ ] concatenateByteArray ( byte [ ] first , byte [ ] second ) throws IOException { ByteArrayOutputStream contentStream = new ByteArrayOutputStream ( ) ; contentStream . write ( first ) ; contentStream . write ( second ) ; return contentStream . toByteArray ( ) ; } \n', 0.26415995723180247)

('private String [ ] [ ] copyDataFromListToTwoDimensionArray ( List < String [ ] > v ) throws OdaException { String [ ] [ ] rowSet = new String [ v . size ( ) ] [ this . rsmd . getColumnCount ( ) ] ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { String [ ] temp = ( String [ ] ) v . get ( i ) ; for ( int j = 0 ; j < temp . length ; j ++ ) { if ( temp [ j ] != null ) rowSet [ i ] [ j ] = temp [ j ] . trim ( ) ; else if ( conn . trailNullColumns ( ) ) { continue ; } else { throw new OdaException ( Messages . getString ( "data_read_error" ) ) ; } } } return rowSet ; } \n', 0.260365453567001)

('public static Geometry ceateGeometryCollection ( List < Geometry > geoms , Class < Geometry > schemaDeclaredType ) { if ( geoms . isEmpty ( ) ) { return null ; } if ( schemaDeclaredType . isAssignableFrom ( geoms . get ( 0 ) . getClass ( ) ) && geoms . size ( ) == 1 ) return geoms . get ( 0 ) ; if ( ! GeometryCollection . class . isAssignableFrom ( schemaDeclaredType ) && ! schemaDeclaredType . isAssignableFrom ( GeometryCollection . class ) ) return geoms . get ( 0 ) ; Geometry geom ; GeometryFactory factory = new GeometryFactory ( ) ; Class < ? extends Geometry > geomType = geoms . get ( 0 ) . getClass ( ) ; if ( geomType == Polygon . class ) { geom = factory . createMultiPolygon ( geoms . toArray ( new Polygon [ geoms . size ( ) ] ) ) ; } else if ( geomType == LinearRing . class ) { geom = factory . createMultiLineString ( geoms . toArray ( new LineString [ geoms . size ( ) ] ) ) ; } else if ( geomType == LineString . class ) { geom = factory . createMultiLineString ( geoms . toArray ( new LineString [ geoms . size ( ) ] ) ) ; } else { geom = factory . createMultiPoint ( geoms . toArray ( new Point [ geoms . size ( ) ] ) ) ; } return geom ; } \n', 0.24921913157615816)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public static String convertFileToString ( final File file ) throws IOException { FileInputStream fileInputStream = new FileInputStream ( file ) ; byte [ ] b = new byte [ fileInputStream . available ( ) ] ; fileInputStream . read ( b ) ; fileInputStream . close ( ) ; String content = new String ( b ) ; return content ; } \n', 0.3091320054253176)

('public static String getClassNameFromSourceFile ( File javaSourceFile , String sourceDirPath ) { String javaSourceFilePath = "" ; try { javaSourceFilePath = javaSourceFile . getCanonicalPath ( ) ; } catch ( IOException ex ) { log . error ( "Error-in-getClassNameFromSourceFile():-" + ex . getMessage ( ) ) ; } String relativeJavaFileName = getRelativeFileName ( javaSourceFilePath , sourceDirPath ) ; String classFileName = convertExtensionFromJavaToClass ( relativeJavaFileName ) ; if ( classFileName . indexOf ( ".class" ) != - 1 ) { classFileName = classFileName . substring ( 0 , classFileName . indexOf ( ".class" ) ) ; } String fullClassName = classFileName ; if ( classFileName . indexOf ( File . separatorChar ) != - 1 ) { fullClassName = classFileName . replace ( File . separatorChar , \'.\' ) ; } return fullClassName ; } \n', 0.30240824154476886)

('protected static Object getConverterForFile ( String filename , Hashtable < String , String > ht ) { Object result ; String extension ; int index ; result = null ; index = filename . lastIndexOf ( \'.\' ) ; if ( index > - 1 ) { extension = filename . substring ( index ) . toLowerCase ( ) ; result = getConverterForExtension ( extension , ht ) ; if ( extension . equals ( ".gz" ) && result == null ) { index = filename . lastIndexOf ( \'.\' , index - 1 ) ; extension = filename . substring ( index ) . toLowerCase ( ) ; result = getConverterForExtension ( extension , ht ) ; } } return result ; } \n', 0.2978798706933324)

('public String convertFileUTF8ToAsici ( String filePath ) throws Exception { FileInputStream fis = new FileInputStream ( filePath ) ; byte [ ] utf8Contents = new byte [ fis . available ( ) ] ; fis . read ( utf8Contents ) ; fis . close ( ) ; String utf8String = new String ( utf8Contents , "UTF8" ) ; return convertStringToAscii ( utf8String ) ; } \n', 0.2948241308291084)

('private String convertFileField ( String fileFieldContent ) throws ArrayIndexOutOfBoundsException { StringBuffer sb = new StringBuffer ( ) ; String [ ] fileContents = SEMICOLON_PATTERN . split ( fileFieldContent ) ; for ( int i = 0 ; i < fileContents . length ; i ++ ) { if ( sb . length ( ) > 0 ) { sb . append ( ";" ) ; } try { sb . append ( convertSingleFileContent ( fileContents [ i ] ) ) ; } catch ( IOException e ) { fileContents [ i + 1 ] = fileContents [ i ] + "|;" + fileContents [ i + 1 ] ; } } return sb . toString ( ) ; } \n', 0.2918485272335526)

('public static String convertFileToString ( java . io . File file ) throws IOException { Scanner s = new Scanner ( file , "UTF-8" ) . useDelimiter ( "|A" ) ; String result = s . hasNext ( ) ? s . next ( ) : "" ; s . close ( ) ; return result ; } \n', 0.2903517458344454)

('protected Resource convertResource ( Resource origResource , String resourceFileName ) throws IOException { byte [ ] bytes = FileCopyUtils . copyToByteArray ( origResource . getInputStream ( ) ) ; String content = new String ( bytes , DEFAULT_CHARSET ) ; String newContent = content ; if ( ! StringUtils . isEmpty ( content ) ) { String regexKey = "|"BLC_PROP:(.*)|"" ; Pattern p = Pattern . compile ( regexKey ) ; Matcher m = p . matcher ( content ) ; while ( m . find ( ) ) { String matchedPlaceholder = m . group ( 0 ) ; String propertyName = m . group ( 1 ) ; String propVal = BLCSystemProperty . resolveSystemProperty ( propertyName ) ; if ( ! StringUtils . isEmpty ( propVal ) ) { propVal = "" ; } newContent = newContent . replaceAll ( matchedPlaceholder , \'"\' + propVal + \'"\' ) ; } } return new GeneratedResource ( newContent . getBytes ( ) , resourceFileName ) ; } \n', 0.28778297973702627)

('public static void convertFileFromUtf16ToUtf8 ( File inputFile , File outputFile ) throws IOException { String charset ; if ( inputFile == null || ! inputFile . canRead ( ) ) { throw new FileNotFoundException ( "Can\'t-read-inputFile." ) ; } try { charset = getFileCharset ( inputFile ) ; } catch ( IOException ex ) { LOGGER . debug ( "Exception-during-charset-detection." , ex ) ; throw new IllegalArgumentException ( "Can\'t-confirm-inputFile-is-UTF-16." ) ; } if ( isCharsetUTF16 ( charset ) ) { if ( ! outputFile . exists ( ) ) { BufferedReader reader = null ; try { if ( equalsIgnoreCase ( charset , CHARSET_UTF_16LE ) ) { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16" ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16BE" ) ) ; } } catch ( UnsupportedEncodingException ex ) { LOGGER . warn ( "Unsupported-exception." , ex ) ; throw ex ; } BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outputFile ) , "UTF-8" ) ) ; int c ; while ( ( c = reader . read ( ) ) != - 1 ) { writer . write ( c ) ; } writer . close ( ) ; reader . close ( ) ; } } else { throw new IllegalArgumentException ( "File-is-not-UTF-16" ) ; } } \n', 0.28106171250211254)

('public String convertStreamToString ( FileInputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.2804427936710572)

('public static String convertStreamToString ( String name ) throws IOException { if ( name != null ) { Writer writer = new StringWriter ( ) ; InputStream is = FileMgmt . class . getResourceAsStream ( name ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "US-ASCII" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } catch ( IOException e ) { System . out . println ( "Exception-" ) ; } finally { try { is . close ( ) ; } catch ( NullPointerException e ) { throw new IOException ( ) ; } } return writer . toString ( ) ; } else { return "" ; } } \n', 0.27419858188928803)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

('private void convertThrowable ( final StringBuilder builder , final Throwable throwable ) { builder . append ( throwable . toString ( ) ) . append ( \'|n\' ) ; for ( final StackTraceElement element : throwable . getStackTrace ( ) ) { builder . append ( "-at-" ) . append ( element ) . append ( \'|n\' ) ; } if ( throwable . getCause ( ) != null ) { builder . append ( "Caused-by-" ) ; this . convertThrowable ( builder , throwable . getCause ( ) ) ; } } \n', 0.36166036937533935)

('public static String convertException ( String classname , Throwable e , int index ) { Throwable prev = null ; StringBuffer message = new StringBuffer ( ) ; int i = index ; for ( Throwable cause = e ; cause != null ; cause = cause . getCause ( ) ) { message . append ( "-[" ) . append ( Integer . toString ( ++ i ) ) . append ( "]:-" ) ; if ( cause instanceof FactoryException ) { message . append ( cause . getMessage ( ) ) ; classname = ( ( FactoryException ) cause ) . getClassname ( ) ; } else if ( prev != null && prev instanceof FactoryException ) { message . append ( DynamicLoader . convertExceptionToString ( classname , cause ) ) ; } else { message . append ( cause . getMessage ( ) ) ; } message . append ( "-at-" ) . append ( cause . getStackTrace ( ) [ 0 ] ) ; prev = cause ; } return message . toString ( ) ; } \n', 0.33468840200447597)

('public String convertIfcStackTerminalTypeEnumToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.3320784055962478)

('public String convertLogTypeMember1ToString ( EDataType eDataType , Object instanceValue ) { if ( instanceValue == null ) return null ; List < ? > list = ( List < ? > ) instanceValue ; if ( list . isEmpty ( ) ) return "" ; StringBuffer result = new StringBuffer ( ) ; for ( Object item : list ) { result . append ( convertLogTypeMember1ItemToString ( EsmConfigPackage . Literals . LOG_TYPE_MEMBER1_ITEM , item ) ) ; result . append ( \'-\' ) ; } return result . substring ( 0 , result . length ( ) - 1 ) ; } \n', 0.3141737480690574)

('private Throwable convertString ( final ListIterator < String > lines , final boolean removeCausedBy ) { String firstLine = lines . next ( ) ; if ( removeCausedBy ) { firstLine = firstLine . substring ( CAUSED_BY_STRING_LENGTH ) ; } final int colon = firstLine . indexOf ( ":" ) ; String throwableClassName ; String message = null ; if ( colon > 1 ) { throwableClassName = firstLine . substring ( 0 , colon ) ; if ( firstLine . length ( ) > colon + 1 ) { message = firstLine . substring ( colon + 1 ) . trim ( ) ; } } else { throwableClassName = firstLine ; } final List < StackTraceElement > stackTrace = new ArrayList < > ( ) ; Throwable cause = null ; while ( lines . hasNext ( ) ) { final String line = lines . next ( ) ; if ( line . startsWith ( "Caused-by-" ) ) { lines . previous ( ) ; cause = convertString ( lines , true ) ; break ; } stackTrace . add ( StackTraceElementAttributeConverter . convertString ( line . trim ( ) . substring ( 3 ) . trim ( ) ) ) ; } return this . getThrowable ( throwableClassName , message , cause , stackTrace . toArray ( new StackTraceElement [ stackTrace . size ( ) ] ) ) ; } \n', 0.27253727520160875)

('public void convertAnother ( Object o ) throws ConverterException { o = config . getProxyHandler ( ) . unwrapIfProxy ( o ) ; try { if ( o == null ) { } else if ( o instanceof CharSequence ) { writer . characters ( o . toString ( ) ) ; } else if ( o instanceof Class < ? > ) { writer . characters ( ( ( Class < ? > ) o ) . getName ( ) ) ; } else if ( ( o . getClass ( ) . isPrimitive ( ) && ! o . getClass ( ) . equals ( byte [ ] . class ) ) || o instanceof Number || o instanceof Boolean ) { writer . characters ( String . valueOf ( o ) ) ; } else { if ( referenceStack . contains ( o ) ) { handleCircularRelationship ( o ) ; } else { referenceStack . push ( o ) ; ObjectMarshaller < XML > marshaller = config . getMarshaller ( o ) ; if ( marshaller == null ) { throw new ConverterException ( "Unconvertable-Object-of-class:-" + o . getClass ( ) . getName ( ) ) ; } marshaller . marshalObject ( o , this ) ; referenceStack . pop ( ) ; } } } catch ( Throwable t ) { throw ConverterUtil . resolveConverterException ( t ) ; } } \n', 0.2683987500371555)

('@ Override public Object convertToArg ( Schema schema , int line , String elem , String attr , String value ) throws UnableToCompleteException { if ( value . length ( ) == 0 ) { return null ; } try { ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; return cl . loadClass ( value ) ; } catch ( ClassNotFoundException e ) { Messages . UNABLE_TO_LOAD_CLASS . log ( logger , value , e ) ; throw new UnableToCompleteException ( ) ; } } \n', 0.24409195887770263)

('@ SuppressWarnings ( "unchecked" ) public String convertToString ( Object value ) throws ClassCastException { Class < ? > clazz = value . getClass ( ) ; return convertToString ( value , ( Class < ? super Object > ) clazz ) ; } \n', 0.2410419925280331)

('public static String convertToString ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value . getClass ( ) . isPrimitive ( ) || value instanceof Integer || value instanceof Long ) { return value . toString ( ) ; } else if ( value instanceof Enum ) { return convertEnumToString ( ( Enum ) value ) ; } else if ( value instanceof DateTime ) { return convertDateTimeToString ( ( DateTime ) value ) ; } else if ( value instanceof Period ) { return convertPeriodToString ( ( Period ) value ) ; } else if ( value instanceof Interval ) { return convertIntervalToString ( ( Interval ) value ) ; } else { throw new TodoImplementException ( value . getClass ( ) ) ; } } \n', 0.24074016201049803)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public static boolean objectsAreEqual ( Object expected , Object actual ) { boolean nullA = expected == null ; boolean nullB = actual == null ; if ( nullA && nullB ) return true ; if ( nullA ^ nullB ) return false ; Class < ? > expectedType = expected . getClass ( ) ; Class < ? > actualType = actual . getClass ( ) ; if ( ! actualType . isAssignableFrom ( expectedType ) && expectedType == String . class ) { Converter converter = ConvertUtils . lookup ( actualType ) ; if ( converter != null ) { Object converted = converter . convert ( actualType , expected ) ; if ( converted != null ) expected = converted ; } } return ( expected == null && actual == null ) || ( expected != null && expected . equals ( actual ) ) ; } \n', 0.30124114969928084)

('@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static int typeCoerceCompare ( TypeConverter converter , Object leftValue , Object rightValue ) { Long leftNum = converter . tryConvertTo ( Long . class , leftValue ) ; Long rightNum = converter . tryConvertTo ( Long . class , rightValue ) ; if ( leftNum != null && rightNum != null ) { return leftNum . compareTo ( rightNum ) ; } Double leftDouble = converter . tryConvertTo ( Double . class , leftValue ) ; Double rightDouble = converter . tryConvertTo ( Double . class , rightValue ) ; if ( leftDouble != null && rightDouble != null ) { return leftDouble . compareTo ( rightDouble ) ; } if ( rightValue instanceof String && ( ! ( leftValue instanceof String ) ) ) { return typeCoerceCompare ( converter , rightValue , leftValue ) * - 1 ; } if ( rightValue instanceof Comparable ) { Object value = converter . tryConvertTo ( rightValue . getClass ( ) , leftValue ) ; if ( value != null ) { return ( ( Comparable ) rightValue ) . compareTo ( value ) * - 1 ; } } if ( leftValue instanceof Comparable ) { Object value = converter . tryConvertTo ( leftValue . getClass ( ) , rightValue ) ; if ( value != null ) { return ( ( Comparable ) leftValue ) . compareTo ( value ) ; } } return compare ( leftValue , rightValue ) ; } \n', 0.266792803044012)

("public void testConvertsToCharacter ( ) throws Exception { Character value = new Character ( 'X' ) ; Character result = ( Character ) converter . convert ( Character . toString ( value . charValue ( ) ) ) ; assertEquals ( value , result ) ; } \n", 0.26112051952134196)

("public void testConvertsToCharacterPrimitive ( ) throws Exception { Character value = new Character ( 'Y' ) ; Character result = ( Character ) primitiveConverter . convert ( String . valueOf ( value . charValue ( ) ) ) ; assertEquals ( value , result ) ; } \n", 0.25019821652026697)

('@ Override public boolean doCompare ( Object lValue , Object rValue , Class < ? > type , Locale locale , TimeZone timeZone , String format ) throws Exception { Object convertedLvalue = MiniLangUtil . convertType ( lValue , type , locale , timeZone , format ) ; Object convertedRvalue = MiniLangUtil . convertType ( rValue , type , locale , timeZone , format ) ; if ( convertedLvalue == null ) { return convertedRvalue != null ; } if ( convertedRvalue == null ) { return true ; } if ( convertedLvalue instanceof BigDecimal && convertedRvalue instanceof BigDecimal ) { BigDecimal lBigDecimal = ( BigDecimal ) convertedLvalue ; BigDecimal rBigDecimal = ( BigDecimal ) convertedRvalue ; return compareBigDecimals ( lBigDecimal , rBigDecimal ) != 0 ; } if ( convertedLvalue instanceof Comparable && convertedRvalue instanceof Comparable ) { Comparable < Object > comparable = UtilGenerics . cast ( convertedLvalue ) ; return comparable . compareTo ( convertedRvalue ) != 0 ; } return ! convertedLvalue . equals ( convertedRvalue ) ; } \n', 0.24848070007099746)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.22518081116080835)

('@ SuppressWarnings ( "unchecked" ) public static < S > void assertToCollection ( String label , S source ) throws Exception { Converter < S , ? extends Collection > toList = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , List . class ) ; Collection < S > listResult = toList . convert ( source ) ; assertEquals ( label + "-converted-to-List" , source , listResult . toArray ( ) [ 0 ] ) ; Converter < S , ? extends Collection > toSet = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , Set . class ) ; Collection < S > setResult = toSet . convert ( source ) ; assertEquals ( label + "-converted-to-Set" , source , setResult . toArray ( ) [ 0 ] ) ; } \n', 0.21955993155415693)

('public void testUpperCaseStringConvertsToTrue ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) trueValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertTrue ( result . booleanValue ( ) ) ; } \n', 0.21326202436121683)

('public void testUpperCaseStringConvertsToFalse ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) falseValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertFalse ( result . booleanValue ( ) ) ; } \n', 0.21129496578034498)

('public void testConvertMessageToFault ( ) throws Exception { LogicalMessageContext lmc = createSampleContext ( ) ; LogicalMessage msg = lmc . getMessage ( ) ; assertTrue ( "The-returned-LogicalMessage-was-null" , msg != null ) ; Source payload = msg . getPayload ( ) ; assertTrue ( "The-returned-payload-(Source)-was-null" , payload != null ) ; String resultContent = _getStringFromSource ( payload ) ; assertTrue ( "The-content-returned-was-null" , resultContent != null ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( sampleSOAP11FaultPayload . getBytes ( ) ) ; StreamSource faultSource = new StreamSource ( bais ) ; msg . setPayload ( faultSource ) ; Source newFaultSource = msg . getPayload ( ) ; assertTrue ( "The-new-fault-content-returned-was-null" , faultSource != null ) ; String newFaultContent = _getStringFromSource ( newFaultSource ) ; assertTrue ( "The-new-fault-content-returned-was-invalid" , newFaultContent . equals ( sampleSOAP11FaultPayload ) ) ; } \n', 0.1947456867518875)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.3421195191429003)

('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.2829333480446985)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.2728460162860971)

('private < E extends Enum < E >> E convertLiteralToEnum ( final Class < E > type , String literalValue ) { E [ ] constants = type . getEnumConstants ( ) ; for ( E inst : constants ) { String [ ] tokens = literalValue . split ( "|." ) ; if ( tokens . length > 1 ) { literalValue = tokens [ tokens . length - 1 ] ; } if ( inst . name ( ) . equals ( literalValue ) ) { return inst ; } } return null ; } \n', 0.2571408680495527)

('public static String convertDecimalNumbersToString ( String decimalString ) throws NumberFormatException { StringBuilder builder = new StringBuilder ( "" ) ; List < Integer > list = new ArrayList < Integer > ( ) ; String string = decimalString . substring ( 1 ) ; for ( String s : string . split ( ",-" ) ) { list . add ( Integer . parseInt ( s ) ) ; } for ( Integer i : list ) { String aChar = Character . valueOf ( ( char ) ( int ) i ) . toString ( ) ; aChar = aChar . trim ( ) ; builder . append ( aChar ) ; } return builder . toString ( ) ; } \n', 0.25009190760180433)

('public static < E extends Enum < E >> List < E > convertToEnum ( String str , Class < E > clazz ) { if ( str == null || str . length ( ) == 0 ) return Collections . emptyList ( ) ; String [ ] metrics = str . split ( "," ) ; List < String > names = Arrays . asList ( metrics ) ; return convertToEnumFromCamelCase ( names , clazz ) ; } \n', 0.24823986592741196)

('private static String convertToCamelCaseNameString ( String nameString ) { String [ ] tokens = nameString . split ( "-" ) ; String result = "" ; for ( String token : tokens ) { if ( result . length ( ) > MAX_LENGTH ) { break ; } result += convertTokenToCamelCase ( token ) ; } return result ; } \n', 0.2460709720338464)

('public static String convertLowerCaseStringToTitleCase ( String value ) { String convertedValue = "" ; boolean loopedOnce = false ; for ( String word : value . split ( "-" ) ) { if ( loopedOnce ) { switch ( word ) { case "a" : case "an" : case "and" : case "in" : case "it" : case "for" : case "of" : case "on" : case "the" : case "to" : case "vs" : convertedValue += \'-\' + word ; break ; default : convertedValue += \'-\' + word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } } else { convertedValue += word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } loopedOnce = true ; } return convertedValue ; } \n', 0.24513751722186938)

('private static byte [ ] convertIPv4StringToByteArray ( String ipstr ) throws Exception { String [ ] parts = ipstr . split ( "|." ) ; if ( parts . length != 4 ) { throw new Exception ( "Invalid-IPv4-address" ) ; } byte [ ] bytes = new byte [ 4 ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { bytes [ i ] = ( byte ) Integer . parseInt ( parts [ i ] ) ; } return bytes ; } \n', 0.24156200368247804)

('@ ValueConverter ( rule = "TextStringValue" ) public IValueConverter < String > TextStringValue ( ) { return new AbstractNullSafeConverter < String > ( ) { @ Override protected String internalToString ( String value ) { String converted = Strings . convertToJavaString ( value , true ) ; converted = converted . substring ( 1 , converted . length ( ) - 2 ) ; converted . replace ( "Â»" , "|Â»" ) ; return "Â«" + converted + "Â»" ; } @ Override protected String internalToValue ( String string , AbstractNode node ) { if ( string . startsWith ( "Â«" ) ) string = string . substring ( 1 ) ; if ( string . endsWith ( "Â»" ) ) string = string . substring ( 0 , string . length ( ) - 1 ) ; String lines [ ] = string . split ( "[-]" ) ; StringBuffer buf = new StringBuffer ( ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { if ( i != 0 ) buf . append ( "-" ) ; buf . append ( lines [ i ] . trim ( ) ) ; } return Strings . convertFromJavaString ( buf . toString ( ) , true ) ; } } ; } \n', 0.2413955326605991)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public static void createDXT3 ( BufferedImage image , File dds ) throws IOException { ByteBuffer buffer = DDSConverter . convertToDxt3 ( image ) ; OutputStream outputStream = new FileOutputStream ( dds ) ; outputStream . write ( buffer . array ( ) ) ; outputStream . close ( ) ; } \n', 0.30863584655694076)

('public static List < OutputStream > convertFilesToStreams ( File [ ] localPaths , Storage dstStorage , String str ) throws IOException { List < OutputStream > outputStreams = new ArrayList < OutputStream > ( ) ; if ( localPaths != null ) { for ( File f : localPaths ) { try { if ( f . exists ( ) ) { LOG . warn ( "Overwriting-existing-file-" + f + "-with-file-downloaded-form-" + str ) ; } outputStreams . add ( new FileOutputStream ( f ) ) ; } catch ( IOException ioe ) { LOG . warn ( "Unable-to-download-file-" + f , ioe ) ; if ( dstStorage != null && ( dstStorage instanceof StorageErrorReporter ) ) { ( ( StorageErrorReporter ) dstStorage ) . reportErrorOnFile ( f ) ; } } } if ( outputStreams . isEmpty ( ) ) { throw new IOException ( "Unable-to-download-to-any-storage-directory" ) ; } } return outputStreams ; } \n', 0.2463156741812489)

('protected ByteArrayOutputStream convertFileListToBytes ( ArrayList < String > fileList ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; if ( fileList . isEmpty ( ) ) { bos . write ( UNICODE_NULL_TERMINATOR ) ; } else { for ( int i = 0 ; i < fileList . size ( ) ; i ++ ) { byte [ ] bytes = fileList . get ( i ) . getBytes ( getDefaultUnicodeEncoding ( ) ) ; bos . write ( bytes , 0 , bytes . length ) ; bos . write ( UNICODE_NULL_TERMINATOR ) ; } } bos . write ( UNICODE_NULL_TERMINATOR ) ; return bos ; } \n', 0.23783357720857093)

('public static File convertMultipartToFile ( MultipartFile file ) throws IOException { File convFile = new File ( file . getOriginalFilename ( ) ) ; convFile . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( convFile ) ; fos . write ( file . getBytes ( ) ) ; fos . close ( ) ; return convFile ; } \n', 0.23506183471293954)

('public static File convertBytesToFile ( final String bArray , final String extension ) throws IOException { File f = File . createTempFile ( "temp" , "." + extension ) ; byte [ ] bytes = bArray . getBytes ( ) ; FileOutputStream fos = new FileOutputStream ( f ) ; fos . write ( bytes ) ; fos . close ( ) ; return f ; } \n', 0.2309322764677173)

('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.22970362534135058)

('public void convertToScatteringStore ( File f ) throws IOException { int BUFFER_SIZE = 65536 ; RandomAccessFile src = new RandomAccessFile ( f , "rw" ) ; long file_size = f . length ( ) ; long current_p = max_slice_size ; long to_write = Math . min ( file_size - current_p , max_slice_size ) ; int write_to_part = 1 ; byte [ ] copy_buffer = new byte [ BUFFER_SIZE ] ; while ( to_write > 0 ) { src . seek ( current_p ) ; File to_f = slicePartFile ( write_to_part ) ; if ( to_f . exists ( ) ) { throw new IOException ( "Copy-error,-slice-already-exists." ) ; } FileOutputStream to_raf = new FileOutputStream ( to_f ) ; while ( to_write > 0 ) { int size_to_copy = ( int ) Math . min ( BUFFER_SIZE , to_write ) ; src . readFully ( copy_buffer , 0 , size_to_copy ) ; to_raf . write ( copy_buffer , 0 , size_to_copy ) ; current_p += size_to_copy ; to_write -= size_to_copy ; } to_raf . flush ( ) ; to_raf . close ( ) ; to_write = Math . min ( file_size - current_p , max_slice_size ) ; ++ write_to_part ; } if ( file_size > max_slice_size ) { src . seek ( 0 ) ; src . setLength ( max_slice_size ) ; } src . close ( ) ; } \n', 0.2280760612935975)

('protected ByteArrayOutputStream convertFileListToBytes ( ArrayList < String > fileList ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < fileList . size ( ) ; i ++ ) { byte [ ] bytes = fileList . get ( i ) . getBytes ( ) ; if ( i != 0 ) bos . write ( 0 ) ; bos . write ( bytes , 0 , bytes . length ) ; } return bos ; } \n', 0.22472411168957185)

('@ Override protected ByteArrayOutputStream convertFileListToBytes ( ArrayList < String > fileList ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; for ( int i = 0 ; i < fileList . size ( ) ; i ++ ) { byte [ ] bytes = fileList . get ( i ) . getBytes ( ) ; bos . write ( bytes , 0 , bytes . length ) ; bos . write ( 0 ) ; } return bos ; } \n', 0.22472411168957185)

('private String convertStreamToFile ( InputStream inputStream ) throws IOException { Random rand = new Random ( ) ; File temp = File . createTempFile ( "kevoreeloaderLib" + rand . nextInt ( ) , ".xmi" ) ; temp . deleteOnExit ( ) ; OutputStream out = new FileOutputStream ( temp ) ; int read = 0 ; byte [ ] bytes = new byte [ 1024 ] ; while ( ( read = inputStream . read ( bytes ) ) != - 1 ) { out . write ( bytes , 0 , read ) ; } inputStream . close ( ) ; out . flush ( ) ; out . close ( ) ; return temp . getAbsolutePath ( ) ; } \n', 0.2239328367713997)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

('protected void initialise ( Connection connection ) { if ( ! initialised ) { synchronized ( this ) { if ( ! initialised ) { Set accessorsToRemove = new HashSet ( ) ; Iterator i = accessorMutatorMap . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Method accessor = ( Method ) i . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; Object value = null ; try { value = accessor . invoke ( connection , null ) ; if ( value != null ) { defaultValues . put ( mutator , value ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Remembering-default-value:-" + accessor . getName ( ) + "()-=-" + value ) ; } } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + accessor . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } try { Object [ ] args = { value } ; mutator . invoke ( connection , args ) ; } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + mutator . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } } Iterator j = accessorsToRemove . iterator ( ) ; while ( j . hasNext ( ) ) { Method accessor = ( Method ) j . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; accessorMutatorMap . remove ( accessor ) ; defaultValues . remove ( mutator ) ; } initialised = true ; } } } } \n', 0.3899768502441775)

('public static Context initialise ( final Map environment ) throws NamingException { Context context ; if ( environment != null && environment . size ( ) > 0 ) { context = new InitialContext ( new Hashtable ( environment ) ) ; } else { context = new InitialContext ( ) ; } return context ; } \n', 0.38813912680444246)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.3795221908993608)

('private static void initialise ( ) { exitCodes = new HashSet < ExitCode > ( ) ; Map < String , String > resources = Resources . get ( ExitStatus . class ) ; for ( String key : resources . keySet ( ) ) { String mnemonic = key . substring ( 0 , key . indexOf ( ( int ) FULL_STOP ) ) ; String numericForm = key . substring ( key . indexOf ( ( int ) FULL_STOP ) + 1 ) ; String description = resources . get ( key ) ; int number = Integer . parseInt ( numericForm ) ; exitCodes . add ( new ExitCode ( number , mnemonic , description ) ) ; } } \n', 0.3787476293033488)

('protected void initialiseCommonFeatures ( Map < Integer , FeatureData > initialMap ) { super . initialiseFeatureMap ( initialMap ) ; commonFeaturesMap . putAll ( initialMap ) ; } \n', 0.3759403677907467)

('@ Override protected void doInitialise ( ) throws InitialisationException { authentications = new ConcurrentHashMap < String , Authentication > ( ) ; } \n', 0.37380482700435735)

('private void initialiseMetricMap ( ) { metricMap = new HashMap < EMethodMetricName , Integer > ( 50 ) ; EMethodMetricName [ ] metrics = EMethodMetricName . values ( ) ; for ( EMethodMetricName metric : metrics ) metricMap . put ( metric , 0 ) ; } \n', 0.3681996314523418)

('protected void initialiseFeatureMap ( Map < Integer , FeatureData > initialMap ) { featureMap . putAll ( initialMap ) ; } \n', 0.3664933131352133)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.36489232472833166)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('private List < Exit > removeLoopExits ( Exit . Reason reason , String label ) { List < Exit > result = new ArrayList < Exit > ( ) ; for ( Iterator < Exit > i = currentExits . iterator ( ) ; i . hasNext ( ) ; ) { Exit exit = i . next ( ) ; if ( exit . reason == reason && ( exit . getLabel ( ) == null || exit . getLabel ( ) . equals ( label ) ) ) { i . remove ( ) ; result . add ( exit ) ; } } return result ; } \n', 0.3481193344252727)

('public void endAvoidNotify ( ) { avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.33474174737464607)

('public void endAvoidNotify ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.3324344539289146)

('public Collection < Stmt > targetsOfLoopExit ( Stmt loopExit ) { assert getLoopExits ( ) . contains ( loopExit ) ; List < Unit > succs = g . getSuccsOf ( loopExit ) ; Collection < Stmt > res = new HashSet < Stmt > ( ) ; for ( Unit u : succs ) { Stmt s = ( Stmt ) u ; res . add ( s ) ; } res . removeAll ( loopStatements ) ; return res ; } \n', 0.3286593377256622)

('@ Override public final void exitLoopBody ( @ NotNull JetLoopExpression expression ) { LoopInfo info = loopInfo . pop ( ) ; elementToBlockInfo . remove ( expression ) ; allBlocks . pop ( ) ; bindLabel ( info . getBodyExitPoint ( ) ) ; } \n', 0.325965596626709)

('public final void removeLoopExit ( LoopExitChord loopExit ) { if ( loopExit == null ) return ; if ( loopExits == loopExit ) { loopExits = null ; return ; } if ( loopExits instanceof Vector ) { @ SuppressWarnings ( "unchecked" ) Vector < LoopExitChord > c = ( Vector < LoopExitChord > ) loopExits ; if ( c . removeElement ( loopExit ) ) { int l = c . size ( ) ; if ( l == 0 ) loopExits = null ; else if ( l == 1 ) loopExits = c . elementAt ( 0 ) ; return ; } } throw new scale . common . InternalError ( "Not-a-loop-exit-" + loopExit + "-of-" + this ) ; } \n', 0.32114893119375504)

('private List < Exit > removeExits ( List < Exit > exits , Exit . Reason reason ) { List < Exit > result = new ArrayList < Exit > ( ) ; for ( Iterator < Exit > i = exits . iterator ( ) ; i . hasNext ( ) ; ) { Exit exit = i . next ( ) ; if ( exit . reason == reason ) { i . remove ( ) ; result . add ( exit ) ; } } return result ; } \n', 0.3058975681420662)

('protected void processDeleteOnExit ( ) throws MessageException { synchronized ( deleteOnExit ) { for ( Iterator < Path > iter = deleteOnExit . iterator ( ) ; iter . hasNext ( ) ; ) { Path path = iter . next ( ) ; try { delete ( path , true ) ; } catch ( IOException e ) { LOG . info ( "Ignoring-failure-to-deleteOnExit-for-path-" + path ) ; } iter . remove ( ) ; } } } \n', 0.3044683541076773)

('private void eliminate ( LoopInfo loop ) { LinkedList < BasicBlock > todo = new LinkedList < BasicBlock > ( ) ; for ( BasicBlock b : loop . loopExit ) { for ( BasicBlock pre : b . getPredecessors ( ) ) { if ( loop . loopBody . contains ( pre ) ) { todo . add ( pre ) ; } } } LinkedList < BasicBlock > connectedToExit = new LinkedList < BasicBlock > ( ) ; while ( ! todo . isEmpty ( ) ) { BasicBlock b = todo . pop ( ) ; connectedToExit . add ( b ) ; if ( b != loop . loopHead ) { for ( BasicBlock pre : b . getPredecessors ( ) ) { if ( ! todo . contains ( pre ) ) { todo . add ( pre ) ; } } } } HashSet < BasicBlock > mustset = mustBeReachedByLoopHead ( loop ) ; for ( BasicBlock b : loop . loopBody ) { if ( connectedToExit . contains ( b ) ) { if ( dontVerifyClones && ( ! mustset . contains ( b ) || loop . isNestedLoop ) ) { markAsClone ( b ) ; } for ( BasicBlock s : new HashSet < BasicBlock > ( b . getSuccessors ( ) ) ) { if ( ! loop . loopExit . contains ( s ) && ! connectedToExit . contains ( s ) ) { b . disconnectFromSuccessor ( s ) ; } } } else { for ( BasicBlock s : new HashSet < BasicBlock > ( b . getSuccessors ( ) ) ) { b . disconnectFromSuccessor ( s ) ; } } } } \n', 0.3038248946363713)

('protected void processDeleteOnExit ( ) { synchronized ( deleteOnExit ) { for ( Iterator < Path > iter = deleteOnExit . iterator ( ) ; iter . hasNext ( ) ; ) { Path path = iter . next ( ) ; try { delete ( path , true ) ; } catch ( IOException e ) { LOG . info ( "Ignoring-failure-to-deleteOnExit-for-path-" + path ) ; } iter . remove ( ) ; } } } \n', 0.30145626448885454)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('public static String generateMD5 ( String unhashed ) { String generated_md5 = null ; if ( unhashed == null ) return null ; try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( unhashed . getBytes ( ) , 0 , unhashed . length ( ) ) ; generated_md5 = new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return generated_md5 ; } \n', 0.4331418272446791)

('private static byte [ ] generateKeyFromPasswordSaltWithMD5 ( byte [ ] password , byte [ ] salt , int keyLen ) throws IOException { if ( salt . length < 8 ) throw new IllegalArgumentException ( "Salt-needs-to-be-at-least-8-bytes-for-key-generation." ) ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "VM-does-not-support-MD5" , e ) ; } byte [ ] key = new byte [ keyLen ] ; byte [ ] tmp = new byte [ md5 . getDigestLength ( ) ] ; while ( true ) { md5 . update ( password , 0 , password . length ) ; md5 . update ( salt , 0 , 8 ) ; int copy = ( keyLen < tmp . length ) ? keyLen : tmp . length ; try { md5 . digest ( tmp , 0 , tmp . length ) ; } catch ( DigestException e ) { IOException ex = new IOException ( "could-not-digest-password" ) ; ex . initCause ( e ) ; throw ex ; } System . arraycopy ( tmp , 0 , key , key . length - keyLen , copy ) ; keyLen -= copy ; if ( keyLen == 0 ) return key ; md5 . update ( tmp , 0 , tmp . length ) ; } } \n', 0.4277104097002139)

('public static String generateMD5 ( InputStream md5Stream ) throws SWORDException { String md5 = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . reset ( ) ; byte [ ] bytes = new byte [ 1024 ] ; int count = 0 ; try { while ( ( count = md5Stream . read ( bytes ) ) != - 1 ) { md . update ( bytes , 0 , count ) ; } } catch ( IOException e ) { throw new SWORDException ( SWORDException . IO_ERROR , e ) ; } byte [ ] md5Digest = md . digest ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( byte b : md5Digest ) { String hex = Integer . toHexString ( b & 0xFF ) ; if ( hex . length ( ) == 1 ) { buffer . append ( "0" ) ; } buffer . append ( hex ) ; } md5 = buffer . toString ( ) ; } catch ( NoSuchAlgorithmException ex ) { log . error ( "MD5-Algorithm-Not-found" ) ; throw new SWORDException ( SWORDException . MD5_MISSING ) ; } finally { if ( md5Stream != null ) { try { md5Stream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return md5 ; } \n', 0.4236590780045079)

('public static Integer generateSHA1 ( String key ) { try { MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hashMsg = md . digest ( key . toString ( ) . getBytes ( ) ) ; BigInteger bi = new BigInteger ( hashMsg ) . abs ( ) ; Integer networkSize = new Double ( Math . pow ( 2 , CHORD_RING_SIZE ) ) . intValue ( ) ; BigInteger mod = new BigInteger ( networkSize . toString ( ) ) ; return bi . mod ( mod ) . intValue ( ) ; } catch ( Exception e ) { String errorMessage = "An-error-has-ocurred-when-trying-to-generate-a-SHA-1-hash-number-for-the-key:-" + key + "-with-max-size-of:-" + CHORD_RING_SIZE + "-bits." ; Tools . appendToOutput ( errorMessage ) ; System . out . println ( errorMessage ) ; return null ; } } \n', 0.42329378813910523)

('private String generateMd5 ( String message ) { String digest = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( message . getBytes ( "UTF-8" ) ) ; StringBuilder sb = new StringBuilder ( 2 * hash . length ) ; for ( byte b : hash ) { sb . append ( String . format ( "%02x" , b & 0xff ) ) ; } digest = sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } return digest ; } \n', 0.41984533143908476)

('public static String generateMD5 ( String ... args ) throws NoSuchAlgorithmException { MessageDigest md ; try { byte [ ] colonBytes = ":" . getBytes ( ) ; md = MessageDigest . getInstance ( "MD5" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; md . update ( arg . getBytes ( ) ) ; if ( i != args . length - 1 ) { md . update ( colonBytes ) ; } } byte byteData [ ] = md . digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { sb . append ( Integer . toString ( ( byteData [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } return sb . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw e ; } } \n', 0.4181341694256403)

('public String generateSHA1checksum ( InputStream inputStream ) { try { if ( inputStream != null ) { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byte [ ] dataBytes = new byte [ 1024 ] ; int byteNumberRead = 0 ; while ( ( byteNumberRead = inputStream . read ( dataBytes ) ) != - 1 ) { md . update ( dataBytes , 0 , byteNumberRead ) ; } byte [ ] mdBytes = md . digest ( ) ; StringBuffer sb = new StringBuffer ( "" ) ; for ( int i = 0 ; i < mdBytes . length ; i ++ ) { sb . append ( Integer . toString ( ( mdBytes [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } inputStream . close ( ) ; return sb . toString ( ) ; } else { LOG . error ( "Input-stream-is-null!" ) ; } } catch ( Exception e ) { LOG . error ( "Could-not-generate-the-checksum." , e ) ; } return null ; } \n', 0.4166514420212688)

('public void generateChallengeHash ( ) { if ( Constants . CRYPTO_OFF ) { byte [ ] concat = new byte [ R_1_size + R_2_size ] ; System . arraycopy ( R_1 , 0 , concat , 0 , R_1 . length ) ; System . arraycopy ( R_2 , 0 , concat , R_1 . length , R_2 . length ) ; this . challengePayload . challengeHash = concat ; } else { md . reset ( ) ; md . update ( R_1 ) ; md . update ( R_2 ) ; this . challengePayload . challengeHash = md . digest ( ) ; } } \n', 0.4098016663773416)

('private String generateMD5Hash ( byte [ ] content ) { String fileMD5 = "" ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } if ( md != null ) { md . update ( content ) ; fileMD5 = DatatypeConverter . printHexBinary ( md . digest ( ) ) . toLowerCase ( ) ; } return fileMD5 ; } \n', 0.4082753133817919)

('private static String generateCash ( String prefix , int value , MessageDigest md ) throws NoSuchAlgorithmException { SecureRandom rnd = SecureRandom . getInstance ( "SHA1PRNG" ) ; byte [ ] tmpBytes = new byte [ 4 ] ; rnd . nextBytes ( tmpBytes ) ; long random = unsignedIntToLong ( tmpBytes ) ; rnd . nextBytes ( tmpBytes ) ; long counter = unsignedIntToLong ( tmpBytes ) ; prefix = prefix + Long . toString ( random , 32 ) + ":" ; String temp ; int tempValue ; byte [ ] bArray ; do { counter ++ ; temp = prefix + Long . toHexString ( counter ) ; md . reset ( ) ; md . update ( temp . getBytes ( ) ) ; bArray = md . digest ( ) ; tempValue = numberOfLeadingZeros ( bArray ) ; } while ( tempValue < value ) ; return temp ; } \n', 0.4071737090356201)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('private static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4429996253804881)

('public static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] ; } \n', 0.4429996253804881)

('private static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getMyStackTraceElement ( ) { StackTraceElement myStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 2 ) { myStackTraceElement = stackTraceElements [ 2 ] ; } } return myStackTraceElement ; } \n', 0.43606062303011456)

('public int getPrunedStackTrace ( int par1 ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - par1 ] ; System . arraycopy ( var2 , 3 + par1 , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42871933313644817)

('public StackTraceElement getLastStackTrace ( ) { final StackTraceElement [ ] stes = Thread . currentThread ( ) . getStackTrace ( ) ; int i = stes . length - 1 ; for ( ; i >= 0 ; -- i ) { StackTraceElement ste = stes [ i ] ; String className = ste . getClassName ( ) ; if ( className . equals ( StaticConsoleLogger . class . getCanonicalName ( ) ) || className . equals ( Logger . class . getCanonicalName ( ) ) ) { break ; } } return stes [ i + 1 ] ; } \n', 0.4284278536130619)

('public static StackTraceElement getCallerStackTraceElement ( ) { StackTraceElement callerStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 3 ) { callerStackTraceElement = stackTraceElements [ 3 ] ; } } return callerStackTraceElement ; } \n', 0.4282413662067419)

('public int getPrunedStackTrace ( int p_85073_1_ ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - p_85073_1_ ] ; System . arraycopy ( var2 , 3 + p_85073_1_ , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42809281907080465)

('public int getPrunedStackTrace ( int size ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - size ] ; System . arraycopy ( var2 , 3 + size , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42681183584127413)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

('void sortProperties ( ) { if ( properties . size ( ) > 1 ) { List < Entry < String , PropertyDescriptor >> entries = new ArrayList < Entry < String , PropertyDescriptor >> ( properties . entrySet ( ) ) ; Collections . sort ( entries , PropertyComparator . comparator ) ; Map < String , PropertyDescriptor > orderedProperties = new LinkedHashMap < String , PropertyDescriptor > ( ( int ) ( entries . size ( ) / 0.75 ) ) ; Map < String , PropertyDescriptor > orderedDeclared = new LinkedHashMap < String , PropertyDescriptor > ( ( int ) ( declaredProperties . size ( ) / 0.75 ) ) ; for ( Entry < String , PropertyDescriptor > e : entries ) { orderedProperties . put ( e . getKey ( ) , e . getValue ( ) ) ; if ( declaredProperties . containsKey ( e . getKey ( ) ) ) { orderedDeclared . put ( e . getKey ( ) , e . getValue ( ) ) ; } } this . properties = orderedProperties ; this . declaredProperties = orderedDeclared ; } } \n', 0.408443290910788)

('@ Override public void setSortProperties ( Container . Sortable container , Object [ ] propertyId , boolean [ ] ascending ) { this . container = container ; final List < Object > ids = new ArrayList < Object > ( ) ; final List < Boolean > orders = new ArrayList < Boolean > ( ) ; final Collection < ? > sortable = container . getSortableContainerPropertyIds ( ) ; for ( int i = 0 ; i < propertyId . length ; i ++ ) { if ( sortable . contains ( propertyId [ i ] ) ) { ids . add ( propertyId [ i ] ) ; orders . add ( Boolean . valueOf ( i < ascending . length ? ascending [ i ] : true ) ) ; } } sortPropertyIds = ids . toArray ( ) ; sortDirections = new boolean [ orders . size ( ) ] ; for ( int i = 0 ; i < sortDirections . length ; i ++ ) { sortDirections [ i ] = ( orders . get ( i ) ) . booleanValue ( ) ; } } \n', 0.3939231167346853)

('public static PropertyListComparator propertyListComparatorWithGuideArray ( Object [ ] guideArray ) { if ( guideArray != null && guideArray . length > 0 ) { Object [ ] sortedArray = guideArray . clone ( ) ; Arrays . sort ( sortedArray , AscendingInsensitivePropertyListComparator ) ; if ( ! Arrays . equals ( guideArray , sortedArray ) ) { PropertyListComparator result = new PropertyListComparator ( true ) ; int size = guideArray . length ; if ( size > 0 ) { result . guideMap = new HashMap ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { Object origEntry = guideArray [ i ] ; Object oneEntry = origEntry ; if ( origEntry instanceof Map ) { Object name = ( ( Map ) origEntry ) . get ( "name" ) ; if ( name == null ) { name = ( ( Map ) origEntry ) . get ( "prototypeName" ) ; } if ( name != null ) { oneEntry = name ; } } if ( oneEntry != null ) { result . guideMap . put ( oneEntry , Integer . valueOf ( i ) ) ; } } } return result ; } } return AscendingInsensitivePropertyListComparator ; } \n', 0.37947371287242776)

('public void sort ( ) { String property = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getRequestParameterMap ( ) . get ( SORT_PROPERTY_PARAMETER ) ; if ( property != null ) { SortOrder currentPropertySortOrder = sortsOrders . get ( property ) ; if ( multipleSorting ) { if ( ! sortPriorities . contains ( property ) ) { sortPriorities . add ( property ) ; } } else { sortsOrders . clear ( ) ; } if ( currentPropertySortOrder == null || currentPropertySortOrder . equals ( SortOrder . descending ) ) { sortsOrders . put ( property , SortOrder . ascending ) ; } else { sortsOrders . put ( property , SortOrder . descending ) ; } } } \n', 0.36445560103268604)

('public List < RelationMember > sortMembers ( List < RelationMember > relationMembers ) { List < RelationMember > newMembers = new ArrayList < > ( ) ; List < RelationMember > defaultMembers = new ArrayList < > ( relationMembers . size ( ) ) ; Map < AdditionalSorter , List < RelationMember >> customMap = new LinkedHashMap < > ( ) ; for ( RelationMember m : relationMembers ) { boolean wasAdded = false ; for ( AdditionalSorter sorter : additionalSorters ) { if ( sorter . acceptsMember ( m ) ) { List < RelationMember > list ; list = customMap . get ( sorter ) ; if ( list == null ) { customMap . put ( sorter , list = new LinkedList < > ( ) ) ; } list . add ( m ) ; wasAdded = true ; break ; } } if ( ! wasAdded ) { defaultMembers . add ( m ) ; } } for ( Entry < AdditionalSorter , List < RelationMember >> entry : customMap . entrySet ( ) ) { newMembers . addAll ( entry . getKey ( ) . sortMembers ( entry . getValue ( ) ) ) ; } newMembers . addAll ( sortMembersByConnectivity ( defaultMembers ) ) ; return newMembers ; } \n', 0.36215416399160527)

('public void sortPropertiesByLowestPrice ( ) { Collections . sort ( this . properties , new Comparator < Property > ( ) { @ Override public int compare ( Property p1 , Property p2 ) { return Double . valueOf ( p1 . getPayAmount ( ) ) . compareTo ( Double . valueOf ( p2 . getPayAmount ( ) ) ) ; } } ) ; } \n', 0.3493189823453705)

('public static ArrayList < Customer > sortCustomers ( HashMap < Integer , Customer > hm ) { Collection < Customer > c = hm . values ( ) ; ArrayList < Customer > a = new ArrayList < Customer > ( c ) ; Collections . sort ( a ) ; return a ; } \n', 0.3464072751275238)

('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.3457964438296415)

('private Element sortEntityTypeProperties ( Element el ) throws JDOMException { XPath xp = XPath . newInstance ( "//x:EntityType" ) ; xp . addNamespace ( "x" , "http://schemas.microsoft.com/ado/2006/04/edm" ) ; for ( Object pNode : xp . selectNodes ( el ) ) { Element node = ( Element ) pNode ; final List < Element > props = new ArrayList < Element > ( ) ; for ( Object pChild : new ArrayList < Object > ( node . getChildren ( ) ) ) { Element child = ( Element ) pChild ; if ( child . getName ( ) . equals ( "Property" ) ) { props . add ( ( Element ) child . clone ( ) ) ; child . detach ( ) ; } } Collections . sort ( props , new Comparator < Element > ( ) { public int compare ( Element o1 , Element o2 ) { return o1 . getAttributeValue ( "Name" ) . compareTo ( o2 . getAttributeValue ( "Name" ) ) ; } } ) ; for ( Element prop : props ) { node . addContent ( ( Content ) prop ) ; } } return el ; } \n', 0.3451312545675277)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('private Object convertBigDecimalToNum ( BigDecimal value ) { Object convertedValue ; if ( value . scale ( ) == 0 ) { logger . trace ( "found-no-fractional-part" ) ; convertedValue = value . toBigInteger ( ) ; } else { logger . trace ( "found-fractional-part" ) ; convertedValue = value . doubleValue ( ) ; } return convertedValue ; } \n', 0.3724895940367403)

("public static String truncateAndConvertDecimalString ( String number , int maxDecimalPlaces ) { if ( number == null ) { return null ; } number = number . trim ( ) ; if ( ! isValidDecimalNumber ( number ) ) { return null ; } number = number . replace ( ',' , '.' ) ; boolean foundDot = false ; int decimals = 0 ; char [ ] chars = number . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c == '.' ) { if ( maxDecimalPlaces == 0 ) { return number . substring ( 0 , i ) ; } foundDot = true ; continue ; } if ( foundDot ) { decimals ++ ; } if ( maxDecimalPlaces == decimals ) { return number . substring ( 0 , i + 1 ) ; } } return number ; } \n", 0.363412392536934)

('public static final String toBinaryUsingBigDecimal ( int numberToConvert ) { int integer = numberToConvert ; if ( integer < 0 ) throw new IllegalArgumentException ( "Method-argument-cannot-be-negative.-number=" + integer ) ; StringBuilder builder = new StringBuilder ( ) ; BigDecimal number = new BigDecimal ( integer ) ; BigDecimal [ ] decimals = null ; while ( number . compareTo ( ZERO ) > 0 ) { decimals = number . divideAndRemainder ( TWO ) ; number = decimals [ 0 ] ; builder . append ( decimals [ 1 ] ) ; } return builder . reverse ( ) . toString ( ) ; } \n', 0.34408959150882024)

('@ Override public Object subtract ( Object a , Object b , Type otherType ) { if ( a == null || b == null ) { return null ; } switch ( typeCode ) { case Types . SQL_REAL : case Types . SQL_FLOAT : case Types . SQL_DOUBLE : { double ad = ( ( Number ) a ) . doubleValue ( ) ; double bd = ( ( Number ) b ) . doubleValue ( ) ; return ValuePool . getDouble ( Double . doubleToLongBits ( ad - bd ) ) ; } case Types . SQL_NUMERIC : case Types . SQL_DECIMAL : { a = convertToDefaultType ( null , a ) ; b = convertToDefaultType ( null , b ) ; BigDecimal abd = ( BigDecimal ) a ; BigDecimal bbd = ( BigDecimal ) b ; return abd . subtract ( bbd ) ; } case Types . TINYINT : case Types . SQL_SMALLINT : case Types . SQL_INTEGER : { int ai = ( ( Number ) a ) . intValue ( ) ; int bi = ( ( Number ) b ) . intValue ( ) ; return ValuePool . getInt ( ai - bi ) ; } case Types . SQL_BIGINT : { long longa = ( ( Number ) a ) . longValue ( ) ; long longb = ( ( Number ) b ) . longValue ( ) ; return ValuePool . getLong ( longa - longb ) ; } default : } throw Error . runtimeError ( ErrorCode . U_S0500 , "NumberType" ) ; } \n', 0.3328360010720416)

('public Object subtract ( Object a , Object b , Type otherType ) { if ( a == null || b == null ) { return null ; } switch ( typeCode ) { case Types . SQL_REAL : case Types . SQL_FLOAT : case Types . SQL_DOUBLE : { double ad = ( ( Number ) a ) . doubleValue ( ) ; double bd = ( ( Number ) b ) . doubleValue ( ) ; return ValuePool . getDouble ( Double . doubleToLongBits ( ad - bd ) ) ; } case Types . SQL_NUMERIC : case Types . SQL_DECIMAL : { a = convertToDefaultType ( null , a ) ; b = convertToDefaultType ( null , b ) ; BigDecimal abd = ( BigDecimal ) a ; BigDecimal bbd = ( BigDecimal ) b ; return abd . subtract ( bbd ) ; } case Types . TINYINT : case Types . SQL_SMALLINT : case Types . SQL_INTEGER : { int ai = ( ( Number ) a ) . intValue ( ) ; int bi = ( ( Number ) b ) . intValue ( ) ; return ValuePool . getInt ( ai - bi ) ; } case Types . SQL_BIGINT : { long longa = ( ( Number ) a ) . longValue ( ) ; long longb = ( ( Number ) b ) . longValue ( ) ; return ValuePool . getLong ( longa - longb ) ; } default : } throw Error . runtimeError ( ErrorCode . U_S0500 , "NumberType" ) ; } \n', 0.3328360010720416)

('public static Double convertToFixedDecimalPlace ( Double number , int decimalPlaces ) { number = new BigDecimal ( number ) . setScale ( decimalPlaces , RoundingMode . HALF_UP ) . doubleValue ( ) ; return number ; } \n', 0.33252576845917886)

("public static Float convertImpliedDecimalFormat ( String format , String toConvert ) { long decimalPlace = 1 ; int indexOf = format . indexOf ( 'V' ) ; if ( indexOf > - 1 ) { boolean isV = false ; for ( int i = 0 ; i < format . length ( ) ; i ++ ) { char charAt = format . charAt ( i ) ; if ( charAt == '9' && isV ) { decimalPlace = 10 * decimalPlace ; } else if ( charAt == 'V' ) { isV = true ; } } } BigDecimal decimal = new BigDecimal ( toConvert ) ; decimal = decimal . divide ( new BigDecimal ( decimalPlace ) ) ; return new Float ( decimal . doubleValue ( ) ) ; } \n", 0.330815430732781)

('public String convertBigIntToEnglish ( BigInteger value ) throws Exception { StringBuffer convertedLongToEnglish = new StringBuffer ( ) ; BigInteger maxValue = BigInteger . valueOf ( 1000 ) . pow ( 21 ) ; if ( value . compareTo ( maxValue ) == 1 || value . compareTo ( maxValue ) == 0 ) { throw new Exception ( "Supplied-too-large-of-a-number" ) ; } else if ( value . compareTo ( BigInteger . valueOf ( 100 ) ) == - 1 ) { convertedLongToEnglish . append ( convertUnder100 ( value ) ) ; } else if ( value . compareTo ( BigInteger . valueOf ( 1000 ) ) == - 1 ) { convertedLongToEnglish . append ( convertUnder1000 ( value ) ) ; } else { for ( int i = 0 ; i < places . length + 1 ; i ++ ) { int exponent = i - 1 ; BigInteger placeValue = BigInteger . valueOf ( 1000 ) . pow ( i ) ; if ( placeValue . compareTo ( value ) == 1 ) { BigInteger mod = BigInteger . valueOf ( 1000 ) . pow ( exponent ) ; BigInteger left = value . divide ( mod ) ; BigInteger right = value . subtract ( ( left . multiply ( mod ) ) ) ; convertedLongToEnglish . append ( convertUnder1000 ( left ) ) ; convertedLongToEnglish . append ( "-" ) ; convertedLongToEnglish . append ( places [ exponent ] ) ; if ( right . compareTo ( new BigInteger ( "0" ) ) == 1 ) { convertedLongToEnglish . append ( ",-" ) ; convertedLongToEnglish . append ( convertBigIntToEnglish ( right ) ) ; } break ; } } } return convertedLongToEnglish . toString ( ) ; } \n', 0.33017166589707964)

('public static final String toBinaryUsingDivideAndDouble ( int numberToConvert ) { int integer = numberToConvert ; if ( integer < 0 ) throw new IllegalArgumentException ( "Method-argument-cannot-be-negative.-number=" + integer ) ; StringBuilder builder = new StringBuilder ( ) ; double temp = 0d ; while ( integer > 0 ) { temp = integer / 2d ; integer = ( int ) temp ; builder . append ( ( temp > integer ) ? 1 : 0 ) ; } return builder . reverse ( ) . toString ( ) ; } \n', 0.32662247179564374)

('public static BigDecimal convertToBigDecimal ( final Object o ) { if ( o instanceof Number ) { return convertToBigDecimal ( ( Number ) o ) ; } return null ; } \n', 0.32030888837284005)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

('public static String leftPad ( final String str , final int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = SPACE ; } final int padLen = padStr . length ( ) ; final int strLen = str . length ( ) ; final int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( padLen == 1 && pads <= PAD_LIMIT ) { return leftPad ( str , size , padStr . charAt ( 0 ) ) ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { final char [ ] padding = new char [ pads ] ; final char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.38298669517910194)

('public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( padLen == 1 && pads <= PAD_LIMIT ) { return leftPad ( str , size , padStr . charAt ( 0 ) ) ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.38129123998229686)

('public String padNumZero ( float num , int wholeLen , int decimalPlaces ) { String numStr = Float . toString ( num ) ; int dpLoc = numStr . indexOf ( "." ) ; int len = wholeLen - dpLoc ; String pads = "" ; if ( numStr . charAt ( 0 ) == \'-\' ) { len += 1 ; for ( int i = 0 ; i < len ; i ++ ) { pads += "0" ; } pads = "-" + pads ; numStr = pads + numStr . substring ( 1 ) ; } else { for ( int i = 0 ; i < len ; i ++ ) { pads += "0" ; } numStr = pads + numStr ; } dpLoc = numStr . indexOf ( "." ) ; int length = numStr . substring ( dpLoc ) . length ( ) ; while ( length < decimalPlaces ) { numStr += "0" ; } return numStr ; } \n', 0.3509185339655699)

('public static long bytesToLongPad ( byte [ ] bytes ) { final int padZeros = Math . max ( 8 - bytes . length , 0 ) ; ByteBuffer bb = ByteBuffer . allocate ( 8 ) ; for ( int i = 0 ; i < padZeros ; i ++ ) { bb . put ( ( byte ) 0 ) ; } bb . put ( bytes , 0 , 8 - padZeros ) ; bb . flip ( ) ; return bb . getLong ( ) ; } \n', 0.34726676558741554)

('public String padNumZero ( double num , int wholeLen , int decimalPlaces ) { String numStr = Double . toString ( num ) ; int dpLoc = numStr . indexOf ( "." ) ; int len = wholeLen - dpLoc ; String pads = "" ; for ( int i = 0 ; i < len ; i ++ ) { pads += "0" ; } numStr = pads + numStr ; dpLoc = numStr . indexOf ( "." ) ; if ( dpLoc + 1 + decimalPlaces > numStr . substring ( dpLoc ) . length ( ) ) { return numStr ; } return numStr . substring ( 0 , dpLoc + 1 + decimalPlaces ) ; } \n', 0.3455736139950102)

('public static String padLeft ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( padLen == 1 && pads <= PAD_LIMIT ) { return padLeft ( str , size , padStr . charAt ( 0 ) ) ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.32829570955953524)

('public static String randomAlphaNumeric ( int length ) { StringBuffer buffer = new StringBuffer ( ) ; String characters = "abcdefghijklmnopqrstuvwxyz0123456789" ; int charactersLength = characters . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { double index = Math . random ( ) * charactersLength ; buffer . append ( characters . charAt ( ( int ) index ) ) ; } return buffer . toString ( ) ; } \n', 0.32263503564371754)

('public static final String toBinaryUsingBigDecimal ( int numberToConvert ) { int integer = numberToConvert ; if ( integer < 0 ) throw new IllegalArgumentException ( "Method-argument-cannot-be-negative.-number=" + integer ) ; StringBuilder builder = new StringBuilder ( ) ; BigDecimal number = new BigDecimal ( integer ) ; BigDecimal [ ] decimals = null ; while ( number . compareTo ( ZERO ) > 0 ) { decimals = number . divideAndRemainder ( TWO ) ; number = decimals [ 0 ] ; builder . append ( decimals [ 1 ] ) ; } return builder . reverse ( ) . toString ( ) ; } \n', 0.316776224065848)

('public static final String toBinaryUsingBigDecimal ( long numberToConvert ) { long longNumber = numberToConvert ; if ( longNumber < 0 ) throw new IllegalArgumentException ( "Method-argument-cannot-be-negative.-number=" + longNumber ) ; StringBuilder builder = new StringBuilder ( ) ; BigDecimal zero = new BigDecimal ( 0 ) ; BigDecimal two = new BigDecimal ( 2 ) ; BigDecimal number = new BigDecimal ( longNumber ) ; BigDecimal [ ] decimals = null ; while ( number . compareTo ( zero ) > 0 ) { decimals = number . divideAndRemainder ( two ) ; number = decimals [ 0 ] ; builder . append ( decimals [ 1 ] ) ; } return builder . reverse ( ) . toString ( ) ; } \n', 0.30706566917951883)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('private static OpenConverter makeArrayOrCollectionConverter ( Type collectionType , Type elementType ) throws OpenDataException { final OpenConverter elementConverter = toConverter ( elementType ) ; final OpenType < ? > elementOpenType = elementConverter . getOpenType ( ) ; final ArrayType < ? > openType = ArrayType . getArrayType ( elementOpenType ) ; final Class < ? > elementOpenClass = elementConverter . getOpenClass ( ) ; final Class < ? > openArrayClass ; final String openArrayClassName ; if ( elementOpenClass . isArray ( ) ) openArrayClassName = "[" + elementOpenClass . getName ( ) ; else openArrayClassName = "[L" + elementOpenClass . getName ( ) + ";" ; try { openArrayClass = Class . forName ( openArrayClassName ) ; } catch ( ClassNotFoundException e ) { throw openDataException ( "Cannot-obtain-array-class" , e ) ; } if ( collectionType instanceof ParameterizedType ) { return new CollectionConverter ( collectionType , openType , openArrayClass , elementConverter ) ; } else { if ( elementConverter . isIdentity ( ) ) { return new IdentityConverter ( collectionType , openType , openArrayClass ) ; } else { return new ArrayConverter ( collectionType , openType , openArrayClass , elementConverter ) ; } } } \n', 0.37350152143470267)

('protected Map < Integer , BytesConverter > createDbToBytesConverters ( ) { Map < Integer , BytesConverter > map = new HashMap < Integer , BytesConverter > ( ) ; map . put ( Types . BINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . BLOB , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . VARBINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . LONGVARBINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . CHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . NCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . CLOB , Base64StringConverter . INSTANCE ) ; map . put ( Types . NCLOB , Base64StringConverter . INSTANCE ) ; map . put ( Types . LONGVARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . LONGNVARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . VARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . NVARCHAR , Base64StringConverter . INSTANCE ) ; return map ; } \n', 0.3506969144298475)

('protected Map < String , BytesConverter > createObjectToBytesConverters ( ) { Map < String , BytesConverter > map = new HashMap < String , BytesConverter > ( ) ; map . put ( "byte[]" , BytesToBytesConverter . INSTANCE ) ; map . put ( String . class . getName ( ) , Utf8StringConverter . INSTANCE ) ; return map ; } \n', 0.343489677699265)

('@ Override protected IConverter createConverter ( Object fromType , Object toType ) { if ( ( fromType == Integer . class ) || ( fromType == int . class ) ) { return new Converter ( fromType , toType ) { @ Override public Object convert ( Object fromObject ) { Integer fromInteger = ( Integer ) fromObject ; return values . get ( fromInteger ) ; } } ; } if ( ( toType == Integer . class ) || ( toType == int . class ) ) { return new Converter ( fromType , toType ) { @ Override public Object convert ( Object fromObject ) { return values . indexOf ( fromObject ) ; } } ; } return super . createConverter ( fromType , toType ) ; } \n', 0.34062092657313936)

('protected Map < String , BytesConverter > createBytesToObjectConverters ( ) { Map < String , BytesConverter > map = new HashMap < String , BytesConverter > ( ) ; map . put ( "byte[]" , BytesToBytesConverter . INSTANCE ) ; map . put ( String . class . getName ( ) , Utf8StringConverter . INSTANCE ) ; return map ; } \n', 0.3361464399477119)

('protected Map < Integer , BytesConverter > createBytesToDbConverters ( ) { Map < Integer , BytesConverter > map = new HashMap < Integer , BytesConverter > ( ) ; map . put ( Types . BINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . BLOB , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . VARBINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . LONGVARBINARY , BytesToBytesConverter . INSTANCE ) ; map . put ( Types . CHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . NCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . CLOB , Base64StringConverter . INSTANCE ) ; map . put ( Types . NCLOB , Base64StringConverter . INSTANCE ) ; map . put ( Types . LONGVARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . LONGNVARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . VARCHAR , Base64StringConverter . INSTANCE ) ; map . put ( Types . NVARCHAR , Base64StringConverter . INSTANCE ) ; return map ; } \n', 0.3334594853889101)

('private Converter [ ] createConverters ( ServiceReference [ ] convRefs ) { List converters = new ArrayList ( ) ; for ( int ii = 0 ; ii < convRefs . length ; ii ++ ) { converters . add ( new Converter ( this . bContext , convRefs [ ii ] ) ) ; } return ( Converter [ ] ) converters . toArray ( new Converter [ 0 ] ) ; } \n', 0.3303088579287472)

('public IConverter createToFromConverter ( ) { return new Converter ( toType , fromType ) { public Object convert ( final Object fromObject ) { K result = null ; final Iterator < Entry < K , L >> iter = modelToUI . entrySet ( ) . iterator ( ) ; while ( result == null && iter . hasNext ( ) ) { final Entry < K , L > entry = iter . next ( ) ; if ( entry . getValue ( ) . equals ( fromObject ) ) { result = entry . getKey ( ) ; } } return result ; } } ; } \n', 0.3217429571610323)

('static Object [ ] convertPrimitiveToObjectArray ( final Object extendee , final Class < ? > arrayType ) { Object [ ] convertedArray ; try { final Class < ? > wrapperClass = ClassExtensions . asWrapped ( arrayType ) ; final Constructor < ? > constructor = wrapperClass . getConstructor ( new Class [ ] { String . class } ) ; final int len = Array . getLength ( extendee ) ; convertedArray = ( Object [ ] ) Array . newInstance ( wrapperClass , len ) ; for ( int i = 0 ; i < len ; i ++ ) { convertedArray [ i ] = constructor . newInstance ( new Object [ ] { Array . get ( extendee , i ) . toString ( ) } ) ; } } catch ( final NoSuchMethodException e ) { throw new IsisException ( e ) ; } catch ( final ArrayIndexOutOfBoundsException e ) { throw new IsisException ( e ) ; } catch ( final IllegalArgumentException e ) { throw new IsisException ( e ) ; } catch ( final InstantiationException e ) { throw new IsisException ( e ) ; } catch ( final IllegalAccessException e ) { throw new IsisException ( e ) ; } catch ( final InvocationTargetException e ) { throw new IsisException ( e ) ; } return convertedArray ; } \n', 0.31619262115474434)

('private < T > T [ ] convertToArray ( Value [ ] jcrValues , Class < T > type ) throws ValueFormatException , RepositoryException { List < T > values = new ArrayList < T > ( ) ; for ( int i = 0 ; i < jcrValues . length ; i ++ ) { T value = convertToType ( i , jcrValues [ i ] , type ) ; if ( value != null ) { values . add ( value ) ; } } @ SuppressWarnings ( "unchecked" ) T [ ] result = ( T [ ] ) Array . newInstance ( type , values . size ( ) ) ; return values . toArray ( result ) ; } \n', 0.30299822168956236)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('public static String readTextFile ( File file ) throws IOException { if ( Locale . getDefault ( ) . getLanguage ( ) . equals ( "en" ) == false ) { return readI18NFile ( file ) ; } FileReader in = new FileReader ( file ) ; int size = ( int ) file . length ( ) ; char [ ] data = new char [ size ] ; int chars_read = 0 ; while ( chars_read < size ) { chars_read += in . read ( data , chars_read , size - chars_read ) ; } return new String ( data ) ; } \n', 0.4254513574659099)

('public static List < String > loadTextFile ( final String location , final List < String > list ) throws IOException { final BufferedReader reader = new BufferedReader ( getReader ( location ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { list . add ( line ) ; line = reader . readLine ( ) ; } return list ; } \n', 0.42468146728707046)

('public void loadTextFile ( String path ) throws IOException { BufferedReader input = new BufferedReader ( new InputStreamReader ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( path ) ) ) ; String line ; while ( input . ready ( ) ) { line = input . readLine ( ) ; StringBuffer word = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ( ) ; ++ i ) { char c = line . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { continue ; } word . append ( c ) ; } if ( word . length ( ) < 1 ) { continue ; } add ( word . toString ( ) ) ; } input . close ( ) ; } \n', 0.42202302827444793)

('public static String readTextFile ( File inputFile ) throws IOException { FileInputStream fis = new FileInputStream ( inputFile ) ; Charset charset = Charset . forName ( "UTF-8" ) ; InputStreamReader isr = new InputStreamReader ( fis , charset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuffer contents = new StringBuffer ( ) ; String line ; String separator = System . getProperty ( "line.separator" ) ; while ( ( line = reader . readLine ( ) ) != null ) { contents . append ( line ) . append ( separator ) ; } fis . close ( ) ; isr . close ( ) ; return contents . toString ( ) ; } \n', 0.41996497953351564)

('private Hashtable readProgramListFromTextFile ( ) throws IOException { final Hashtable result = new Hashtable ( ) ; final InputStream is = getClass ( ) . getResourceAsStream ( "/programs/programs.txt" ) ; int c = 0 ; while ( c >= 0 ) { final StringBuffer line = new StringBuffer ( ) ; while ( ( c = is . read ( ) ) > 0 && c != \'|n\' && c != \'|r\' ) { line . append ( ( char ) c ) ; } if ( ! line . toString ( ) . startsWith ( "#" ) && line . length ( ) > 0 ) { result . put ( line . toString ( ) , "/programs/" + line . toString ( ) ) ; } } return result ; } \n', 0.4191684070453872)

('public static String readTextFile ( File file ) throws IOException { BufferedReader in = null ; try { if ( ! file . exists ( ) ) { Object [ ] args = { file } ; throw new IOException ( MessageFormat . format ( ResourceBundleFactory . getBundle ( BUNDLE_NAME ) . getString ( "FILE_DOES_NOT_EXIST" ) , args ) ) ; } in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; int fileSize = ( int ) file . length ( ) ; char [ ] buf = new char [ fileSize ] ; in . read ( buf , 0 , fileSize ) ; return new String ( buf ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ignored ) { ; } } } } \n', 0.4181872665292285)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.41573641785888943)

('private void loadTextFile ( ) throws IOException { logger . debug ( "Entering-loadTextFile()" ) ; FileReader fr = new FileReader ( selectedFile ) ; int ch = 0 ; StringBuffer readFile = new StringBuffer ( ) ; while ( ch != - 1 ) { ch = fr . read ( ) ; if ( ch != - 1 ) readFile . append ( ( char ) ch ) ; } fr . close ( ) ; resultTextFile = readFile . toString ( ) ; } \n', 0.415044455216781)

('public static String loadTextFile ( File file ) throws IOException { char [ ] buffer = new char [ 4096 ] ; int len ; StringBuilder input = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { while ( ( len = reader . read ( buffer ) ) != - 1 ) { input . append ( buffer , 0 , len ) ; } } finally { reader . close ( ) ; } return input . toString ( ) ; } \n', 0.4145982548659303)

('private String readEmbeddedTextFile ( String filepath ) throws IOException { InputStream is = BuildConfigGenerator . class . getResourceAsStream ( filepath ) ; if ( is != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; StringBuilder total = new StringBuilder ( reader . readLine ( ) ) ; while ( ( line = reader . readLine ( ) ) != null ) { total . append ( \'|n\' ) ; total . append ( line ) ; } return total . toString ( ) ; } throw new IOException ( "BuildConfig-template-is-missing!" ) ; } \n', 0.41441637494707717)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('private Object convertToTypedArray ( Object input , String propertyName , Class < ? > componentType ) { if ( input instanceof Collection ) { Collection < ? > coll = ( Collection < ? > ) input ; Object result = Array . newInstance ( componentType , coll . size ( ) ) ; int i = 0 ; for ( Iterator < ? > it = coll . iterator ( ) ; it . hasNext ( ) ; i ++ ) { Object value = convertIfNecessary ( buildIndexedPropertyName ( propertyName , i ) , null , it . next ( ) , componentType ) ; Array . set ( result , i , value ) ; } return result ; } else if ( input . getClass ( ) . isArray ( ) ) { if ( componentType . equals ( input . getClass ( ) . getComponentType ( ) ) && ! this . propertyEditorRegistry . hasCustomEditorForElement ( componentType , propertyName ) ) { return input ; } int arrayLength = Array . getLength ( input ) ; Object result = Array . newInstance ( componentType , arrayLength ) ; for ( int i = 0 ; i < arrayLength ; i ++ ) { Object value = convertIfNecessary ( buildIndexedPropertyName ( propertyName , i ) , null , Array . get ( input , i ) , componentType ) ; Array . set ( result , i , value ) ; } return result ; } else { Object result = Array . newInstance ( componentType , 1 ) ; Object value = convertIfNecessary ( buildIndexedPropertyName ( propertyName , 0 ) , null , input , componentType ) ; Array . set ( result , 0 , value ) ; return result ; } } \n', 0.346325566939139)

('public Iterator < ? > convertAnythingToIterator ( InstanceScope scope , Object o ) { o = convertAnythingIteratableToIterator ( scope , o ) ; if ( o instanceof Iterator ) return ( Iterator < ? > ) o ; List < Object > singleton = new ST . AttributeList ( 1 ) ; singleton . add ( o ) ; return singleton . iterator ( ) ; } \n', 0.3190679734346171)

('private List < String > getEnumNames ( Class < T > optionsEnumClass ) { return FluentIterable . from ( Arrays . asList ( optionsEnumClass . getEnumConstants ( ) ) ) . transform ( Enums . stringConverter ( optionsEnumClass ) . reverse ( ) ) . toList ( ) ; } \n', 0.31719139408488584)

('public static Enum < ? > [ ] toEnums ( final Collection < Object > vector ) throws DataNotCompatibleException { if ( vector == null || vector . isEmpty ( ) ) return new Enum [ 0 ] ; ClassLoader cl = Factory . getClassLoader ( ) ; Enum < ? > [ ] classes = new Enum [ vector . size ( ) ] ; int i = 0 ; for ( Object o : vector ) { int pos = i ++ ; String en = String . valueOf ( o ) ; String ename = null ; String cn = null ; if ( en . indexOf ( \'-\' ) > 0 ) { cn = String . valueOf ( o ) . substring ( 0 , en . indexOf ( \'-\' ) ) . trim ( ) ; ename = String . valueOf ( o ) . substring ( en . indexOf ( \'-\' ) + 1 ) . trim ( ) ; } try { Class < ? > cls = Class . forName ( cn , false , cl ) ; for ( Object obj : cls . getEnumConstants ( ) ) { if ( obj instanceof Enum ) { if ( ( ( Enum < ? > ) obj ) . name ( ) . equals ( ename ) ) { classes [ pos ] = ( Enum < ? > ) obj ; } } } } catch ( ClassNotFoundException e ) { System . out . println ( "Failed-to-find-class-" + cn + "-using-a-classloader-of-type-" + cl . getClass ( ) . getName ( ) ) ; DominoUtils . handleException ( e ) ; classes [ pos ] = null ; } } return classes ; } \n', 0.3168790521067198)

('private Object convertToCollection ( Object obj , ReifiedType type ) throws Exception { ReifiedType valueType = type . getActualTypeArgument ( 0 ) ; Collection newCol = ( Collection ) getCollection ( toClass ( type ) ) . newInstance ( ) ; if ( obj . getClass ( ) . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( obj ) ; i ++ ) { try { newCol . add ( convert ( Array . get ( obj , i ) , valueType ) ) ; } catch ( Exception t ) { throw new Exception ( "Unable-to-convert-from-" + obj + "-to-" + type + "(error-converting-array-element)" , t ) ; } } } else { for ( Object item : ( Collection ) obj ) { try { newCol . add ( convert ( item , valueType ) ) ; } catch ( Exception t ) { throw new Exception ( "Unable-to-convert-from-" + obj + "-to-" + type + "(error-converting-collection-entry)" , t ) ; } } } return newCol ; } \n', 0.3151343617009444)

('protected Collection < T > convertValueToCollection ( Object value ) { if ( value instanceof Iterable ) { Iterable iterable = ( Iterable ) value ; Collection < T > collection = createCollection ( 0 ) ; for ( Object element : iterable ) { collection . add ( convertType ( element ) ) ; } return collection ; } if ( value instanceof CharSequence ) { value = CsvUtil . toStringArray ( value . toString ( ) ) ; } Class type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return convertPrimitiveArrayToCollection ( value , componentType ) ; } else { Object [ ] array = ( Object [ ] ) value ; Collection < T > result = createCollection ( array . length ) ; for ( Object a : array ) { result . add ( convertType ( a ) ) ; } return result ; } } return convertToSingleElementCollection ( value ) ; } \n', 0.3143279278517115)

('final Object toNonNullOpenValue ( MXBeanLookup lookup , Object value ) throws OpenDataException { final Collection valueCollection = ( Collection ) value ; if ( valueCollection instanceof SortedSet ) { Comparator comparator = ( ( SortedSet ) valueCollection ) . comparator ( ) ; if ( comparator != null ) { final String msg = "Cannot-convert-SortedSet-with-non-null-comparator:-" + comparator ; throw new OpenDataException ( msg ) ; } } final Object [ ] openArray = ( Object [ ] ) Array . newInstance ( getOpenClass ( ) . getComponentType ( ) , valueCollection . size ( ) ) ; int i = 0 ; for ( Object o : valueCollection ) openArray [ i ++ ] = elementConverter . toOpenValue ( lookup , o ) ; return openArray ; } \n', 0.3105862779620868)

('private static Map < String , Object > convertAttributeValuesToMultiValuedObjects ( final Map < String , Object > attributes ) { final Set < Map . Entry < String , Object >> entries = attributes . entrySet ( ) ; return entries . stream ( ) . collect ( Collectors . toMap ( Map . Entry :: getKey , entry -> { final Object value = entry . getValue ( ) ; if ( value instanceof Collection || value instanceof Map || value instanceof Object [ ] || value instanceof Iterator || value instanceof Enumeration ) { return value ; } else { return Collections . singleton ( value ) ; } } ) ) ; } \n', 0.310496988982079)

('@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) private Object getPotentiallyConvertedSimpleRead ( Object value , Class < ? > target ) { if ( value == null || target == null || target . isAssignableFrom ( value . getClass ( ) ) ) { return value ; } if ( conversions . hasCustomReadTarget ( value . getClass ( ) , target ) ) { return conversionService . convert ( value , target ) ; } if ( Enum . class . isAssignableFrom ( target ) ) { return Enum . valueOf ( ( Class < Enum > ) target , value . toString ( ) ) ; } return conversionService . convert ( value , target ) ; } \n', 0.3055139684874344)

('protected Object fromCollectionToArray ( final Class componentType , final Collection source , final ConversionContext context ) { final int length = source . size ( ) ; final Object [ ] result = ( Object [ ] ) Array . newInstance ( componentType , length ) ; if ( length == 0 ) { return result ; } final ConverterFactory converterFactory = context . getConverterFactory ( ) ; int i = 0 ; for ( final Iterator it = source . iterator ( ) ; it . hasNext ( ) ; ++ i ) { final Object sourceElement = it . next ( ) ; final Converter converter = converterFactory . getConverter ( sourceElement . getClass ( ) , componentType ) ; result [ i ] = converter . convert ( sourceElement , componentType , context ) ; } return result ; } \n', 0.30471558578091784)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public boolean isOnLine ( Point pt ) { Container parent = oLink . getParent ( ) ; Point newPoint = ( Point ) pt . clone ( ) ; if ( parent != null ) newPoint = SwingUtilities . convertPoint ( parent , pt , oLink ) ; boolean isOnLink = false ; if ( isCurved ) { if ( oLinkPath != null ) { double tol = ( nThickness / 2 ) + LINE_TOLERANCE ; double tols = tol / 2 ; isOnLink = oLinkPath . intersects ( new Integer ( newPoint . x ) . doubleValue ( ) - tols , new Integer ( newPoint . y ) . doubleValue ( ) - tols , tol , tol ) ; } } else if ( isSquared ) { if ( oRectOne != null && oRectTwo != null && oRectThree != null && ( oRectOne . contains ( newPoint ) || oRectTwo . contains ( newPoint ) || oRectThree . contains ( newPoint ) ) ) { isOnLink = true ; } } else { isOnLink = oLink . onLine ( pt , LINE_TOLERANCE ) ; } return isOnLink ; } \n', 0.28002712484203174)

('public static boolean isStrictMethodInvocationConvertible ( Class formal , Class actual , boolean possibleVarArg ) { if ( actual == null && ! formal . isPrimitive ( ) ) { return true ; } if ( formal . isAssignableFrom ( actual ) ) { return true ; } if ( formal . isPrimitive ( ) ) { if ( formal == Short . TYPE && ( actual == Byte . TYPE ) ) return true ; if ( formal == Integer . TYPE && ( actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Long . TYPE && ( actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Float . TYPE && ( actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Double . TYPE && ( actual == Float . TYPE || actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; } if ( possibleVarArg && formal . isArray ( ) ) { if ( actual . isArray ( ) ) { actual = actual . getComponentType ( ) ; } return isStrictMethodInvocationConvertible ( formal . getComponentType ( ) , actual , false ) ; } return false ; } \n', 0.26879710012396996)

('public static boolean implicitConvertable ( TypeInfo from , TypeInfo to ) { if ( from . equals ( to ) ) { return true ; } if ( from . equals ( TypeInfoFactory . stringTypeInfo ) && to . equals ( TypeInfoFactory . doubleTypeInfo ) ) { return true ; } if ( from . equals ( TypeInfoFactory . voidTypeInfo ) ) { return true ; } Integer f = numericTypes . get ( from ) ; Integer t = numericTypes . get ( to ) ; if ( f == null || t == null ) { return false ; } if ( f . intValue ( ) > t . intValue ( ) ) { return false ; } return true ; } \n', 0.2612905196644175)

('public void runAllTests ( ) { ru . writeln ( "--start--" ) ; printInputLines ( ) ; splitString ( ) ; parseIntegers ( ) ; printAlternateChars ( ) ; printLengthAndSize ( ) ; printGrid ( ) ; changeCharacterCase ( ) ; integerSquareRoot ( ) ; sortIntegers ( ) ; hashLookup ( ) ; printSubstring ( ) ; formatIntegersZeros ( ) ; formatIntegersSpaces ( ) ; sumIntegers ( ) ; ceilingFloor ( ) ; stringContains ( ) ; stringTrim ( ) ; splitStringPipe ( ) ; getASCII ( ) ; ASCIItoChar ( ) ; charToOrdinal ( ) ; ordinalToChar ( ) ; cloneArray ( ) ; initIntArray ( ) ; lookupElement ( ) ; listToArray ( ) ; formatDecimal ( ) ; incrementDate ( ) ; arrayInit ( ) ; loopBreak ( ) ; sortAscendingDescending ( ) ; sortObjects ( ) ; flipBits ( ) ; exponentiateIntegers ( ) ; checkIntervalOverlap ( ) ; convertNumberBase ( ) ; processLinkedLists ( ) ; reverseString ( ) ; dontReverseString ( ) ; countIntegers ( ) ; countIntegers2 ( ) ; cloneStack ( ) ; ru . writeln ( "--end--" ) ; } \n', 0.25768044032430926)

('protected Boolean booleanConvert ( Object value ) { if ( value instanceof Boolean ) { return ( Boolean ) value ; } if ( value instanceof Number ) { return ( Math . abs ( ( ( Number ) value ) . doubleValue ( ) ) < Float . MIN_VALUE ) ? Boolean . FALSE : Boolean . TRUE ; } if ( value instanceof String ) { String strValue = ( ( String ) value ) . trim ( ) ; try { return ( Integer . parseInt ( strValue ) == 0 ) ? Boolean . FALSE : Boolean . TRUE ; } catch ( NumberFormatException e ) { strValue = strValue . toLowerCase ( ) ; if ( TRUE_STRINGS . contains ( strValue ) ) { return Boolean . TRUE ; } if ( FALSE_STRINGS . contains ( strValue ) ) { return Boolean . FALSE ; } } } throw new BeanMappingException ( "Unsupported-convert:-[" + String . class + "," + Boolean . class . getName ( ) + "]" ) ; } \n', 0.2470510587710113)

('public boolean implicitCast ( Type from , Type to ) throws ClassNotFound { if ( from == to ) return true ; int toTypeCode = to . getTypeCode ( ) ; switch ( from . getTypeCode ( ) ) { case TC_BYTE : if ( toTypeCode == TC_SHORT ) return true ; case TC_SHORT : case TC_CHAR : if ( toTypeCode == TC_INT ) return true ; case TC_INT : if ( toTypeCode == TC_LONG ) return true ; case TC_LONG : if ( toTypeCode == TC_FLOAT ) return true ; case TC_FLOAT : if ( toTypeCode == TC_DOUBLE ) return true ; case TC_DOUBLE : default : return false ; case TC_NULL : return to . inMask ( TM_REFERENCE ) ; case TC_ARRAY : if ( ! to . isType ( TC_ARRAY ) ) { return ( to == Type . tObject || to == Type . tCloneable || to == Type . tSerializable ) ; } else { do { from = from . getElementType ( ) ; to = to . getElementType ( ) ; } while ( from . isType ( TC_ARRAY ) && to . isType ( TC_ARRAY ) ) ; if ( from . inMask ( TM_ARRAY | TM_CLASS ) && to . inMask ( TM_ARRAY | TM_CLASS ) ) { return isMoreSpecific ( from , to ) ; } else { return ( from . getTypeCode ( ) == to . getTypeCode ( ) ) ; } } case TC_CLASS : if ( toTypeCode == TC_CLASS ) { ClassDefinition fromDef = getClassDefinition ( from ) ; ClassDefinition toDef = getClassDefinition ( to ) ; return toDef . implementedBy ( this , fromDef . getClassDeclaration ( ) ) ; } else { return false ; } } } \n', 0.24367630955371067)

('public static void testReadFromSkipPayload ( ) throws Exception { Message msg = new Message ( Util . createRandomAddress ( "A" ) , Util . createRandomAddress ( "B" ) , "bela" . getBytes ( ) ) ; addHeaders ( msg ) ; byte [ ] buf = Util . streamableToByteBuffer ( msg ) ; ByteArrayDataInputStream in = new ByteArrayDataInputStream ( buf ) ; Message msg2 = new Message ( false ) ; int payload_position = msg2 . readFromSkipPayload ( in ) ; msg2 . setBuffer ( buf , payload_position , buf . length - payload_position ) ; assert msg2 . getOffset ( ) == payload_position ; assert msg2 . getLength ( ) == msg . getLength ( ) ; assert msg2 . size ( ) == msg . size ( ) ; Message copy = msg2 . copy ( ) ; assert copy . getOffset ( ) == payload_position ; assert copy . getLength ( ) == msg . getLength ( ) ; assert copy . size ( ) == msg2 . size ( ) ; } \n', 0.23985180649376256)

('public boolean hasConverter ( Class template ) { boolean found = converters . keySet ( ) . contains ( template ) ; Iterator it = converters . values ( ) . iterator ( ) ; while ( ! found && it != null && it . hasNext ( ) ) { found = template . isAssignableFrom ( ( ( Converter ) it . next ( ) ) . convertsTo ( ) ) ; } return found ; } \n', 0.23099078414556606)

('public void testConvertsToTrue ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( trueValues . get ( 0 ) ) ; assertTrue ( result . booleanValue ( ) ) ; } \n', 0.23038202446570333)

('private void testSortDistinct ( boolean eliminateDuplicates ) throws Exception { int LOOP_SIZE = 1024 * 16 ; File tmpFile = Util . createTempFileDelOnExit ( "test" , "txt" ) ; PrintStream ps = new PrintStream ( new FileOutputStream ( tmpFile ) ) ; Random r = new Random ( ) ; for ( int i = 0 ; i < LOOP_SIZE ; i ++ ) { ps . println ( r . nextInt ( LOOP_SIZE / 2 ) + "-" + i ) ; } ps . close ( ) ; pigServer . registerQuery ( "A-=-LOAD-\'" + Util . generateURI ( tmpFile . toString ( ) , pigContext ) + "\';" ) ; if ( eliminateDuplicates ) { pigServer . registerQuery ( "B-=-DISTINCT-(FOREACH-A-GENERATE-$0)-PARALLEL-10;" ) ; } else { pigServer . registerQuery ( "B-=-ORDER-A-BY-$0-PARALLEL-10;" ) ; } Iterator < Tuple > iter = pigServer . openIterator ( "B" ) ; String last = "" ; HashSet < Integer > seen = new HashSet < Integer > ( ) ; if ( ! iter . hasNext ( ) ) Assert . fail ( "No-Results-obtained" ) ; while ( iter . hasNext ( ) ) { Tuple t = iter . next ( ) ; if ( eliminateDuplicates ) { Integer act = Integer . parseInt ( t . get ( 0 ) . toString ( ) ) ; Assert . assertFalse ( seen . contains ( act ) ) ; seen . add ( act ) ; } else { Assert . assertTrue ( last . compareTo ( t . get ( 0 ) . toString ( ) ) <= 0 ) ; Assert . assertEquals ( t . size ( ) , 2 ) ; last = t . get ( 0 ) . toString ( ) ; } } } \n', 0.2301914183651906)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('public static int convertToInt ( String str ) throws NumberFormatException { int s , e ; for ( s = 0 ; s < str . length ( ) ; s ++ ) if ( Character . isDigit ( str . charAt ( s ) ) ) break ; for ( e = str . length ( ) ; e > 0 ; e -- ) if ( Character . isDigit ( str . charAt ( e - 1 ) ) ) break ; if ( e > s ) { try { return Integer . parseInt ( str . substring ( s , e ) ) ; } catch ( NumberFormatException ex ) { Log . e ( "convertToInt" , ex ) ; throw new NumberFormatException ( ) ; } } else { throw new NumberFormatException ( ) ; } } \n', 0.3897049253959102)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.38881819720642374)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.37822569717556054)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.37820241142063793)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.3781016161063178)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.3772291174528063)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.3752796206086033)

('public static int convertToInteger ( String rawValue ) throws XMPException { try { if ( rawValue == null || rawValue . length ( ) == 0 ) { throw new XMPException ( "Empty-convert-string" , XMPError . BADVALUE ) ; } if ( rawValue . startsWith ( "0x" ) ) { return Integer . parseInt ( rawValue . substring ( 2 ) , 16 ) ; } else { return Integer . parseInt ( rawValue ) ; } } catch ( NumberFormatException e ) { throw new XMPException ( "Invalid-integer-string" , XMPError . BADVALUE ) ; } } \n', 0.37437199593690673)

('public static byte [ ] convertToFourBytes ( long numberToConvert ) { byte [ ] numInBytes = new byte [ 4 ] ; String s1 = Long . toHexString ( numberToConvert ) ; if ( s1 . length ( ) % 2 != 0 ) { s1 = "0" + s1 ; } if ( s1 . length ( ) == 16 ) { s1 = s1 . substring ( 8 , s1 . length ( ) ) ; } byte [ ] hexas = DatatypeConverter . parseHexBinary ( s1 ) ; if ( hexas . length == 1 ) { numInBytes [ 0 ] = 0 ; numInBytes [ 1 ] = 0 ; numInBytes [ 2 ] = 0 ; numInBytes [ 3 ] = hexas [ 0 ] ; } else if ( hexas . length == 2 ) { numInBytes [ 0 ] = 0 ; numInBytes [ 1 ] = 0 ; numInBytes [ 2 ] = hexas [ 0 ] ; numInBytes [ 3 ] = hexas [ 1 ] ; } else if ( hexas . length == 3 ) { numInBytes [ 0 ] = 0 ; numInBytes [ 1 ] = hexas [ 0 ] ; numInBytes [ 2 ] = hexas [ 1 ] ; numInBytes [ 3 ] = hexas [ 2 ] ; } else { numInBytes [ 0 ] = hexas [ 0 ] ; numInBytes [ 1 ] = hexas [ 1 ] ; numInBytes [ 2 ] = hexas [ 2 ] ; numInBytes [ 3 ] = hexas [ 3 ] ; } return numInBytes ; } \n', 0.36889671483747316)

('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; value = value . replaceAll ( "|," , "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( value ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( value ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( value ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( value ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( value ) ; } } catch ( NumberFormatException nfe ) { } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.365163486703839)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

('public static String convertToStringUTF8 ( byte [ ] byteArray ) throws UnsupportedEncodingException { return new String ( byteArray , UTF8_CHARSET ) ; } \n', 0.35874313678012715)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.34732607717293607)

('protected Character convertObjectToChar ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { if ( ( ( String ) sourceObject ) . length ( ) < 1 ) { return null ; } return new Character ( ( ( String ) sourceObject ) . charAt ( 0 ) ) ; } if ( sourceObject instanceof Number ) { return new Character ( ( char ) ( ( Number ) sourceObject ) . byteValue ( ) ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . CHAR ) ; } \n', 0.3419930522480763)

('public static byte [ ] convertToByteArray ( String s ) { try { return s . getBytes ( "UTF8" ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; throw new Error ( "Platform-doesn\'t-support-UTF8-encoding" ) ; } } \n', 0.3313940648771572)

('@ Override protected Byte convertObjectToByte ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToByte ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToByte ( sourceObject ) ; } \n', 0.3291214073557483)

('public String convertToJavaString ( byte [ ] sourceBytes , int offset , int numToConvert ) { return new String ( sourceBytes , offset , numToConvert , UTF8_CHARSET ) ; } \n', 0.32651840812862915)

('public static String convertToHexString ( byte [ ] toBeConverted ) { if ( toBeConverted == null ) { throw new NullPointerException ( "Parameter-to-be-converted-can-not-be-null" ) ; } char [ ] converted = new char [ toBeConverted . length * 2 ] ; for ( int i = 0 ; i < toBeConverted . length ; i ++ ) { byte b = toBeConverted [ i ] ; converted [ i * 2 ] = HEX_CHARS [ b >> 4 & 0x0F ] ; converted [ i * 2 + 1 ] = HEX_CHARS [ b & 0x0F ] ; } return String . valueOf ( converted ) ; } \n', 0.3262108365654625)

('public static String convertToString ( final int numberToConvert , final int base ) { int number = numberToConvert ; final char [ ] buffer = new char [ ( numberToConvert / ALPHABET_CHARS . length ) + 1 ] ; int charPosition = buffer . length - 1 ; if ( number == 0 ) { buffer [ charPosition -- ] = ALPHABET_CHARS [ number ] ; } else { while ( number > 0 ) { buffer [ charPosition -- ] = ALPHABET_CHARS [ number % base ] ; number /= base ; } } return new String ( buffer , charPosition + 1 , buffer . length - charPosition - 1 ) ; } \n', 0.3259423484420169)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.32247379670813014)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('private boolean checkBlob ( byte [ ] retrBytes ) throws Exception { boolean passed = false ; BufferedInputStream bIn = new BufferedInputStream ( new FileInputStream ( testBlobFile ) ) ; try { int fileLength = ( int ) testBlobFile . length ( ) ; if ( retrBytes . length == fileLength ) { for ( int i = 0 ; i < fileLength ; i ++ ) { byte fromFile = ( byte ) ( bIn . read ( ) & 0xff ) ; if ( retrBytes [ i ] != fromFile ) { passed = false ; System . out . println ( "Byte-pattern-differed-at-position-" + i + "-,-" + retrBytes [ i ] + "-!=-" + fromFile ) ; for ( int j = 0 ; ( j < ( i + 10 ) ) ; j ++ ) { System . out . print ( Integer . toHexString ( retrBytes [ j ] & 0xff ) + "-" ) ; } break ; } passed = true ; } } else { passed = false ; System . out . println ( "retrBytes.length(" + retrBytes . length + ")-!=-testBlob.length(" + fileLength + ")" ) ; } return passed ; } finally { if ( bIn != null ) { bIn . close ( ) ; } } } \n', 0.24401992126419164)

('@ Deprecated protected void createFileIfNotExist ( String fileContents , String fileName ) throws TeEngineMlException { File file = new File ( fileName ) ; boolean toCreate = true ; if ( file . exists ( ) ) if ( file . isFile ( ) ) toCreate = false ; if ( toCreate ) { try { PrintWriter printWriter = new PrintWriter ( file ) ; try { printWriter . println ( fileContents ) ; } finally { if ( printWriter != null ) printWriter . close ( ) ; } } catch ( IOException e ) { throw new TeEngineMlException ( "Could-not-create-file:-" + fileName + ".-See-nested-exception" , e ) ; } } } \n', 0.2379019872330059)

('private void doUploadDownloadFileTest ( CloudFile file , int fileSize ) throws IOException , StorageException { File sourceFile = File . createTempFile ( "sourceFile" , ".tmp" ) ; File destinationFile = new File ( sourceFile . getParentFile ( ) , "destinationFile.tmp" ) ; try { byte [ ] buffer = FileTestHelper . getRandomBuffer ( fileSize ) ; java . io . FileOutputStream fos = new java . io . FileOutputStream ( sourceFile ) ; fos . write ( buffer ) ; fos . close ( ) ; file . uploadFromFile ( sourceFile . getAbsolutePath ( ) ) ; file . downloadToFile ( destinationFile . getAbsolutePath ( ) ) ; assertTrue ( "Destination-file-does-not-exist." , destinationFile . exists ( ) ) ; assertEquals ( "Destination-file-does-not-match-input-file." , fileSize , destinationFile . length ( ) ) ; java . io . FileInputStream fis = new java . io . FileInputStream ( destinationFile ) ; byte [ ] readBuffer = new byte [ fileSize ] ; fis . read ( readBuffer ) ; fis . close ( ) ; for ( int i = 0 ; i < fileSize ; i ++ ) { assertEquals ( "File-contents-do-not-match." , buffer [ i ] , readBuffer [ i ] ) ; } } finally { if ( sourceFile . exists ( ) ) { sourceFile . delete ( ) ; } if ( destinationFile . exists ( ) ) { destinationFile . delete ( ) ; } } } \n', 0.2325002401121551)

('private void checkFile ( ) throws IOException { boolean writeHeader = false ; if ( ! res . exists ( ) ) { res . createFile ( true ) ; writeHeader = true ; } else if ( res . length ( ) == 0 ) { writeHeader = true ; } else if ( res . length ( ) > maxFileSize ) { Resource parent = res . getParentResource ( ) ; String name = res . getName ( ) ; for ( int i = maxFiles ; i > 0 ; i -- ) { Resource to = parent . getRealResource ( name + "." + i + ".bak" ) ; Resource from = parent . getRealResource ( name + "." + ( i - 1 ) + ".bak" ) ; if ( from . exists ( ) ) { if ( to . exists ( ) ) to . delete ( ) ; from . renameTo ( to ) ; } } res . renameTo ( parent . getRealResource ( name + ".1.bak" ) ) ; res = parent . getRealResource ( name ) ; res . createNewFile ( ) ; writeHeader = true ; } if ( writeHeader ) { writeHeader = false ; write ( LogUtil . getHeader ( ) ) ; } } \n', 0.2311131011741721)

('private void doUploadDownloadFileTest ( CloudBlockBlob blob , int fileSize ) throws IOException , StorageException { File sourceFile = File . createTempFile ( "sourceFile" , ".tmp" ) ; File destinationFile = new File ( sourceFile . getParentFile ( ) , "destinationFile.tmp" ) ; try { byte [ ] buffer = BlobTestHelper . getRandomBuffer ( fileSize ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; fos . write ( buffer ) ; fos . close ( ) ; blob . uploadFromFile ( sourceFile . getAbsolutePath ( ) ) ; blob . downloadToFile ( destinationFile . getAbsolutePath ( ) ) ; assertTrue ( "Destination-file-does-not-exist." , destinationFile . exists ( ) ) ; assertEquals ( "Destination-file-does-not-match-input-file." , fileSize , destinationFile . length ( ) ) ; FileInputStream fis = new FileInputStream ( destinationFile ) ; byte [ ] readBuffer = new byte [ fileSize ] ; fis . read ( readBuffer ) ; fis . close ( ) ; for ( int i = 0 ; i < fileSize ; i ++ ) { assertEquals ( "File-contents-do-not-match." , buffer [ i ] , readBuffer [ i ] ) ; } } finally { if ( sourceFile . exists ( ) ) { sourceFile . delete ( ) ; } if ( destinationFile . exists ( ) ) { destinationFile . delete ( ) ; } } } \n', 0.22648871359511907)

('private void doUploadDownloadFileTest ( CloudPageBlob blob , int fileSize ) throws IOException , StorageException { File sourceFile = File . createTempFile ( "sourceFile" , ".tmp" ) ; File destinationFile = new File ( sourceFile . getParentFile ( ) , "destinationFile.tmp" ) ; try { byte [ ] buffer = BlobTestHelper . getRandomBuffer ( fileSize ) ; FileOutputStream fos = new FileOutputStream ( sourceFile ) ; fos . write ( buffer ) ; fos . close ( ) ; blob . uploadFromFile ( sourceFile . getAbsolutePath ( ) ) ; blob . downloadToFile ( destinationFile . getAbsolutePath ( ) ) ; assertTrue ( "Destination-file-does-not-exist." , destinationFile . exists ( ) ) ; assertEquals ( "Destination-file-does-not-match-input-file." , fileSize , destinationFile . length ( ) ) ; FileInputStream fis = new FileInputStream ( destinationFile ) ; byte [ ] readBuffer = new byte [ fileSize ] ; fis . read ( readBuffer ) ; fis . close ( ) ; for ( int i = 0 ; i < fileSize ; i ++ ) { assertEquals ( "File-contents-do-not-match." , buffer [ i ] , readBuffer [ i ] ) ; } } finally { if ( sourceFile . exists ( ) ) { sourceFile . delete ( ) ; } if ( destinationFile . exists ( ) ) { destinationFile . delete ( ) ; } } } \n', 0.22648871359511907)

('private Class < ? > loadClassFromFile ( File classFile ) throws NoClassDefFoundError { int classFileLength = ( int ) classFile . length ( ) ; byte [ ] classFileContent = new byte [ classFileLength ] ; readFileContent ( classFile , classFileContent ) ; String binaryClassName = classFile . getName ( ) . substring ( 0 , classFile . getName ( ) . lastIndexOf ( "." ) ) ; try { return super . loadClass ( binaryClassName ) ; } catch ( ClassNotFoundException cnfe ) { } File parentDirectory = classFile ; while ( true ) { if ( nameToClassMapper . containsKey ( binaryClassName ) ) { return nameToClassMapper . get ( binaryClassName ) ; } try { Class < ? > definedClass = defineClass ( binaryClassName , classFileContent , 0 , classFileLength ) ; nameToClassMapper . put ( binaryClassName , definedClass ) ; return definedClass ; } catch ( NoClassDefFoundError error ) { parentDirectory = parentDirectory . getParentFile ( ) ; if ( parentDirectory == null ) { throw new NoClassDefFoundError ( "Class-file-" + classFile . getName ( ) + "-is-not-located-in-proper-directory-structure." ) ; } binaryClassName = parentDirectory . getName ( ) + "." + binaryClassName ; } } } \n', 0.22125528925886667)

('private void copyJarEntryToFile ( final String jarFileName , final File destinationFolder , final JarEntry jarEntry ) throws IOException , FileNotFoundException { String name = jarEntry . getName ( ) ; if ( this . includeJavaClientClassesInWebServerResources == null || this . includeJavaClientClassesInWebServerResources . booleanValue ( ) == false ) { String prefix = "WebServerResources/Java" ; if ( name . startsWith ( prefix ) ) { return ; } } String destinationFolderWithPathFromJarEntry = destinationFolder + File . separator + name . substring ( 0 , name . lastIndexOf ( \'/\' ) ) ; String destinationName = name . substring ( name . lastIndexOf ( \'/\' ) + 1 ) ; File file = new File ( destinationFolderWithPathFromJarEntry , destinationName ) ; if ( ! file . getParentFile ( ) . exists ( ) ) { file . getParentFile ( ) . mkdirs ( ) ; } file . createNewFile ( ) ; InputStream is = null ; OutputStream os = null ; try { is = new JarFile ( jarFileName ) . getInputStream ( jarEntry ) ; os = new FileOutputStream ( file ) ; byte [ ] buf = new byte [ 1024 ] ; int len ; while ( ( len = is . read ( buf ) ) > 0 ) { os . write ( buf , 0 , len ) ; } } finally { if ( is != null ) { is . close ( ) ; } if ( os != null ) { os . close ( ) ; } } } \n', 0.22006221814327656)

('private boolean isUpToDateShallow ( int inputHash , Environment env ) throws IOException { if ( hasPersistentVersionChanged ( ) ) return false ; if ( hasSourceFileChanged ( inputHash ) ) return false ; if ( desugaringsFile != null && ! FileCommands . exists ( desugaringsFile ) ) return false ; for ( Entry < Path , Integer > entry : generatedFileHashes . entrySet ( ) ) if ( FileCommands . fileHash ( entry . getKey ( ) ) != entry . getValue ( ) ) return false ; for ( Entry < RelativePath , Integer > entry : dependingFileHashes . entrySet ( ) ) if ( FileCommands . fileHash ( entry . getKey ( ) ) != entry . getValue ( ) ) return false ; for ( Entry < Path , Integer > entry : dependencies . entrySet ( ) ) if ( FileCommands . fileHash ( entry . getKey ( ) ) != entry . getValue ( ) ) return false ; return true ; } \n', 0.21766568071923403)

("private void testFile ( Path inPath , Path outPath , DataConverter converter , DecisionForest forest , Dataset dataset , List < double [ ] > results , Random rng ) throws IOException { FSDataOutputStream ofile = null ; if ( outPath != null ) { ofile = outFS . create ( outPath ) ; } FSDataInputStream input = dataFS . open ( inPath ) ; try { Scanner scanner = new Scanner ( input ) ; while ( scanner . hasNextLine ( ) ) { String line = scanner . nextLine ( ) ; if ( line . isEmpty ( ) ) { continue ; } Instance instance = converter . convert ( line ) ; double prediction = forest . classify ( dataset , rng , instance ) ; if ( ofile != null ) { ofile . writeChars ( Double . toString ( prediction ) ) ; ofile . writeChar ( '|n' ) ; } results . add ( new double [ ] { dataset . getLabel ( instance ) , prediction } ) ; } scanner . close ( ) ; } finally { Closeables . closeQuietly ( input ) ; } } \n", 0.21194300624429194)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('@ Override protected String convertToString ( final Object value ) throws Throwable { Date date = null ; if ( value instanceof Date ) { date = ( Date ) value ; } else if ( value instanceof Calendar ) { date = ( ( Calendar ) value ) . getTime ( ) ; } else if ( value instanceof Long ) { date = new Date ( ( ( Long ) value ) . longValue ( ) ) ; } String result = null ; if ( this . useLocaleFormat && date != null ) { DateFormat format = null ; if ( this . patterns != null && this . patterns . length > 0 ) { format = this . getFormat ( this . patterns [ 0 ] ) ; } else { format = this . getFormat ( this . locale , this . timeZone ) ; } result = format . format ( date ) ; } else { result = value . toString ( ) ; } return result ; } \n', 0.3761257961436767)

('public static String convertDateToXSDString ( Date date ) { if ( date == null ) { return null ; } StringBuilder lexicalForm ; String dateTime = convertDateToString ( date , true ) ; int len = dateTime . length ( ) - 1 ; if ( dateTime . indexOf ( \'.\' , len - 4 ) != - 1 ) { while ( dateTime . charAt ( len - 1 ) == \'0\' ) { len -- ; } if ( dateTime . charAt ( len - 1 ) == \'.\' ) { len -- ; } lexicalForm = new StringBuilder ( dateTime . substring ( 0 , len ) ) ; lexicalForm . append ( \'Z\' ) ; } else { lexicalForm = new StringBuilder ( dateTime ) ; } if ( date . before ( ONE_CE ) ) { DateFormat df = new SimpleDateFormat ( "yyyy" ) ; df . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; StringBuilder year = new StringBuilder ( String . valueOf ( Integer . parseInt ( df . format ( date ) ) - 1 ) ) ; while ( year . length ( ) < 4 ) { year . insert ( 0 , \'0\' ) ; } lexicalForm . replace ( 0 , lexicalForm . indexOf ( "-" , 4 ) , year . toString ( ) ) ; if ( date . before ( ONE_BCE ) ) { lexicalForm . insert ( 0 , "-" ) ; } } return lexicalForm . toString ( ) ; } \n', 0.37342337307003537)

('@ Override protected String convertToString ( Object value ) throws Throwable { Date date = null ; if ( value instanceof Date ) { date = ( Date ) value ; } else if ( value instanceof Calendar ) { date = ( ( Calendar ) value ) . getTime ( ) ; } else if ( value instanceof Long ) { date = new Date ( ( ( Long ) value ) . longValue ( ) ) ; } String result = null ; if ( useLocaleFormat && date != null ) { DateFormat format = null ; if ( patterns != null && patterns . length > 0 ) { format = getFormat ( patterns [ 0 ] ) ; } else { format = getFormat ( locale , timeZone ) ; } logFormat ( "Formatting" , format ) ; result = format . format ( date ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-format-\'" + result + "\'" ) ; } } else { result = value . toString ( ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-toString()-\'" + result + "\'" ) ; } } return result ; } \n', 0.366592157692203)

("private Date convertToDefaultDate ( String value ) throws ParseException { DateFormat df = SearchUtils . getDateFormat ( contextProperties ) ; String dateValue = value ; if ( SearchUtils . isTimeZoneSupported ( contextProperties , Boolean . FALSE ) ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx != - 1 ) { dateValue = value . substring ( 0 , idx ) + value . substring ( idx + 1 ) ; } } return df . parse ( dateValue ) ; } \n", 0.36656608647432554)

('private long convertExpirationTimeToSeconds ( String expirationTimeString , TimeUnitConfig . Enum timeUnit ) throws IllegalArgumentException { long expirationTime ; try { expirationTime = Long . valueOf ( expirationTimeString . trim ( ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Manual-expiration-time-cannot-be-parsed-due-to-invalid-characters." + "Please-review-it-and-make-sure-it-is-set-correctly." , e ) ; } if ( timeUnit . equals ( TimeUnitConfig . HOURS ) ) { return expirationTime * 3600 ; } else if ( timeUnit . equals ( TimeUnitConfig . MINUTES ) ) { return expirationTime * 60 ; } else { return expirationTime ; } } \n', 0.3654149403868622)

('public static long convertToMillis ( String valueToConvert ) throws NumberFormatException { valueToConvert = valueToConvert . trim ( ) ; String timeVal = valueToConvert . toLowerCase ( ) ; int index = 0 ; float factor = 1.0f ; if ( timeVal . endsWith ( "us" ) ) { factor = 0.001f ; index = timeVal . indexOf ( "us" ) ; } else if ( timeVal . endsWith ( "ms" ) ) { factor = 1.0f ; index = timeVal . indexOf ( "ms" ) ; } else if ( timeVal . endsWith ( "s" ) ) { factor = 1000.0f ; index = timeVal . indexOf ( \'s\' ) ; } else if ( timeVal . endsWith ( "m" ) ) { factor = 1000.0f * 60.0f ; index = timeVal . indexOf ( \'m\' ) ; } else if ( timeVal . endsWith ( "h" ) ) { factor = 1000.0f * 60.0f * 60.0f ; index = timeVal . indexOf ( \'h\' ) ; } else if ( timeVal . endsWith ( "d" ) ) { factor = 1000.0f * 60.0f * 60.0f * 24.0f ; index = timeVal . indexOf ( \'d\' ) ; } if ( index == 0 ) { index = timeVal . length ( ) ; } Float fVal = new Float ( timeVal . substring ( 0 , index ) ) ; return ( ( long ) ( fVal . floatValue ( ) * factor ) ) ; } \n', 0.36015567853597297)

('public Object convertToDatabaseType ( Object value ) { if ( value == null ) { return null ; } if ( value . getClass ( ) == ClassConstants . UTILDATE ) { return Helper . timestampFromDate ( ( java . util . Date ) value ) ; } else if ( value instanceof Character ) { return ( ( Character ) value ) . toString ( ) ; } else if ( value instanceof Calendar ) { return Helper . timestampFromDate ( ( ( Calendar ) value ) . getTime ( ) ) ; } else if ( value instanceof BigInteger ) { return new BigDecimal ( ( BigInteger ) value ) ; } else if ( value instanceof char [ ] ) { return new String ( ( char [ ] ) value ) ; } else if ( value instanceof Character [ ] ) { return convertObject ( value , ClassConstants . STRING ) ; } else if ( value instanceof Byte [ ] ) { return convertObject ( value , ClassConstants . APBYTE ) ; } return value ; } \n', 0.35297480233823686)

('@ Override public byte [ ] convertToNoSqlImpl ( Object value ) { LocalDate dt = ( LocalDate ) value ; long milliseconds = dt . toDate ( ) . getTime ( ) ; return StandardConverters . convertToBytes ( milliseconds ) ; } \n', 0.34492528946028495)

('private double localDateToDouble ( final LocalDate date ) { String dateAsIntText = Integer . toString ( LocalDateToIntConverter . convertToInt ( date ) ) ; return Double . parseDouble ( dateAsIntText ) ; } \n', 0.3425653619993803)

('public Date convertBsToAd ( String bsDate ) { int bsYear = 0 , bsMonth = 0 , bsDayOfMonth = 0 ; if ( separator == null ) { if ( ! matchFormat ( bsDate ) ) { throw new InvalidDateFormat ( "incorrect-date-format-" + format + "-date-provided-was-" + bsDate ) ; } bsDayOfMonth = Integer . parseInt ( bsDate . substring ( 0 , 2 ) ) ; bsMonth = Integer . parseInt ( bsDate . substring ( 2 , 4 ) ) ; bsYear = Integer . parseInt ( bsDate . substring ( 4 ) ) ; } else { String [ ] bsDates = bsDate . split ( separator ) ; bsYear = Integer . parseInt ( bsDates [ 0 ] ) ; bsMonth = Integer . parseInt ( bsDates [ 1 ] ) ; bsDayOfMonth = Integer . parseInt ( bsDates [ 2 ] ) ; } int lookupIndex = getLookupIndex ( bsYear ) ; if ( validateBsDate ( bsYear , bsMonth , bsDayOfMonth ) ) { return convertBsToAd ( bsDate , bsMonth , bsDayOfMonth , lookupIndex ) ; } else { throw new IllegalStateException ( "invalid-BS-date" ) ; } } \n', 0.3414823003548005)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('@ Converter public static byte [ ] convertToByteArray ( StreamCache cache , Exchange exchange ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; cache . writeTo ( os ) ; return os . toByteArray ( ) ; } \n', 0.39872405219597484)

('public static byte [ ] convertToByteArray ( String s ) { try { return s . getBytes ( "UTF8" ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; throw new Error ( "Platform-doesn\'t-support-UTF8-encoding" ) ; } } \n', 0.36438375589623284)

('public static int [ ] convertBytesToInts ( byte [ ] bytes ) { try { int nInts = bytes . length / ( Integer . SIZE / 8 ) ; int [ ] ints = new int [ nInts ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nInts ; i ++ ) { if ( dis . available ( ) >= ( Integer . SIZE / 8 ) ) { ints [ i ] = dis . readInt ( ) ; } } dis . close ( ) ; return ints ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.36362471116465367)

('public static byte [ ] convertStringsToByteArray ( final String ... values ) throws IOException { final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; try { for ( String value : values ) { final byte [ ] valueAsBytes = value . getBytes ( Charset . forName ( "UTF-8" ) ) ; stream . write ( ByteBuffer . allocate ( 4 ) . putInt ( valueAsBytes . length ) . array ( ) ) ; stream . write ( valueAsBytes ) ; } return stream . toByteArray ( ) ; } finally { stream . close ( ) ; } } \n', 0.36095374919080353)

('public static long [ ] convertBytesToLongs ( byte [ ] bytes ) { try { int nLongs = bytes . length / ( Long . SIZE / 8 ) ; long [ ] longs = new long [ nLongs ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nLongs ; i ++ ) { if ( dis . available ( ) >= ( Long . SIZE / 8 ) ) { longs [ i ] = dis . readLong ( ) ; } } dis . close ( ) ; return longs ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.3605742858137524)

('protected byte [ ] convertObjectToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof byte [ ] ) { return ( byte [ ] ) sourceObject ; } else if ( sourceObject instanceof Byte [ ] ) { Byte [ ] objectBytes = ( Byte [ ] ) sourceObject ; byte [ ] bytes = new byte [ objectBytes . length ] ; for ( int index = 0 ; index < objectBytes . length ; index ++ ) { bytes [ index ] = objectBytes [ index ] . byteValue ( ) ; } return bytes ; } else if ( sourceObject instanceof String ) { return Helper . buildBytesFromHexString ( ( String ) sourceObject ) ; } else if ( sourceObject instanceof Blob ) { Blob blob = ( Blob ) sourceObject ; try { return blob . getBytes ( 1L , ( int ) blob . length ( ) ) ; } catch ( SQLException exception ) { throw DatabaseException . sqlException ( exception ) ; } } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . APBYTE ) ; } \n', 0.3588265906290626)

('private byte [ ] convertIntoTempByteArray ( byte [ ] input ) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Reader reader = new InputStreamReader ( bais ) ; BufferedReader breader = new BufferedReader ( reader ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( true ) { String line = breader . readLine ( ) ; if ( line != null ) { String [ ] replacement = lineConverter . getReplacement ( line ) ; writeReplacement ( baos , replacement ) ; } else { break ; } } return baos . toByteArray ( ) ; } \n', 0.35572394153126585)

('public byte [ ] convertToBytes ( DataHandler dh ) throws IOException { InputStream is = dh . getInputStream ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { int read = 0 ; byte [ ] bytes = new byte [ 1024 ] ; while ( ( read = is . read ( bytes ) ) != - 1 ) { baos . write ( bytes , 0 , read ) ; } } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception e ) { LOG . error ( "Could-not-close-input-stream-:-" + e . getMessage ( ) ) ; } } } return baos . toByteArray ( ) ; } \n', 0.35141268588424246)

('public static short convertBytesToShort ( byte [ ] array , int offset ) { return convertBytesToShort ( array [ offset + 1 ] , array [ offset ] ) ; } \n', 0.3495781017278845)

('public static float [ ] convertBytesToFloats ( byte [ ] bytes ) { try { int nFloats = bytes . length / ( Float . SIZE / 8 ) ; float [ ] floats = new float [ nFloats ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nFloats ; i ++ ) { if ( dis . available ( ) >= ( Float . SIZE / 8 ) ) { floats [ i ] = dis . readFloat ( ) ; } } dis . close ( ) ; return floats ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.34885908596597914)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('public static Converter < Integer > getIntegerConverter ( ) { if ( integerConverter == null ) { integerConverter = new Converter < Integer > ( ) { public Integer convert ( Object o ) { return ( o != null ) ? Integer . valueOf ( o . toString ( ) ) : 0 ; } public String serialize ( Object o ) { return ( o != null ) ? o . toString ( ) : "" ; } } ; } return integerConverter ; } \n', 0.26555668849497804)

('public static Boolean convertStringToBoolean ( String s ) { if ( s == null ) { String message = Logging . getMessage ( "nullValue.StringIsNull" ) ; Logging . logger ( ) . severe ( message ) ; throw new IllegalArgumentException ( message ) ; } try { s = s . trim ( ) ; if ( s . length ( ) == 0 ) return null ; if ( s . length ( ) == 1 ) return convertNumericStringToBoolean ( s ) ; return Boolean . valueOf ( s ) ; } catch ( NumberFormatException e ) { String message = Logging . getMessage ( "generic.ConversionError" , s ) ; Logging . logger ( ) . log ( java . util . logging . Level . SEVERE , message , e ) ; return null ; } } \n', 0.2594232119317943)

('protected Boolean convertObjectToBoolean ( Object sourceObject ) { if ( sourceObject instanceof Character ) { switch ( Character . toLowerCase ( ( ( Character ) sourceObject ) . charValue ( ) ) ) { case \'1\' : case \'t\' : return Boolean . TRUE ; case \'0\' : case \'f\' : return Boolean . FALSE ; } } if ( sourceObject instanceof String ) { String stringValue = ( ( String ) sourceObject ) . toLowerCase ( ) ; if ( stringValue . equals ( "t" ) || stringValue . equals ( "true" ) || stringValue . equals ( "1" ) ) { return Boolean . TRUE ; } else if ( stringValue . equals ( "f" ) || stringValue . equals ( "false" ) || stringValue . equals ( "0" ) ) { return Boolean . FALSE ; } } if ( sourceObject instanceof Number ) { int intValue = ( ( Number ) sourceObject ) . intValue ( ) ; if ( intValue != 0 ) { return Boolean . TRUE ; } else if ( intValue == 0 ) { return Boolean . FALSE ; } } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . BOOLEAN ) ; } \n', 0.25312595190361065)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.2417559716453611)

('public void testUpperCaseStringConvertsToTrue ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) trueValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertTrue ( result . booleanValue ( ) ) ; } \n', 0.24144773237767703)

('public void testUpperCaseStringConvertsToFalse ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) falseValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertFalse ( result . booleanValue ( ) ) ; } \n', 0.23655422436851445)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.22597026876512916)

('private static Object coerce ( CommandSession session , Class < ? > type , Object arg , int [ ] convert ) { if ( arg == null ) { return null ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) ) { return arg ; } if ( type . isArray ( ) ) { return NO_MATCH ; } if ( type . isPrimitive ( ) && arg instanceof Long ) { Number num = ( Number ) arg ; if ( type == short . class ) { return num . shortValue ( ) ; } if ( type == int . class ) { return num . intValue ( ) ; } if ( type == long . class ) { return num . longValue ( ) ; } } convert [ 0 ] += 2 ; Object converted = session . convert ( type , arg ) ; if ( converted != null ) { return converted ; } String string = arg . toString ( ) ; if ( type . isAssignableFrom ( String . class ) ) { return string ; } if ( type . isPrimitive ( ) ) { type = primitiveToObject ( type ) ; } try { return type . getConstructor ( String . class ) . newInstance ( string ) ; } catch ( Exception e ) { } if ( type == Character . class && string . length ( ) == 1 ) { return string . charAt ( 0 ) ; } return NO_MATCH ; } \n', 0.21639947378992894)

('@ Override public Object extractValueFromBytes ( int offset , byte [ ] bytes ) { Long val = endianConverter . convertNumber ( offset , bytes , 4 ) ; if ( val == null ) { return null ; } else { return Float . intBitsToFloat ( val . intValue ( ) ) ; } } \n', 0.21407391630450046)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.21174524932748867)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

('private Serializable copyObject ( Serializable o ) throws RemoteException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; byte [ ] ba = bos . toByteArray ( ) ; Method m = IxcRegistryImpl . getIxcClassLoader ( importer ) . getDeserializeMethod ( ) ; return ( Serializable ) m . invoke ( null , new Object [ ] { ba } ) ; } catch ( RemoteException ex ) { throw ex ; } catch ( Exception ex ) { throw new RemoteException ( "Cannot-copy-object" , ex ) ; } } \n', 0.40537060398417707)

('@ XmlElementDecl ( namespace = AMZN_NS , name = "CopyObject" ) public JAXBElement < CopyObject > createCopyObject ( CopyObject r ) { return Util . createGeneric ( r , CopyObject . class ) ; } \n', 0.40423278690176023)

('@ SuppressWarnings ( "unchecked" ) public static < T > T copyInstance ( T src ) { if ( src == null ) { throw new NullPointerException ( "src-cannot-be-null" ) ; } T copyInstance = null ; Class < T > srcClass = ( Class < T > ) src . getClass ( ) ; PropertyDescriptor [ ] props = retrievePropertyDescriptors ( srcClass ) ; try { copyInstance = ( T ) srcClass . newInstance ( ) ; for ( PropertyDescriptor pd : props ) { Method rm = pd . getReadMethod ( ) ; Method wm = pd . getWriteMethod ( ) ; if ( wm != null && rm != null ) { wm . invoke ( copyInstance , rm . invoke ( src ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return copyInstance ; } \n', 0.39487107591654114)

('public static < T > T copyObject ( final Class < T > clazz , final T sourceObject ) { try { final byte [ ] byteArray = toByteArray ( sourceObject ) ; return fromByteArray ( clazz , byteArray ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can-not-copy-" , e ) ; } } \n', 0.3917783189621187)

('public static Object deepCopy ( Object src ) throws InstantiationException , IllegalAccessException { Class < ? > clazz = src . getClass ( ) ; if ( Modifier . isFinal ( clazz . getModifiers ( ) ) ) { return src ; } Object dst = clazz . newInstance ( ) ; if ( src instanceof Calendar ) { ( ( Calendar ) dst ) . setTimeInMillis ( ( ( Calendar ) src ) . getTimeInMillis ( ) ) ; return dst ; } Field [ ] fields = clazz . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Object fObj = fields [ i ] . get ( src ) ; if ( fObj == null ) { continue ; } Class < ? > fRealType = fObj . getClass ( ) ; if ( ( ! fRealType . isPrimitive ( ) ) || ( ! fRealType . isEnum ( ) ) || fRealType . getPackage ( ) != JAVA_LANG_PKG ) { if ( fRealType . isArray ( ) ) { Object [ ] items = ( Object [ ] ) fObj ; fObj = Array . newInstance ( fRealType . getComponentType ( ) , items . length ) ; for ( int j = 0 ; j < items . length ; j ++ ) { Array . set ( fObj , j , deepCopy ( items [ j ] ) ) ; } } else { fObj = deepCopy ( fObj ) ; } } fields [ i ] . set ( dst , fObj ) ; } return dst ; } \n', 0.3884000434864907)

('public Object copyToNDJavaArray ( ) { Object javaArray ; try { javaArray = java . lang . reflect . Array . newInstance ( getElementType ( ) , getShape ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } IndexIterator iter = getIndexIterator ( ) ; reflectArrayCopyOut ( javaArray , this , iter ) ; return javaArray ; } \n', 0.3871508605741164)

('public static Object copyOf ( Object src ) { int srcLength = Array . getLength ( src ) ; Class < ? > srcComponentType = src . getClass ( ) . getComponentType ( ) ; Object dest = Array . newInstance ( srcComponentType , srcLength ) ; if ( srcComponentType . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( src ) ; i ++ ) { Array . set ( dest , i , copyOf ( Array . get ( src , i ) ) ) ; } } else { System . arraycopy ( src , 0 , dest , 0 , srcLength ) ; } return dest ; } \n', 0.3835520166607283)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('private void setRunTime ( Method method , Object target ) { if ( BaseRunTimer . isActive ( ) ) { long runningTime = System . currentTimeMillis ( ) - startTime ; BaseRunTimer . addTimer ( target . getClass ( ) . getName ( ) + "." + method . getName ( ) + "-run-" + runningTime + "-ms" ) ; } } \n', 0.3471635881988181)

('@ SuppressWarnings ( "unchecked" ) public static < T extends Iface > T recordMethodCallsAndAverageTimes ( final BlurMetrics metrics , final T t , Class < T > clazz ) { InvocationHandler handler = new InvocationHandler ( ) { @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { long start = System . nanoTime ( ) ; try { return method . invoke ( t , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } finally { long end = System . nanoTime ( ) ; MethodCall methodCall = metrics . methodCalls . get ( method . getName ( ) ) ; if ( methodCall == null ) { methodCall = new MethodCall ( ) ; metrics . methodCalls . put ( method . getName ( ) , methodCall ) ; } methodCall . invokes . incrementAndGet ( ) ; methodCall . times . addAndGet ( end - start ) ; } } } ; return ( T ) Proxy . newProxyInstance ( clazz . getClassLoader ( ) , new Class [ ] { clazz } , handler ) ; } \n', 0.3466681026219154)

('private void doTimedObjectProcessing ( Class ejbClass , EjbDescriptor ejbDesc ) { MethodDescriptor timeoutMethodDesc = null ; Class nextClass = ejbClass ; while ( ( nextClass != Object . class ) && ( nextClass != null ) && ( timeoutMethodDesc == null ) ) { Method [ ] methods = nextClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( ( m . getAnnotation ( Timeout . class ) != null ) ) { timeoutMethodDesc = new MethodDescriptor ( m , MethodDescriptor . TIMER_METHOD ) ; break ; } } nextClass = nextClass . getSuperclass ( ) ; } if ( ( timeoutMethodDesc == null ) && javax . ejb . TimedObject . class . isAssignableFrom ( ejbClass ) ) { timeoutMethodDesc = new MethodDescriptor ( "ejbTimeout" , "@Timeout-method" , new String [ ] { "javax.ejb.Timer" } , MethodDescriptor . TIMER_METHOD ) ; } if ( timeoutMethodDesc != null ) { ejbDesc . setEjbTimeoutMethod ( timeoutMethodDesc ) ; } return ; } \n', 0.3357506067777899)

('public static BenchmarkMethod createBenchmarkMethodFromTimeMethod ( BenchmarkClass benchmarkClass , Method timeMethod ) throws InvalidBenchmarkException { checkArgument ( isTimeMethod ( timeMethod ) ) ; if ( ! Arrays . equals ( timeMethod . getParameterTypes ( ) , new Class < ? > [ ] { int . class } ) ) { throw new InvalidBenchmarkException ( "Microbenchmark-methods-must-accept-a-single-int-parameter:-" + timeMethod . getName ( ) ) ; } if ( Util . isStatic ( timeMethod ) ) { throw new InvalidBenchmarkException ( "Microbenchmark-methods-must-not-be-static:-" + timeMethod . getName ( ) ) ; } String methodName = timeMethod . getName ( ) ; String shortName = methodName . substring ( "time" . length ( ) ) ; return new BenchmarkMethod ( benchmarkClass , timeMethod , shortName ) ; } \n', 0.33549803175228066)

('private static void executeViaReflection ( Order orderObject , int itrCount ) throws Exception { Method orderIdMethod = Order . class . getMethod ( functionToCall ) ; long start ; start = System . currentTimeMillis ( ) ; for ( int cnt = 0 ; cnt < itrCount ; cnt ++ ) { orderIdMethod . invoke ( orderObject ) ; } System . out . println ( String . format ( "%s-Function-Call-for-%s-calls-took-%s(ms)" , "Reflection" , itrCount , ( System . currentTimeMillis ( ) - start ) ) ) ; } \n', 0.3250837823649798)

('public long getExecutionTime ( ) { if ( _executeMultiple . get ( ) == false ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('public long getExecutionTime ( ) { if ( ! _executeMultiple . get ( ) ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('protected Date getBuildStartTime ( ) { try { Method getRequestMethod = session . getClass ( ) . getMethod ( "getRequest" ) ; Object mavenExecutionRequest = getRequestMethod . invoke ( session ) ; Method getStartTimeMethod = mavenExecutionRequest . getClass ( ) . getMethod ( "getStartTime" ) ; Date buildStartTime = ( Date ) getStartTimeMethod . invoke ( mavenExecutionRequest ) ; return buildStartTime ; } catch ( Exception e ) { getLog ( ) . debug ( "unable-to-get-start-time-for-the-current-build:-" + e . getMessage ( ) ) ; } return new Date ( ) ; } \n', 0.32364701771858695)

('private static void executeViaMethodHandle ( Order orderObject , int itrCount ) throws Throwable { MethodHandles . Lookup lookup = MethodHandles . lookup ( ) ; MethodHandle m = lookup . findVirtual ( Order . class , functionToCall , MethodType . methodType ( Integer . TYPE ) ) ; long start ; start = System . currentTimeMillis ( ) ; for ( int cnt = 0 ; cnt < itrCount ; cnt ++ ) { m . invoke ( orderObject ) ; } System . out . println ( String . format ( "%s-Function-Call-for-%s-calls-took-%s(ms)" , "JDK-7-Methodhandle" , itrCount , ( System . currentTimeMillis ( ) - start ) ) ) ; } \n', 0.3235504774248598)

('public Object executeTimed ( long timeout ) throws TimeOutException , InterruptedException , Throwable { executeAsync ( ) ; executeThread . join ( timeout ) ; if ( execException == null && ! finished ) { interrupt ( ) ; if ( ! finished ) { execException = new TimeOutException ( "execution-timed-out-(" + timeout + "ms)" ) ; } } if ( execException != null ) { throw execException ; } return retval ; } \n', 0.32027491869860314)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static String readFirstLineFromFile ( File file ) { BufferedReader reader = null ; try { try { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } String text = reader . readLine ( ) ; return text ; } catch ( IOException e ) { throw new PersistenceException ( e ) ; } finally { DBHelper . closeQuietly ( reader ) ; } } \n', 0.4285793071263142)

('public String readLineOfText ( ) { String lineOfText = null ; try { lineOfText = inFile . readLine ( ) ; } catch ( Exception err ) { try { throw ( err ) ; } catch ( Exception e ) { } } return ( lineOfText ) ; } \n', 0.4169343667775761)

('public static String getLineOfTextFromFile ( ) throws IOException { return reader . readLine ( ) ; } \n', 0.4138493485793753)

('public List < String > readLinesFromTextFile ( String filePath ) { List < String > lines = new ArrayList < String > ( ) ; File aFile = new File ( filePath ) ; try { BufferedReader input = new BufferedReader ( new FileReader ( aFile ) ) ; try { String line = null ; while ( ( line = input . readLine ( ) ) != null ) { lines . add ( line ) ; } } finally { input . close ( ) ; } } catch ( IOException ex ) { LOG . severe ( ex . toString ( ) ) ; } return lines ; } \n', 0.39796673837851426)

('public static String readTextFileFromSystem ( String path ) throws IOException { String contents = "" ; try { BufferedReader in = new BufferedReader ( new FileReader ( path ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { contents = contents + line ; } in . close ( ) ; } catch ( IOException e ) { String detail = "IOException-when-reading-in-text-file-from-path:-" + path ; IOException ee = new IOException ( detail , e ) ; Logger . getLogger ( Util . class . getName ( ) ) . throwing ( "Util" , "readTextFileFromSystem" , ee ) ; throw ee ; } return contents ; } \n', 0.39791848567298505)

('private void parseTextLogFile ( String filePath ) throws IOException { mParser = new EventLogParser ( ) ; String tagFile = filePath + TAG_FILE_EXT ; if ( mParser . init ( tagFile ) == false ) { if ( mAlternateTagFile != null ) { if ( mParser . init ( mAlternateTagFile ) == false ) { printAndExit ( "Failed-to-get-event-tags-from-" + mAlternateTagFile , false ) ; } } else { printAndExit ( "Failed-to-get-event-tags-from-" + tagFile , false ) ; } } BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filePath ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { processEvent ( mParser . parse ( line ) ) ; } } \n', 0.3951670136559205)

('public static String readText ( ) throws IOException { String endOfText = END_OF_FILE ; StringBuilder sb = new StringBuilder ( ) ; String nameFile ; try { nameFile = br . readLine ( ) ; try { file = new File ( nameFile ) ; if ( file . createNewFile ( ) ) { LOGGER . info ( "File-is-created." ) ; } else { LOGGER . info ( "File-exists." ) ; throw new IllegalArgumentException ( ) ; } } catch ( IOException e ) { LOGGER . info ( "File-name-contains-illegal-characters." ) ; } try ( PrintStream fileWriter = new PrintStream ( nameFile ) ) { while ( true ) { nameFile = br . readLine ( ) ; if ( nameFile . equals ( endOfText ) ) { if ( ! END_OF_FILE . equals ( nameFile ) ) { sb . append ( nameFile ) ; } break ; } sb . append ( nameFile ) ; sb . append ( END_LINE ) ; } fileWriter . print ( sb . toString ( ) ) ; return sb . toString ( ) ; } } finally { if ( br != null ) { br . close ( ) ; } } } \n', 0.394090897044863)

('public ArrayList < String > readFromTextFile ( ) { File fileToRead = new File ( System . getenv ( "localappdata" ) + "/eCook/ShoppingLists/" + "shoppingList.txt" ) ; if ( fileToRead . exists ( ) ) { ArrayList < String > shoppingList = new ArrayList < String > ( ) ; try { FileReader fileStream = new FileReader ( System . getenv ( "localappdata" ) + "/eCook/ShoppingLists/" + "shoppingList.txt" ) ; BufferedReader input = new BufferedReader ( fileStream ) ; String line = input . readLine ( ) ; while ( line != null ) { shoppingList . add ( line ) ; line = input . readLine ( ) ; } input . close ( ) ; } catch ( IOException ex ) { logger . log ( Level . SEVERE , "Error-when-reading-shopping-list-file" ) ; ex . printStackTrace ( ) ; } return shoppingList ; } else { return new ArrayList < String > ( ) ; } } \n', 0.38755957879360226)

('private static List < String > readTextFile ( final URL fileURL , final boolean skipEmptyLines ) throws IOException { final List < String > content = new ArrayList < String > ( ) ; BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader ( new InputStreamReader ( fileURL . openStream ( ) ) ) ; String line ; StringBuffer entry = new StringBuffer ( ) ; boolean readMore = false ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( ( ! skipEmptyLines || line . trim ( ) . length ( ) > 0 ) && line . charAt ( 0 ) != LINE_COMMENT_PREFIX ) { if ( line . endsWith ( LINE_CONTINUE_CHAR ) ) { entry . append ( line . substring ( 0 , line . length ( ) - 1 ) ) ; continue ; } else { entry . append ( line ) ; content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; continue ; } } if ( line . trim ( ) . length ( ) == 0 && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; } } if ( entry != null && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; } } finally { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } return content ; } \n', 0.3859143098030262)

('public int loadTextFile ( String filename ) throws IOException { BufferedReader reader ; String line = null ; reader = new BufferedReader ( new FileReader ( new File ( filename ) ) ) ; while ( ( line = reader . readLine ( ) ) != null ) { int index = line . indexOf ( "#" ) ; if ( index != - 1 ) line = line . substring ( 0 , index ) ; if ( line . length ( ) > 0 ) { String [ ] input = line . split ( "=" ) ; if ( input . length != 2 ) { continue ; } input [ 0 ] = input [ 0 ] . trim ( ) ; input [ 1 ] = input [ 1 ] . trim ( ) ; input [ 0 ] = input [ 0 ] . toLowerCase ( Locale . ENGLISH ) ; this . addParameter ( input [ 0 ] , input [ 1 ] ) ; } } reader . close ( ) ; return this . getNumberOfKeys ( ) ; } \n', 0.3833646679571634)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('@ SuppressWarnings ( "unchecked" ) private List < Converter > buildConverterList ( List < Map < String , Object >> converters ) { if ( converters == null || converters . isEmpty ( ) ) { return Collections . emptyList ( ) ; } final List < Converter > cl = Lists . newArrayListWithCapacity ( converters . size ( ) ) ; for ( Map < String , Object > converterSummary : converters ) { cl . add ( new Converter ( Converter . Type . fromString ( converterSummary . get ( "type" ) . toString ( ) ) , ( Map < String , Object > ) converterSummary . get ( "config" ) ) ) ; } return cl ; } \n', 0.3216503999865896)

('public List < SDatabaseCreated > convertToSListDatabaseCreated ( Collection < DatabaseCreated > input ) { List < SDatabaseCreated > result = new ArrayList < SDatabaseCreated > ( ) ; for ( DatabaseCreated o : input ) { result . add ( convertToSObject ( o ) ) ; } return result ; } \n', 0.3079909144833222)

('private Converter [ ] createConverters ( ServiceReference [ ] convRefs ) { List converters = new ArrayList ( ) ; for ( int ii = 0 ; ii < convRefs . length ; ii ++ ) { converters . add ( new Converter ( this . bContext , convRefs [ ii ] ) ) ; } return ( Converter [ ] ) converters . toArray ( new Converter [ 0 ] ) ; } \n', 0.3031687408612834)

('private Object convertListToArray ( Class pType , List pList ) { Class valueType = pType . getComponentType ( ) ; Object ret = Array . newInstance ( valueType , pList . size ( ) ) ; int i = 0 ; for ( Object value : pList ) { if ( value == null ) { if ( ! valueType . isPrimitive ( ) ) { Array . set ( ret , i ++ , null ) ; } else { throw new IllegalArgumentException ( "Cannot-use-a-null-value-in-an-array-of-type-" + valueType . getSimpleName ( ) ) ; } } else { if ( valueType . isAssignableFrom ( value . getClass ( ) ) ) { Array . set ( ret , i ++ , value ) ; } else { Array . set ( ret , i ++ , convertFromString ( valueType . getCanonicalName ( ) , value . toString ( ) ) ) ; } } } return ret ; } \n', 0.29746844985411913)

('public List < SFile > convertToSListFile ( Collection < File > input ) { List < SFile > result = new ArrayList < SFile > ( ) ; for ( File o : input ) { result . add ( convertToSObject ( o ) ) ; } return result ; } \n', 0.29347740311016257)

('protected Collection < T > convertValueToCollection ( Object value ) { if ( value instanceof Iterable ) { Iterable iterable = ( Iterable ) value ; Collection < T > collection = createCollection ( 0 ) ; for ( Object element : iterable ) { collection . add ( convertType ( element ) ) ; } return collection ; } if ( value instanceof CharSequence ) { value = CsvUtil . toStringArray ( value . toString ( ) ) ; } Class type = value . getClass ( ) ; if ( type . isArray ( ) ) { Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return convertPrimitiveArrayToCollection ( value , componentType ) ; } else { Object [ ] array = ( Object [ ] ) value ; Collection < T > result = createCollection ( array . length ) ; for ( Object a : array ) { result . add ( convertType ( a ) ) ; } return result ; } } return convertToSingleElementCollection ( value ) ; } \n', 0.292774558911135)

('public static List < String > convertLiteralListToList ( List < SimpleLiteral > values ) { List < String > stringList = new ArrayList < String > ( values . size ( ) ) ; for ( SimpleLiteral sl : values ) { String value = BindingUtility . convertStringListToString ( sl . getContent ( ) ) ; stringList . add ( value ) ; } return stringList ; } \n', 0.28869515571413956)

('public static List < SQLParams > convertBeansToSqlParams ( List beans , SQLInfo sql , String dbname , int action , Connection con ) throws SQLException { if ( beans == null ) return null ; List < SQLParams > batchparams = new ArrayList < SQLParams > ( beans . size ( ) ) ; for ( Object bean : beans ) { SQLParams params = convertBeanToSqlParams ( bean , sql , dbname , action , con ) ; batchparams . add ( params ) ; } return batchparams ; } \n', 0.2885987863015831)

('public List < SSettingsSaved > convertToSListSettingsSaved ( Collection < SettingsSaved > input ) { List < SSettingsSaved > result = new ArrayList < SSettingsSaved > ( ) ; for ( SettingsSaved o : input ) { result . add ( convertToSObject ( o ) ) ; } return result ; } \n', 0.2834538154826417)

('private < T > Collection < Object > convertValues ( QName propName , List < PrismPropertyValue < T >> values ) throws SchemaException { Collection < Object > convertedValues = new ArrayList < > ( ) ; for ( PrismValue value : values ) { Object converted = UcfUtil . convertValueToIcf ( value , null , propName ) ; convertedValues . add ( converted ) ; } return convertedValues ; } \n', 0.28027115809298747)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.22827352679027355)

('public static Element convertToNewFormat ( Element profileFile , InspectionProfile profile ) { Element rootElement = new Element ( INSPECTIONS_TAG ) ; rootElement . setAttribute ( NAME_ATT , profile . getName ( ) ) ; final InspectionToolWrapper [ ] tools = profile . getInspectionTools ( null ) ; for ( final Object o : profileFile . getChildren ( INSP_TOOL_TAG ) ) { Element toolElement = ( ( Element ) o ) . clone ( ) ; String toolClassName = toolElement . getAttributeValue ( CLASS_ATT ) ; final String shortName = convertToShortName ( toolClassName , tools ) ; if ( shortName == null ) { continue ; } toolElement . setAttribute ( CLASS_ATT , shortName ) ; rootElement . addContent ( toolElement ) ; } return rootElement ; } \n', 0.21752330557728616)

('public static void convertFileFromUtf16ToUtf8 ( File inputFile , File outputFile ) throws IOException { String charset ; if ( inputFile == null || ! inputFile . canRead ( ) ) { throw new FileNotFoundException ( "Can\'t-read-inputFile." ) ; } try { charset = getFileCharset ( inputFile ) ; } catch ( IOException ex ) { logger . debug ( "Exception-during-charset-detection." , ex ) ; throw new IllegalArgumentException ( "Can\'t-confirm-inputFile-is-UTF-16." ) ; } if ( isCharsetUTF16 ( charset ) ) { if ( ! outputFile . exists ( ) ) { BufferedReader reader = null ; try { if ( equalsIgnoreCase ( charset , CHARSET_UTF_16LE ) ) { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16" ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16BE" ) ) ; } } catch ( UnsupportedEncodingException ex ) { logger . warn ( "Unsupported-exception." , ex ) ; throw ex ; } BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outputFile ) , "UTF-8" ) ) ; int c ; while ( ( c = reader . read ( ) ) != - 1 ) { writer . write ( c ) ; } writer . close ( ) ; reader . close ( ) ; } } else { throw new IllegalArgumentException ( "File-is-not-UTF-16" ) ; } } \n', 0.21648424852644635)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.2140206174415257)

('private BidiStringConverter buildRecentFilesSizeConverter ( ) { return new BidiStringConverter ( ) { public String convertToString ( Object o ) { return ( o == null ) ? null : ( ( Integer ) o ) . toString ( ) ; } public Object convertToObject ( String s ) { if ( s == null ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } Integer i = new Integer ( s ) ; if ( i . intValue ( ) < 0 || i . intValue ( ) > RecentFilesManager . MAX_MAX_SIZE ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } return i ; } public String toString ( ) { return "RecentFilesManager-IntegerStringConverter" ; } } ; } \n', 0.20967616735656736)

('protected ByteArrayOutputStream convertFileListToBytes ( ArrayList < String > fileList ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; if ( fileList . isEmpty ( ) ) { bos . write ( UNICODE_NULL_TERMINATOR ) ; } else { for ( int i = 0 ; i < fileList . size ( ) ; i ++ ) { byte [ ] bytes = fileList . get ( i ) . getBytes ( getDefaultUnicodeEncoding ( ) ) ; bos . write ( bytes , 0 , bytes . length ) ; bos . write ( UNICODE_NULL_TERMINATOR ) ; } } bos . write ( UNICODE_NULL_TERMINATOR ) ; return bos ; } \n', 0.20499135768048482)

('public String printTestConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionTestConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionTestConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printTestConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.190893398983095)

('public void write ( T object , OutputStream outputStream ) throws IOException { StringBuilder buffer = new StringBuilder ( ) ; for ( String property : converters . keySet ( ) ) { PropertyConverter < T > converter = converters . get ( property ) ; Object value = converter . convert ( object , property ) ; if ( value == null ) { buffer . append ( DELIMITER ) ; } else { buffer . append ( ReportFormatHelper . quoteIfInvalidCharacters ( value . toString ( ) ) ) . append ( DELIMITER ) ; } } buffer . delete ( buffer . length ( ) - 1 , buffer . length ( ) ) . append ( "-" ) ; outputStream . write ( buffer . toString ( ) . getBytes ( ) ) ; } \n', 0.1870794139591739)

('static void convertToSeq ( String inputFileName , String outputDirName ) throws IOException { Configuration configuration = new Configuration ( ) ; FileSystem fs = FileSystem . get ( configuration ) ; Writer writer = new SequenceFile . Writer ( fs , configuration , new Path ( outputDirName + "/chunk-0" ) , Text . class , Text . class ) ; BufferedReader reader = null ; reader = new BufferedReader ( configuration . getConfResourceAsReader ( inputFileName ) ) ; Text key = new Text ( ) ; Text value = new Text ( ) ; long uniqueid = 0 ; while ( true ) { uniqueid ++ ; String line = reader . readLine ( ) ; if ( line == null ) { break ; } String [ ] tokens = line . split ( "-" , 2 ) ; if ( tokens . length != 2 ) { continue ; } String category = tokens [ 0 ] ; String id = "" + uniqueid ; String message = tokens [ 1 ] ; key . set ( "/" + category + "/" + id ) ; value . set ( message ) ; writer . append ( key , value ) ; } reader . close ( ) ; writer . close ( ) ; } \n', 0.16895719900160158)

('public static String convertReaderToString ( Reader reader ) throws IOException { final StringBuilder text = new StringBuilder ( ) ; final char [ ] buf = new char [ 1024 ] ; int len = 0 ; while ( ( len = reader . read ( buf ) ) >= 0 ) { text . append ( buf , 0 , len ) ; } return text . toString ( ) ; } \n', 0.16675459034084)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('public static String convertDateToXSDString ( Date date ) { if ( date == null ) { return null ; } StringBuilder lexicalForm ; String dateTime = convertDateToString ( date , true ) ; int len = dateTime . length ( ) - 1 ; if ( dateTime . indexOf ( \'.\' , len - 4 ) != - 1 ) { while ( dateTime . charAt ( len - 1 ) == \'0\' ) { len -- ; } if ( dateTime . charAt ( len - 1 ) == \'.\' ) { len -- ; } lexicalForm = new StringBuilder ( dateTime . substring ( 0 , len ) ) ; lexicalForm . append ( \'Z\' ) ; } else { lexicalForm = new StringBuilder ( dateTime ) ; } if ( date . before ( ONE_CE ) ) { DateFormat df = new SimpleDateFormat ( "yyyy" ) ; df . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; StringBuilder year = new StringBuilder ( String . valueOf ( Integer . parseInt ( df . format ( date ) ) - 1 ) ) ; while ( year . length ( ) < 4 ) { year . insert ( 0 , \'0\' ) ; } lexicalForm . replace ( 0 , lexicalForm . indexOf ( "-" , 4 ) , year . toString ( ) ) ; if ( date . before ( ONE_BCE ) ) { lexicalForm . insert ( 0 , "-" ) ; } } return lexicalForm . toString ( ) ; } \n', 0.41733908011452703)

('private long convertExpirationTimeToSeconds ( String expirationTimeString , TimeUnitConfig . Enum timeUnit ) throws IllegalArgumentException { long expirationTime ; try { expirationTime = Long . valueOf ( expirationTimeString . trim ( ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Manual-expiration-time-cannot-be-parsed-due-to-invalid-characters." + "Please-review-it-and-make-sure-it-is-set-correctly." , e ) ; } if ( timeUnit . equals ( TimeUnitConfig . HOURS ) ) { return expirationTime * 3600 ; } else if ( timeUnit . equals ( TimeUnitConfig . MINUTES ) ) { return expirationTime * 60 ; } else { return expirationTime ; } } \n', 0.3835903748759175)

('public static long convertToMillis ( String valueToConvert ) throws NumberFormatException { valueToConvert = valueToConvert . trim ( ) ; String timeVal = valueToConvert . toLowerCase ( ) ; int index = 0 ; float factor = 1.0f ; if ( timeVal . endsWith ( "us" ) ) { factor = 0.001f ; index = timeVal . indexOf ( "us" ) ; } else if ( timeVal . endsWith ( "ms" ) ) { factor = 1.0f ; index = timeVal . indexOf ( "ms" ) ; } else if ( timeVal . endsWith ( "s" ) ) { factor = 1000.0f ; index = timeVal . indexOf ( \'s\' ) ; } else if ( timeVal . endsWith ( "m" ) ) { factor = 1000.0f * 60.0f ; index = timeVal . indexOf ( \'m\' ) ; } else if ( timeVal . endsWith ( "h" ) ) { factor = 1000.0f * 60.0f * 60.0f ; index = timeVal . indexOf ( \'h\' ) ; } else if ( timeVal . endsWith ( "d" ) ) { factor = 1000.0f * 60.0f * 60.0f * 24.0f ; index = timeVal . indexOf ( \'d\' ) ; } if ( index == 0 ) { index = timeVal . length ( ) ; } Float fVal = new Float ( timeVal . substring ( 0 , index ) ) ; return ( ( long ) ( fVal . floatValue ( ) * factor ) ) ; } \n', 0.3722630477804959)

('static Double convertSubtitleTimingStringToTime ( final String timingString ) throws NumberFormatException { if ( isBlank ( timingString ) ) { throw new IllegalArgumentException ( "timingString-should-not-be-blank." ) ; } final StringTokenizer st = new StringTokenizer ( timingString , ":" ) ; try { int h = Integer . parseInt ( st . nextToken ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ; double s = Double . parseDouble ( replace ( st . nextToken ( ) , "," , "." ) ) ; if ( h >= 0 ) { return h * 3600 + m * 60 + s ; } else { return h * 3600 - m * 60 - s ; } } catch ( NumberFormatException nfe ) { logger . debug ( "Failed-to-convert-timing-string-"" + timingString + ""." ) ; throw nfe ; } } \n', 0.36182085489541815)

('@ Override protected String convertToString ( final Object value ) throws Throwable { Date date = null ; if ( value instanceof Date ) { date = ( Date ) value ; } else if ( value instanceof Calendar ) { date = ( ( Calendar ) value ) . getTime ( ) ; } else if ( value instanceof Long ) { date = new Date ( ( ( Long ) value ) . longValue ( ) ) ; } String result = null ; if ( this . useLocaleFormat && date != null ) { DateFormat format = null ; if ( this . patterns != null && this . patterns . length > 0 ) { format = this . getFormat ( this . patterns [ 0 ] ) ; } else { format = this . getFormat ( this . locale , this . timeZone ) ; } result = format . format ( date ) ; } else { result = value . toString ( ) ; } return result ; } \n', 0.35907660954379733)

('public static String convertDateToNewTimeZone ( String dateValue , String initialTZ , String finalTZ , boolean allday ) throws Exception { SimpleDateFormat simpleDateFormat ; String convertedDate ; if ( allday ) { simpleDateFormat = new SimpleDateFormat ( "EEEE,-dd-MMMM,-yyyy" ) ; } else { simpleDateFormat = new SimpleDateFormat ( "EEEE,-dd-MMMM,-yyyy-hh:mm-a" ) ; } Date date = simpleDateFormat . parse ( dateValue ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; int hours = getHoursDifferences ( initialTZ , finalTZ ) ; calendar . add ( Calendar . HOUR_OF_DAY , hours ) ; int currentDay = calendar . get ( Calendar . DAY_OF_MONTH ) ; int currentYear = calendar . get ( Calendar . YEAR ) ; int weekDay = calendar . get ( Calendar . DAY_OF_WEEK ) ; int currentMonth = calendar . get ( Calendar . MONTH ) ; DateFormat sdf = DateFormat . getTimeInstance ( DateFormat . SHORT ) ; String newtime = sdf . format ( calendar . getTime ( ) ) ; if ( allday ) { convertedDate = String . format ( "%s,-%s-%s,-%s" , weekDays [ weekDay ] , String . valueOf ( currentDay ) , monthNames [ currentMonth ] , String . valueOf ( currentYear ) ) ; } else { convertedDate = String . format ( "%s,-%s-%s,-%s-%s" , weekDays [ weekDay ] , String . valueOf ( currentDay ) , monthNames [ currentMonth ] , String . valueOf ( currentYear ) , newtime ) ; } return convertedDate ; } \n', 0.3554839378175786)

("private Date convertToDefaultDate ( String value ) throws ParseException { DateFormat df = SearchUtils . getDateFormat ( contextProperties ) ; String dateValue = value ; if ( SearchUtils . isTimeZoneSupported ( contextProperties , Boolean . FALSE ) ) { int idx = value . lastIndexOf ( ':' ) ; if ( idx != - 1 ) { dateValue = value . substring ( 0 , idx ) + value . substring ( idx + 1 ) ; } } return df . parse ( dateValue ) ; } \n", 0.3512872053638032)

('@ Override protected String convertToString ( Object value ) throws Throwable { Date date = null ; if ( value instanceof Date ) { date = ( Date ) value ; } else if ( value instanceof Calendar ) { date = ( ( Calendar ) value ) . getTime ( ) ; } else if ( value instanceof Long ) { date = new Date ( ( ( Long ) value ) ) ; } String result ; if ( useLocaleFormat && date != null ) { DateFormat format ; if ( patterns != null && patterns . length > 0 ) { format = getFormat ( patterns [ 0 ] ) ; } else { format = getFormat ( locale , timeZone ( ) ) ; } logFormat ( "Formatting" , format ) ; result = format . format ( date ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-format-\'" + result + "\'" ) ; } } else { result = value . toString ( ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-toString()-\'" + result + "\'" ) ; } } return result ; } \n', 0.3467741311482726)

('@ Override protected String convertToString ( final Object value ) throws Throwable { Date date = null ; if ( value instanceof Date ) { date = ( Date ) value ; } else if ( value instanceof Calendar ) { date = ( ( Calendar ) value ) . getTime ( ) ; } else if ( value instanceof Long ) { date = new Date ( ( ( Long ) value ) . longValue ( ) ) ; } String result = null ; if ( useLocaleFormat && date != null ) { DateFormat format = null ; if ( patterns != null && patterns . length > 0 ) { format = getFormat ( patterns [ 0 ] ) ; } else { format = getFormat ( locale , timeZone ) ; } logFormat ( "Formatting" , format ) ; result = format . format ( date ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-format-\'" + result + "\'" ) ; } } else { result = value . toString ( ) ; if ( log ( ) . isDebugEnabled ( ) ) { log ( ) . debug ( "-Converted-to-String-using-toString()-\'" + result + "\'" ) ; } } return result ; } \n', 0.3458376990397053)

('public static String convertToString ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value . getClass ( ) . isPrimitive ( ) || value instanceof Integer || value instanceof Long ) { return value . toString ( ) ; } else if ( value instanceof Enum ) { return convertEnumToString ( ( Enum ) value ) ; } else if ( value instanceof DateTime ) { return convertDateTimeToString ( ( DateTime ) value ) ; } else if ( value instanceof Period ) { return convertPeriodToString ( ( Period ) value ) ; } else if ( value instanceof Interval ) { return convertIntervalToString ( ( Interval ) value ) ; } else { throw new TodoImplementException ( value . getClass ( ) ) ; } } \n', 0.3447201387680992)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('public Object read ( Object request , Map kvp , Map rawKvp ) throws Exception { for ( Iterator e = kvp . entrySet ( ) . iterator ( ) ; e . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) e . next ( ) ; String property = ( String ) entry . getKey ( ) ; Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } if ( filter ( property ) ) { continue ; } if ( ! hasRepeatedParameters ) { Object rawValue = rawKvp . get ( property ) ; if ( rawValue instanceof String [ ] ) { throw new ServiceException ( "Found-multiple,-inconsistent-values-for-parameter-" + property + ":-" + Arrays . toString ( ( String [ ] ) rawValue ) , ServiceException . INVALID_PARAMETER_VALUE , property ) ; } } Class < ? extends Object > targetClass = request . getClass ( ) ; Class < ? extends Object > valueClass = value . getClass ( ) ; Method setter = OwsUtils . setter ( targetClass , property , valueClass ) ; if ( setter == null ) { setter = OwsUtils . setter ( request . getClass ( ) , property , null ) ; if ( setter != null ) { Class target = setter . getParameterTypes ( ) [ 0 ] ; Object converted = Converters . convert ( value , target ) ; if ( converted != null ) { value = converted ; } else { setter = null ; } } } if ( setter != null ) { setter . invoke ( request , new Object [ ] { value } ) ; } } return request ; } \n', 0.23679392516388031)

('private Converter [ ] filterConverters ( Converter [ ] allConverters ) { Map < String , Converter > lastInDataToConverter = new HashMap < String , Converter > ( ) ; for ( int ii = 0 ; ii < allConverters . length ; ii ++ ) { Converter converter = allConverters [ ii ] ; String lastInputData = getLastConverterInData ( converter ) ; if ( lastInDataToConverter . containsKey ( lastInputData ) ) { Converter alreadyStoredConverter = lastInDataToConverter . get ( lastInputData ) ; Converter chosenConverter = returnPreferredConverter ( converter , alreadyStoredConverter ) ; lastInDataToConverter . put ( lastInputData , chosenConverter ) ; } else { lastInDataToConverter . put ( lastInputData , converter ) ; } } return ( Converter [ ] ) lastInDataToConverter . values ( ) . toArray ( new Converter [ 0 ] ) ; } \n', 0.223793056750968)

('public void getNumOfMonitorList ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @ Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; if ( source != null ) { Iterable numEnumerable = ( Iterable ) source ; Iterator numIterator = numEnumerable . iterator ( ) ; while ( numIterator . hasNext ( ) ) { nums . add ( Integer . parseInt ( numIterator . next ( ) . toString ( ) ) ) ; } } return nums ; } } ; getConfigFromCache ( new GetConfigurationValueParameters ( ConfigurationValues . ValidNumOfMonitors , getDefaultConfigurationVersion ( ) ) , aQuery ) ; } \n', 0.20949725553573828)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.20538705531595902)

('@ SuppressWarnings ( "unchecked" ) public void loadConvertersFromImport ( List < Map < String , Object >> imports ) { if ( imports == null || imports . isEmpty ( ) ) { return ; } for ( Map < String , Object > imp : imports ) { final Converter . Type type = Converter . Type . valueOf ( ( ( String ) imp . get ( "type" ) ) . toUpperCase ( ) ) ; converters . add ( new Converter ( type , ( Map < String , Object > ) imp . get ( "config" ) ) ) ; } } \n', 0.19992927203665806)

('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.19127479531152472)

('private static Element createOperatingSystemPatterns ( final Data data , final Document doc ) { final List < OperatingSystemPattern > patterns = new ArrayList < OperatingSystemPattern > ( data . getOperatingSystemPatterns ( ) . size ( ) ) ; for ( final Entry < Integer , SortedSet < OperatingSystemPattern >> entry : data . getOperatingSystemPatterns ( ) . entrySet ( ) ) { patterns . addAll ( entry . getValue ( ) ) ; } Collections . sort ( patterns , new OrderedPatternComparator < OperatingSystemPattern > ( ) ) ; final Element browserTypesElement = doc . createElement ( Tag . OPERATING_SYSTEMS_REG ) ; for ( final OperatingSystemPattern pattern : patterns ) { final Element t = doc . createElement ( Tag . OPERATING_SYSTEM_REG ) ; final Element order = doc . createElement ( Tag . ORDER ) ; order . appendChild ( doc . createTextNode ( String . valueOf ( pattern . getPosition ( ) ) ) ) ; t . appendChild ( order ) ; final Element id = doc . createElement ( Tag . OS_ID ) ; id . appendChild ( doc . createTextNode ( String . valueOf ( pattern . getId ( ) ) ) ) ; t . appendChild ( id ) ; final Element family = doc . createElement ( Tag . REGSTRING ) ; family . appendChild ( doc . createTextNode ( RegularExpressionConverter . convertPatternToPerlRegex ( pattern . getPattern ( ) ) ) ) ; t . appendChild ( family ) ; browserTypesElement . appendChild ( t ) ; } return browserTypesElement ; } \n', 0.1768096958302562)

('@ SuppressWarnings ( "unchecked" ) private List < Converter > buildConverterList ( List < Map < String , Object >> converters ) { if ( converters == null || converters . isEmpty ( ) ) { return Collections . emptyList ( ) ; } final List < Converter > cl = Lists . newArrayListWithCapacity ( converters . size ( ) ) ; for ( Map < String , Object > converterSummary : converters ) { cl . add ( new Converter ( Converter . Type . fromString ( converterSummary . get ( "type" ) . toString ( ) ) , ( Map < String , Object > ) converterSummary . get ( "config" ) ) ) ; } return cl ; } \n', 0.17278399917578385)

('final Object toNonNullOpenValue ( MXBeanLookup lookup , Object value ) throws OpenDataException { final Collection valueCollection = ( Collection ) value ; if ( valueCollection instanceof SortedSet ) { Comparator comparator = ( ( SortedSet ) valueCollection ) . comparator ( ) ; if ( comparator != null ) { final String msg = "Cannot-convert-SortedSet-with-non-null-comparator:-" + comparator ; throw new OpenDataException ( msg ) ; } } final Object [ ] openArray = ( Object [ ] ) Array . newInstance ( getOpenClass ( ) . getComponentType ( ) , valueCollection . size ( ) ) ; int i = 0 ; for ( Object o : valueCollection ) openArray [ i ++ ] = elementConverter . toOpenValue ( lookup , o ) ; return openArray ; } \n', 0.17012840325239006)

('public String printTestConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionTestConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionTestConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printTestConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.16703346632520083)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('@ Override public byte [ ] convertSchemaBase64ToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { StringTokenizer tokenizer = new StringTokenizer ( ( String ) sourceObject ) ; StringBuilder builder = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { builder . append ( tokenizer . nextToken ( ) ) ; } byte [ ] bytes = Base64 . base64Decode ( builder . toString ( ) . getBytes ( ) ) ; return bytes ; } return convertObjectToByteArray ( sourceObject ) ; } \n', 0.22156284143057722)

('private String convertTabsToSpaces ( IDocument document , String text , int offset , String indentString ) throws BadLocationException { if ( text . indexOf ( "-" ) != - 1 ) { if ( text . equals ( "-" ) ) { deleteWhitespaceAfter ( document , offset ) ; text = indentString ; } else { char [ ] chars = text . toCharArray ( ) ; FastStringBuffer newText = new FastStringBuffer ( ) ; for ( int count = 0 ; count < chars . length ; count ++ ) { if ( chars [ count ] == \'|t\' ) { newText . append ( indentString ) ; } else { newText . append ( chars [ count ] ) ; } } text = newText . toString ( ) ; } } return text ; } \n', 0.20037882476411673)

('public void write ( T object , OutputStream outputStream ) throws IOException { StringBuilder buffer = new StringBuilder ( ) ; for ( String property : converters . keySet ( ) ) { PropertyConverter < T > converter = converters . get ( property ) ; Object value = converter . convert ( object , property ) ; if ( value == null ) { buffer . append ( DELIMITER ) ; } else { buffer . append ( ReportFormatHelper . quoteIfInvalidCharacters ( value . toString ( ) ) ) . append ( DELIMITER ) ; } } buffer . delete ( buffer . length ( ) - 1 , buffer . length ( ) ) . append ( "-" ) ; outputStream . write ( buffer . toString ( ) . getBytes ( ) ) ; } \n', 0.17408266562946997)

('private Throwable convertString ( final ListIterator < String > lines , final boolean removeCausedBy ) { String firstLine = lines . next ( ) ; if ( removeCausedBy ) { firstLine = firstLine . substring ( CAUSED_BY_STRING_LENGTH ) ; } final int colon = firstLine . indexOf ( ":" ) ; String throwableClassName ; String message = null ; if ( colon > 1 ) { throwableClassName = firstLine . substring ( 0 , colon ) ; if ( firstLine . length ( ) > colon + 1 ) { message = firstLine . substring ( colon + 1 ) . trim ( ) ; } } else { throwableClassName = firstLine ; } final List < StackTraceElement > stackTrace = new ArrayList < > ( ) ; Throwable cause = null ; while ( lines . hasNext ( ) ) { final String line = lines . next ( ) ; if ( line . startsWith ( "Caused-by-" ) ) { lines . previous ( ) ; cause = convertString ( lines , true ) ; break ; } stackTrace . add ( StackTraceElementAttributeConverter . convertString ( line . trim ( ) . substring ( 3 ) . trim ( ) ) ) ; } return this . getThrowable ( throwableClassName , message , cause , stackTrace . toArray ( new StackTraceElement [ stackTrace . size ( ) ] ) ) ; } \n', 0.1701845045281182)

('public static String convertToPinyinFirstCharString ( String text , String separator , boolean remainNone ) { List < Pinyin > pinyinList = PinyinDictionary . convertToPinyin ( text , remainNone ) ; int length = pinyinList . size ( ) ; StringBuilder sb = new StringBuilder ( length * ( 1 + separator . length ( ) ) ) ; int i = 1 ; for ( Pinyin pinyin : pinyinList ) { sb . append ( pinyin . getFirstChar ( ) ) ; if ( i < length ) { sb . append ( separator ) ; } ++ i ; } return sb . toString ( ) ; } \n', 0.16236733170475404)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.15821071661827435)

('@ Override public Object convertToArg ( Schema schema , int line , String elem , String attr , String value ) throws UnableToCompleteException { String token = value . trim ( ) ; String tokenNoStar = token . replaceAll ( Pattern . quote ( BindingProperty . GLOB_STAR ) , "" ) ; if ( BindingProperty . GLOB_STAR . equals ( token ) || Util . isValidJavaIdent ( tokenNoStar ) ) { return new PropertyValueGlob ( token ) ; } else { Messages . PROPERTY_VALUE_INVALID . log ( logger , token , null ) ; throw new UnableToCompleteException ( ) ; } } \n', 0.15367795848158056)

('public static String convertStringToTitleCase ( String toConvert ) { BreakIterator wordBreaker = BreakIterator . getWordInstance ( ) ; wordBreaker . setText ( toConvert ) ; int end ; String word = "" ; for ( int start = wordBreaker . first ( ) ; ( end = wordBreaker . next ( ) ) != BreakIterator . DONE ; start = end ) { word += StringProcessing . wordToTitleCase ( toConvert . substring ( start , end ) ) ; } return word ; } \n', 0.14949094671970953)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.14564378103656933)

('public static String convertLowerCaseStringToTitleCase ( String value ) { String convertedValue = "" ; boolean loopedOnce = false ; for ( String word : value . split ( "-" ) ) { if ( loopedOnce ) { switch ( word ) { case "a" : case "an" : case "and" : case "in" : case "it" : case "for" : case "of" : case "on" : case "the" : case "to" : case "vs" : convertedValue += \'-\' + word ; break ; default : convertedValue += \'-\' + word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } } else { convertedValue += word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } loopedOnce = true ; } return convertedValue ; } \n', 0.14309879095547354)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.2493496268573035)

('public static String convertToPinyinFirstCharString ( String text , String separator , boolean remainNone ) { List < Pinyin > pinyinList = PinyinDictionary . convertToPinyin ( text , remainNone ) ; int length = pinyinList . size ( ) ; StringBuilder sb = new StringBuilder ( length * ( 1 + separator . length ( ) ) ) ; int i = 1 ; for ( Pinyin pinyin : pinyinList ) { sb . append ( pinyin . getFirstChar ( ) ) ; if ( i < length ) { sb . append ( separator ) ; } ++ i ; } return sb . toString ( ) ; } \n', 0.23809108374773014)

('private String convertTabsToSpaces ( IDocument document , String text , int offset , String indentString ) throws BadLocationException { if ( text . indexOf ( "-" ) != - 1 ) { if ( text . equals ( "-" ) ) { deleteWhitespaceAfter ( document , offset ) ; text = indentString ; } else { char [ ] chars = text . toCharArray ( ) ; FastStringBuffer newText = new FastStringBuffer ( ) ; for ( int count = 0 ; count < chars . length ; count ++ ) { if ( chars [ count ] == \'|t\' ) { newText . append ( indentString ) ; } else { newText . append ( chars [ count ] ) ; } } text = newText . toString ( ) ; } } return text ; } \n', 0.22684537331024895)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.22507001136228252)

('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.22244121888560128)

('public static String convertLowerCaseStringToTitleCase ( String value ) { String convertedValue = "" ; boolean loopedOnce = false ; for ( String word : value . split ( "-" ) ) { if ( loopedOnce ) { switch ( word ) { case "a" : case "an" : case "and" : case "in" : case "it" : case "for" : case "of" : case "on" : case "the" : case "to" : case "vs" : convertedValue += \'-\' + word ; break ; default : convertedValue += \'-\' + word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } } else { convertedValue += word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } loopedOnce = true ; } return convertedValue ; } \n', 0.2181279414764394)

('public static String convertStringToTitleCase ( String toConvert ) { BreakIterator wordBreaker = BreakIterator . getWordInstance ( ) ; wordBreaker . setText ( toConvert ) ; int end ; String word = "" ; for ( int start = wordBreaker . first ( ) ; ( end = wordBreaker . next ( ) ) != BreakIterator . DONE ; start = end ) { word += StringProcessing . wordToTitleCase ( toConvert . substring ( start , end ) ) ; } return word ; } \n', 0.20568308809208108)

('@ Override public byte [ ] convertSchemaBase64ToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { StringTokenizer tokenizer = new StringTokenizer ( ( String ) sourceObject ) ; StringBuilder builder = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { builder . append ( tokenizer . nextToken ( ) ) ; } byte [ ] bytes = Base64 . base64Decode ( builder . toString ( ) . getBytes ( ) ) ; return bytes ; } return convertObjectToByteArray ( sourceObject ) ; } \n', 0.19427551505171697)

('public static String convertDecimalNumbersToString ( String decimalString ) throws NumberFormatException { StringBuilder builder = new StringBuilder ( "" ) ; List < Integer > list = new ArrayList < Integer > ( ) ; String string = decimalString . substring ( 1 ) ; for ( String s : string . split ( ",-" ) ) { list . add ( Integer . parseInt ( s ) ) ; } for ( Integer i : list ) { String aChar = Character . valueOf ( ( char ) ( int ) i ) . toString ( ) ; aChar = aChar . trim ( ) ; builder . append ( aChar ) ; } return builder . toString ( ) ; } \n', 0.18596705620392986)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.17856452453214117)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('private BidiStringConverter buildRecentFilesSizeConverter ( ) { return new BidiStringConverter ( ) { public String convertToString ( Object o ) { return ( o == null ) ? null : ( ( Integer ) o ) . toString ( ) ; } public Object convertToObject ( String s ) { if ( s == null ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } Integer i = new Integer ( s ) ; if ( i . intValue ( ) < 0 || i . intValue ( ) > RecentFilesManager . MAX_MAX_SIZE ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } return i ; } public String toString ( ) { return "RecentFilesManager-IntegerStringConverter" ; } } ; } \n', 0.24714493843839652)

('public void getNumOfMonitorList ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @ Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; if ( source != null ) { Iterable numEnumerable = ( Iterable ) source ; Iterator numIterator = numEnumerable . iterator ( ) ; while ( numIterator . hasNext ( ) ) { nums . add ( Integer . parseInt ( numIterator . next ( ) . toString ( ) ) ) ; } } return nums ; } } ; getConfigFromCache ( new GetConfigurationValueParameters ( ConfigurationValues . ValidNumOfMonitors , getDefaultConfigurationVersion ( ) ) , aQuery ) ; } \n', 0.23206273364270463)

('public static Converter < Double > getNumberConverter ( ) { if ( numberConverter == null ) { numberConverter = new Converter < Double > ( ) { public Double convert ( Object o ) { return ( o != null ) ? Double . valueOf ( o . toString ( ) ) : 0 ; } public String serialize ( Object o ) { return ( o != null ) ? o . toString ( ) : "" ; } } ; } return numberConverter ; } \n', 0.21832926651576826)

('public static Converter < Integer > getIntegerConverter ( ) { if ( integerConverter == null ) { integerConverter = new Converter < Integer > ( ) { public Integer convert ( Object o ) { return ( o != null ) ? Integer . valueOf ( o . toString ( ) ) : 0 ; } public String serialize ( Object o ) { return ( o != null ) ? o . toString ( ) : "" ; } } ; } return integerConverter ; } \n', 0.21366026515877742)

('private float lookup ( float refValue , ContainerWrapper parent , ComponentWrapper comp ) { float res = UnitConverter . UNABLE ; for ( int i = CONVERTERS . size ( ) - 1 ; i >= 0 ; i -- ) { res = CONVERTERS . get ( i ) . convertToPixels ( value , unitStr , isHor , refValue , parent , comp ) ; if ( res != UnitConverter . UNABLE ) return res ; } return PlatformDefaults . convertToPixels ( value , unitStr , isHor , refValue , parent , comp ) ; } \n', 0.19938552476170956)

('public static Object convertNumberToWrapper ( Number num , Class < ? > wrapper ) { if ( wrapper . equals ( String . class ) ) { return num . toString ( ) ; } else if ( wrapper . equals ( Boolean . class ) ) { return Boolean . valueOf ( num . intValue ( ) == 1 ) ; } else if ( wrapper . equals ( Double . class ) ) { return Double . valueOf ( num . doubleValue ( ) ) ; } else if ( wrapper . equals ( Long . class ) ) { return Long . valueOf ( num . longValue ( ) ) ; } else if ( wrapper . equals ( Float . class ) ) { return Float . valueOf ( num . floatValue ( ) ) ; } else if ( wrapper . equals ( Integer . class ) ) { return Integer . valueOf ( num . intValue ( ) ) ; } else if ( wrapper . equals ( Short . class ) ) { return Short . valueOf ( num . shortValue ( ) ) ; } else if ( wrapper . equals ( Byte . class ) ) { return Byte . valueOf ( num . byteValue ( ) ) ; } throw new ConversionException ( String . format ( "Unable-to-convert-number-to:-%s" , wrapper ) ) ; } \n', 0.197979868485071)

('@ Override public Object extractValueFromBytes ( int offset , byte [ ] bytes ) { Long val = endianConverter . convertNumber ( offset , bytes , 4 ) ; if ( val == null ) { return null ; } else { return Float . intBitsToFloat ( val . intValue ( ) ) ; } } \n', 0.19090031952687175)

('public static byte [ ] convertToDecimalBytes ( Object obj ) { Object value = obj ; Class clazz = obj . getClass ( ) ; if ( Byte . class . equals ( clazz ) || Short . class . equals ( clazz ) || Integer . class . equals ( clazz ) || Long . class . equals ( clazz ) ) { clazz = Double . class ; Double d = translate ( obj ) ; value = d ; } BaseConverter converter = stdConverters . get ( clazz ) ; if ( converter == null ) throw new IllegalArgumentException ( "Type-not-supported-at-this-time=" + obj . getClass ( ) ) ; return converter . convertToNoSql ( value ) ; } \n', 0.18334698177685804)

('@ SuppressWarnings ( "unchecked" ) public void loadConvertersFromImport ( List < Map < String , Object >> imports ) { if ( imports == null || imports . isEmpty ( ) ) { return ; } for ( Map < String , Object > imp : imports ) { final Converter . Type type = Converter . Type . valueOf ( ( ( String ) imp . get ( "type" ) ) . toUpperCase ( ) ) ; converters . add ( new Converter ( type , ( Map < String , Object > ) imp . get ( "config" ) ) ) ; } } \n', 0.18334530891433345)

('protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { try { if ( sourceObject instanceof String ) { return new BigDecimal ( ( String ) sourceObject ) ; } if ( sourceObject instanceof Number ) { return new BigDecimal ( ( ( Number ) sourceObject ) . doubleValue ( ) ) ; } if ( sourceObject instanceof Boolean ) { if ( ( ( Boolean ) sourceObject ) . booleanValue ( ) ) { return BigDecimal . valueOf ( 1 ) ; } else { return BigDecimal . valueOf ( 0 ) ; } } } catch ( NumberFormatException exception ) { throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . NUMBER , exception ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . NUMBER ) ; } \n', 0.18214891770087893)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('protected static String convertToMethodSignature ( String methodName , String descriptor , boolean full ) { if ( descriptor . charAt ( 0 ) != \'(\' ) { throw new IllegalArgumentException ( "Can\'t-convert-" + descriptor ) ; } int p = descriptor . lastIndexOf ( \')\' ) ; String params = descriptor . substring ( 1 , p ) ; StringTokenizer tokenizer = new StringTokenizer ( params , ";" ) ; StringBuilder sb = new StringBuilder ( ) ; if ( full ) { String retParam = descriptor . substring ( p + 1 ) ; if ( retParam . endsWith ( ";" ) ) { retParam = retParam . substring ( 0 , retParam . length ( ) - 1 ) ; } String ret = convertParam ( retParam ) ; int r = ret . lastIndexOf ( "." ) ; if ( r > 0 ) { ret = ret . substring ( r + 1 ) ; } sb . append ( ret ) . append ( "-" ) ; } sb . append ( methodName ) . append ( "(" ) ; while ( tokenizer . hasMoreTokens ( ) ) { String param = tokenizer . nextToken ( ) ; sb . append ( convertParam ( param ) ) ; if ( tokenizer . hasMoreTokens ( ) ) { sb . append ( ",-" ) ; } } sb . append ( ")" ) ; return sb . toString ( ) ; } \n', 0.2755374560733284)

('public org . omg . CosNaming . NameComponent [ ] convertToNameComponent ( String theStringifiedName ) throws org . omg . CosNaming . NamingContextPackage . InvalidName { String [ ] theStringifiedNameComponents = breakStringToNameComponents ( theStringifiedName ) ; if ( ( theStringifiedNameComponents == null ) || ( theStringifiedNameComponents . length == 0 ) ) { return null ; } NameComponent [ ] theNameComponents = new NameComponent [ theStringifiedNameComponents . length ] ; for ( int i = 0 ; i < theStringifiedNameComponents . length ; i ++ ) { theNameComponents [ i ] = createNameComponentFromString ( theStringifiedNameComponents [ i ] ) ; } return theNameComponents ; } \n', 0.2566612755444992)

('protected QName convertObjectToQName ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof QName ) { return ( QName ) sourceObject ; } if ( sourceObject instanceof String ) { return qnameFromString ( ( String ) sourceObject ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , Constants . QNAME_CLASS ) ; } \n', 0.24367863769607823)

('private Object attemptToConvertStringToEnum ( Class < ? > requiredType , String trimmedValue , Object currentConvertedValue ) { Object convertedValue = currentConvertedValue ; if ( Enum . class == requiredType ) { int index = trimmedValue . lastIndexOf ( "." ) ; if ( index > - 1 ) { String enumType = trimmedValue . substring ( 0 , index ) ; String fieldName = trimmedValue . substring ( index + 1 ) ; ClassLoader cl = this . targetObject . getClass ( ) . getClassLoader ( ) ; try { Class < ? > enumValueType = ClassUtils . forName ( enumType , cl ) ; Field enumField = enumValueType . getField ( fieldName ) ; convertedValue = enumField . get ( null ) ; } catch ( ClassNotFoundException ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Enum-class-[" + enumType + "]-cannot-be-loaded" , ex ) ; } } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + fieldName + "]-isn\'t-an-enum-value-for-type-[" + enumType + "]" , ex ) ; } } } } if ( convertedValue == currentConvertedValue ) { try { Field enumField = requiredType . getField ( trimmedValue ) ; convertedValue = enumField . get ( null ) ; } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + convertedValue + "]-isn\'t-an-enum-value" , ex ) ; } } } return convertedValue ; } \n', 0.2433637957845509)

('public static Converter lookupConverter ( Class type ) { Converter c = CONVERT_UTILS . lookup ( type ) ; if ( c != null ) return c ; c = ConvertUtils . lookup ( type ) ; if ( c != null ) return c ; try { if ( type . getClassLoader ( ) == null ) return null ; Class < ? > cl = type . getClassLoader ( ) . loadClass ( type . getName ( ) + "$StaplerConverterImpl" ) ; c = ( Converter ) cl . newInstance ( ) ; CONVERT_UTILS . register ( c , type ) ; return c ; } catch ( ClassNotFoundException e ) { } catch ( IllegalAccessException e ) { IllegalAccessError x = new IllegalAccessError ( ) ; x . initCause ( e ) ; throw x ; } catch ( InstantiationException e ) { InstantiationError x = new InstantiationError ( ) ; x . initCause ( e ) ; throw x ; } if ( Enum . class . isAssignableFrom ( type ) ) { return ENUM_CONVERTER ; } return null ; } \n', 0.24276514104641472)

('private Object convertToArray ( String pType , String pValue ) { String t = pType . substring ( 1 , 2 ) ; Class valueType ; if ( t . equals ( "L" ) ) { String oType = pType . substring ( 2 , pType . length ( ) - 1 ) . replace ( \'/\' , \'.\' ) ; valueType = ClassUtil . classForName ( oType ) ; if ( valueType == null ) { throw new IllegalArgumentException ( "No-class-of-type-" + oType + "found" ) ; } } else { valueType = TYPE_SIGNATURE_MAP . get ( t ) ; if ( valueType == null ) { throw new IllegalArgumentException ( "Cannot-convert-to-unknown-array-type-" + t ) ; } } String [ ] values = EscapeUtil . splitAsArray ( pValue , EscapeUtil . PATH_ESCAPE , "," ) ; Object ret = Array . newInstance ( valueType , values . length ) ; int i = 0 ; for ( String value : values ) { Array . set ( ret , i ++ , value . equals ( "[null]" ) ? null : convertFromString ( valueType . getCanonicalName ( ) , value ) ) ; } return ret ; } \n', 0.24002640382750623)

('private String convertToString ( Object object ) { if ( object instanceof Enum ) return convertToString ( ( Enum ) object ) ; if ( object instanceof Class ) return ( ( Class ) object ) . getName ( ) ; return String . valueOf ( object ) ; } \n', 0.23714228937502885)

('private static String convertToCamelCaseNameString ( String nameString ) { String [ ] tokens = nameString . split ( "-" ) ; String result = "" ; for ( String token : tokens ) { if ( result . length ( ) > MAX_LENGTH ) { break ; } result += convertTokenToCamelCase ( token ) ; } return result ; } \n', 0.2346027725130073)

('private static Object coerce ( CommandSession session , Class < ? > type , Object arg , int [ ] convert ) { if ( arg == null ) { return null ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) ) { return arg ; } if ( type . isArray ( ) ) { return NO_MATCH ; } if ( type . isPrimitive ( ) && arg instanceof Long ) { Number num = ( Number ) arg ; if ( type == short . class ) { return num . shortValue ( ) ; } if ( type == int . class ) { return num . intValue ( ) ; } if ( type == long . class ) { return num . longValue ( ) ; } } convert [ 0 ] += 2 ; Object converted = session . convert ( type , arg ) ; if ( converted != null ) { return converted ; } String string = arg . toString ( ) ; if ( type . isAssignableFrom ( String . class ) ) { return string ; } if ( type . isPrimitive ( ) ) { type = primitiveToObject ( type ) ; } try { return type . getConstructor ( String . class ) . newInstance ( string ) ; } catch ( Exception e ) { } if ( type == Character . class && string . length ( ) == 1 ) { return string . charAt ( 0 ) ; } return NO_MATCH ; } \n', 0.22866172408944951)

('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; value = value . replaceAll ( "|," , "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( value ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( value ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( value ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( value ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( value ) ; } } catch ( NumberFormatException nfe ) { } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.22304204613983453)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public void testGetLinesFromBorderWithOnePixelWidthAllAround ( ) throws Exception { style . setBorderWidth ( "1" ) ; border = new Border ( style , insideMargin ) ; verifyLine ( border . getTopLine ( ) , 0 , 0 , 99 , 0 ) ; verifyLine ( border . getRightLine ( ) , 99 , 0 , 99 , 199 ) ; verifyLine ( border . getBottomLine ( ) , 99 , 199 , 0 , 199 ) ; verifyLine ( border . getLeftLine ( ) , 0 , 199 , 0 , 0 ) ; } \n', 0.2783547266032367)

('private char getPlusOneCharacter ( ) throws LinePositionPointerOutOfBoundaryException { if ( hasNextCharacter ( ) ) { return lineCharacters [ linePosition + 1 ] ; } else throw ( new LinePositionPointerOutOfBoundaryException ( ) ) ; } \n', 0.27647886228430896)

('public void testGetLinesFromBorderWithOnePixelWidthAllAroundAndSomeMargin ( ) throws Exception { style . setBorderWidth ( "1" ) ; insideMargin = new Box ( 20 , 30 , 100 , 200 ) ; border = new Border ( style , insideMargin ) ; int right = insideMargin . width - 1 + 20 ; int bottom = insideMargin . height - 1 + 30 ; verifyLine ( border . getTopLine ( ) , 20 , 30 , right , 30 ) ; verifyLine ( border . getRightLine ( ) , right , 30 , right , bottom ) ; verifyLine ( border . getBottomLine ( ) , right , bottom , 20 , bottom ) ; verifyLine ( border . getLeftLine ( ) , 20 , bottom , 20 , 30 ) ; } \n', 0.27427049036445417)

('private ApexCodeLocation getLocationFromStackLine ( String name , String stackTrace ) { if ( Utils . isEmpty ( name ) || Utils . isEmpty ( stackTrace ) ) return null ; String line = null ; String column = null ; try { String [ ] temp = stackTrace . split ( "line" ) ; line = temp [ 1 ] . split ( "," ) [ 0 ] . trim ( ) ; String c = temp [ 1 ] . trim ( ) ; column = c . split ( "column" ) [ 1 ] . trim ( ) ; if ( Utils . isNotEmpty ( column ) && column . contains ( "-" ) ) { column = column . substring ( 0 , column . indexOf ( "-" ) ) ; } } catch ( Exception e ) { } return new ApexCodeLocation ( name , line , column ) ; } \n', 0.26672943681896677)

('private static ApexCodeLocation getLocationFromStackLine ( String name , String stackTrace ) { if ( Utils . isEmpty ( name ) || Utils . isEmpty ( stackTrace ) ) { logger . warn ( "Unable-to-get-location-from-stacktrace---name-and/or-stacktrace-is-null" ) ; return null ; } String line = null ; String column = null ; try { String [ ] temp = stackTrace . split ( "line" ) ; line = temp [ 1 ] . split ( "," ) [ 0 ] . trim ( ) ; String c = temp [ 1 ] . trim ( ) ; column = c . split ( "column" ) [ 1 ] . trim ( ) ; if ( Utils . isNotEmpty ( column ) && column . contains ( "-" ) ) { column = column . substring ( 0 , column . indexOf ( "-" ) ) ; } } catch ( Exception e ) { logger . warn ( "Unable-to-get-location-from-stacktrace" , e ) ; } return new ApexCodeLocation ( name , line , column ) ; } \n', 0.26526074679397)

('public StatusLine parseStatusLine ( final CharArrayBuffer buffer , final ParserCursor cursor ) throws ParseException { if ( buffer == null ) { throw new IllegalArgumentException ( "Char-array-buffer-may-not-be-null" ) ; } if ( cursor == null ) { throw new IllegalArgumentException ( "Parser-cursor-may-not-be-null" ) ; } int indexFrom = cursor . getPos ( ) ; int indexTo = cursor . getUpperBound ( ) ; try { ProtocolVersion ver = parseProtocolVersion ( buffer , cursor ) ; skipWhitespace ( buffer , cursor ) ; int i = cursor . getPos ( ) ; int blank = buffer . indexOf ( \'-\' , i , indexTo ) ; if ( blank < 0 ) { blank = indexTo ; } int statusCode = 0 ; String s = buffer . substringTrimmed ( i , blank ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( ! Character . isDigit ( s . charAt ( j ) ) ) { throw new ParseException ( "Status-line-contains-invalid-status-code:-" + buffer . substring ( indexFrom , indexTo ) ) ; } } try { statusCode = Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { throw new ParseException ( "Status-line-contains-invalid-status-code:-" + buffer . substring ( indexFrom , indexTo ) ) ; } i = blank ; String reasonPhrase = null ; if ( i < indexTo ) { reasonPhrase = buffer . substringTrimmed ( i , indexTo ) ; } else { reasonPhrase = "" ; } return createStatusLine ( ver , statusCode , reasonPhrase ) ; } catch ( IndexOutOfBoundsException e ) { throw new ParseException ( "Invalid-status-line:-" + buffer . substring ( indexFrom , indexTo ) ) ; } } \n', 0.2506893316091231)

('@ Override public String [ ] getCommandLine ( boolean needContext , boolean externalUse , int statOption , int traceOption , String ... codeOptions ) { setExternalUse ( externalUse ) ; String [ ] cmd = null ; try { cmd = getCommandLine ( ) ; } catch ( ProcessorException e ) { ExceptionHandler . process ( e ) ; } cmd = addCommmandLineAttch ( needContext , cmd , context != null ? context . getName ( ) : IContext . DEFAULT , statOption , traceOption , codeOptions ) ; if ( Platform . OS_LINUX . equals ( getTargetPlatform ( ) ) ) { cmd = ( String [ ] ) ArrayUtils . add ( cmd , JobScriptsManager . CMDFORUNIX ) ; } else if ( Platform . OS_WIN32 . equals ( getTargetPlatform ( ) ) ) { cmd = ( String [ ] ) ArrayUtils . add ( cmd , JobScriptsManager . CMDFORWIN ) ; } return cmd ; } \n', 0.23918198547962619)

('public String [ ] getCommandLine ( boolean needContext , boolean externalUse , int statOption , int traceOption , String ... codeOptions ) { setExternalUse ( externalUse ) ; String [ ] cmd = null ; try { cmd = getCommandLine ( ) ; } catch ( ProcessorException e ) { ExceptionHandler . process ( e ) ; } cmd = addCommmandLineAttch ( needContext , cmd , context . getName ( ) , statOption , traceOption , codeOptions ) ; if ( Platform . OS_LINUX . equals ( getTargetPlatform ( ) ) ) { cmd = ( String [ ] ) ArrayUtils . add ( cmd , JobScriptsManager . CMDFORUNIX ) ; } else if ( Platform . OS_WIN32 . equals ( getTargetPlatform ( ) ) ) { cmd = ( String [ ] ) ArrayUtils . add ( cmd , JobScriptsManager . CMDFORWIN ) ; } return cmd ; } \n', 0.23918136649186922)

('private boolean isStackTraceLineFiltred ( boolean isFirstLine , String line ) { if ( ! isFirstLine && stackTraceFilterAction . isChecked ( ) ) { for ( String pattern : STACK_TRACE_FILTER_PATTERNS ) { if ( pattern . charAt ( pattern . length ( ) - 1 ) == \'*\' ) { pattern = pattern . substring ( 0 , pattern . length ( ) - 1 ) ; } else if ( Character . isUpperCase ( pattern . charAt ( 0 ) ) ) { pattern = "at-" + pattern + \'.\' ; } else { int lastDotIndex = pattern . lastIndexOf ( \'.\' ) ; if ( ( lastDotIndex != - 1 ) && ( lastDotIndex != pattern . length ( ) - 1 ) && Character . isUpperCase ( pattern . charAt ( lastDotIndex + 1 ) ) ) { pattern += \'.\' ; } } if ( line . indexOf ( pattern ) > 0 ) { return true ; } } } return false ; } \n', 0.23515939794128227)

('@ Nullable private static StackTraceElement parseStackTraceLine ( @ NotNull String line ) { Matcher matcher = STACK_TRACE_ELEMENT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String declaringClass = matcher . group ( 1 ) ; String methodName = matcher . group ( 2 ) ; String fileName = matcher . group ( 3 ) ; String lineNumber = matcher . group ( 4 ) ; return new StackTraceElement ( declaringClass , methodName , fileName , Integer . parseInt ( lineNumber ) ) ; } return null ; } \n', 0.22986420813182712)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('private ArrayList < String > convertMapToListInt ( HashMap < String , Integer > map ) { HashMap < String , Double > convertedMap = new HashMap < String , Double > ( ) ; for ( String key : map . keySet ( ) ) { convertedMap . put ( key , map . get ( key ) . doubleValue ( ) ) ; } return convertMapToList ( convertedMap ) ; } \n', 0.4123906371189145)

('public static Map < String , Map < String , String >> convertTripleListToMaps ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , Map < String , String >> results = new HashMap < String , Map < String , String >> ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 3 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 3 ) { String role = list . get ( count ) ; String key = list . get ( count + 1 ) ; String val = list . get ( count + 2 ) ; Map < String , String > roleMap = results . get ( role ) ; if ( roleMap == null ) { roleMap = new HashMap < String , String > ( ) ; results . put ( role , roleMap ) ; } if ( roleMap . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-for-key-" + key + "-under-" + role ) ; } roleMap . put ( key , val ) ; } } return results ; } \n', 0.3923345746619985)

('public static Map < String , String > convertTupleListToMap ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , String > results = new HashMap < String , String > ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 2 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 2 ) { String key = list . get ( count ) ; String val = list . get ( count + 1 ) ; if ( results . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-" + key ) ; } results . put ( key , val ) ; } } return results ; } \n', 0.3858308548055216)

('protected void convertAll ( ) { if ( converted ) return ; for ( java . util . Map . Entry < Object , Object > e : underlying . entrySet ( ) ) { if ( e . getValue ( ) instanceof Number ) super . put ( e . getKey ( ) , enumClass . getEnumConstants ( ) [ ( ( Number ) e . getValue ( ) ) . intValue ( ) ] ) ; else super . put ( e . getKey ( ) , Enum . valueOf ( enumClass , e . getValue ( ) . toString ( ) ) ) ; } converted = true ; } \n', 0.3696076060158482)

('protected static List convertToValue ( MapiPropertyType mapiPropType , Iterator < String > strings ) throws Exception { EwsUtilities . validateParam ( strings , "strings" ) ; MapiTypeConverterMapEntry typeConverter = getMapiTypeConverterMap ( ) . get ( mapiPropType ) ; List array = new ArrayList ( ) ; int index = 0 ; while ( strings . hasNext ( ) ) { Object value = typeConverter . ConvertToValueOrDefault ( strings . next ( ) ) ; array . add ( index , value ) ; } return array ; } \n', 0.3615719876158464)

('public static List < Object > convertToValue ( MapiPropertyType mapiPropType , Iterator < String > strings ) throws Exception { EwsUtilities . validateParam ( strings , "strings" ) ; MapiTypeConverterMapEntry typeConverter = getMapiTypeConverterMap ( ) . get ( mapiPropType ) ; List < Object > array = new ArrayList < Object > ( ) ; int index = 0 ; while ( strings . hasNext ( ) ) { Object value = typeConverter . convertToValueOrDefault ( strings . next ( ) ) ; array . add ( index , value ) ; } return array ; } \n', 0.3533894450878803)

('protected static List < Object > convertToValue ( MapiPropertyType mapiPropType , Iterator < String > strings ) throws Exception { EwsUtilities . validateParam ( strings , "strings" ) ; MapiTypeConverterMapEntry typeConverter = getMapiTypeConverterMap ( ) . get ( mapiPropType ) ; List < Object > array = new ArrayList < Object > ( ) ; int index = 0 ; while ( strings . hasNext ( ) ) { Object value = typeConverter . ConvertToValueOrDefault ( strings . next ( ) ) ; array . add ( index , value ) ; } return array ; } \n', 0.3533894450878803)

('private static String convertFromList ( String name , List < ? > list , boolean isProperty ) { String json = null ; if ( list != null && ! list . isEmpty ( ) ) { String format = "[%s]" ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( sb . length ( ) > 0 ) { sb . append ( "," ) ; } json = JsonConverter . convertFromKeyValue ( null , list . get ( i ) ) ; if ( json != null ) { sb . append ( json ) ; } } if ( isProperty ) { format = ""%s":[%s]" ; if ( name == null || "" . equals ( name ) ) { name = "list" ; } json = String . format ( format , name , sb . toString ( ) ) ; } else { if ( name != null && ! "" . equals ( name ) ) { format = ""%s":[%s]" ; json = String . format ( format , name , sb . toString ( ) ) ; } else { json = String . format ( format , sb . toString ( ) ) ; } } } return json ; } \n', 0.34975239935852054)

('public static List < Integer > convertStringListToIntList ( List < String > list , String [ ] convertFrom , int [ ] convertTo ) { if ( list == null ) { return null ; } List < Integer > convertedList = new ArrayList < > ( list . size ( ) ) ; for ( String str : list ) { int strIndex = getArrayIndex ( convertFrom , str ) ; if ( strIndex < 0 ) { Log . w ( TAG , "Ignoring-invalid-value-" + str ) ; continue ; } if ( strIndex < convertTo . length ) { convertedList . add ( convertTo [ strIndex ] ) ; } } return convertedList ; } \n', 0.34572162970026465)

('static void convertToMapOfElementProperties ( Map < String , String > map , Map < QName , ElementProperty > elementsMap ) { if ( map != null ) { for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; String text = null ; boolean child = false ; int d = value . indexOf ( \'}\' ) ; d = value . indexOf ( \'=\' , d < 0 ? 0 : d ) ; if ( d > 0 ) { text = value . substring ( d + 1 ) ; value = value . substring ( 0 , d ) ; } if ( key . endsWith ( "/" ) ) { key = key . substring ( 0 , key . length ( ) - 1 ) ; child = true ; } QName lname = DOMUtils . convertStringToQName ( key ) ; QName rname = DOMUtils . convertStringToQName ( value ) ; ElementProperty desc = new ElementProperty ( rname , text , child ) ; elementsMap . put ( lname , desc ) ; } } } \n', 0.34104201134908385)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.3125