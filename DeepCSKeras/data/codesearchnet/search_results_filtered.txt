########################## 1 #################################
('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42189944410094926)

('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

('public String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4086881582715446)

('private static String convertReaderToString ( Reader reader ) throws IOException { if ( reader != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40778385592006827)

('private String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) { try { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } catch ( IOException e ) { throw new RuntimeException ( "Did-not-expect-this-one..." , e ) ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } \n', 0.4074249952540185)

('private static String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public static String convertStreamToString ( final InputStream is ) throws IOException { if ( is == null ) { throw new IOException ( "Empty-stream" ) ; } else { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } } \n', 0.40742241077751923)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('public static Integer [ ] createIntegerArrFromCollection ( List < Integer [ ] > integerArrList ) { if ( integerArrList == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; Iterator < Integer [ ] > iterator = integerArrList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer [ ] integerArr = iterator . next ( ) ; if ( integerArr != null && integerArr . length > 0 ) { for ( Integer integerValue : integerArr ) { if ( integerValue != null ) { integerList . add ( integerValue ) ; } } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.36514417254870113)

('protected static final < O extends Object > Interval < O > createFromList ( List < IntervalData < O >> intervals ) { Interval < O > newInterval = new Interval < O > ( ) ; if ( intervals . size ( ) == 1 ) { IntervalData < O > middle = intervals . get ( 0 ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; newInterval . add ( middle ) ; return newInterval ; } int half = intervals . size ( ) / 2 ; IntervalData < O > middle = intervals . get ( half ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; List < IntervalData < O >> leftIntervals = new ArrayList < IntervalData < O >> ( ) ; List < IntervalData < O >> rightIntervals = new ArrayList < IntervalData < O >> ( ) ; for ( IntervalData < O > interval : intervals ) { if ( interval . end < newInterval . center ) { leftIntervals . add ( interval ) ; } else if ( interval . start > newInterval . center ) { rightIntervals . add ( interval ) ; } else { newInterval . add ( interval ) ; } } if ( leftIntervals . size ( ) > 0 ) newInterval . left = createFromList ( leftIntervals ) ; if ( rightIntervals . size ( ) > 0 ) newInterval . right = createFromList ( rightIntervals ) ; return newInterval ; } \n', 0.337776059959168)

('public ArrayList < ArrayList < Double >> createTestList ( int num_points , boolean integers , boolean negative ) { ArrayList < ArrayList < Double >> test_list = new ArrayList ( ) ; for ( int i = 0 ; i < num_points ; i ++ ) { ArrayList < Double > temp_arraylist = new ArrayList ( ) ; double temp_val1 = Math . random ( ) * scale_x ; double temp_val2 = Math . random ( ) * scale_y ; if ( integers ) { temp_val1 = Math . floor ( temp_val1 ) ; temp_val2 = Math . floor ( temp_val2 ) ; } if ( negative ) { temp_val1 = temp_val1 * 2 - scale_x ; temp_val2 = temp_val2 * 2 - scale_y ; } temp_arraylist . add ( temp_val1 ) ; temp_arraylist . add ( temp_val2 ) ; test_list . add ( temp_arraylist ) ; } return test_list ; } \n', 0.32433913586832874)

('private static ArrayList < SmsMessage > createMessageListFromRawRecords ( List < SmsRawData > records ) { ArrayList < SmsMessage > messages = new ArrayList < SmsMessage > ( ) ; if ( records != null ) { int count = records . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SmsRawData data = records . get ( i ) ; if ( data != null ) { SmsMessage sms = SmsMessage . createFromEfRecord ( i + 1 , data . getBytes ( ) ) ; if ( sms != null ) { messages . add ( sms ) ; } } } } return messages ; } \n', 0.32180324625878154)

('public static List < Track > createListFromResultSet ( final ResultSet rs ) throws SQLException { final List < Track > tracks = new ArrayList < Track > ( ) ; while ( rs . next ( ) ) tracks . add ( Track . createFromResultSet ( rs ) ) ; return tracks ; } \n', 0.3149692570249006)

('public List createIntegerListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( BigInteger ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . INTEGER , item ) ) ; } return result ; } \n', 0.31496377986000623)

('private ArrayList < String > arrayToArrayList ( String [ ] array ) { ArrayList < String > arraylist = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { arraylist . add ( array [ i ] ) ; } return arraylist ; } \n', 0.31113449677079336)

('protected List < MusicIndex > createIndexesFromExpression ( String expr ) { List < MusicIndex > result = new ArrayList < MusicIndex > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( expr , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { MusicIndex index = createIndexFromExpression ( tokenizer . nextToken ( ) ) ; result . add ( index ) ; } return result ; } \n', 0.30197965752895306)

('public ArrayList < String > inferredOrthologsToArrayList ( final String seq_name , double threshold_orthologs ) { HashMap < String , Integer > o_hashmap = null ; String name = null ; double o = 0.0 ; final ArrayList < String > arraylist = new ArrayList < String > ( ) ; if ( _o_hash_maps == null ) { throw new IllegalStateException ( "Orthologs-have-not-been-calculated-(successfully)." ) ; } if ( threshold_orthologs < 0.0 ) { threshold_orthologs = 0.0 ; } else if ( threshold_orthologs > 100.0 ) { threshold_orthologs = 100.0 ; } o_hashmap = getInferredOrthologs ( seq_name ) ; if ( o_hashmap == null ) { throw new IllegalStateException ( "Orthologs-for-" + seq_name + "-were-not-established." ) ; } if ( _seq_names . length > 0 ) { I : for ( int i = 0 ; i < _seq_names . length ; ++ i ) { name = _seq_names [ i ] ; if ( name . equals ( seq_name ) ) { continue I ; } o = getBootstrapValueFromHash ( o_hashmap , name ) ; if ( o < threshold_orthologs ) { continue I ; } arraylist . add ( name ) ; } } return arraylist ; } \n', 0.29810528098606914)

('public List createDoubleListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( Double ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . DOUBLE , item ) ) ; } return result ; } \n', 0.2971617146950231)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('public < T extends Iterable < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList ( iterables . length ) ; for ( T iterable : iterables ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3500509165733183)

('public < T extends Iterable < ? extends Key >> JoinIterator ( Aggregator < Key , Value > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = new Comparator < Key > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public int compare ( Key o1 , Key o2 ) { return ( ( Comparable < Key > ) o1 ) . compareTo ( o2 ) ; } } ; for ( T iterable : iterables ) { final Entry entry = new Entry ( size ++ , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; } } \n', 0.34550463930287495)

('public final HashMap collectCachebyAccess ( int rate ) { HashMap resultmap = new HashMap ( ) ; int expectSize = maxSize * rate / 100 ; while ( size > expectSize ) { String key = null ; if ( accessList . getLast ( ) != null ) { key = ( String ) accessList . getLast ( ) . object ; } if ( key != null ) { resultmap . put ( key , hashmap . get ( key ) ) ; remove ( ( String ) accessList . getLast ( ) . object ) ; } else { remove ( ( String ) emptyList . getLast ( ) . object ) ; } } System . out . println ( "rate-is-:-" + size * 100 / maxSize ) ; return resultmap ; } \n', 0.3387688714683485)

('private Iterable < Tile > makeMapIteratorIterable ( final MapIterator m ) { return new Iterable < Tile > ( ) { public Iterator < Tile > iterator ( ) { return new Iterator < Tile > ( ) { public boolean hasNext ( ) { return m . hasNext ( ) ; } public Tile next ( ) { return getTile ( m . next ( ) ) ; } public void remove ( ) { m . remove ( ) ; } } ; } } ; } \n', 0.33329208623876416)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final Indexable indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('private Iterator < Annotation > getAnnotationIterator ( boolean cleanup , boolean recurse ) { Iterator < Annotation > iter = getAnnotationIterator ( cleanup ) ; if ( ! recurse || fAttachments . isEmpty ( ) ) return iter ; List < Iterator < Annotation >> iterators = new ArrayList < > ( fAttachments . size ( ) + 1 ) ; iterators . add ( iter ) ; Iterator < Object > it = fAttachments . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) iterators . add ( fAttachments . get ( it . next ( ) ) . getAnnotationIterator ( ) ) ; return new MetaIterator < > ( iterators . iterator ( ) ) ; } \n', 0.3319734088313099)

('public Iterable < ? extends Key > iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public Iterable < ? extends Key > iterate ( final Indexable indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public net . varkhan . base . containers . Iterable < ? extends Key > iterate ( final long [ ] indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('public double randomInRange ( double min , double max ) { double range = max - min ; double scaled = randomNumGenerator_ . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42066172439532096)

('public static Vector < Range > randomRangesWithOffsets ( int number , double offset , boolean isFixOffset , List < Double > values , Range boundary ) { Vector < Range > ranges = new Vector < Range > ( ) ; int size = values . size ( ) ; Random generator = new Random ( ) ; generator . setSeed ( System . nanoTime ( ) ) ; double _offset = 0.0 ; if ( isFixOffset ) { _offset = offset ; } else { _offset = generator . nextDouble ( ) * offset ; } for ( int i = 0 ; i < number ; i ++ ) { int r = generator . nextInt ( size ) ; double start , end ; start = Math . max ( boundary . getStart ( ) , values . get ( r ) - _offset ) ; end = Math . min ( boundary . getEnd ( ) , values . get ( r ) + _offset ) ; Range range = new Range ( start , end ) ; ranges . add ( range ) ; } return ranges ; } \n', 0.40823690872016083)

('public static int getRandomIntByRange ( int _iRangeLimit ) { return Math . abs ( g_randomObj . nextInt ( _iRangeLimit ) ) ; } \n', 0.40734959195999004)

('public static BigInteger createRandomInRange ( BigInteger min , BigInteger max , SecureRandom random ) { int cmp = min . compareTo ( max ) ; if ( cmp >= 0 ) { if ( cmp > 0 ) { throw new IllegalArgumentException ( "\'min\'-may-not-be-greater-than-\'max\'" ) ; } return min ; } if ( min . bitLength ( ) > max . bitLength ( ) / 2 ) { return createRandomInRange ( ZERO , max . subtract ( min ) , random ) . add ( min ) ; } for ( int i = 0 ; i < MAX_ITERATIONS ; ++ i ) { BigInteger x = new BigInteger ( max . bitLength ( ) , random ) ; if ( x . compareTo ( min ) >= 0 && x . compareTo ( max ) <= 0 ) { return x ; } } return new BigInteger ( max . subtract ( min ) . bitLength ( ) - 1 , random ) . add ( min ) ; } \n', 0.40213987034254695)

('public static int randomIntegerInRange ( final int min , final int max ) { return Utils . getRandomGenerator ( ) . nextInt ( max - min + 1 ) + min ; } \n', 0.3946602058890578)

('public static Double generateRandomDoubleInRange ( double low , double high ) { double percentage = Math . random ( ) ; double result = low + ( high - low ) * percentage ; return result ; } \n', 0.3875989747979697)

('private DataBag generateRandomSortedSamples ( int numSamples , int max ) throws Exception { Random rand = new Random ( 1000 ) ; List < Tuple > samples = new ArrayList < Tuple > ( ) ; for ( int i = 0 ; i < numSamples ; i ++ ) { Tuple t = tFact . newTuple ( 1 ) ; t . set ( 0 , rand . nextInt ( max ) ) ; samples . add ( t ) ; } Collections . sort ( samples ) ; return new NonSpillableDataBag ( samples ) ; } \n', 0.37559212601017566)

('static int [ ] randomIntArray ( final int length , final int range ) { final int [ ] array = new int [ length ] ; final Random generator = new Random ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = generator . nextInt ( range ) ; } return array ; } \n', 0.3680162602005158)

('public static int [ ] generateRandomTernary ( int N , int numOnes , int numNegOnes , SecureRandom random ) { Integer one = Integers . valueOf ( 1 ) ; Integer minusOne = Integers . valueOf ( - 1 ) ; Integer zero = Integers . valueOf ( 0 ) ; List list = new ArrayList ( ) ; for ( int i = 0 ; i < numOnes ; i ++ ) { list . add ( one ) ; } for ( int i = 0 ; i < numNegOnes ; i ++ ) { list . add ( minusOne ) ; } while ( list . size ( ) < N ) { list . add ( zero ) ; } Collections . shuffle ( list , random ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( ( Integer ) list . get ( i ) ) . intValue ( ) ; } return arr ; } \n', 0.35316886227906197)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.42556612403100647)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.42457246965468176)

('public static int convertStringToInt ( String str ) throws BookStoreException { int returnValue = 0 ; try { returnValue = Integer . parseInt ( str ) ; } catch ( Exception ex ) { throw new BookStoreException ( ex ) ; } return returnValue ; } \n', 0.42450212508579)

('public static int convertStringToInt ( String str ) throws Exception { int returnValue = 0 ; returnValue = Integer . parseInt ( str ) ; return returnValue ; } \n', 0.42450212508579)

('public int convertStringToInt ( String numberAsString ) throws NumberFormatException { int intToReturn = 0 ; try { intToReturn = Integer . parseInt ( numberAsString ) ; } catch ( NumberFormatException e ) { throw e ; } return intToReturn ; } \n', 0.41991733380635005)

('public static int convertStringToIntDef ( String string , int defaultValue ) { try { return Integer . parseInt ( string ) ; } catch ( NumberFormatException e ) { return defaultValue ; } } \n', 0.4149517042983897)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.4081503043985538)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.40780405246205736)

('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; value = value . replaceAll ( "|," , "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( value ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( value ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( value ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( value ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( value ) ; } } catch ( NumberFormatException nfe ) { } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.40751204187907863)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.40614039395713675)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('public List < String > initializeTexts ( ) { List < String > ret = new ArrayList < String > ( ) ; BufferedReader reader = null ; files = getJavaFiles ( ) ; try { for ( String oneFile : files ) { File file = new File ( oneFile ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; StringBuilder stringBuilder = new StringBuilder ( ) ; String ls = ExperimentDataUtil . EOL ; while ( ( line = reader . readLine ( ) ) != null ) { stringBuilder . append ( line ) ; stringBuilder . append ( ls ) ; } reader . close ( ) ; String data = stringBuilder . toString ( ) ; String name = oneFile . substring ( oneFile . indexOf ( SRC_TOKEN ) + SRC_TOKEN . length ( ) ) ; name = name . substring ( 0 , name . indexOf ( JAVA_FILE_TYPE ) ) ; name = name . replace ( "|" , "." ) ; fileNames . add ( name ) ; ret . add ( data ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return ret ; } \n', 0.3713574990046598)

('private static void initialize ( String filename ) throws IllegalInputException { params . clear ( ) ; paramPosition . clear ( ) ; paramValues . clear ( ) ; int counter = 0 ; try { String fileName = "" ; if ( ! filename . equals ( "" ) ) { fileName = filename ; } else { fileName = DEFAULT_CONFIG_FILE_NAME ; } BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . charAt ( 0 ) != \'#\' ) { String [ ] content = line . split ( ":" ) ; String name = content [ 0 ] ; String values = content [ 1 ] . trim ( ) ; if ( name . equals ( "number_of_runs" ) ) { number_of_runs = Integer . parseInt ( values ) ; } else { String [ ] valuesArray = values . split ( "-" ) ; params . put ( name , valuesArray ) ; paramPosition . put ( counter , name ) ; counter ++ ; paramValues . add ( valuesArray ) ; } } } reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . exit ( 0 ) ; } } \n', 0.3473700098880026)

('public static boolean initializeOpt ( ) { try { BufferedReader br = new BufferedReader ( new FileReader ( settingsPath ) ) ; String sCurrentLine ; platforms = new ArrayList < String [ ] > ( ) ; plugins = new ArrayList < String [ ] > ( ) ; resources = new ArrayList < String [ ] > ( ) ; sCurrentLine = br . readLine ( ) ; while ( ( sCurrentLine != null ) ) { if ( sCurrentLine . contains ( "platform-id" ) ) { platforms . add ( retrieveParam ( sCurrentLine , PLAT_PARAMETERS ) ) ; } if ( sCurrentLine . contains ( "plugin-id" ) ) { plugins . add ( retrieveParam ( sCurrentLine , PLUG_PARAMETERS ) ) ; } if ( sCurrentLine . contains ( "resource-id" ) ) { resources . add ( retrieveParam ( sCurrentLine , RES_PARAMETERS ) ) ; } if ( sCurrentLine . contains ( "priority-max-value" ) ) { maxPriority = Integer . parseInt ( sCurrentLine . substring ( sCurrentLine . indexOf ( \'"\' ) + 1 , sCurrentLine . lastIndexOf ( \'"\' ) ) ) ; } sCurrentLine = br . readLine ( ) ; } br . close ( ) ; return true ; } catch ( IOException e ) { return false ; } } \n', 0.3461323769867741)

('private void initDict ( String file ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; String temp = null ; while ( ( temp = in . readLine ( ) ) != null ) { String [ ] wordlist = temp . split ( "-" ) ; for ( String word : wordlist ) { List < String > indexList = getSubStrings ( word ) ; for ( String oneIdx : indexList ) { if ( nwords . containsKey ( oneIdx ) ) { List < String > fullWords = nwords . get ( oneIdx ) ; if ( fullWords . contains ( word ) ) { continue ; } fullWords . add ( word ) ; nwords . put ( oneIdx , fullWords ) ; } else { List < String > entries = new ArrayList < String > ( ) ; entries . add ( word ) ; nwords . put ( oneIdx , entries ) ; } } } } } finally { if ( in != null ) in . close ( ) ; } } \n', 0.33988270310869273)

('public boolean initFromFile2 ( String fileName ) { File file = new File ( fileName ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( file ) ) ; String lineContent = null ; int _i = 0 ; while ( ( lineContent = reader . readLine ( ) ) != null ) { lineContent = lineContent . replaceAll ( "|t" , "-" ) ; lineContent = lineContent . replaceAll ( "-" , "-" ) ; lineContent = lineContent . trim ( ) ; if ( "" . equals ( lineContent ) ) { continue ; } String [ ] eles = lineContent . split ( "-" ) ; if ( eles . length != 9 ) { _i ++ ; continue ; } for ( int _j = 0 ; _j < 9 ; _j ++ ) { int mi = _i / 3 ; int mj = _j / 3 ; int i = _i - 3 * mi ; int j = _j - 3 * mj ; this . confirmOne ( mi , mj , i , j , Byte . valueOf ( eles [ _j ] ) ) ; } _i ++ ; } reader . close ( ) ; return true ; } catch ( IOException e ) { e . printStackTrace ( ) ; return false ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } } } \n', 0.32047571612854875)

('protected final void initialize ( int w , int h , int bpp , TwTwoReadStream stream , int [ ] pixels , boolean isPhotoCodec ) { if ( bpp != 16 && bpp != 24 ) throw new IllegalArgumentException ( "Invalid-depth-:" + bpp ) ; this . isPhotoCodec = isPhotoCodec ; isMultiColorSection = true ; pixelZero = PIXEL_ZERO_INITIAL_STATE ; pixelOne = PIXEL_ONE_INITIAL_STATE ; super . initialize ( w , h , bpp , stream ) ; output = pixels ; if ( initialScanLine . length < w ) { initialScanLine = new int [ w ] ; for ( int i = 0 ; i < w ; i ++ ) { initialScanLine [ i ] = PIXEL_ZERO_INITIAL_STATE ; } } if ( isPhotoCodec ) { photographicWeighting = INITIAL_PHOTOGRAPHIC_WEIGHTING ; int [ ] initialPixelCache = ( bpp == 16 ) ? initialPixelCache16 : initialPixelCache24 ; System . arraycopy ( initialPixelCache , 0 , pixelCache , 0 , pixelCache . length ) ; } } \n', 0.3180843057215118)

('private void init ( Vec2f point1 , Vec2f point2 , Vec2f point3 , Vec2f point4 ) { start = _points [ 0 ] = point1 ; ctrl_one = _points [ 1 ] = point2 ; ctrl_two = _points [ 2 ] = point3 ; end = _points [ 3 ] = point4 ; this . setLocation ( start ) ; this . updateSegs ( ) ; _pois = new ArrayList < Vec2f > ( ) ; _drawBorder = false ; _drawDots = new ArrayList < CircleShape > ( ) ; _drawLines = new ArrayList < LineSegment > ( ) ; } \n', 0.31496901188514614)

('private void initializeRandomCentroids ( ) { centroids = new ArrayList < List < Double >> ( ) ; System . out . println ( "Initialing-random-centroids..." ) ; for ( int i = 0 ; i < SharedClass . K_VALUE ; i ++ ) { List < Double > tempOneCentroid = new ArrayList < > ( ) ; for ( int j = 0 ; j < SharedClass . VECTOR_LENGTH ; j ++ ) { tempOneCentroid . add ( SharedClass . randomInRange ( 0.0 , 1.0 ) ) ; } centroids . add ( tempOneCentroid ) ; } copyOfInitialCentroids = centroids ; System . out . println ( "Random-centroids-initialied!!!-" ) ; } \n', 0.31138344889779124)

('public static double [ ] loadMatrix ( File file , String separator ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; String line ; List < String [ ] > lines = new ArrayList < > ( ) ; while ( ( line = in . readLine ( ) ) != null ) { lines . add ( line . split ( separator ) ) ; if ( lines . get ( lines . size ( ) - 1 ) . length != lines . get ( 0 ) . length ) { throw new IOException ( "Invalid-matrix!" ) ; } } double [ ] result = new double [ lines . size ( ) * lines . get ( 0 ) . length ] ; int k = 0 ; for ( String [ ] row : lines ) { for ( int j = 0 ; j < row . length ; j ++ ) { result [ k ++ ] = Double . valueOf ( row [ j ] . trim ( ) ) ; } } return result ; } finally { if ( in != null ) { in . close ( ) ; } } } \n', 0.2995084045709868)

('private void importConfig ( ) throws Exception { final BufferedReader read = new BufferedReader ( new FileReader ( this . config ) ) ; String line ; final List < String [ ] > lines = new ArrayList < String [ ] > ( ) ; while ( ( line = read . readLine ( ) ) != null ) { lines . add ( line . split ( Pattern . quote ( "-" ) ) ) ; } read . close ( ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { if ( lines . get ( i ) . length == 1 ) { if ( lines . get ( i ) [ 0 ] . isEmpty ( ) ) { continue ; } else { final List < String [ ] > dataContent = new ArrayList < String [ ] > ( ) ; int j = i ; j ++ ; while ( ! lines . get ( j ) [ 0 ] . isEmpty ( ) ) { j ++ ; if ( lines . size ( ) <= j ) { break ; } if ( lines . get ( j ) != null ) { dataContent . add ( lines . get ( j ) ) ; } if ( lines . size ( ) <= j + 1 || lines . get ( j + 1 ) . length == 0 ) { j ++ ; break ; } } this . data . put ( lines . get ( i ) [ 0 ] , dataContent ) ; i = j ; } } else { throw new IllegalArgumentException ( "Fehlerhafte-Konfigurationsdatei." ) ; } } } \n', 0.2981311463555627)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

('private static boolean containsCheckOnDoubleArray ( double [ ] array , Double compareTest ) { double test = compareTest . doubleValue ( ) ; for ( double d : array ) if ( d == test ) return true ; return false ; } \n', 0.3602336326876485)

('private static boolean containsCheckOnShortArray ( short [ ] array , Short compareTest ) { short test = compareTest . shortValue ( ) ; for ( short s : array ) if ( s == test ) return true ; return false ; } \n', 0.34824413533627085)

('void assertContains ( AssertionInfo info , Failures failures , Object array , Object value , Index index ) { assertNotNull ( info , array ) ; assertNotEmpty ( info , failures , array ) ; checkIndexValueIsValid ( index , sizeOf ( array ) - 1 ) ; Object actualElement = Array . get ( array , index . value ) ; if ( ! areEqual ( actualElement , value ) ) throw failures . failure ( info , shouldContainAtIndex ( array , value , index , Array . get ( array , index . value ) , comparisonStrategy ) ) ; } \n', 0.34135652419799833)

('void assertContains ( Description description , Object array , Object value , Index index ) { assertNotNull ( description , array ) ; assertNotEmpty ( description , array ) ; checkIndexValueIsValid ( index , sizeOf ( array ) - 1 ) ; Object actualElement = Array . get ( array , index . value ) ; if ( areEqual ( actualElement , value ) ) { return ; } throw failures . failure ( description , shouldContainAtIndex ( array , value , index , Array . get ( array , index . value ) ) ) ; } \n', 0.34080533955243075)

('void assertContainsExactly ( AssertionInfo info , Failures failures , Object actual , Object values ) { if ( commonChecks ( info , actual , values ) ) return ; assertNotNull ( info , actual ) ; assertIsArray ( info , actual ) ; assertIsArray ( info , values ) ; int actualSize = sizeOf ( actual ) ; int expectedSize = sizeOf ( values ) ; if ( actualSize != expectedSize ) throw failures . failure ( info , shouldHaveSameSize ( actual , values , actualSize , expectedSize , comparisonStrategy ) ) ; List < Object > actualWithoutDuplicates = asListWithoutDuplicatesAccordingToComparisonStrategy ( actual ) ; List < Object > notFound = containsOnly ( actualWithoutDuplicates , values ) ; if ( actualWithoutDuplicates . isEmpty ( ) && notFound . isEmpty ( ) ) { int arrayLength = sizeOf ( actual ) ; for ( int i = 0 ; i < arrayLength ; i ++ ) { Object actualElement = Array . get ( actual , i ) ; Object expectedElement = Array . get ( values , i ) ; if ( ! areEqual ( actualElement , expectedElement ) ) { throw failures . failure ( info , elementsDifferAtIndex ( actualElement , expectedElement , i , comparisonStrategy ) ) ; } } return ; } throw failures . failure ( info , shouldContainExactly ( actual , values , notFound , actualWithoutDuplicates , comparisonStrategy ) ) ; } \n', 0.3404522116788363)

('private static boolean containsCheckOnFloatArray ( float [ ] array , Float compareTest ) { float test = compareTest . floatValue ( ) ; for ( float f : array ) if ( f == test ) return true ; return false ; } \n', 0.3390590700170038)

('private static boolean containsCheckOnLongArray ( long [ ] array , Long compareTest ) { long test = compareTest . longValue ( ) ; for ( long l : array ) if ( l == test ) return true ; return false ; } \n', 0.3370525576539739)

('void assertContainsOnly ( AssertionInfo info , Failures failures , Object actual , Object values ) { if ( commonChecks ( info , actual , values ) ) return ; List < Object > notExpected = asListWithoutDuplicatesAccordingToComparisonStrategy ( actual ) ; List < Object > notFound = containsOnly ( notExpected , values ) ; if ( notExpected . isEmpty ( ) && notFound . isEmpty ( ) ) return ; throw failures . failure ( info , shouldContainOnly ( actual , values , notFound , notExpected , comparisonStrategy ) ) ; } \n', 0.33698370363562014)

('public void verifyValues ( ) { List known = new ArrayList ( confirmed . values ( ) ) ; List test = new ArrayList ( values ) ; int size = confirmed . size ( ) ; boolean empty = confirmed . isEmpty ( ) ; assertEquals ( "values-should-be-same-size-as-HashMap\'s" + "-Test:-" + test + "-Real:-" + known , size , values . size ( ) ) ; assertEquals ( "values-should-be-empty-if-HashMap-is" + "-Test:-" + test + "-Real:-" + known , empty , values . isEmpty ( ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , test . containsAll ( known ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , known . containsAll ( test ) ) ; for ( Iterator it = known . iterator ( ) ; it . hasNext ( ) ; ) { boolean removed = test . remove ( it . next ( ) ) ; assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , removed ) ; } assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , test . isEmpty ( ) ) ; } \n', 0.3342096505976902)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public String lookupEnumString ( int e ) { String result = map . get ( e ) ; return ( result == null ) ? "Unknown-enum-value=" + e : result ; } \n', 0.4212740360120386)

('public static < T extends Enum < T >> T getEnumFromStringCaseSensitive ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.39054080139591285)

('public static AccountAcTypeEnum lookupEnum ( String value ) { return AccountAcTypeEnum . valueMap . get ( value ) ; } \n', 0.3833591515632784)

('private static < T extends Enum < T >> T getEnumFromValue ( Class < T > enumType , int value ) { int ordinal ; int [ ] registeredValues = sEnumValues . get ( enumType ) ; if ( registeredValues != null ) { ordinal = - 1 ; for ( int i = 0 ; i < registeredValues . length ; ++ i ) { if ( registeredValues [ i ] == value ) { ordinal = i ; break ; } } } else { ordinal = value ; } T [ ] values = enumType . getEnumConstants ( ) ; if ( ordinal < 0 || ordinal >= values . length ) { throw new IllegalArgumentException ( String . format ( "Argument-\'value\'-(%d)-was-not-a-valid-enum-value-for-type-%s-" + "(registered?-%b)" , value , enumType , ( registeredValues != null ) ) ) ; } return values [ ordinal ] ; } \n', 0.3812954251206542)

('public static < T extends Enum < T >> T getEnumFromString ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string . trim ( ) . toUpperCase ( ) ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.38014169306173196)

('protected Enumerated resolveEnum ( final Object value ) throws InvalidEnumerationException { return toState11 ( ( String ) value ) ; } \n', 0.3782833591892833)

('public static Enum getEnumFromString ( Class enumClass , String code ) { ClassHelper . initializeCheck ( enumClass ) ; Iterator iter = enums . values ( enumClass ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Enum myEnum = ( Enum ) iter . next ( ) ; if ( code . equals ( myEnum . getCode ( ) . toString ( ) ) ) { return myEnum ; } } DebugHome . getDebugLog ( ) . warn ( "Unknown-enum,-class-=-" + enumClass . getName ( ) + ",-code-=-" + code ) ; return null ; } \n', 0.3692864157425656)

('public static < E extends Enum < E >> EnumSet < E > getEnumSetFromString ( Class < E > enumType , String enumString ) { EnumSet < E > es = EnumSet . noneOf ( enumType ) ; if ( ! Strings . isNullOrEmpty ( enumString ) ) { String [ ] split = enumString . split ( "," ) ; for ( String s : split ) { es . add ( Enum . valueOf ( enumType , s ) ) ; } } return es ; } \n', 0.36732509354335485)

('public static < T extends Enum < ? >> T lookupEnum ( String name , Class < T > vocab ) { if ( Strings . isNullOrEmpty ( name ) ) { return null ; } final String normedType = name . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; T [ ] values = vocab . getEnumConstants ( ) ; if ( values != null ) { for ( T val : values ) { final String normedVal = val . name ( ) . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; if ( normedType . equals ( normedVal ) ) { return val ; } } } throw new IllegalArgumentException ( "Cannot-parse-" + name + "-into-a-known-" + vocab . getSimpleName ( ) ) ; } \n', 0.36052107724200017)

('protected E stringToEnum ( final String string ) { final E value = _stringToEnum . get ( string ) ; if ( value == null ) { throw new OpenGammaRuntimeException ( "unexpected-value:-" + string ) ; } return value ; } \n', 0.3565804403862347)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('protected void recursiveNestedJoin ( EventBean lookupEvent , int nestingOrderIndex , EventBean [ ] currentPath , Collection < EventBean [ ] > result , ExprEvaluatorContext exprEvaluatorContext ) { List < EventBean [ ] > nestedResult = new LinkedList < EventBean [ ] > ( ) ; ExecNode nestedExecNode = childNodes . get ( nestingOrderIndex ) ; nestedExecNode . process ( lookupEvent , currentPath , nestedResult , exprEvaluatorContext ) ; boolean isLastStream = ( nestingOrderIndex == nestingOrderLength - 1 ) ; if ( ! isLastStream ) { for ( EventBean [ ] row : nestedResult ) { EventBean lookup = row [ nestedStreams [ nestingOrderIndex ] ] ; recursiveNestedJoin ( lookup , nestingOrderIndex + 1 , row , result , exprEvaluatorContext ) ; } return ; } for ( EventBean [ ] row : nestedResult ) { result . add ( row ) ; } } \n', 0.3494762225854692)

('public void visitForeachLoop ( JCEnhancedForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStat ( tree . var , loopEnv ) ; Type exprType = types . upperBound ( attribExpr ( tree . expr , loopEnv ) ) ; chk . checkNonVoid ( tree . pos ( ) , exprType ) ; Type elemtype = types . elemtype ( exprType ) ; if ( elemtype == null ) { Type base = types . asSuper ( exprType , syms . iterableType . tsym ) ; if ( base == null ) { log . error ( tree . expr . pos ( ) , "foreach.not.applicable.to.type" , exprType , diags . fragment ( "type.req.array.or.iterable" ) ) ; elemtype = types . createErrorType ( exprType ) ; } else { List < Type > iterableParams = base . allparams ( ) ; elemtype = iterableParams . isEmpty ( ) ? syms . objectType : types . upperBound ( iterableParams . head ) ; } } chk . checkType ( tree . expr . pos ( ) , elemtype , tree . var . sym . type ) ; loopEnv . tree = tree ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.31910015986070384)

('private NestedLoops ( final Vector2D [ ] loop ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; surrounded = new ArrayList < NestedLoops > ( ) ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( previous ) . getX ( ) , line . toSubSpace ( current ) . getX ( ) ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.3025557593544445)

('@ SuppressWarnings ( "serial" ) public void testNestedRuntimeExceptionWithRootCause ( ) { String myMessage = "mesg-for-this-exception" ; String rootCauseMesg = "this-is-the-obscure-message-of-the-root-cause" ; Exception rootCause = new Exception ( rootCauseMesg ) ; NestedRuntimeException nex = new NestedRuntimeException ( myMessage , rootCause ) { } ; assertEquals ( nex . getCause ( ) , rootCause ) ; assertTrue ( nex . getMessage ( ) . indexOf ( myMessage ) != - 1 ) ; assertTrue ( nex . getMessage ( ) . indexOf ( rootCauseMesg ) != - 1 ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pw = new PrintWriter ( baos ) ; nex . printStackTrace ( pw ) ; pw . flush ( ) ; String stackTrace = new String ( baos . toByteArray ( ) ) ; assertFalse ( stackTrace . indexOf ( rootCause . getClass ( ) . getName ( ) ) == - 1 ) ; assertFalse ( stackTrace . indexOf ( rootCauseMesg ) == - 1 ) ; } \n', 0.30085220317759176)

('public void visitWhileLoop ( JCWhileLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || ! tree . cond . type . isTrue ( ) ; } \n', 0.29932897137891834)

('public void visitForLoop ( JCForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStats ( tree . init , loopEnv ) ; if ( tree . cond != null ) attribExpr ( tree . cond , loopEnv , syms . booleanType ) ; loopEnv . tree = tree ; attribStats ( tree . step , loopEnv ) ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.2981734140170164)

('protected final int readUntilNestedIgnoreCase ( String endString ) { int index = Util . indexOfNestedIgnoreCase ( fStringSource , endString , fCurrentPosition ) ; if ( index != ( - 1 ) ) { fCurrentPosition = index + 2 + endString . length ( ) ; return 2 + endString . length ( ) ; } fCurrentPosition = fStringSource . length ( ) ; return 0 ; } \n', 0.2973384710464471)

('public void addNestedPos ( ExtractionPos loop ) { nested_loops . add ( loop ) ; } \n', 0.2955534288106427)

('private void removeLoopWithExitNode ( Map < CfgBlock , Set < CfgBlock >> loops , CfgBlock header , Set < CfgBlock > body , CfgBlock headerExitBlock ) { CfgBlock headerClone = null ; for ( CfgBlock b : new HashSet < CfgBlock > ( body ) ) { if ( method . containsEdge ( b , header ) ) { method . removeEdge ( method . getEdge ( b , header ) ) ; if ( headerClone == null ) { headerClone = header . deepCopy ( ) ; addBlockToLoops ( header , headerClone , loops ) ; method . addEdge ( headerClone , headerExitBlock ) ; } method . addEdge ( b , headerClone ) ; } } } \n', 0.29077522927152594)

('protected int incrementLoopExitRepeatition ( Stmt stmt ) { int value = this . getLoopExitRepeatition ( stmt ) ; this . loopExitToRepeatitionMap . put ( stmt , ++ value ) ; return value ; } \n', 0.2897714675806873)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('public static HashSet < Integer [ ] > ways ( int SIZE ) { if ( SIZE <= 3 ) { return new HashSet < Integer [ ] > ( ) ; } HashSet < Integer [ ] > result = new HashSet < Integer [ ] > ( ) ; HashSet < Integer [ ] > tmpResult = new HashSet < Integer [ ] > ( ) ; Integer [ ] init = new Integer [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { init [ i ] = - 1 ; } result . add ( init ) ; Integer [ ] tmpIt ; for ( int i = 0 ; i < SIZE ; i ++ ) { for ( Integer [ ] it : result ) { for ( int position = 0 ; position < SIZE ; position ++ ) { if ( it [ position ] == - 1 ) { tmpIt = it . clone ( ) ; tmpIt [ position ] = i ; if ( isValid ( tmpIt , SIZE ) ) { tmpResult . add ( tmpIt ) ; } } } } result = ( HashSet < Integer [ ] > ) tmpResult . clone ( ) ; tmpResult . clear ( ) ; } return result ; } \n', 0.2827058915147148)

('public static Object [ ] makeDifferenceArray ( Object [ ] items , Object [ ] remove ) { if ( items == null ) return ( EMPTY_OBJECT_ARRAY ) ; if ( remove == null ) return ( items ) ; Set holder = makeDifferenceSet ( items , remove ) ; Object [ ] ret = ( Object [ ] ) Array . newInstance ( items . getClass ( ) . getComponentType ( ) , holder . size ( ) ) ; holder . toArray ( ret ) ; return ( ret ) ; } \n', 0.2752536134228617)

('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final int initialCapacity ) { return Util . makeArrayList ( initialCapacity ) ; } \n', 0.25944119104017654)

('public static Integer [ ] createIntegerArrFromCollection ( List < Integer [ ] > integerArrList ) { if ( integerArrList == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; Iterator < Integer [ ] > iterator = integerArrList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer [ ] integerArr = iterator . next ( ) ; if ( integerArr != null && integerArr . length > 0 ) { for ( Integer integerValue : integerArr ) { if ( integerValue != null ) { integerList . add ( integerValue ) ; } } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.20683059309728571)

('public static void initArray ( final Object oArr ) { if ( oArr == null || ! oArr . getClass ( ) . isArray ( ) || oArr . getClass ( ) . isPrimitive ( ) ) return ; final Object arr [ ] = ( Object [ ] ) oArr ; for ( int i = 0 ; i < arr . length ; i ++ ) if ( arr [ i ] == null ) try { arr [ i ] = oArr . getClass ( ) . getComponentType ( ) . newInstance ( ) ; } catch ( final Exception e ) { } else initArray ( arr [ i ] ) ; } \n', 0.2040489235679044)

('public void testCreatePrimitiveArray ( ) throws SQLException { double in [ ] [ ] = new double [ 2 ] [ 2 ] ; in [ 0 ] [ 0 ] = 3.5 ; in [ 0 ] [ 1 ] = - 4.5 ; in [ 1 ] [ 0 ] = 10.0 / 3 ; in [ 1 ] [ 1 ] = 77 ; Array arr = _conn . createArrayOf ( "float8" , in ) ; Double out [ ] [ ] = ( Double [ ] [ ] ) arr . getArray ( ) ; assertEquals ( 2 , out . length ) ; assertEquals ( 2 , out [ 0 ] . length ) ; assertEquals ( 3.5 , out [ 0 ] [ 0 ] , 0.00001 ) ; assertEquals ( - 4.5 , out [ 0 ] [ 1 ] , 0.00001 ) ; assertEquals ( 10.0 / 3 , out [ 1 ] [ 0 ] , 0.00001 ) ; assertEquals ( 77 , out [ 1 ] [ 1 ] , 0.00001 ) ; } \n', 0.20183489705511393)

('public Object [ ] createEStringArrayFromString ( EDataType eDataType , String initialValue ) { return ( Object [ ] ) super . createFromString ( initialValue ) ; } \n', 0.2007816090980968)

('private void registerORBInitializers ( Properties props ) { String orbInitPrefix = ORBConstants . PI_ORB_INITIALIZER_CLASS_PREFIX ; Enumeration propertyNames = props . propertyNames ( ) ; ArrayList initializerList = new ArrayList ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String propertyName = ( String ) propertyNames . nextElement ( ) ; if ( propertyName . startsWith ( orbInitPrefix ) ) { String initClassName = propertyName . substring ( orbInitPrefix . length ( ) ) ; try { Class initClass = ORBClassLoader . loadClass ( initClassName ) ; if ( ORBInitializer . class . isAssignableFrom ( initClass ) ) { if ( initClass != null ) { ORBInitializer initializer = ( ORBInitializer ) initClass . newInstance ( ) ; initializerList . add ( initializer ) ; } } } catch ( Exception e ) { } } } if ( initializerList . size ( ) > 0 ) { orbInitializers = ( ORBInitializer [ ] ) initializerList . toArray ( new ORBInitializer [ 0 ] ) ; } else { orbInitializers = null ; } } \n', 0.19424673362010497)

('private String [ ] makePrefixArray ( ) { String [ ] prefixes = ( String [ ] ) declaredNamespaceMap . keySet ( ) . toArray ( new String [ declaredNamespaceMap . size ( ) ] ) ; Arrays . sort ( prefixes ) ; return prefixes ; } \n', 0.19394437230368422)

('private static ArrayList < GeneralForm > populateMobileNumbers ( List < Object [ ] > mobileNumberList ) throws Exception { ArrayList < GeneralForm > populatedList = new ArrayList < GeneralForm > ( ) ; GeneralForm generalForm = null ; for ( int count = 0 ; count < mobileNumberList . size ( ) ; count ++ ) { generalForm = new GeneralForm ( ) ; generalForm . setMobileOwnerName ( ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 0 ] != null ? ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 0 ] . toString ( ) : "-" ) ; StringBuffer mobileNumber = new StringBuffer ( ) ; mobileNumber . append ( ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 1 ] != null ? ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 1 ] . toString ( ) : "" ) ; mobileNumber . append ( ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 2 ] != null ? ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 2 ] . toString ( ) : "" ) ; mobileNumber . append ( ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 3 ] != null ? ( ( Object [ ] ) mobileNumberList . get ( count ) ) [ 3 ] . toString ( ) : "" ) ; generalForm . setMobileNumber ( mobileNumber . toString ( ) ) ; populatedList . add ( generalForm ) ; } return populatedList ; } \n', 0.19092595164312617)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('public static String getRandomString ( int maxLength , boolean fixedTextLength ) { Random r = new Random ( ) ; int length ; if ( ! fixedTextLength ) { length = ( int ) ( ( r . nextDouble ( ) * ( double ) maxLength ) + 1.0 ) ; } else { length = maxLength ; } String random = "" ; for ( int i = 0 ; i < length ; i ++ ) { random += getRandomChar ( ) ; } return random ; } \n', 0.44463312362721774)

('private static String getRandomAlphaString ( int length ) { StringBuffer buf = new StringBuffer ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { char randChar = ( char ) ( 97 + generator . nextInt ( 26 ) ) ; buf . append ( randChar ) ; } return buf . toString ( ) ; } \n', 0.4390913036347347)

('public static String getRandomAlphanumericString ( int length ) { StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( randomAlphaNumericCharacters [ random . nextInt ( randomAlphaNumericCharacters . length ) ] ) ; } return sb . toString ( ) ; } \n', 0.43253386353057166)

('protected String generateRandomString ( int length ) { Random random = new Random ( ) ; StringBuilder randomStringBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { randomStringBuilder . append ( Integer . toHexString ( random . nextInt ( 0x10 ) ) ) ; } return randomStringBuilder . toString ( ) ; } \n', 0.42714600374995665)

("public static String generateRandomString ( int length ) { char [ ] characters = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char start , end ; switch ( random . nextInt ( 4 ) ) { case 0 : start = 'A' ; end = 'Z' ; case 1 : start = '0' ; end = '9' ; default : start = 'a' ; end = 'z' ; } characters [ i ] = ( char ) ( start + random . nextInt ( end - start ) ) ; } return new String ( characters ) ; } \n", 0.4237233491623514)

("public String randomDecimalString ( int start , int end , int scale ) { int val = randomInt ( start , end ) ; int whole = val / RESCALE [ scale ] ; int part = val % RESCALE [ scale ] ; decimalString . setLength ( 0 ) ; decimalString . append ( whole ) ; decimalString . append ( '.' ) ; int pos = decimalString . length ( ) ; decimalString . append ( part ) ; int tempScale = decimalString . length ( ) - pos ; if ( tempScale < scale ) { for ( int i = 0 ; i < ( scale - tempScale ) ; i ++ ) decimalString . insert ( pos , '0' ) ; } return decimalString . toString ( ) ; } \n", 0.42272620335214184)

('public static String generateRandomString ( ) { Random rnd = new Random ( ) ; int noOfCAPSAlpha = 2 ; int noOfDigits = 2 ; int noOfSplChars = 2 ; char [ ] pswd = new char [ Constant . LOGIN_PASSWORD_LENGTH ] ; int index = 0 , i ; for ( i = 0 ; i < noOfCAPSAlpha ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = ALPHA_CAPS . charAt ( rnd . nextInt ( ALPHA_CAPS . length ( ) ) ) ; } for ( i = 0 ; i < noOfDigits ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = NUM . charAt ( rnd . nextInt ( NUM . length ( ) ) ) ; } for ( i = 0 ; i < noOfSplChars ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = SPL_CHARS . charAt ( rnd . nextInt ( SPL_CHARS . length ( ) ) ) ; } for ( i = 0 ; i < Constant . LOGIN_PASSWORD_LENGTH ; i ++ ) { if ( pswd [ i ] == 0 ) { pswd [ i ] = ALPHA . charAt ( rnd . nextInt ( ALPHA . length ( ) ) ) ; } } return String . valueOf ( pswd ) ; } \n', 0.42042499784998816)

('private static String generateRandomString ( int length ) { String allowedChars = "0123456789abcdefghijklmnopqrstuvwxyz" ; Random random = new Random ( ) ; int max = allowedChars . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int value = random . nextInt ( max ) ; buffer . append ( allowedChars . charAt ( value ) ) ; } return buffer . toString ( ) ; } \n', 0.42009728664531476)

('private static String generateRandomString ( int length ) { StringBuilder result = new StringBuilder ( length ) ; byte [ ] bytes = new byte [ length ] ; random . nextBytes ( bytes ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result . append ( BASE64_ALPHABET [ bytes [ i ] & 0x3F ] ) ; } return result . toString ( ) ; } \n', 0.4186660656578442)

('public static String generateRandomString ( int count ) { Random random = new Random ( ) ; StringBuffer buffer = new StringBuffer ( ) ; while ( count -- != 0 ) { char ch = ( char ) ( random . nextInt ( 96 ) + 32 ) ; buffer . append ( ch ) ; } return buffer . toString ( ) ; } \n', 0.41864125499838556)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public void printBitArrays ( ) { for ( ArrayList < Integer > bitArray : bitArrays ) { for ( Integer bit : bitArray ) { System . out . print ( bit . intValue ( ) ) ; } System . out . println ( ) ; } } \n', 0.33993759585503436)

('protected void printObjectArrayContents ( Object objectArrayToPrint ) { Object [ ] arrayToPrint = ( Object [ ] ) objectArrayToPrint ; System . out . print ( "-RESULT:-" ) ; for ( int i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( i > 0 ) { System . out . print ( ",-" ) ; } System . out . print ( arrayToPrint [ i ] ) ; } System . out . println ( "-" ) ; } \n', 0.3253158161385643)

('private static void printArray ( String label , String [ ] array ) { System . out . print ( label ) ; System . out . print ( ":-" ) ; String result = Arrays . toString ( array ) ; System . out . println ( result ) ; } \n', 0.30809361127763923)

('public static void printStringArrayToFile ( String [ ] array , String fileName ) { try { formatter = new Formatter ( fileName ) ; } catch ( FileNotFoundException e ) { System . err . println ( "File-Not-Found-Exception-:" + fileName ) ; return ; } for ( int i = 0 ; i < array . length ; i ++ ) { formatter . format ( "%s-" , array [ i ] ) ; } formatter . flush ( ) ; formatter . close ( ) ; } \n', 0.30592278089384217)

('public static void printIntArrayToFile ( int [ ] array , String fileName ) { try { formatter = new Formatter ( fileName ) ; } catch ( FileNotFoundException e ) { System . err . println ( "File-Not-Found-Exception-:" + fileName ) ; return ; } for ( int i = 0 ; i < array . length ; i ++ ) { formatter . format ( "%d-" , array [ i ] ) ; } formatter . flush ( ) ; formatter . close ( ) ; } \n', 0.2967523202614558)

('public static String printArray ( byte [ ] array , boolean withHash ) { if ( array == null ) return "null" ; int limit = 8 ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( "[B0x" ) ; if ( array . length <= limit || IS_ARRAYS_DEBUG ) { sb . append ( toHexString ( array ) ) ; if ( withHash ) { sb . append ( ",h=" ) ; sb . append ( Integer . toHexString ( Arrays . hashCode ( array ) ) ) ; sb . append ( \']\' ) ; } } else { sb . append ( toHexString ( array , limit ) ) ; sb . append ( "..[" ) ; sb . append ( array . length ) ; if ( withHash ) { sb . append ( "],h=" ) ; sb . append ( Integer . toHexString ( Arrays . hashCode ( array ) ) ) ; } sb . append ( \']\' ) ; } return sb . toString ( ) ; } \n', 0.2938189126509444)

('public static void printArray ( int [ ] array ) { Arrays . sort ( array ) ; System . out . println ( Arrays . toString ( array ) ) ; } \n', 0.2886685853640042)

('public static void printDoubleArrayToFile ( double [ ] array , String fileName ) { try { formatter = new Formatter ( fileName ) ; } catch ( FileNotFoundException e ) { System . err . println ( "File-Not-Found-Exception-:" + fileName ) ; return ; } for ( int i = 0 ; i < array . length ; i ++ ) { formatter . format ( "%f-" , array [ i ] ) ; } formatter . flush ( ) ; formatter . close ( ) ; } \n', 0.28591905828546593)

('public static String printArrayToDialogString ( Object [ ] array ) { if ( array == null ) return "null" ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( i > 0 ) if ( i == array . length - 1 ) buffer . append ( "-and-" ) ; else buffer . append ( ",-" ) ; buffer . append ( "\'" ) . append ( shortenPath ( array [ i ] . toString ( ) , 60 ) ) . append ( "\'" ) ; } return buffer . toString ( ) ; } \n', 0.2835580463268764)

('public static void printFloatArrayToFile ( float [ ] array , String fileName ) { try { formatter = new Formatter ( fileName ) ; } catch ( FileNotFoundException e ) { System . err . println ( "File-Not-Found-Exception-:" + fileName ) ; return ; } for ( int i = 0 ; i < array . length ; i ++ ) { formatter . format ( "%f-" , array [ i ] ) ; } formatter . flush ( ) ; formatter . close ( ) ; } \n', 0.28326051282563036)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('public static < K , V extends Comparable < V >> Map < K , V > sortMapByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.47019823717805165)

('private static Map sortMapByValues ( Map map ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( ( Map . Entry ) ( o2 ) ) . getValue ( ) == ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ? ( ( Comparable ) ( ( Map . Entry ) ( o1 ) ) . getKey ( ) ) . compareTo ( ( ( Map . Entry ) ( o2 ) ) . getKey ( ) ) : ( ( Comparable ) ( ( Map . Entry ) ( o2 ) ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ; } } ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46917912357463765)

('public static Map < Long , Float > sortMapByValue ( Map < Long , Float > map ) { List < Map . Entry < Long , Float >> list = new LinkedList < Entry < Long , Float >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Long , Float >> ( ) { @ Override public int compare ( Map . Entry < Long , Float > o1 , Map . Entry < Long , Float > o2 ) { if ( o1 . getValue ( ) <= o2 . getValue ( ) ) { return 1 ; } else { return - 1 ; } } } ) ; Map < Long , Float > result = new LinkedHashMap < Long , Float > ( ) ; for ( Iterator < Entry < Long , Float >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Long , Float > entry = it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } \n', 0.4682754856723419)

('public static < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k1 ) . compareTo ( map . get ( k2 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return new LinkedHashMap < K , V > ( sortedByValues ) ; } \n', 0.46806062228012674)

('public static HashMap sortMapByValues ( HashMap map ) { List < Map . Entry > list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new MapValueSorter ( ) ) ; HashMap sortedHashMap = new LinkedHashMap ( ) ; for ( Map . Entry e : list ) { sortedHashMap . put ( e . getKey ( ) , e . getValue ( ) ) ; } return sortedHashMap ; } \n', 0.46781194072755194)

('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46680150576087603)

('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

('static public < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public < K extends Comparable < K > , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) { return k1 . compareTo ( k2 ) ; } else { return compare ; } } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public static < K , V extends Comparable < V >> TreeMap < K , V > sortByValues ( final TreeMap < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; TreeMap < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.46532808992763286)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('public String doSquareRootsMath ( ArrayList < String > mathSymbolsToCompute , ArrayList < Double > mathNumbersToCompute , int isThereASquareRoot ) { double myNumberToTakeSquareRootOf = mathNumbersToCompute . get ( isThereASquareRoot ) ; if ( myNumberToTakeSquareRootOf < 0 ) return ( "ERROR" ) ; else { double mySquareRootedNumber = Math . sqrt ( myNumberToTakeSquareRootOf ) ; double myTruncatedSquareRootedNumber = truncateMyDecimal ( mySquareRootedNumber ) ; mathSymbolsToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . add ( isThereASquareRoot , mySquareRootedNumber ) ; return ( String . valueOf ( myTruncatedSquareRootedNumber ) ) ; } } \n', 0.2772193949730584)

('public RealMatrix getSquareRoot ( ) { if ( ! isSymmetric ) { throw new MathUnsupportedOperationException ( ) ; } final double [ ] sqrtEigenValues = new double [ realEigenvalues . length ] ; for ( int i = 0 ; i < realEigenvalues . length ; i ++ ) { final double eigen = realEigenvalues [ i ] ; if ( eigen <= 0 ) { throw new MathUnsupportedOperationException ( ) ; } sqrtEigenValues [ i ] = FastMath . sqrt ( eigen ) ; } final RealMatrix sqrtEigen = MatrixUtils . createRealDiagonalMatrix ( sqrtEigenValues ) ; final RealMatrix v = getV ( ) ; final RealMatrix vT = getVT ( ) ; return v . multiply ( sqrtEigen ) . multiply ( vT ) ; } \n', 0.2488529753303889)

('public static BigInteger squareRoot ( BigInteger a ) { int bl ; BigInteger result , remainder , b ; if ( a . compareTo ( ZERO ) < 0 ) { throw new ArithmeticException ( "cannot-extract-root-of-negative-number" + a + "." ) ; } bl = a . bitLength ( ) ; result = ZERO ; remainder = ZERO ; if ( ( bl & 1 ) != 0 ) { result = result . add ( ONE ) ; bl -- ; } while ( bl > 0 ) { remainder = remainder . multiply ( FOUR ) ; remainder = remainder . add ( BigInteger . valueOf ( ( a . testBit ( -- bl ) ? 2 : 0 ) + ( a . testBit ( -- bl ) ? 1 : 0 ) ) ) ; b = result . multiply ( FOUR ) . add ( ONE ) ; result = result . multiply ( TWO ) ; if ( remainder . compareTo ( b ) != - 1 ) { result = result . add ( ONE ) ; remainder = remainder . subtract ( b ) ; } } return result ; } \n', 0.2282895285339142)

('public static double logRootMeanSquare ( double [ ] samples ) { assert samples . length > 0 ; double sumOfSquares = 0.0f ; for ( double sample : samples ) { sumOfSquares += sample * sample ; } double rootMeanSquare = Math . sqrt ( sumOfSquares / samples . length ) ; rootMeanSquare = Math . max ( rootMeanSquare , 1 ) ; return ( LogMath . log10 ( ( float ) rootMeanSquare ) * 20 ) ; } \n', 0.2191175718171015)

('private static RealMatrix squareRoot ( final RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.21810060821739316)

('private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.21810060821739316)

('private int determine ( TreeNode root ) { if ( root == null ) { return 0 ; } else { int leftDepth = determine ( root . left ) ; int rightDepth = determine ( root . right ) ; if ( leftDepth < 0 || rightDepth < 0 || Math . abs ( leftDepth - rightDepth ) > 1 ) return - 1 ; return Math . max ( leftDepth , rightDepth ) + 1 ; } } \n', 0.2150927644903356)

('private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.20787253667564554)

('private static RealMatrix squareRoot ( final RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.2078725366756455)

('public final double rootRelativeSquaredError ( ) { if ( m_NoPriors ) return Double . NaN ; return 100.0 * rootMeanSquaredError ( ) / rootMeanPriorSquaredError ( ) ; } \n', 0.20629253994491284)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
('public byte [ ] concatenateTwoByteArrays ( byte [ ] a , byte [ ] b ) { byte [ ] c = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } \n', 0.34917792092265965)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , final Object [ ] three , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 3 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; matrix [ 2 ] = three ; return concatArrays ( matrix ) ; } \n', 0.34365154097903006)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 2 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; return concatArrays ( matrix ) ; } \n', 0.32860896141681817)

('public static < A extends Comparable < A > , B > void sortTwoArrays ( A [ ] firstArray , B [ ] secondArray ) { if ( firstArray . length != secondArray . length ) { throw new RuntimeException ( "Both-arrays-must-be-of-the-same-length" ) ; } class element { public A first ; public B second ; } element [ ] elements = new element [ firstArray . length ] ; Arrays . sort ( elements , new Comparator < element > ( ) { public int compare ( element a , element b ) { return a . first . compareTo ( b . first ) ; } } ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { firstArray [ i ] = elements [ i ] . first ; secondArray [ i ] = elements [ i ] . second ; } } \n', 0.3259440797441201)

('private String [ ] concatenateArraysForInput ( String [ ] param , String [ ] value ) { String [ ] array = ( String [ ] ) Array . newInstance ( param [ 0 ] . getClass ( ) , param . length + value . length ) ; int j = 0 ; if ( param . length == value . length ) { for ( int i = 0 ; i < param . length ; i ++ ) { if ( i == 0 ) j = j + i ; else j = j + 1 ; array [ j ] = param [ i ] ; j = j + 1 ; array [ j ] = value [ i ] ; } } else { logger . warn ( "WARNING:-Check-your-array-size" ) ; } return array ; } \n', 0.3249121396561949)

('public static void sortBubbleTwo ( int [ ] array ) { try { for ( int end = 0 ; end < array . length - 1 ; end ++ ) { for ( int index = 0 ; index < array . length - end - 1 ; index ++ ) { if ( array [ index ] > array [ index + 1 ] ) { int temp = array [ index ] ; array [ index ] = array [ index + 1 ] ; array [ index + 1 ] = temp ; System . out . println ( Arrays . toString ( array ) ) ; } } } } catch ( NullPointerException e ) { System . out . println ( "Array-is-empty!" ) ; } System . out . println ( ) ; } \n', 0.3212984501886853)

('public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( Objects . isEmpty ( array1 ) ) { return array2 ; } if ( Objects . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArr , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArr , array1 . length , array2 . length ) ; return newArr ; } \n', 0.31814045405613983)

('public static < T > T [ ] concatenateArrays ( T [ ] first , T [ ] ... rest ) { int totalLength = first . length ; for ( T [ ] array : rest ) { totalLength += array . length ; } T [ ] result = Arrays . copyOf ( first , totalLength ) ; int offset = first . length ; for ( T [ ] array : rest ) { System . arraycopy ( array , 0 , result , offset , array . length ) ; offset += array . length ; } return result ; } \n', 0.31546183172548464)

('private static < T > void concatenateArrays ( Iterable < T [ ] > arraysToConcatenate , T [ ] destination ) { int nextStartIndexToUse = 0 ; for ( T [ ] array : arraysToConcatenate ) { System . arraycopy ( array , 0 , destination , nextStartIndexToUse , array . length ) ; nextStartIndexToUse += array . length ; } } \n', 0.31076428099890496)

('public static java . lang . Object concatenateArrays ( Class < ? > resultClass , java . lang . Object arr1 , java . lang . Object arr2 ) throws ArrayStoreException { if ( arr1 == null ) { return arr2 ; } else if ( arr2 == null ) { return arr1 ; } java . lang . Object newArray = Array . newInstance ( resultClass , Array . getLength ( arr1 ) + Array . getLength ( arr2 ) ) ; System . arraycopy ( arr1 , 0 , newArray , 0 , Array . getLength ( arr1 ) ) ; System . arraycopy ( arr2 , 0 , newArray , Array . getLength ( arr1 ) , Array . getLength ( arr2 ) ) ; return newArray ; } \n', 0.30608763426169416)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public File createFileFromURL ( URL resource ) { LOGGER . info ( "Resource-is-{}." , resource . getPath ( ) ) ; String [ ] arr = resource . getPath ( ) . split ( "/" ) ; String filenameWithoutPath = arr [ arr . length - 1 ] ; File configFile = null ; try { String fileContent = Resources . toString ( resource , Charset . defaultCharset ( ) ) ; configFile = createFileFromString ( fileContent , filenameWithoutPath ) ; } catch ( IOException e ) { LOGGER . error ( "Error-reading-resource-{}." , resource . getPath ( ) , e ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.37207679938316557)

('public File createFileFromString ( EDataType eDataType , String initialValue ) { return ( File ) super . createFromString ( eDataType , initialValue ) ; } \n', 0.3547786782348934)

('public static String stringFromFileContents ( final IFile file ) throws CoreException , IOException { final InputStream fileStream = file . getContents ( ) ; final InputStreamReader fileReader = new InputStreamReader ( fileStream , file . getCharset ( true ) ) ; final char fileContentsBuffer [ ] = new char [ fileStream . available ( ) ] ; final int fileSize = fileReader . read ( fileContentsBuffer ) ; return new String ( fileContentsBuffer , 0 , fileSize ) ; } \n', 0.349216823806321)

('private String makeFileName ( String contentType , boolean skipAutoNumber , boolean skipSuffix ) { StringBuilder sb = new StringBuilder ( FileServer . resolveBaseRelativeName ( getFilename ( ) ) ) ; sb . append ( timeStamp ) ; if ( ! skipAutoNumber ) { String number = Long . toString ( nextNumber ( ) ) ; for ( int i = number . length ( ) ; i < numberPadLength ; i ++ ) { sb . append ( \'0\' ) ; } sb . append ( number ) ; } if ( ! skipSuffix ) { sb . append ( \'.\' ) ; if ( contentType != null ) { int i = contentType . indexOf ( \'/\' ) ; if ( i != - 1 ) { int j = contentType . indexOf ( \';\' ) ; if ( j != - 1 ) { sb . append ( contentType . substring ( i + 1 , j ) ) ; } else { sb . append ( contentType . substring ( i + 1 ) ) ; } } else { sb . append ( "unknown" ) ; } } else { sb . append ( "unknown" ) ; } } return sb . toString ( ) ; } \n', 0.3458917791408854)

('String getFileContentsFromJar ( JarFile jarFile , JarEntry jarEntry ) throws IOException { StringBuffer fileContent = new StringBuffer ( ) ; InputStream is = jarFile . getInputStream ( jarEntry ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; int length = 500 ; byte buf [ ] = new byte [ length ] ; int count = 0 ; while ( ( count = bis . read ( buf , 0 , length ) ) != - 1 ) { fileContent . append ( new String ( buf , 0 , count ) ) ; buf = new byte [ length ] ; } bis . close ( ) ; is . close ( ) ; return fileContent . toString ( ) ; } \n', 0.340092415981402)

('public static boolean createFromHFileLink ( final Configuration conf , final FileSystem fs , final Path dstFamilyPath , final String hfileLinkName ) throws IOException { Matcher m = LINK_NAME_PATTERN . matcher ( hfileLinkName ) ; if ( ! m . matches ( ) ) { throw new IllegalArgumentException ( hfileLinkName + "-is-not-a-valid-HFileLink-name!" ) ; } return create ( conf , fs , dstFamilyPath , m . group ( 1 ) , m . group ( 2 ) , m . group ( 3 ) ) ; } \n', 0.3376042573568567)

('private File createFileFromString ( String fileContent , String filenameWithoutPath ) { File configFile = null ; createWorkingDirectory ( ) ; LOGGER . info ( "Copy-resource-to-folder-{}." , workingDirectory . getAbsolutePath ( ) ) ; LOGGER . info ( "Targetname-is-{}." , filenameWithoutPath ) ; try { workingDirectory . mkdirs ( ) ; LOGGER . info ( "Create-file-from-Resource-String:-{}," , fileContent ) ; configFile = new File ( workingDirectory , filenameWithoutPath ) ; LOGGER . info ( "Write-file-{}." , configFile . getAbsolutePath ( ) ) ; Files . write ( fileContent , configFile , Charset . defaultCharset ( ) ) ; } catch ( IOException e ) { LOGGER . error ( "Could-not-create-File-from-resource-String:-{}" , fileContent ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.3354318964415436)

('public static String stringWithContentsOfFile ( File file ) { try { byte [ ] buffer = new byte [ ( int ) file . length ( ) ] ; BufferedInputStream stream = new BufferedInputStream ( new FileInputStream ( file ) ) ; stream . read ( buffer ) ; stream . close ( ) ; return new String ( buffer , "UTF-8" ) ; } catch ( IOException e ) { return null ; } } \n', 0.32816960291085495)

('public static void createFileFromResource ( String path , Resource bin ) throws IOException { InputStream is = null ; OutputStream os = null ; if ( bin . exists ( ) ) return ; try { Util . copy ( is = new VideoInputImpl ( null ) . getClass ( ) . getResourceAsStream ( path ) , os = bin . getOutputStream ( ) ) ; } finally { Util . closeEL ( is ) ; Util . closeEL ( os ) ; } } \n', 0.32515733453474194)

("static File createTempFileWithContent ( @ NotNull String namePrefix , @ NotNull String nameSuffix , @ NotNull String content ) throws IOException { namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '|' ) + 1 ) ; namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '/' ) + 1 ) ; namePrefix = namePrefix . replace ( '.' , '_' ) ; File tempFile = File . createTempFile ( namePrefix , nameSuffix ) ; tempFile . deleteOnExit ( ) ; final BufferedOutputStream stream = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; stream . write ( content . getBytes ( ) ) ; stream . close ( ) ; return tempFile ; } \n", 0.32362114274295406)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('@ NotNull public static String convertExceptionStackToString ( @ NotNull final Throwable ex ) { final StringBuilder sb = new StringBuilder ( ) ; for ( @ NotNull final StackTraceElement element : ex . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } if ( ex instanceof UmbrellaException ) { sb . append ( "Unwrapping-UmbrellaException-" ) ; final UmbrellaException umbrellaException = ( UmbrellaException ) ex ; for ( @ NotNull final Throwable throwable : umbrellaException . getCauses ( ) ) { for ( @ NotNull final StackTraceElement element : throwable . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } } } return sb . toString ( ) ; } \n', 0.44490724544019167)

('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

('private static String stackTraceToString ( Throwable t ) { final StringBuilder sb = new StringBuilder ( ) ; final String indent = "-at-" ; for ( StackTraceElement frame : t . getStackTrace ( ) ) { sb . append ( indent ) ; sb . append ( frame . toString ( ) ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } \n', 0.4279314670430304)

('public static String stackTraceToString ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( StackTraceElement s : Thread . currentThread ( ) . getStackTrace ( ) ) { sb . append ( s . toString ( ) ) ; sb . append ( "-" ) ; } sb . deleteCharAt ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; } \n', 0.42317379269620653)

('public static String exceptionStackTraceToString ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; StreamUtil . close ( pw ) ; StreamUtil . close ( sw ) ; return sw . toString ( ) ; } \n', 0.42203330086544305)

('public static String toStackTraceString ( final Throwable throwable ) { final Writer result = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( result ) ; throwable . printStackTrace ( printWriter ) ; return result . toString ( ) ; } \n', 0.42014845456648114)

('private static String stackTraceToString ( Throwable e ) { StringBuilder sb = new StringBuilder ( ) ; for ( StackTraceElement element : e . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } \n', 0.41933071513323433)

('public static String stackTraceToString ( Throwable e ) { StringBuilder sb = new StringBuilder ( ) ; for ( StackTraceElement element : e . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } return sb . toString ( ) ; } \n', 0.41933071513323433)

('private static String exceptionStackTraceToString ( Throwable e ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; e . printStackTrace ( pw ) ; String s = sw . toString ( ) ; return s ; } \n', 0.41878107987594426)

('public static String toStringWithFullStackTrace ( Throwable t ) { if ( t == null ) { return "!null" ; } StringWriter stringWriter = new StringWriter ( 128 ) ; t . printStackTrace ( new PrintWriter ( stringWriter ) ) ; return stringWriter . toString ( ) ; } \n', 0.4185765308989781)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public int compare ( final String string1 , final String string2 ) { String string1Copy = string1 . toLowerCase ( ) ; String string2Copy = string2 . toLowerCase ( ) ; int len1 = string1 . length ( ) ; int len2 = string2 . length ( ) ; String liczba1 = "" ; String liczba2 = "" ; for ( int i = 0 ; i < ( ( len1 > len2 ) ? len1 : len2 ) ; i ++ ) { if ( i == len1 && len2 > len1 ) { return - 1 ; } if ( i == len2 && len1 > len2 ) { return 1 ; } Character c1 = string1Copy . charAt ( i ) ; Character c2 = string2Copy . charAt ( i ) ; if ( isDigit ( c1 ) && isDigit ( c2 ) ) { liczba1 += c1 ; liczba2 += c2 ; } else if ( isDigit ( c1 ) && liczba1 . length ( ) > 0 ) { return 1 ; } else if ( isDigit ( c2 ) && liczba1 . length ( ) > 0 ) { return - 1 ; } else { if ( ! liczba1 . equals ( liczba2 ) ) { return liczba1 . compareTo ( liczba2 ) ; } liczba1 = "" ; liczba2 = "" ; if ( ! c1 . equals ( c2 ) ) { return c1 . compareTo ( c2 ) ; } } } return string1Copy . compareTo ( string2Copy ) ; } \n', 0.366311296330726)

('@ Override public boolean equals ( Object object ) { if ( this == object ) { return true ; } if ( ! ( object instanceof DateFormatSymbols ) ) { return false ; } DateFormatSymbols rhs = ( DateFormatSymbols ) object ; return localPatternChars . equals ( rhs . localPatternChars ) && Arrays . equals ( ampms , rhs . ampms ) && Arrays . equals ( eras , rhs . eras ) && Arrays . equals ( months , rhs . months ) && Arrays . equals ( shortMonths , rhs . shortMonths ) && Arrays . equals ( shortWeekdays , rhs . shortWeekdays ) && Arrays . equals ( weekdays , rhs . weekdays ) && timeZoneStringsEqual ( this , rhs ) ; } \n', 0.35672369510509155)

('private int compareStringOrNull ( final String thisString , final String otherString ) { if ( thisString == null ) { if ( otherString != null ) { return - 1 ; } } else { if ( otherString == null ) { return 1 ; } final int result = thisString . compareTo ( otherString ) ; if ( result != 0 ) { return result ; } } return 0 ; } \n', 0.34628851103881336)

('@ Override public int compare ( Object o1 , Object o2 ) { String s1 = o1 . toString ( ) ; String s2 = o2 . toString ( ) ; Matcher m1 = splitPattern . matcher ( s1 ) ; Matcher m2 = splitPattern . matcher ( s2 ) ; if ( m1 . matches ( ) && m2 . matches ( ) ) { String class1 = m1 . group ( 1 ) ; String pos1 = m1 . group ( 2 ) ; String class2 = m2 . group ( 1 ) ; String pos2 = m2 . group ( 2 ) ; if ( class1 . equals ( class2 ) ) { return NumericComparator . INSTANCE . compare ( pos1 , pos2 ) ; } else { return class1 . compareTo ( class2 ) ; } } return s1 . compareTo ( s2 ) ; } \n', 0.34570884938565394)

('public static int StringCompareIgnCase ( String lhs , String rhs ) { return NormalizeString ( lhs ) . compareToIgnoreCase ( NormalizeString ( rhs ) ) ; } \n', 0.34453683534365276)

('private static boolean equalsStrings ( String string1 , String string2 ) { return ( ( ( string1 == null ) && ( string2 == null ) ) || string1 . equals ( string2 ) ) ; } \n', 0.34235840277758334)

('private int compareString ( String s1 , String s2 ) { if ( s1 != null && s1 . equals ( s2 ) ) { return 0 ; } if ( s1 == null ) { return - 1 ; } if ( s2 == null ) { return 1 ; } return String . CASE_INSENSITIVE_ORDER . compare ( s1 , s2 ) ; } \n', 0.34068496127643105)

('private static int compareStringForChinese ( String s1 , String s2 ) { String m_s1 = null , m_s2 = null ; try { m_s1 = new String ( s1 . getBytes ( "GB2312" ) , "GBK" ) ; m_s2 = new String ( s2 . getBytes ( "GB2312" ) , "GBK" ) ; } catch ( Exception ex ) { LOGGER . error ( "compareStringForChineseError" , ex ) ; return s1 . compareTo ( s2 ) ; } int res = chineseCompareTo ( m_s1 , m_s2 ) ; return res ; } \n', 0.33881479899367073)

('public static int StringCompare ( String lhs , String rhs ) { return NormalizeString ( lhs ) . compareTo ( NormalizeString ( rhs ) ) ; } \n', 0.3379810324932133)

('private static boolean compareString ( String string1 , String string2 ) { if ( string1 == null ) { if ( string2 == null ) { return true ; } } else { if ( string2 != null && string1 . equals ( string2 ) ) { return true ; } } return false ; } \n', 0.33704140089513956)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public static String [ ] splitString ( String str , String regex ) { String buffer = null ; if ( str . contains ( "<" ) && str . indexOf ( ">" ) > str . indexOf ( "<" ) ) { buffer = str . substring ( str . indexOf ( "<" ) , str . indexOf ( ">" ) + 1 ) ; str = str . replaceAll ( "<[^>]*>" , "!!----!!" ) ; } String [ ] split = str . split ( regex ) ; int count = 0 ; for ( String s : split ) { if ( ! s . isEmpty ( ) ) { count ++ ; } } String [ ] result = new String [ count ] ; count = 0 ; for ( String s : split ) { if ( ! s . isEmpty ( ) ) { result [ count ] = s ; count ++ ; } } if ( buffer != null ) { for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = result [ i ] . replaceAll ( "!!----!!" , buffer ) ; } } return result ; } \n', 0.39929085507016104)

('public static String splitString ( String str , int split ) { StringBuffer result = new StringBuffer ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { result . append ( str . charAt ( i ) ) ; if ( i > 0 && i % split == 0 ) { while ( i < str . length ( ) - 1 && str . charAt ( i ) != \'-\' ) { i ++ ; result . append ( str . charAt ( i ) ) ; } result . append ( "<br>" ) ; } } return result . toString ( ) ; } \n', 0.3937887944676628)

('public static String [ ] splitStringToArray ( final CharSequence s , final char c ) { if ( s == null || s . length ( ) == 0 ) { return Strings . EMPTY_ARRAY ; } int count = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { count ++ ; } } final String [ ] result = new String [ count ] ; final StringBuilder builder = new StringBuilder ( ) ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { if ( builder . length ( ) > 0 ) { result [ res ++ ] = builder . toString ( ) ; builder . setLength ( 0 ) ; } } else { builder . append ( s . charAt ( i ) ) ; } } if ( builder . length ( ) > 0 ) { result [ res ++ ] = builder . toString ( ) ; } if ( res != count ) { String [ ] result1 = new String [ res ] ; System . arraycopy ( result , 0 , result1 , 0 , res ) ; return result1 ; } return result ; } \n', 0.39186095551488026)

('public static String [ ] splitString ( String stringToSplit , String charToSplitAt ) { int end = - 1 ; int start = 0 ; int maxPos = stringToSplit . length ( ) ; java . util . ArrayList list = new java . util . ArrayList ( ) ; do { end = stringToSplit . indexOf ( charToSplitAt , start ) ; list . add ( stringToSplit . substring ( start , end ) ) ; start = end + 1 ; } while ( ( end > - 1 ) && ( end < maxPos ) ) ; String [ ] retVal = new String [ list . size ( ) ] ; list . toArray ( retVal ) ; return retVal ; } \n', 0.39119069265614875)

('public static String [ ] splitStringToArray ( String data , int limit ) { return null != data ? data . split ( String . format ( "(?s)(?<=|G.{%d})" , limit ) ) : null ; } \n', 0.391068383764549)

('private String [ ] splitString ( String source ) { String curString = "" ; ArrayList < String > resultList = new ArrayList < String > ( ) ; for ( int i = 0 ; i < source . length ( ) ; i ++ ) { Character curChar = source . charAt ( i ) ; if ( splitChars . contains ( curChar . toString ( ) ) ) { if ( curString . length ( ) > 0 ) resultList . add ( curString ) ; curString = "" ; } else curString += curChar ; } if ( curString . length ( ) > 0 ) resultList . add ( curString ) ; return ( resultList . toArray ( new String [ resultList . size ( ) ] ) ) ; } \n', 0.3902000683194021)

('public static List < String > splitStringBySpace ( String str ) { List < String > result = new ArrayList < String > ( ) ; if ( str != null ) { String [ ] strArr = str . split ( "-" ) ; for ( String s : strArr ) { if ( StringUtils . isNotEmpty ( s ) ) { result . add ( s ) ; } } } return result ; } \n', 0.3901487264631988)

('private static String [ ] splitString ( String str ) { return str . split ( "-|-|-|-|-" ) ; } \n', 0.3898809856093662)

('public static List < String > splitString ( String expr , String separator ) { if ( expr == null ) { return null ; } List results = new ArrayList ( 6 ) ; String [ ] array = expr . split ( separator ) ; for ( String item : array ) { String v = item . trim ( ) ; if ( v . length ( ) > 0 ) { results . add ( v ) ; } } return results ; } \n', 0.3898311839488534)

('private static int [ ] splitString ( String bonus ) { String [ ] split = bonus . split ( "-" ) ; int [ ] bonuses = new int [ split . length ] ; for ( int i = 0 ; i < split . length ; i ++ ) { bonuses [ i ] = Integer . parseInt ( split [ i ] ) ; } return bonuses ; } \n', 0.38846759025998234)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('private void createFileAndWriteTo ( String diffOutput , File jApiCmpBuildDir ) throws IOException , MojoFailureException { File outputfile = new File ( jApiCmpBuildDir . getCanonicalPath ( ) + File . separator + "japicmp.diff" ) ; writeToFile ( diffOutput , outputfile ) ; } \n', 0.3682859538380898)

('public static BufferedWriter openFileToWrite ( String pathToFile , String encoding ) { try { return Files . newBufferedWriter ( new File ( pathToFile ) . toPath ( ) , Charset . forName ( encoding ) ) ; } catch ( IOException e ) { LOG . error ( "-" , e ) ; return null ; } } \n', 0.3561619246806307)

('public void writeBlobToFile ( Blob myBlob , String blobOutputFilePath ) { blobOutputFilePath = blobOutputFilePath . replace ( "|" , "/" ) ; String METHOD_NAME = "writeBlobToFile()" ; File binaryFile = new File ( blobOutputFilePath ) ; FileOutputStream outstream = null ; InputStream instream = null ; try { if ( ! binaryFile . exists ( ) ) { binaryFile . createNewFile ( ) ; } outstream = new FileOutputStream ( binaryFile ) ; instream = myBlob . getBinaryStream ( ) ; int chunk = 4096 ; byte [ ] buffer = new byte [ chunk ] ; int length = - 1 ; while ( ( length = instream . read ( buffer ) ) != - 1 ) { outstream . write ( buffer , 0 , length ) ; } outstream . flush ( ) ; } catch ( IOException io_excp ) { System . err . println ( METHOD_NAME + "---Error:-" + io_excp ) ; io_excp . printStackTrace ( ) ; } catch ( SQLException sql_excp ) { System . err . println ( METHOD_NAME + "---Error:-" + sql_excp ) ; sql_excp . printStackTrace ( ) ; } finally { try { instream . close ( ) ; outstream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } } \n', 0.348664084944721)

('private boolean writeImageToFileAsJpeg ( File f , Bitmap b ) { try { f . createNewFile ( ) ; FileOutputStream thumbFileStream = openFileOutput ( f . getName ( ) , Context . MODE_PRIVATE ) ; b . compress ( Bitmap . CompressFormat . JPEG , 95 , thumbFileStream ) ; thumbFileStream . close ( ) ; return true ; } catch ( IOException e ) { Log . e ( TAG , "Error-while-writing-bitmap-to-file-" + e ) ; f . delete ( ) ; } return false ; } \n', 0.3348247431183819)

('protected void createAndWriteDefaultMessageToMarkerFile ( File file ) throws IOException { log . debug ( "Creating-file-" , file . getAbsolutePath ( ) ) ; file . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( file ) ; try { fos . write ( dateFormat . format ( new Date ( ) ) . getBytes ( ) ) ; } finally { try { fos . close ( ) ; } catch ( Exception e ) { } } } \n', 0.33337875764044633)

('private static File writeToDisk ( Context context , String content ) throws IOException { File outputDir = context . getExternalFilesDir ( null ) ; File outputFile = File . createTempFile ( "andFHEM-" , ".log" , outputDir ) ; outputFile . setReadable ( true , true ) ; outputFile . deleteOnExit ( ) ; Files . write ( content , outputFile , Charsets . UTF_8 ) ; return outputFile ; } \n', 0.33301200314494783)

('private void writeExceptionToFile ( Throwable exception , File log ) throws IOException { log . createNewFile ( ) ; PrintWriter writer = null ; try { writer = new PrintWriter ( log ) ; exceptionReportWriter . writeReport ( writer , exception ) ; } finally { InternalUtils . close ( writer ) ; } } \n', 0.3317629306680717)

('private String writeInputStreamToDisk ( String filename , InputStream data , boolean compress ) throws IOException { Path filePath = BASE_DIRECTORY . resolve ( Joiner . on ( "." ) . join ( filename , SUFFIX_GZIP ) ) ; Files . deleteIfExists ( filePath ) ; Path createdFilePath = Files . createFile ( filePath ) ; OutputStream os = new FileOutputStream ( createdFilePath . toFile ( ) ) ; if ( compress ) { os = new GZIPOutputStream ( os ) ; } IOUtils . copyLarge ( data , os ) ; IOUtils . closeQuietly ( os ) ; return createdFilePath . toUri ( ) . toString ( ) . replaceFirst ( FILE_URI_PREFIX , "" ) ; } \n', 0.3289854552220145)

('public static void writeCompressedToFile ( Path path , CompoundTag tag ) throws IOException { if ( ! Files . exists ( path ) ) { Files . createDirectories ( path . getParent ( ) ) ; try { Files . createFile ( path ) ; } catch ( FileAlreadyExistsException e ) { } } try ( OutputStream outputStream = new BufferedOutputStream ( new GZIPOutputStream ( Files . newOutputStream ( path ) ) ) ) { writeUncompressedToStream ( outputStream , tag ) ; } } \n', 0.325938404212612)

('private File createTempFile ( ) throws Exception { String tempFile = selectedProject . getLocation ( ) . append ( _TEMPFOLDER ) . append ( System . currentTimeMillis ( ) + _XLP ) . toOSString ( ) ; FileOutputStream output = new FileOutputStream ( tempFile ) ; StringBuffer dataSB = new StringBuffer ( ) ; dataSB . append ( "<?xml-version="1.0"-encoding="UTF-8"?>-" ) ; dataSB . append ( "<mergerFiles>-" ) ; for ( IFile iFile : selectIFiles ) { dataSB . append ( MessageFormat . format ( "-<mergerFile-filePath="{0}"/>-" , TextUtil . cleanSpecialString ( iFile . getLocation ( ) . toOSString ( ) ) ) ) ; } dataSB . append ( "</mergerFiles>-" ) ; output . write ( dataSB . toString ( ) . getBytes ( "UTF-8" ) ) ; output . close ( ) ; File file = new File ( tempFile ) ; return file ; } \n', 0.32031896394553555)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

('protected void initialise ( Connection connection ) { if ( ! initialised ) { synchronized ( this ) { if ( ! initialised ) { Set accessorsToRemove = new HashSet ( ) ; Iterator i = accessorMutatorMap . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Method accessor = ( Method ) i . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; Object value = null ; try { value = accessor . invoke ( connection , null ) ; if ( value != null ) { defaultValues . put ( mutator , value ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Remembering-default-value:-" + accessor . getName ( ) + "()-=-" + value ) ; } } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + accessor . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } try { Object [ ] args = { value } ; mutator . invoke ( connection , args ) ; } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + mutator . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } } Iterator j = accessorsToRemove . iterator ( ) ; while ( j . hasNext ( ) ) { Method accessor = ( Method ) j . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; accessorMutatorMap . remove ( accessor ) ; defaultValues . remove ( mutator ) ; } initialised = true ; } } } } \n', 0.3899768502441775)

('public static Context initialise ( final Map environment ) throws NamingException { Context context ; if ( environment != null && environment . size ( ) > 0 ) { context = new InitialContext ( new Hashtable ( environment ) ) ; } else { context = new InitialContext ( ) ; } return context ; } \n', 0.38813912680444246)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.3795221908993608)

('private static void initialise ( ) { exitCodes = new HashSet < ExitCode > ( ) ; Map < String , String > resources = Resources . get ( ExitStatus . class ) ; for ( String key : resources . keySet ( ) ) { String mnemonic = key . substring ( 0 , key . indexOf ( ( int ) FULL_STOP ) ) ; String numericForm = key . substring ( key . indexOf ( ( int ) FULL_STOP ) + 1 ) ; String description = resources . get ( key ) ; int number = Integer . parseInt ( numericForm ) ; exitCodes . add ( new ExitCode ( number , mnemonic , description ) ) ; } } \n', 0.3787476293033488)

('protected void initialiseCommonFeatures ( Map < Integer , FeatureData > initialMap ) { super . initialiseFeatureMap ( initialMap ) ; commonFeaturesMap . putAll ( initialMap ) ; } \n', 0.3759403677907467)

('@ Override protected void doInitialise ( ) throws InitialisationException { authentications = new ConcurrentHashMap < String , Authentication > ( ) ; } \n', 0.37380482700435735)

('private void initialiseMetricMap ( ) { metricMap = new HashMap < EMethodMetricName , Integer > ( 50 ) ; EMethodMetricName [ ] metrics = EMethodMetricName . values ( ) ; for ( EMethodMetricName metric : metrics ) metricMap . put ( metric , 0 ) ; } \n', 0.3681996314523418)

('protected void initialiseFeatureMap ( Map < Integer , FeatureData > initialMap ) { featureMap . putAll ( initialMap ) ; } \n', 0.3664933131352133)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.36489232472833166)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('@ Override protected final void insideLoop ( ) { try { doProcessing ( ) ; } catch ( Throwable e ) { Log . error ( "Event-processing-error!" , e ) ; } try { selector . select ( 50 ) ; } catch ( IOException e ) { Log . error ( "Select-failed!" , e ) ; } try { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; synchronized ( selectedKeys ) { Iterator < ? > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) iter . next ( ) ; iter . remove ( ) ; processKey ( key ) ; } } } catch ( ClosedSelectorException e ) { } } \n', 0.3672683587663921)

('@ Override protected final void insideLoop ( ) { try { doProcessing ( ) ; } catch ( Throwable e ) { Log . error ( "Event-processing-error!" , e ) ; } try { selector . select ( getSelectorTimeout ( ) ) ; } catch ( IOException e ) { Log . error ( "Select-failed!" , e ) ; } try { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; synchronized ( selectedKeys ) { if ( ! selectedKeys . isEmpty ( ) ) { Iterator < ? > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) iter . next ( ) ; iter . remove ( ) ; processKey ( key ) ; } } } } catch ( ClosedSelectorException e ) { } } \n', 0.35396138124898646)

('public void processRemovedTasks ( Enumeration removedTasks ) { boolean anyRemoved = false ; Set toSubtract = new HashSet ( ) ; while ( removedTasks . hasMoreElements ( ) ) { anyRemoved = true ; Task task = ( Task ) removedTasks . nextElement ( ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer:-Got-a-removed-task---" + task + "-from-" + task . getSource ( ) ) ; } REMOVE_TASKS ++ ; REMOVE_TONS += task . getPreferredValue ( AspectType . QUANTITY ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer---number-of-removed-SUPPLY-tasks:-" + REMOVE_TASKS + ",-aggregated-quantity-from-removed-SUPPLY-tasks:-" + REMOVE_TONS + "-tons." ) ; } } Set unplannedInternal = new HashSet ( ) ; for ( Iterator iter = allInternalTasks . getCollection ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Task internalTask = ( Task ) iter . next ( ) ; if ( internalTask . getPlanElement ( ) == null ) { unplannedInternal . add ( internalTask ) ; } } toSubtract = new HashSet ( allInternalTasks . getRemovedCollection ( ) ) ; unplannedInternal . removeAll ( toSubtract ) ; handleUnplanned ( unplannedInternal ) ; toSubtract . addAll ( unplannedInternal ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer---subtracting-" + toSubtract . size ( ) + "-tasks." ) ; } for ( Iterator iter = toSubtract . iterator ( ) ; iter . hasNext ( ) ; ) { subtractTaskFromReceiver ( ( Task ) iter . next ( ) ) ; } } \n', 0.33926747348422165)

('public void endAvoidNotify ( ) { avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.33474174737464607)

('public void endAvoidNotify ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.3324344539289146)

('private synchronized int invalidateWorkForOneNode ( String nodeId ) { if ( isInSafeMode ( ) ) return 0 ; assert nodeId != null ; DatanodeDescriptor dn = datanodeMap . get ( nodeId ) ; if ( dn == null ) { recentInvalidateSets . remove ( nodeId ) ; return 0 ; } Collection < Block > invalidateSet = recentInvalidateSets . get ( nodeId ) ; if ( invalidateSet == null ) return 0 ; ArrayList < Block > blocksToInvalidate = new ArrayList < Block > ( blockInvalidateLimit ) ; Iterator < Block > it = invalidateSet . iterator ( ) ; for ( int blkCount = 0 ; blkCount < blockInvalidateLimit && it . hasNext ( ) ; blkCount ++ ) { blocksToInvalidate . add ( it . next ( ) ) ; it . remove ( ) ; } if ( ! it . hasNext ( ) ) recentInvalidateSets . remove ( nodeId ) ; dn . addBlocksToBeInvalidated ( blocksToInvalidate ) ; if ( NameNode . stateChangeLog . isInfoEnabled ( ) ) { StringBuffer blockList = new StringBuffer ( ) ; for ( Block blk : blocksToInvalidate ) { blockList . append ( \'-\' ) ; blockList . append ( blk ) ; } NameNode . stateChangeLog . info ( "BLOCK*-ask-" + dn . getName ( ) + "-to-delete-" + blockList ) ; } return blocksToInvalidate . size ( ) ; } \n', 0.31554800275754596)

('private int invalidateWorkForOneNode ( String nodeId ) { writeLock ( ) ; try { if ( isInSafeMode ( ) ) { return 0 ; } assert nodeId != null ; DatanodeDescriptor dn = datanodeMap . get ( nodeId ) ; if ( dn == null ) { recentInvalidateSets . remove ( nodeId ) ; return 0 ; } Collection < Block > invalidateSet = recentInvalidateSets . get ( nodeId ) ; if ( invalidateSet == null ) { return 0 ; } ArrayList < Block > blocksToInvalidate = new ArrayList < Block > ( blockInvalidateLimit ) ; Iterator < Block > it = invalidateSet . iterator ( ) ; for ( int blkCount = 0 ; blkCount < blockInvalidateLimit && it . hasNext ( ) ; blkCount ++ ) { blocksToInvalidate . add ( it . next ( ) ) ; it . remove ( ) ; } if ( ! it . hasNext ( ) ) { recentInvalidateSets . remove ( nodeId ) ; } dn . addBlocksToBeInvalidated ( blocksToInvalidate ) ; if ( NameNode . stateChangeLog . isInfoEnabled ( ) ) { StringBuffer blockList = new StringBuffer ( ) ; for ( Block blk : blocksToInvalidate ) { blockList . append ( \'-\' ) ; blockList . append ( blk ) ; } NameNode . stateChangeLog . info ( "BLOCK*-ask-" + dn . getName ( ) + "-to-delete-" + blockList ) ; } pendingDeletionBlocksCount -= blocksToInvalidate . size ( ) ; return blocksToInvalidate . size ( ) ; } finally { writeUnlock ( ) ; } } \n', 0.31240241846205075)

('private void processCollectedWhileDisconnected ( ) { Iterator < Subscription > iteratorSub = outboxSubs . iterator ( ) ; while ( iteratorSub . hasNext ( ) ) { subscribe ( iteratorSub . next ( ) ) ; iteratorSub . remove ( ) ; } Iterator < Publication > iteratorPublication = outboxPubs . iterator ( ) ; while ( iteratorPublication . hasNext ( ) ) { publish ( iteratorPublication . next ( ) ) ; iteratorPublication . remove ( ) ; } Iterator < Announcement > iteratorAnn = outboxAnnouncements . iterator ( ) ; while ( iteratorAnn . hasNext ( ) ) { announce ( iteratorAnn . next ( ) ) ; iteratorAnn . remove ( ) ; } } \n', 0.3033024958263294)

('private ConnectionListener removeForFrequencyCheck ( ) { log . debug ( "Checking-for-connection-within-frequency" ) ; ConnectionListener result = null ; Iterator < ConnectionListener > iter = cls . iterator ( ) ; while ( result == null && iter . hasNext ( ) ) { ConnectionListener cl = iter . next ( ) ; long lastCheck = cl . getLastValidatedTime ( ) ; if ( ( System . currentTimeMillis ( ) - lastCheck ) >= poolConfiguration . getBackgroundValidationMillis ( ) ) { result = cl ; cls . remove ( cl ) ; } } return result ; } \n', 0.30249696904115464)

('private synchronized int invalidateWorkForOneNode ( ) { if ( isInSafeMode ( ) ) return 0 ; if ( recentInvalidateSets . isEmpty ( ) ) return 0 ; String firstNodeId = recentInvalidateSets . keySet ( ) . iterator ( ) . next ( ) ; assert firstNodeId != null ; DatanodeDescriptor dn = datanodeMap . get ( firstNodeId ) ; Collection < Block > invalidateSet = recentInvalidateSets . remove ( firstNodeId ) ; if ( invalidateSet == null || dn == null ) return 0 ; ArrayList < Block > blocksToInvalidate = new ArrayList < Block > ( blockInvalidateLimit ) ; Iterator < Block > it = invalidateSet . iterator ( ) ; for ( int blkCount = 0 ; blkCount < blockInvalidateLimit && it . hasNext ( ) ; blkCount ++ ) { blocksToInvalidate . add ( it . next ( ) ) ; it . remove ( ) ; } if ( it . hasNext ( ) ) recentInvalidateSets . put ( firstNodeId , invalidateSet ) ; dn . addBlocksToBeInvalidated ( blocksToInvalidate ) ; if ( NameNode . stateChangeLog . isInfoEnabled ( ) ) { StringBuffer blockList = new StringBuffer ( ) ; for ( Block blk : blocksToInvalidate ) { blockList . append ( \'-\' ) ; blockList . append ( blk ) ; } NameNode . stateChangeLog . info ( "BLOCK*-ask-" + dn . getName ( ) + "-to-delete-" + blockList ) ; } return blocksToInvalidate . size ( ) ; } \n', 0.3004265402368955)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('public static String generateMD5 ( String unhashed ) { String generated_md5 = null ; if ( unhashed == null ) return null ; try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( unhashed . getBytes ( ) , 0 , unhashed . length ( ) ) ; generated_md5 = new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return generated_md5 ; } \n', 0.4331418272446791)

('private static byte [ ] generateKeyFromPasswordSaltWithMD5 ( byte [ ] password , byte [ ] salt , int keyLen ) throws IOException { if ( salt . length < 8 ) throw new IllegalArgumentException ( "Salt-needs-to-be-at-least-8-bytes-for-key-generation." ) ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "VM-does-not-support-MD5" , e ) ; } byte [ ] key = new byte [ keyLen ] ; byte [ ] tmp = new byte [ md5 . getDigestLength ( ) ] ; while ( true ) { md5 . update ( password , 0 , password . length ) ; md5 . update ( salt , 0 , 8 ) ; int copy = ( keyLen < tmp . length ) ? keyLen : tmp . length ; try { md5 . digest ( tmp , 0 , tmp . length ) ; } catch ( DigestException e ) { IOException ex = new IOException ( "could-not-digest-password" ) ; ex . initCause ( e ) ; throw ex ; } System . arraycopy ( tmp , 0 , key , key . length - keyLen , copy ) ; keyLen -= copy ; if ( keyLen == 0 ) return key ; md5 . update ( tmp , 0 , tmp . length ) ; } } \n', 0.4277104097002139)

('public static String generateMD5 ( InputStream md5Stream ) throws SWORDException { String md5 = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . reset ( ) ; byte [ ] bytes = new byte [ 1024 ] ; int count = 0 ; try { while ( ( count = md5Stream . read ( bytes ) ) != - 1 ) { md . update ( bytes , 0 , count ) ; } } catch ( IOException e ) { throw new SWORDException ( SWORDException . IO_ERROR , e ) ; } byte [ ] md5Digest = md . digest ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( byte b : md5Digest ) { String hex = Integer . toHexString ( b & 0xFF ) ; if ( hex . length ( ) == 1 ) { buffer . append ( "0" ) ; } buffer . append ( hex ) ; } md5 = buffer . toString ( ) ; } catch ( NoSuchAlgorithmException ex ) { log . error ( "MD5-Algorithm-Not-found" ) ; throw new SWORDException ( SWORDException . MD5_MISSING ) ; } finally { if ( md5Stream != null ) { try { md5Stream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return md5 ; } \n', 0.4236590780045079)

('public static Integer generateSHA1 ( String key ) { try { MessageDigest md = MessageDigest . getInstance ( "SHA-1" ) ; byte [ ] hashMsg = md . digest ( key . toString ( ) . getBytes ( ) ) ; BigInteger bi = new BigInteger ( hashMsg ) . abs ( ) ; Integer networkSize = new Double ( Math . pow ( 2 , CHORD_RING_SIZE ) ) . intValue ( ) ; BigInteger mod = new BigInteger ( networkSize . toString ( ) ) ; return bi . mod ( mod ) . intValue ( ) ; } catch ( Exception e ) { String errorMessage = "An-error-has-ocurred-when-trying-to-generate-a-SHA-1-hash-number-for-the-key:-" + key + "-with-max-size-of:-" + CHORD_RING_SIZE + "-bits." ; Tools . appendToOutput ( errorMessage ) ; System . out . println ( errorMessage ) ; return null ; } } \n', 0.42329378813910523)

('private String generateMd5 ( String message ) { String digest = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( message . getBytes ( "UTF-8" ) ) ; StringBuilder sb = new StringBuilder ( 2 * hash . length ) ; for ( byte b : hash ) { sb . append ( String . format ( "%02x" , b & 0xff ) ) ; } digest = sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } return digest ; } \n', 0.41984533143908476)

('public static String generateMD5 ( String ... args ) throws NoSuchAlgorithmException { MessageDigest md ; try { byte [ ] colonBytes = ":" . getBytes ( ) ; md = MessageDigest . getInstance ( "MD5" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; md . update ( arg . getBytes ( ) ) ; if ( i != args . length - 1 ) { md . update ( colonBytes ) ; } } byte byteData [ ] = md . digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { sb . append ( Integer . toString ( ( byteData [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } return sb . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw e ; } } \n', 0.4181341694256403)

('public String generateSHA1checksum ( InputStream inputStream ) { try { if ( inputStream != null ) { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byte [ ] dataBytes = new byte [ 1024 ] ; int byteNumberRead = 0 ; while ( ( byteNumberRead = inputStream . read ( dataBytes ) ) != - 1 ) { md . update ( dataBytes , 0 , byteNumberRead ) ; } byte [ ] mdBytes = md . digest ( ) ; StringBuffer sb = new StringBuffer ( "" ) ; for ( int i = 0 ; i < mdBytes . length ; i ++ ) { sb . append ( Integer . toString ( ( mdBytes [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } inputStream . close ( ) ; return sb . toString ( ) ; } else { LOG . error ( "Input-stream-is-null!" ) ; } } catch ( Exception e ) { LOG . error ( "Could-not-generate-the-checksum." , e ) ; } return null ; } \n', 0.4166514420212688)

('public void generateChallengeHash ( ) { if ( Constants . CRYPTO_OFF ) { byte [ ] concat = new byte [ R_1_size + R_2_size ] ; System . arraycopy ( R_1 , 0 , concat , 0 , R_1 . length ) ; System . arraycopy ( R_2 , 0 , concat , R_1 . length , R_2 . length ) ; this . challengePayload . challengeHash = concat ; } else { md . reset ( ) ; md . update ( R_1 ) ; md . update ( R_2 ) ; this . challengePayload . challengeHash = md . digest ( ) ; } } \n', 0.4098016663773416)

('private String generateMD5Hash ( byte [ ] content ) { String fileMD5 = "" ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } if ( md != null ) { md . update ( content ) ; fileMD5 = DatatypeConverter . printHexBinary ( md . digest ( ) ) . toLowerCase ( ) ; } return fileMD5 ; } \n', 0.4082753133817919)

('private static String generateCash ( String prefix , int value , MessageDigest md ) throws NoSuchAlgorithmException { SecureRandom rnd = SecureRandom . getInstance ( "SHA1PRNG" ) ; byte [ ] tmpBytes = new byte [ 4 ] ; rnd . nextBytes ( tmpBytes ) ; long random = unsignedIntToLong ( tmpBytes ) ; rnd . nextBytes ( tmpBytes ) ; long counter = unsignedIntToLong ( tmpBytes ) ; prefix = prefix + Long . toString ( random , 32 ) + ":" ; String temp ; int tempValue ; byte [ ] bArray ; do { counter ++ ; temp = prefix + Long . toHexString ( counter ) ; md . reset ( ) ; md . update ( temp . getBytes ( ) ) ; bArray = md . digest ( ) ; tempValue = numberOfLeadingZeros ( bArray ) ; } while ( tempValue < value ) ; return temp ; } \n', 0.4071737090356201)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('private static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4429996253804881)

('public static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] ; } \n', 0.4429996253804881)

('private static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getMyStackTraceElement ( ) { StackTraceElement myStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 2 ) { myStackTraceElement = stackTraceElements [ 2 ] ; } } return myStackTraceElement ; } \n', 0.43606062303011456)

('public int getPrunedStackTrace ( int par1 ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - par1 ] ; System . arraycopy ( var2 , 3 + par1 , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42871933313644817)

('public StackTraceElement getLastStackTrace ( ) { final StackTraceElement [ ] stes = Thread . currentThread ( ) . getStackTrace ( ) ; int i = stes . length - 1 ; for ( ; i >= 0 ; -- i ) { StackTraceElement ste = stes [ i ] ; String className = ste . getClassName ( ) ; if ( className . equals ( StaticConsoleLogger . class . getCanonicalName ( ) ) || className . equals ( Logger . class . getCanonicalName ( ) ) ) { break ; } } return stes [ i + 1 ] ; } \n', 0.4284278536130619)

('public static StackTraceElement getCallerStackTraceElement ( ) { StackTraceElement callerStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 3 ) { callerStackTraceElement = stackTraceElements [ 3 ] ; } } return callerStackTraceElement ; } \n', 0.4282413662067419)

('public int getPrunedStackTrace ( int p_85073_1_ ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - p_85073_1_ ] ; System . arraycopy ( var2 , 3 + p_85073_1_ , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42809281907080465)

('public int getPrunedStackTrace ( int size ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - size ] ; System . arraycopy ( var2 , 3 + size , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42681183584127413)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

('public static Object [ ] sortOnProperty ( Object [ ] data , String PropName ) { Class ArrayClass = data . getClass ( ) . getComponentType ( ) ; ClassProperty TheProp = ClassAnalyzer . getClassProperty ( ArrayClass , PropName ) ; Method getMethod = TheProp . getGetMethod ( ) ; Object [ ] testData = ( Object [ ] ) Array . newInstance ( getMethod . getReturnType ( ) , data . length ) ; try { for ( int i = 0 ; i < data . length ; i ++ ) { Object Added = getMethod . invoke ( data [ i ] , EMPTY_OBJECT_ARRAY ) ; testData [ i ] = Added ; } } catch ( IllegalAccessException ex ) { throw new IllegalArgumentException ( "IllegalAccessException-getter-for-" + PropName + "-not-found" ) ; } catch ( InvocationTargetException ex ) { throw new IllegalArgumentException ( "InvokationTargetException-getter-for-" + PropName + "-not-found" ) ; } int [ ] order = getSortOrder ( testData ) ; if ( true ) throw new UnsupportedOperationException ( "Fix-This" ) ; Object [ ] ret = null ; for ( int i = 0 ; i < order . length ; i ++ ) ret [ i ] = data [ order [ i ] ] ; return ( ret ) ; } \n', 0.4152134705390136)

('public Collection sort ( Object object , String property ) { List properties = new ArrayList ( 1 ) ; properties . add ( property ) ; if ( object instanceof Collection ) { return sort ( ( Collection ) object , properties ) ; } else if ( object instanceof Object [ ] ) { return sort ( ( Object [ ] ) object , properties ) ; } else if ( object instanceof Map ) { return sort ( ( Map ) object , properties ) ; } return null ; } \n', 0.41263685074800294)

('public static < O > List < O > sort ( List < O > objects , List < String > properties ) { LinkedHashSet < String > propertiesSet = new LinkedHashSet < String > ( ) ; for ( String property : properties ) { propertiesSet . add ( property ) ; } return sort ( objects , propertiesSet ) ; } \n', 0.40241167183293286)

('private Element sortProperties ( Element el ) throws JDOMException { XPath xp = XPath . newInstance ( "//m:properties" ) ; xp . addNamespace ( "m" , "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata" ) ; for ( Object pNode : xp . selectNodes ( el ) ) { Element node = ( Element ) pNode ; final List < Element > props = new ArrayList < Element > ( ) ; for ( Object pChild : new ArrayList < Object > ( node . getChildren ( ) ) ) { Element child = ( Element ) pChild ; props . add ( ( Element ) child . clone ( ) ) ; child . detach ( ) ; } Collections . sort ( props , new Comparator < Element > ( ) { public int compare ( Element o1 , Element o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ; for ( Element prop : props ) { node . addContent ( ( Content ) prop ) ; } } return el ; } \n', 0.3951366370347644)

('@ Override public void setSortProperties ( Container . Sortable container , Object [ ] propertyId , boolean [ ] ascending ) { this . container = container ; final List < Object > ids = new ArrayList < Object > ( ) ; final List < Boolean > orders = new ArrayList < Boolean > ( ) ; final Collection < ? > sortable = container . getSortableContainerPropertyIds ( ) ; for ( int i = 0 ; i < propertyId . length ; i ++ ) { if ( sortable . contains ( propertyId [ i ] ) ) { ids . add ( propertyId [ i ] ) ; orders . add ( Boolean . valueOf ( i < ascending . length ? ascending [ i ] : true ) ) ; } } sortPropertyIds = ids . toArray ( ) ; sortDirections = new boolean [ orders . size ( ) ] ; for ( int i = 0 ; i < sortDirections . length ; i ++ ) { sortDirections [ i ] = ( orders . get ( i ) ) . booleanValue ( ) ; } } \n', 0.3939231167346853)

('public static PropertyListComparator propertyListComparatorWithGuideArray ( Object [ ] guideArray ) { if ( guideArray != null && guideArray . length > 0 ) { Object [ ] sortedArray = guideArray . clone ( ) ; Arrays . sort ( sortedArray , AscendingInsensitivePropertyListComparator ) ; if ( ! Arrays . equals ( guideArray , sortedArray ) ) { PropertyListComparator result = new PropertyListComparator ( true ) ; int size = guideArray . length ; if ( size > 0 ) { result . guideMap = new HashMap ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { Object origEntry = guideArray [ i ] ; Object oneEntry = origEntry ; if ( origEntry instanceof Map ) { Object name = ( ( Map ) origEntry ) . get ( "name" ) ; if ( name == null ) { name = ( ( Map ) origEntry ) . get ( "prototypeName" ) ; } if ( name != null ) { oneEntry = name ; } } if ( oneEntry != null ) { result . guideMap . put ( oneEntry , Integer . valueOf ( i ) ) ; } } } return result ; } } return AscendingInsensitivePropertyListComparator ; } \n', 0.37947371287242776)

('private void sortByCustomization ( ) { if ( LauncherApplication . SHOW_CTAPP_FEATURE ) { ctApps . clear ( ) ; ctFirstPageApps . clear ( ) ; for ( AppInfo info : mApps ) { String className = info . componentName . getClassName ( ) ; int index = mCTClassArray . indexOf ( className ) ; if ( index > - 1 ) { ctApps . add ( info ) ; } int firstPageIndex = mCTFirstPageArray . indexOf ( className ) ; if ( firstPageIndex > - 1 ) { ctFirstPageApps . add ( info ) ; } } mApps . removeAll ( ctApps ) ; Collections . sort ( ctApps , APP_CT_COMPARATOR ) ; mApps . removeAll ( ctFirstPageApps ) ; Collections . sort ( ctFirstPageApps , APP_CT_FIRSTPAGE_COMPARATOR ) ; } } \n', 0.37056671261219065)

('public void sort ( ) { String property = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getRequestParameterMap ( ) . get ( SORT_PROPERTY_PARAMETER ) ; if ( property != null ) { SortOrder currentPropertySortOrder = sortsOrders . get ( property ) ; if ( multipleSorting ) { if ( ! sortPriorities . contains ( property ) ) { sortPriorities . add ( property ) ; } } else { sortsOrders . clear ( ) ; } if ( currentPropertySortOrder == null || currentPropertySortOrder . equals ( SortOrder . descending ) ) { sortsOrders . put ( property , SortOrder . ascending ) ; } else { sortsOrders . put ( property , SortOrder . descending ) ; } } } \n', 0.36445560103268604)

('public void sort ( ) { startUnitOfWork ( ) ; TokenInitiative currentInitiative = getTokenInitiative ( getCurrent ( ) ) ; Collections . sort ( tokens , new Comparator < TokenInitiative > ( ) { public int compare ( TokenInitiative o1 , TokenInitiative o2 ) { Object one = null ; if ( o1 . state != null ) { one = o1 . state ; try { one = Double . valueOf ( o1 . state ) ; } catch ( NumberFormatException e ) { } } Object two = null ; if ( o2 . state != null ) { two = o2 . state ; try { two = Double . valueOf ( o2 . state ) ; } catch ( NumberFormatException e ) { } } if ( one == two || ( one != null && one . equals ( two ) ) ) return 0 ; if ( one == null ) return 1 ; if ( two == null ) return - 1 ; if ( one instanceof Double & two instanceof Double ) return ( ( Double ) two ) . compareTo ( ( Double ) one ) ; if ( one instanceof String & two instanceof String ) return ( ( String ) two ) . compareTo ( ( String ) one ) ; if ( one instanceof Double ) return - 1 ; return 1 ; } } ) ; getPCS ( ) . firePropertyChange ( TOKENS_PROP , null , tokens ) ; setCurrent ( indexOf ( currentInitiative ) ) ; finishUnitOfWork ( ) ; } \n', 0.3554084382457869)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('public static double roundToDecimalPlaces ( final double val , final int decimalPlaces ) { String zeros = "1" ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { zeros += "0" ; } int decimal = Integer . valueOf ( zeros ) . intValue ( ) ; if ( ! isNullOrZero ( val ) ) { return ( double ) Math . round ( val * decimal ) / decimal ; } return val ; } \n', 0.47474848012569243)

('public static Double roundToDecimalPlaces ( final Double val , final int decimalPlaces ) { if ( ! isNullOrZero ( val ) ) { return Double . valueOf ( roundToDecimalPlaces ( val . doubleValue ( ) , decimalPlaces ) ) ; } return val ; } \n', 0.4708190755488689)

('public static float roundDecimal ( float value , double places ) { double multiplier = Math . pow ( 10 , places ) ; value *= multiplier ; return ( float ) ( Math . round ( value ) / multiplier ) ; } \n', 0.46927089065622263)

('public static Double roundToNDecimalPlaces ( Double toBeFormatted , int nDecimalPlaces ) { double decPlacesFact = Math . pow ( 10 , nDecimalPlaces ) ; return ( double ) Math . round ( toBeFormatted * decPlacesFact ) / decPlacesFact ; } \n', 0.46764733215472787)

('public static float roundFloat ( float number , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( String . valueOf ( number ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } catch ( Exception e ) { logger . error ( e ) ; return number ; } } \n', 0.46368390074375193)

('protected double roundToDecimalPlaces ( double number , int decimalPlace , boolean place ) { int temp = 1 ; for ( int i = 0 ; i < decimalPlace ; i ++ ) { temp = temp * 10 ; } if ( place ) { number = number / temp ; number = Math . round ( number ) ; number = number * temp ; } else { number = number * temp ; number = Math . round ( number ) ; number = number / temp ; } return number ; } \n', 0.462814356628056)

('public static double roundBigDecimalDouble ( double d , int decimalPlaces ) { BigDecimal bd = new BigDecimal ( Double . toString ( d ) ) ; bd = bd . setScale ( decimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . doubleValue ( ) ; } \n', 0.46216983525252214)

('public static float round ( float num , int decimalPlaces ) { float digit = 1 ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { digit *= 10 ; } return Math . round ( num * digit ) / digit ; } \n', 0.4608344527940348)

('public static float round ( float valueToRound , int numDecimalPlaces ) { BigDecimal bd = new BigDecimal ( Float . toString ( valueToRound ) ) ; bd = bd . setScale ( numDecimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } \n', 0.4595635904307136)

('public static double roundToDecimals ( double d , int decimalPlace ) { BigDecimal bd = new BigDecimal ( Double . toString ( d ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . doubleValue ( ) ; } \n', 0.45728728843997446)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

('@ NonNull public static String leftPadWithZeros ( @ Nullable final String toPad , final int finalSize ) { final StringBuilder temp = new StringBuilder ( ) ; if ( CoreLibConstants . IS_PARAMETER_CHECKING_ENABLED ) { if ( finalSize < 0 ) { throw new IllegalArgumentException ( "finalSize-cannot-be-negative" ) ; } } if ( null != toPad ) { temp . append ( toPad ) ; } if ( temp . length ( ) < finalSize ) { do { temp . insert ( 0 , \'0\' ) ; } while ( finalSize != temp . length ( ) ) ; } return temp . toString ( ) ; } \n', 0.4060354117236279)

('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40178837872132317)

('public static String leftPad ( final String str , final int size , final char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > StringUtils . PAD_LIMIT ) { return StringUtils . leftPad ( str , size , String . valueOf ( padChar ) ) ; } return StringUtils . padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40175002810435456)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( new Integer ( size ) , substring ) ; } \n', 0.3974942111254081)

('public static final byte [ ] leftPad ( byte [ ] value , int length , int padByte ) { byte [ ] left = new byte [ length ] ; Arrays . fill ( left , ( byte ) padByte ) ; System . arraycopy ( value , 0 , left , length - value . length , value . length ) ; return left ; } \n', 0.39301718397741947)

("public static String leftPadMultiline ( String input , char padChar , int padWidth ) { StringBuilder buf = new StringBuilder ( input ) ; String paddingString = repeatedChar ( padChar , padWidth ) ; int i = 0 ; while ( i < buf . length ( ) ) { if ( buf . charAt ( i ) == '|n' ) { buf . insert ( i + 1 , paddingString ) ; } i ++ ; } return buf . toString ( ) ; } \n", 0.39250052489166726)

('public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isNullOrEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.3913625230645047)

('private void leftPadZeros ( int value , int digits , StringBuilder sb ) { for ( int i = 1 ; i < digits ; ++ i ) { if ( value < Math . pow ( 10 , i ) ) sb . append ( "0" ) ; } sb . append ( value ) ; } \n', 0.387739525938552)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( Integer . valueOf ( size ) , substring ) ; } \n', 0.3873597474059222)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public static < ArrayType > PermutationGenerator < ArrayType > createOptimizedGenerator ( ArrayType array ) { OptimizedGeneratorCreator creator = _optimizedGeneratorCreators . get ( array . getClass ( ) ) ; if ( creator == null ) { throw new NoSuchOptimizedPermutationGeneratorException ( array . getClass ( ) ) ; } return creator . createOptimizedGenerator ( array ) ; } \n', 0.30212441214158237)

('public GenericArrayType asGenericArray ( Type type ) { if ( type instanceof Class < ? > ) { Class < ? > cls = ( Class < ? > ) type ; if ( cls . isArray ( ) ) { return factory . makeArray ( cls . getComponentType ( ) ) ; } else { return null ; } } else if ( type instanceof ParameterizedType ) { ParameterizedType pType = ( ParameterizedType ) type ; Class < ? > rawCls = ( Class < ? > ) pType . getRawType ( ) ; if ( rawCls . isArray ( ) ) { return factory . makeArray ( factory . make ( rawCls . getComponentType ( ) , pType . getActualTypeArguments ( ) ) ) ; } else { return null ; } } else if ( type instanceof GenericArrayType ) { return ( GenericArrayType ) type ; } else { return null ; } } \n', 0.30167930700723833)

('public static Integer [ ] createIntegerArrFromCollection ( List < Integer [ ] > integerArrList ) { if ( integerArrList == null ) { return null ; } List < Integer > integerList = new LinkedList < Integer > ( ) ; Iterator < Integer [ ] > iterator = integerArrList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer [ ] integerArr = iterator . next ( ) ; if ( integerArr != null && integerArr . length > 0 ) { for ( Integer integerValue : integerArr ) { if ( integerValue != null ) { integerList . add ( integerValue ) ; } } } } return GeneralUtils . createIntegerArrFromCollection ( integerList ) ; } \n', 0.2958510707323725)

('private static String createClassName ( Class extendz , Class [ ] interfaces ) throws IOException { if ( extendz == null ) extendz = Object . class ; StringBuilder sb = new StringBuilder ( extendz . getName ( ) ) ; if ( interfaces != null && interfaces . length > 0 ) { sb . append ( \';\' ) ; String [ ] arr = new String [ interfaces . length ] ; for ( int i = 0 ; i < interfaces . length ; i ++ ) { arr [ i ] = interfaces [ i ] . getName ( ) ; } Arrays . sort ( arr ) ; sb . append ( railo . runtime . type . util . ListUtil . arrayToList ( arr , ";" ) ) ; } String key = KeyGenerator . createVariable ( sb . toString ( ) ) ; return key ; } \n', 0.29366711119936006)

('@ SuppressWarnings ( "unchecked" ) public LoadGenerationStrategy createLoadGenerationStrategy ( String loadGenerationStrategyClassName , JSONObject loadGenerationStrategyParams , Generator generator , int id ) throws Exception { LoadGenerationStrategy loadGenStrategy = null ; Class < LoadGenerationStrategy > loadGenStrategyClass = ( Class < LoadGenerationStrategy > ) Class . forName ( loadGenerationStrategyClassName ) ; Constructor < LoadGenerationStrategy > loadGenStrategyCtor = loadGenStrategyClass . getConstructor ( new Class [ ] { Generator . class , long . class , JSONObject . class } ) ; loadGenStrategy = ( LoadGenerationStrategy ) loadGenStrategyCtor . newInstance ( new Object [ ] { generator , id , loadGenerationStrategyParams } ) ; return loadGenStrategy ; } \n', 0.29334996387640655)

('public Method [ ] createImplementation ( final JavaClass [ ] interfacesToImplement ) throws Exception { if ( interfacesToImplement == null ) { final String message = "Interface-to-implement-must-not-be-<null>." ; throw new IllegalArgumentException ( message ) ; } if ( ! isInitialized ( ) ) { final String message = "BCELInterfaceImplementationGenerator-is-not-initialized." ; throw new IllegalStateException ( message ) ; } final Set gmList = new HashSet ( ) ; final MethodDesc [ ] interfaceMethods = extractMethods ( interfacesToImplement ) ; for ( int i = 0 ; i < interfaceMethods . length ; ++ i ) { final MethodDesc im = interfaceMethods [ i ] ; if ( im . name . equals ( "<clinit>" ) ) { continue ; } final Method generatedMethod = createMethodWrapper ( im ) ; gmList . add ( generatedMethod ) ; } return ( Method [ ] ) gmList . toArray ( new Method [ gmList . size ( ) ] ) ; } \n', 0.2891641407450414)

('< T > T createMappedBean ( ControllerService plugin , boolean requiresPrefix , Class < T > clazz , String beanName , Map < String , RequestParameter > parameters ) throws IllegalAccessException , InstantiationException { Map < String , String [ ] > beanParams = new HashMap < String , String [ ] > ( ) ; String prefix = requiresPrefix ? beanName + "." : "" ; for ( String key : parameters . keySet ( ) ) { if ( key . startsWith ( prefix ) ) { String paramName = key . substring ( prefix . length ( ) ) ; beanParams . put ( paramName , parameters . get ( key ) . toArray ( ) ) ; } } T bean = clazz . newInstance ( ) ; for ( String key : beanParams . keySet ( ) ) { String [ ] value = beanParams . get ( key ) ; String setterName = "set" + key . substring ( 0 , 1 ) . toUpperCase ( ) + key . substring ( 1 ) ; try { boolean success = callSetter ( plugin , setterName , clazz , bean , value ) ; if ( ! success ) { Field f = clazz . getField ( key ) ; Object o = getValue ( plugin , f , f . getGenericType ( ) , value ) ; if ( o != null ) { f . set ( bean , o ) ; } } } catch ( Exception e ) { } } return bean ; } \n', 0.26952882204917394)

('@ SafeVarargs public static < T > TestDataGenerator < ArrayList < T >> arrayListGenerator ( final T ... elements ) { return new TestDataGenerator < ArrayList < T >> ( ) { @ Override public ArrayList < T > generate ( ) { return new ArrayList < T > ( Arrays . asList ( elements ) ) ; } } ; } \n', 0.2646186274142995)

('public Type [ ] getGenericInterfaces ( ) { Type [ ] result ; synchronized ( Caches . genericInterfaces ) { result = Caches . genericInterfaces . get ( this ) ; if ( result == null ) { String annotationSignature = AnnotationAccess . getSignature ( this ) ; if ( annotationSignature == null ) { result = getInterfaces ( ) ; } else { GenericSignatureParser parser = new GenericSignatureParser ( getClassLoader ( ) ) ; parser . parseForClass ( this , annotationSignature ) ; result = Types . getTypeArray ( parser . interfaceTypes , false ) ; } Caches . genericInterfaces . put ( this , result ) ; } } return ( result . length == 0 ) ? result : result . clone ( ) ; } \n', 0.25291219715394897)

('public boolean isAssignableGenericArrayType ( GenericArrayType from , Type to ) { if ( to instanceof Class < ? > ) { Class < ? > cls = ( Class < ? > ) to ; return cls . equals ( Object . class ) || cls . equals ( Cloneable . class ) || cls . equals ( Serializable . class ) || ( cls . isArray ( ) && isAssignable ( from . getGenericComponentType ( ) , cls . getComponentType ( ) ) ) ; } else if ( to instanceof GenericArrayType ) { return isAssignable ( from . getGenericComponentType ( ) , ( ( GenericArrayType ) to ) . getGenericComponentType ( ) ) ; } else if ( to instanceof ParameterizedType ) { ParameterizedType ptype = ( ParameterizedType ) to ; Class < ? > rawType = ( Class < ? > ) ptype . getRawType ( ) ; if ( rawType . isArray ( ) ) { TypeFactory f = TypeFactory . v ( ) ; return isAssignable ( from . getGenericComponentType ( ) , f . make ( rawType . getComponentType ( ) , ptype . getActualTypeArguments ( ) ) ) ; } else { return false ; } } else if ( to instanceof TypeVariable < ? > ) { return isAssignableToVar ( from , ( TypeVariable < ? > ) to ) ; } else if ( to instanceof WildcardType ) { return isAssignableToWildcard ( from , ( WildcardType ) to ) ; } return false ; } \n', 0.2502922653807361)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('public static String readTextFile ( File file ) throws IOException { if ( Locale . getDefault ( ) . getLanguage ( ) . equals ( "en" ) == false ) { return readI18NFile ( file ) ; } FileReader in = new FileReader ( file ) ; int size = ( int ) file . length ( ) ; char [ ] data = new char [ size ] ; int chars_read = 0 ; while ( chars_read < size ) { chars_read += in . read ( data , chars_read , size - chars_read ) ; } return new String ( data ) ; } \n', 0.4254513574659099)

('public static List < String > loadTextFile ( final String location , final List < String > list ) throws IOException { final BufferedReader reader = new BufferedReader ( getReader ( location ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { list . add ( line ) ; line = reader . readLine ( ) ; } return list ; } \n', 0.42468146728707046)

('public void loadTextFile ( String path ) throws IOException { BufferedReader input = new BufferedReader ( new InputStreamReader ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( path ) ) ) ; String line ; while ( input . ready ( ) ) { line = input . readLine ( ) ; StringBuffer word = new StringBuffer ( ) ; for ( int i = 0 ; i < line . length ( ) ; ++ i ) { char c = line . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { continue ; } word . append ( c ) ; } if ( word . length ( ) < 1 ) { continue ; } add ( word . toString ( ) ) ; } input . close ( ) ; } \n', 0.42202302827444793)

('public static String readTextFile ( File inputFile ) throws IOException { FileInputStream fis = new FileInputStream ( inputFile ) ; Charset charset = Charset . forName ( "UTF-8" ) ; InputStreamReader isr = new InputStreamReader ( fis , charset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuffer contents = new StringBuffer ( ) ; String line ; String separator = System . getProperty ( "line.separator" ) ; while ( ( line = reader . readLine ( ) ) != null ) { contents . append ( line ) . append ( separator ) ; } fis . close ( ) ; isr . close ( ) ; return contents . toString ( ) ; } \n', 0.41996497953351564)

('private Hashtable readProgramListFromTextFile ( ) throws IOException { final Hashtable result = new Hashtable ( ) ; final InputStream is = getClass ( ) . getResourceAsStream ( "/programs/programs.txt" ) ; int c = 0 ; while ( c >= 0 ) { final StringBuffer line = new StringBuffer ( ) ; while ( ( c = is . read ( ) ) > 0 && c != \'|n\' && c != \'|r\' ) { line . append ( ( char ) c ) ; } if ( ! line . toString ( ) . startsWith ( "#" ) && line . length ( ) > 0 ) { result . put ( line . toString ( ) , "/programs/" + line . toString ( ) ) ; } } return result ; } \n', 0.4191684070453872)

('public static String readTextFile ( File file ) throws IOException { BufferedReader in = null ; try { if ( ! file . exists ( ) ) { Object [ ] args = { file } ; throw new IOException ( MessageFormat . format ( ResourceBundleFactory . getBundle ( BUNDLE_NAME ) . getString ( "FILE_DOES_NOT_EXIST" ) , args ) ) ; } in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; int fileSize = ( int ) file . length ( ) ; char [ ] buf = new char [ fileSize ] ; in . read ( buf , 0 , fileSize ) ; return new String ( buf ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException ignored ) { ; } } } } \n', 0.4181872665292285)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.41573641785888943)

('private void loadTextFile ( ) throws IOException { logger . debug ( "Entering-loadTextFile()" ) ; FileReader fr = new FileReader ( selectedFile ) ; int ch = 0 ; StringBuffer readFile = new StringBuffer ( ) ; while ( ch != - 1 ) { ch = fr . read ( ) ; if ( ch != - 1 ) readFile . append ( ( char ) ch ) ; } fr . close ( ) ; resultTextFile = readFile . toString ( ) ; } \n', 0.415044455216781)

('public static String loadTextFile ( File file ) throws IOException { char [ ] buffer = new char [ 4096 ] ; int len ; StringBuilder input = new StringBuilder ( ) ; BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { while ( ( len = reader . read ( buffer ) ) != - 1 ) { input . append ( buffer , 0 , len ) ; } } finally { reader . close ( ) ; } return input . toString ( ) ; } \n', 0.4145982548659303)

('private String readEmbeddedTextFile ( String filepath ) throws IOException { InputStream is = BuildConfigGenerator . class . getResourceAsStream ( filepath ) ; if ( is != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is ) ) ; String line ; StringBuilder total = new StringBuilder ( reader . readLine ( ) ) ; while ( ( line = reader . readLine ( ) ) != null ) { total . append ( \'|n\' ) ; total . append ( line ) ; } return total . toString ( ) ; } throw new IOException ( "BuildConfig-template-is-missing!" ) ; } \n', 0.41441637494707717)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('private static Enumeration nodeToEnum ( Node n ) { if ( n . children == null ) { return ( n . items == null ) ? org . openide . util . Enumerations . empty ( ) : Collections . enumeration ( n . items ) ; } class DeepAndItems implements org . openide . util . Enumerations . Processor { public Object process ( Object obj , Collection toAdd ) { Node n2 = ( Node ) obj ; if ( n2 . children != null ) { toAdd . addAll ( n2 . children ) ; } if ( ( n2 . items == null ) || n2 . items . isEmpty ( ) ) { return org . openide . util . Enumerations . empty ( ) ; } else { return Collections . enumeration ( n2 . items ) ; } } } Enumeration en = org . openide . util . Enumerations . queue ( org . openide . util . Enumerations . singleton ( n ) , new DeepAndItems ( ) ) ; return new NeedsSortEnum ( org . openide . util . Enumerations . concat ( en ) ) ; } \n', 0.35970563173695225)

('public static < T > void forEach ( Iterable < T > iterable , int from , int to , Procedure < ? super T > procedure ) { if ( from < 0 || to < 0 ) { throw new IllegalArgumentException ( "Neither-from-nor-to-may-be-negative." ) ; } Iterator < T > iterator = IteratorIterate . advanceIteratorTo ( iterable . iterator ( ) , from ) ; int i = from ; while ( iterator . hasNext ( ) && i <= to ) { procedure . value ( iterator . next ( ) ) ; i ++ ; } } \n', 0.342719694694018)

('public Iterator < ? > findIterator ( Object instance ) throws PropertyException { if ( iteratorMethod != null ) { Object ret = invoke ( iteratorMethod , instance , null ) ; if ( ret instanceof Iterator < ? > ) { return ( Iterator < ? > ) ret ; } else if ( ret instanceof Enumeration < ? > ) { return new EnumIterator < Object > ( ( Enumeration < ? > ) ret ) ; } else if ( ret instanceof Object [ ] ) { return new ArrayIterator ( ( Object [ ] ) ret ) ; } } throw new PropertyException ( ( instance == null ? "null" : instance . getClass ( ) . getName ( ) ) + "-is-not-a-list" ) ; } \n', 0.3373585117175308)

('protected boolean _acceptJsonFormatVisitorForEnum ( JsonFormatVisitorWrapper visitor , JavaType typeHint , Class < ? > enumType ) throws JsonMappingException { JsonStringFormatVisitor stringVisitor = visitor . expectStringFormat ( typeHint ) ; if ( stringVisitor != null ) { Set < String > enums = new LinkedHashSet < String > ( ) ; for ( Object en : enumType . getEnumConstants ( ) ) { try { enums . add ( String . valueOf ( _accessorMethod . invoke ( en ) ) ) ; } catch ( Exception e ) { Throwable t = e ; while ( t instanceof InvocationTargetException && t . getCause ( ) != null ) { t = t . getCause ( ) ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw JsonMappingException . wrapWithPath ( t , en , _accessorMethod . getName ( ) + "()" ) ; } } stringVisitor . enumTypes ( enums ) ; } return true ; } \n', 0.3328698093681087)

('final public Iterator < ? > getIterator ( Object instance ) throws PropertyException { if ( instance instanceof Object [ ] ) return new ArrayIterator ( ( Object [ ] ) instance ) ; else if ( instance . getClass ( ) . isArray ( ) ) return new PrimitiveArrayIterator ( instance ) ; else if ( instance instanceof Iterator < ? > ) return ( Iterator < ? > ) instance ; else if ( instance instanceof Enumeration < ? > ) return new EnumIterator < Object > ( ( Enumeration < ? > ) instance ) ; else return getOperator ( instance ) . findIterator ( instance ) ; } \n', 0.3228866027639164)

('public Enumeration toEnumeration ( Object obj ) { if ( obj instanceof Enumeration ) { return ( Enumeration ) obj ; } else if ( obj instanceof Iterator ) { return new ItrEnum ( ( Iterator ) obj ) ; } else if ( obj instanceof Object [ ] ) { return new ObjectArrayEnum ( ( Object [ ] ) obj ) ; } else if ( obj instanceof Collection ) { return Collections . enumeration ( ( Collection ) obj ) ; } else if ( obj instanceof Map ) { return new ItrEnum ( ( ( Map ) obj ) . entrySet ( ) . iterator ( ) ) ; } else if ( Runtime . isArray ( obj ) ) { return new ArrayEnum ( obj ) ; } else if ( obj instanceof String ) { return new StringEnum ( ( String ) obj ) ; } else { return null ; } } \n', 0.3190425137062266)

('private List < String > getEnumNames ( Class < T > optionsEnumClass ) { return FluentIterable . from ( Arrays . asList ( optionsEnumClass . getEnumConstants ( ) ) ) . transform ( Enums . stringConverter ( optionsEnumClass ) . reverse ( ) ) . toList ( ) ; } \n', 0.31719139408488584)

('public static Enum < ? > [ ] toEnums ( final Collection < Object > vector ) throws DataNotCompatibleException { if ( vector == null || vector . isEmpty ( ) ) return new Enum [ 0 ] ; ClassLoader cl = Factory . getClassLoader ( ) ; Enum < ? > [ ] classes = new Enum [ vector . size ( ) ] ; int i = 0 ; for ( Object o : vector ) { int pos = i ++ ; String en = String . valueOf ( o ) ; String ename = null ; String cn = null ; if ( en . indexOf ( \'-\' ) > 0 ) { cn = String . valueOf ( o ) . substring ( 0 , en . indexOf ( \'-\' ) ) . trim ( ) ; ename = String . valueOf ( o ) . substring ( en . indexOf ( \'-\' ) + 1 ) . trim ( ) ; } try { Class < ? > cls = Class . forName ( cn , false , cl ) ; for ( Object obj : cls . getEnumConstants ( ) ) { if ( obj instanceof Enum ) { if ( ( ( Enum < ? > ) obj ) . name ( ) . equals ( ename ) ) { classes [ pos ] = ( Enum < ? > ) obj ; } } } } catch ( ClassNotFoundException e ) { System . out . println ( "Failed-to-find-class-" + cn + "-using-a-classloader-of-type-" + cl . getClass ( ) . getName ( ) ) ; DominoUtils . handleException ( e ) ; classes [ pos ] = null ; } } return classes ; } \n', 0.3168790521067198)

('CNBindingEnumeration ( CNCtx ctx , boolean isLookedUpCtx , Hashtable env ) { String batch = ( env != null ? ( String ) env . get ( javax . naming . Context . BATCHSIZE ) : null ) ; if ( batch != null ) { try { batchsize = Integer . parseInt ( batch ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Batch-size-not-numeric:-" + batch ) ; } } _ctx = ctx ; _ctx . incEnumCount ( ) ; this . isLookedUpCtx = isLookedUpCtx ; _env = env ; _bindingList = new BindingListHolder ( ) ; BindingIteratorHolder _bindingIterH = new BindingIteratorHolder ( ) ; _ctx . _nc . list ( 0 , _bindingList , _bindingIterH ) ; _bindingIter = _bindingIterH . value ; if ( _bindingIter != null ) { more = _bindingIter . next_n ( batchsize , _bindingList ) ; } else { more = false ; } counter = 0 ; } \n', 0.31389336656289357)

('CNBindingEnumeration ( CNCtx ctx , boolean isLookedUpCtx , Hashtable < ? , ? > env ) { String batch = ( env != null ? ( String ) env . get ( javax . naming . Context . BATCHSIZE ) : null ) ; if ( batch != null ) { try { batchsize = Integer . parseInt ( batch ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Batch-size-not-numeric:-" + batch ) ; } } _ctx = ctx ; _ctx . incEnumCount ( ) ; this . isLookedUpCtx = isLookedUpCtx ; _env = env ; _bindingList = new BindingListHolder ( ) ; BindingIteratorHolder _bindingIterH = new BindingIteratorHolder ( ) ; _ctx . _nc . list ( 0 , _bindingList , _bindingIterH ) ; _bindingIter = _bindingIterH . value ; if ( _bindingIter != null ) { more = _bindingIter . next_n ( batchsize , _bindingList ) ; } else { more = false ; } counter = 0 ; } \n', 0.31389336656289357)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('private boolean checkPossessionOfTwoOfClubs ( ) { if ( robotsCards . contains ( Object ) ) { possessionOfTwoOfClubs = true ; } else { possessionOfTwoOfClubs = false ; } return possessionOfTwoOfClubs ; } \n', 0.3535034633387055)

('public static void checkLoaded ( ) { if ( LOAD_ERROR != null ) { throw LOAD_ERROR ; } BigInteger two = BigInteger . valueOf ( 2 ) ; BigInteger three = BigInteger . valueOf ( 3 ) ; BigInteger five = BigInteger . valueOf ( 5 ) ; BigInteger answer ; answer = modPowInsecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowInsecure-returned-the-wrong-answer" ) ; } answer = modPowSecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowSecure-returned-the-wrong-answer" ) ; } } \n', 0.3468051299255108)

('public < E > void assertHasAtLeastOneElementOfType ( AssertionInfo info , E [ ] actual , Class < ? > type ) { Objects . instance ( ) . assertNotNull ( info , actual ) ; boolean found = false ; for ( Object o : actual ) { if ( ! type . isInstance ( o ) ) continue ; found = true ; break ; } if ( ! found ) throw failures . failure ( info , shouldHaveAtLeastOneElementOfType ( actual , type ) ) ; } \n', 0.337571886370023)

('private T checkReceivedAtLeastOnce ( final T r ) { T ret = r ; if ( target . isClosed ( ) && ! receivedAtLeastOnce . get ( ) ) ret = prev ; receivedAtLeastOnce . set ( true ) ; return ret ; } \n', 0.3298283033261171)

('private static boolean isConcreteBoolean ( Value value ) { if ( value . getObjectLabels ( ) . size ( ) == 1 && value . getObjectLabels ( ) . iterator ( ) . next ( ) . getKind ( ) == ObjectLabel . Kind . BOOLEAN ) { value = Conversion . toBoolean ( value ) ; } return ( value . isMaybeTrueButNotFalse ( ) || value . isMaybeFalseButNotTrue ( ) ) && ! value . isMaybeOtherThanBool ( ) ; } \n', 0.3275656709512298)

('private boolean isTest ( ITypeBinding binding ) { if ( Modifier . isAbstract ( binding . getModifiers ( ) ) ) return false ; if ( Annotation . RUN_WITH . annotatesTypeOrSuperTypes ( binding ) || Annotation . TEST . annotatesAtLeastOneMethod ( binding ) ) { return true ; } return CoreTestSearchEngine . isTestImplementor ( binding ) ; } \n', 0.3155820809246038)

('private void checkThreeOfKind ( int currentPlayer ) { int score = 0 ; if ( ones . size ( ) >= 3 || twos . size ( ) >= 3 || threes . size ( ) >= 3 || fours . size ( ) >= 3 || fives . size ( ) >= 3 || sixes . size ( ) >= 3 ) { for ( int i = 0 ; i < N_DICE ; i ++ ) { score += allDices [ i ] ; } } eachCategoryScore [ currentPlayer ] [ category ] = score ; } \n', 0.31145353746588295)

('public static boolean isProbablePrime ( BigInteger n ) { if ( n . compareTo ( ZERO ) <= 0 ) return false ; if ( n . equals ( ONE ) ) return false ; if ( n . equals ( TWO ) ) return true ; if ( n . equals ( THREE ) ) return true ; if ( n . mod ( TWO ) . equals ( ZERO ) ) return false ; for ( int i = 0 ; i < ITERATIONS ; i ++ ) { BigInteger a ; do { a = new BigInteger ( n . bitLength ( ) , rand ) ; } while ( a . compareTo ( ONE ) <= 0 || a . compareTo ( n . subtract ( ONE ) ) >= 0 ) ; if ( isWitness ( a , n ) ) return false ; } return true ; } \n', 0.3090957167293948)

('@ Override public boolean isAtLeastOneDatasourceSelected ( ) { boolean atLeastOneDatasourceSelected = false ; for ( DataSource ds : this . allDataSources ) { if ( ds . getEnabled ( ) ) atLeastOneDatasourceSelected = true ; } return atLeastOneDatasourceSelected ; } \n', 0.3074874076751585)

('@ SuppressWarnings ( { "unchecked" , "cast" } ) public boolean isDAafterTrue ( Variable v ) { Object _parameters = v ; if ( isDAafterTrue_Variable_values == null ) isDAafterTrue_Variable_values = new java . util . HashMap ( 4 ) ; if ( isDAafterTrue_Variable_values . containsKey ( _parameters ) ) { return ( ( Boolean ) isDAafterTrue_Variable_values . get ( _parameters ) ) . booleanValue ( ) ; } ASTNode$State state = state ( ) ; int num = state . boundariesCrossed ; boolean isFinal = this . is$Final ( ) ; boolean isDAafterTrue_Variable_value = isDAafterTrue_compute ( v ) ; if ( isFinal && num == state ( ) . boundariesCrossed ) isDAafterTrue_Variable_values . put ( _parameters , Boolean . valueOf ( isDAafterTrue_Variable_value ) ) ; return isDAafterTrue_Variable_value ; } \n', 0.30704672881348416)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('private int convertFromStringToInt ( String numberPart ) { return Integer . valueOf ( numberPart ) ; } \n', 0.42021392691657145)

('public static Integer [ ] convertFromHexStringToInts ( String s ) { int numOfHexStrings = s . length ( ) / 8 + ( s . length ( ) % 8 != 0 ? 1 : 0 ) ; String [ ] strings = new String [ numOfHexStrings ] ; int j = 0 ; System . out . println ( "String-is-" + s ) ; for ( int i = 0 ; i < numOfHexStrings ; i ++ ) { strings [ i ] = s . substring ( j , j + ( s . length ( ) - j < 8 ? s . length ( ) - j : 8 ) ) ; if ( strings [ i ] . length ( ) < 8 ) { String str = "" ; for ( int k = 0 ; k < ( 8 - strings [ i ] . length ( ) ) ; k ++ ) { str += "0" ; } strings [ i ] = str + strings [ i ] ; } System . out . println ( "Made:-" + strings [ i ] ) ; j += 8 ; } Integer [ ] ints = new Integer [ numOfHexStrings ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { BigInteger uncipheredInt = new BigInteger ( strings [ i ] , 16 ) ; ints [ i ] = uncipheredInt . intValue ( ) ; System . out . println ( "::" + Integer . toHexString ( ints [ i ] ) ) ; } return ints ; } \n', 0.39587863534638223)

('private String convertToStringFromInt ( int integer ) { return Integer . toString ( integer ) ; } \n', 0.3903831810149264)

('public static int convertToInt ( String str ) throws NumberFormatException { int s , e ; for ( s = 0 ; s < str . length ( ) ; s ++ ) if ( Character . isDigit ( str . charAt ( s ) ) ) break ; for ( e = str . length ( ) ; e > 0 ; e -- ) if ( Character . isDigit ( str . charAt ( e - 1 ) ) ) break ; if ( e > s ) { try { return Integer . parseInt ( str . substring ( s , e ) ) ; } catch ( NumberFormatException ex ) { Log . e ( "convertToInt" , ex ) ; throw new NumberFormatException ( ) ; } } else { throw new NumberFormatException ( ) ; } } \n', 0.3897049253959102)

('public static Integer convertIP4FromStringToInt ( final String ip ) { String [ ] ipStrArray = ip . split ( "|." ) ; int ipInt = 0 ; for ( int i = 3 ; i >= 0 ; i -- ) { int tmpIP = Integer . parseInt ( ipStrArray [ i ] ) ; if ( i == 0 ) { ipInt = ipInt + NumberBin . bin2power24 + tmpIP ; } else if ( i == 1 ) { ipInt = ipInt + NumberBin . bin2power16 + tmpIP ; } else if ( i == 2 ) { ipInt = ipInt + NumberBin . bin2power8 + tmpIP ; } else if ( i == 3 ) { ipInt = ipInt + tmpIP ; } } return ipInt ; } \n', 0.3895843816492708)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.38881819720642374)

('public static String convertToShortString ( String guid ) { if ( guid == null || guid . length ( ) == 0 ) { return guid ; } String padded = guid ; if ( guid . length ( ) <= 36 ) { padded = "0" + guid ; } int totalLen = padded . length ( ) ; StringBuffer sb = new StringBuffer ( ) ; int idx = 0 ; while ( idx < totalLen ) { StringBuffer part = new StringBuffer ( ) ; int cnt = 0 ; while ( cnt < 3 && idx < totalLen ) { char c ; if ( ( c = padded . charAt ( idx ++ ) ) != \'-\' ) { part . append ( c ) ; cnt ++ ; } } int base = Integer . parseInt ( part . toString ( ) , 16 ) ; StringBuffer str2 = new StringBuffer ( ) ; for ( int j = 0 ; j < 2 ; j ++ ) { int tmp = base / 64 ; int rem = base - tmp * 64 ; base = tmp ; str2 . insert ( 0 , getBase64Char ( rem ) ) ; } sb . append ( str2 ) ; } return sb . toString ( ) ; } \n', 0.38490407569198826)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.3795511176829235)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.37822569717556054)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.37820241142063793)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

('public static char convertStringToChar ( final String value ) { char convertedValue = Constants . INVALID_CHAR ; if ( ! isObjectNullOrEmpty ( value ) ) { convertedValue = value . charAt ( 0 ) ; } return convertedValue ; } \n', 0.3779271047498269)

('public String convertUnicodeCharacterRepresentation ( String input ) { if ( ! ( input . contains ( "|u" ) || input . contains ( "|U" ) ) ) return input ; final char [ ] chars = input . toCharArray ( ) ; for ( int offset = 0 ; 6 + offset < chars . length ; offset ++ ) { if ( chars [ offset ] == \'|\' && ( chars [ offset + 1 ] == \'u\' || chars [ offset + 1 ] == \'U\' ) ) { chars [ offset + 1 ] = \'u\' ; for ( int i = 2 ; i < 6 ; i ++ ) { chars [ offset + i ] = Character . toUpperCase ( chars [ offset + i ] ) ; } offset += 5 ; } } return new String ( chars ) ; } \n', 0.3586416168174792)

('@ NotNull public static CharSequence convertToBytesIfAsciiString ( @ NotNull CharSequence name ) { int length = name . length ( ) ; if ( length == 0 ) return "" ; byte [ ] bytes = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char c = name . charAt ( i ) ; if ( c >= 128 ) { return new String ( name . toString ( ) ) ; } bytes [ i ] = ( byte ) c ; } return new ByteArrayCharSequence ( bytes ) ; } \n', 0.35798380207931746)

('public static String convertChars ( String orig_name , String chars , char toChar ) { StringBuffer tmp = new StringBuffer ( orig_name ) ; int i ; for ( i = 0 ; i < tmp . length ( ) ; i ++ ) { if ( chars . indexOf ( tmp . charAt ( i ) ) != - 1 ) { tmp . setCharAt ( i , toChar ) ; } } return new String ( tmp ) ; } \n', 0.35639166002818)

('public String convert ( CharSequence chars , int offset , int count ) { if ( offset < 0 ) { throw new StringIndexOutOfBoundsException ( offset ) ; } if ( count < 0 ) { throw new StringIndexOutOfBoundsException ( count ) ; } int end = offset + count ; if ( end > chars . length ( ) ) { throw new StringIndexOutOfBoundsException ( offset + count ) ; } StringBuffer buffer = new StringBuffer ( ) ; for ( int i = offset ; i < end ; i ++ ) { buffer . append ( convert ( chars . charAt ( i ) ) ) ; } return buffer . toString ( ) ; } \n', 0.3523151005408147)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.34732607717293607)

('public static String convertSpecialChars ( String s ) { char c ; int len = s . length ( ) ; StringBuilder sb = new StringBuilder ( len ) ; int i = 0 ; while ( i < len ) { c = s . charAt ( i ++ ) ; if ( c == \'|\' ) { c = s . charAt ( i ++ ) ; if ( c == \'n\' ) { c = \'|n\' ; } else if ( c == \'r\' ) { c = \'|r\' ; } else if ( c == \'t\' ) { c = \'|t\' ; } else if ( c == \'f\' ) { c = \'|f\' ; } else if ( c == \'|b\' ) { c = \'|b\' ; } else if ( c == \'|"\' ) { c = \'|"\' ; } else if ( c == \'|\'\' ) { c = \'|\'\' ; } else if ( c == \'|\' ) { c = \'|\' ; } } sb . append ( c ) ; } return sb . toString ( ) ; } \n', 0.34553940819206996)

('private String convertToJava ( String cssUnicode ) { final int codePoint = Integer . parseInt ( cssUnicode , 16 ) ; final char [ ] chars = Character . toChars ( codePoint ) ; return String . valueOf ( chars ) ; } \n', 0.34547575720112567)

('public static String convertByteArrayToStringWithoutEscape ( byte [ ] data , int offset , int length ) { StringBuilder sb = new StringBuilder ( length ) ; for ( int i = offset ; i < length && i < data . length ; i ++ ) { sb . append ( ( char ) data [ i ] ) ; } return sb . toString ( ) ; } \n', 0.34483506461771884)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('private void checkIfLocalFileExistsAndCanRead ( ) throws FileTransferException { if ( ! localFile . exists ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , new FileNotFoundException ( localFile . getAbsolutePath ( ) ) , true ) ; } if ( ! localFile . canRead ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , "File-exists-but-cannot-be-read" , true ) ; } } \n', 0.4041461995914023)

('public static void verifyFileExistsAndReadable ( File file ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File-"" + file . getName ( ) + ""-doesn\'t-exist." ) ; } if ( ! file . isFile ( ) ) { throw new IllegalArgumentException ( "File-"" + file . getName ( ) + ""-is-not-a-valid-file-that-can-be-read-as-a-manifest.-Is-it-a-directory?" ) ; } if ( ! file . canRead ( ) ) { throw new IllegalArgumentException ( "Unable-to-read-file-"" + file . getName ( ) + "".-Check-permissions." ) ; } } \n', 0.3608483060212261)

('public static final void checkExistingStandardFile ( final File file , final String msgFileType ) throws IOException { checkExistingFile ( file , msgFileType ) ; if ( ! file . isFile ( ) ) { throw new IOException ( "The-" + msgFileType + "-is-not-a-standard-file:-" + file . getAbsolutePath ( ) ) ; } } \n', 0.35254100029944035)

('public boolean checkIfFileExistsInScratch ( final String pathUnderScratch ) { File targetFile = new File ( testingProperties . getProperty ( GENERATED_FILE_DIRECTORY_KEY ) + pathUnderScratch ) ; return targetFile . exists ( ) ; } \n', 0.3520516807624018)

('public static boolean testFileExists ( String name ) { boolean status ; if ( ( testSaveLocationExists ( ) ) && ( ! name . equals ( "" ) ) ) { File path = Environment . getExternalStorageDirectory ( ) ; File newPath = constructFilePaths ( path . toString ( ) , name ) ; status = newPath . exists ( ) ; } else { status = false ; } return status ; } \n', 0.3475057493660556)

('protected static boolean testFileExists ( String name ) { boolean status ; if ( ( testSaveLocationExists ( ) ) && ( ! name . equals ( "" ) ) ) { File path = Environment . getExternalStorageDirectory ( ) ; File newPath = constructFilePaths ( path . toString ( ) , name ) ; status = newPath . exists ( ) ; } else { status = false ; } return status ; } \n', 0.3475057493660556)

('public static boolean isFileExist ( String filename , Context context ) { boolean isExist = false ; File file = context . getFileStreamPath ( filename ) ; if ( file . exists ( ) ) { isExist = true ; } return isExist ; } \n', 0.3402456063615633)

('public static Boolean checkDirOrFileExists ( int timeoutSECONDS , int pollingTimeMILISECONDS , String path ) { long counter = 0 ; boolean existence = false ; while ( counter < TimeUnit . SECONDS . toMillis ( timeoutSECONDS ) ) { File test = new File ( path ) ; if ( test . exists ( ) ) { existence = true ; break ; } else { try { TimeUnit . MILLISECONDS . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } counter = counter + 200 ; } } return existence ; } \n', 0.3335353327254119)

('public static boolean isFileExists ( String fileName , File parentFolder ) { LOGGER . info ( "checking-if-file-with-name-" + fileName + "-exists-in-folder-" + parentFolder . getAbsolutePath ( ) ) ; File [ ] fileArray = parentFolder . listFiles ( ) ; String existingFileName = "" ; int extensionIndex = 0 ; boolean fileExists = false ; if ( fileArray != null ) { for ( File file : fileArray ) { existingFileName = file . getName ( ) ; extensionIndex = existingFileName . indexOf ( UtilConstants . DOT ) ; extensionIndex = extensionIndex == - 1 ? existingFileName . length ( ) : extensionIndex ; if ( existingFileName . substring ( 0 , extensionIndex ) . equals ( fileName ) ) { LOGGER . info ( "file-exists-with-name-" + fileName + "-in-folder-" + parentFolder . getAbsolutePath ( ) ) ; fileExists = true ; break ; } } } return fileExists ; } \n', 0.33205805889680395)

('public static Boolean checkDirOrFileNotExists ( int timeoutSECONDS , int pollingTimeMILISECONDS , String path ) { long counter = 0 ; boolean existence = false ; while ( counter < TimeUnit . SECONDS . toMillis ( timeoutSECONDS ) ) { File test = new File ( path ) ; if ( test . exists ( ) ) { try { TimeUnit . MILLISECONDS . sleep ( 200 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } counter = counter + 200 ; } else { existence = true ; break ; } } return existence ; } \n', 0.33058188460921406)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('@ Koan public void usingDateFormatToParseDates ( ) throws ParseException { DateFormat dateFormat = new SimpleDateFormat ( "MM-dd-yyyy" ) ; Date date2 = dateFormat . parse ( "01-01-2000" ) ; assertEquals ( date2 . toString ( ) , __ ) ; } \n', 0.42556282134148515)

('public static String convertDateToStringInRFC3339 ( Date date ) { DateTime dt = new DateTime ( date . getTime ( ) , 480 ) ; String wholeFormat = dt . toString ( ) ; String result = wholeFormat . substring ( 0 , wholeFormat . indexOf ( "." ) ) + wholeFormat . substring ( wholeFormat . indexOf ( "." ) + 4 ) ; return result ; } \n', 0.41813192766866075)

('public static List < String > convertDatesToString ( List < DateTime > dates , DateTimeFormatter formatter ) { List < String > dateString = new ArrayList < > ( ) ; formatter . withZoneUTC ( ) ; for ( DateTime date : dates ) { dateString . add ( formatter . print ( date ) ) ; } return dateString ; } \n', 0.4173676639816935)

('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.41281115376975164)

('public static Date convertStringToDateInPostList ( String dateString ) throws ParseException { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy/M/d-H:mm:ss" , Locale . ENGLISH ) ; return sdf1 . parse ( dateString ) ; } \n', 0.4122611692448791)

('public static Date convertStringToDateInQueryResult ( String dateString ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( "yyyy/M/d-HH:mm" , Locale . ENGLISH ) ; return sdf . parse ( dateString ) ; } \n', 0.41130191593095455)

('public static String dateToString ( Date date ) { int month = date . getMonth ( ) + 1 ; int day = date . getDate ( ) ; int year = 1900 + date . getYear ( ) ; String dateString = monthToName ( month ) + "-" + ( day < 10 ? "0" + day : day ) + "-" + year ; return dateString ; } \n', 0.4103675001306205)

('private static String formatToDefaultDateOrString ( final Object value ) { if ( value instanceof Date ) { return DatePropertyParser . format ( ( Date ) value , DateProperty . getDefaultFormat ( ) ) ; } else { return value . toString ( ) ; } } \n', 0.40816710408284096)

('public static String convertDateToString ( Date date ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( ALLOWED_DATE_FORMAT ) ; return sdf . format ( date ) ; } \n', 0.4074081851786442)

('public static java . util . Date stringDateToJavaDate ( String newDate ) { if ( newDate == null || newDate . equals ( "" ) ) { return null ; } String [ ] parts = newDate . split ( "-" ) ; String [ ] date = parts [ 0 ] . split ( "-" ) ; String [ ] time = null ; if ( parts . length > 1 ) { time = parts [ 1 ] . split ( ":" ) ; time [ 2 ] = time [ 2 ] . replaceAll ( "|.0" , "" ) ; } else { time = "00:00:00" . split ( ":" ) ; } GregorianCalendar cal = ( GregorianCalendar ) Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( new Integer ( date [ 0 ] ) . intValue ( ) , ( new Integer ( date [ 1 ] ) . intValue ( ) - 1 ) , new Integer ( date [ 2 ] ) . intValue ( ) , new Integer ( time [ 0 ] ) . intValue ( ) , new Integer ( time [ 1 ] ) . intValue ( ) , new Integer ( time [ 2 ] ) . intValue ( ) ) ; return cal . getTime ( ) ; } \n', 0.40725082876363206)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('private static ByteArrayInputStream convertToByteArrayInputStream ( InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; return byteArrayInputStream ; } \n', 0.4039060814012379)

('@ NonNull private static ByteArrayInputStream convertToByteArrayInputStream ( @ NonNull final InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; final byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } return new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; } \n', 0.4039000299514178)

('public static byte [ ] convertStreamToBytes ( InputStream stream ) throws IOException { if ( stream == null ) { return null ; } ByteArrayOutputStream output = new ByteArrayOutputStream ( ) ; copyStream ( stream , output ) ; return output . toByteArray ( ) ; } \n', 0.4017717341597527)

('@ Converter public static byte [ ] convertToByteArray ( StreamCache cache , Exchange exchange ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; cache . writeTo ( os ) ; return os . toByteArray ( ) ; } \n', 0.39872405219597484)

('public byte [ ] convertToBytes ( final SerializedType object ) throws IOException { byte [ ] byteArray = null ; if ( object != null ) { final ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; try { this . writeObject ( byteStream , object ) ; } finally { byteStream . close ( ) ; } byteArray = byteStream . toByteArray ( ) ; } return byteArray ; } \n', 0.3938027618937444)

('public static byte [ ] convertToByteArray ( InputStream inputStream ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; FileCopyUtils . copy ( inputStream , out ) ; return out . toByteArray ( ) ; } \n', 0.39225606519718825)

('public static byte [ ] convertToByteArray ( final InputStream is , int length , boolean close ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out , is , length , close ) ; out . close ( ) ; return out . toByteArray ( ) ; } \n', 0.38982828577891115)

('protected ByteArrayInputStream convertToByteArrayInputStream ( Source source ) throws TransformerException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; transform ( source , new StreamResult ( bos ) ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } \n', 0.38975845952977056)

('private ByteArrayInputStream convertToByteArrayInputStream ( Source source ) throws TransformerException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; transform ( source , new StreamResult ( bos ) ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } \n', 0.38975845952977056)

('public static byte [ ] convertToByteArray ( final InputStream is , int length ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out , is , length ) ; return out . toByteArray ( ) ; } \n', 0.38880788876088657)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
("public static boolean isNumericOnly ( String aString ) { boolean foundDecimal = false ; for ( int i = aString . length ( ) ; i -- > 0 ; ) { char c = aString . charAt ( i ) ; if ( c == '-' ) { if ( i != 0 ) { return false ; } } else if ( c == '.' ) { if ( ! foundDecimal ) { foundDecimal = true ; } else { return false ; } } else if ( ! Character . isDigit ( c ) ) { return false ; } } return true ; } \n", 0.39740705196300374)

('public static boolean isNumericWithOperators ( CharSequence cs ) { if ( cs == null ) { return false ; } String allowedCharsInNumeric = "<>=--" ; int sz = cs . length ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { char ch = cs . charAt ( i ) ; if ( ! ( Character . isDigit ( ch ) || allowedCharsInNumeric . indexOf ( ch ) > - 1 ) ) { return false ; } } return true ; } \n', 0.38277370847434755)

('public static boolean isNumericString ( String s ) { boolean b = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isNumeric ( s . charAt ( i ) ) ) { b = false ; break ; } } return b ; } \n', 0.37890025167967745)

('static boolean isNumericString ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! isNumeric ( s . charAt ( i ) ) ) { return false ; } } return true ; } \n', 0.37880803947354214)

("private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( '%' ) ; int slen = s . length ( ) ; int digit , zone = 0 ; if ( percent == - 1 ) { return - 1 ; } for ( int i = percent + 1 ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ']' ) { if ( i == percent + 1 ) { return - 1 ; } break ; } if ( ( digit = Character . digit ( c , 10 ) ) < 0 ) { return - 1 ; } zone = ( zone * 10 ) + digit ; } return zone ; } \n", 0.3721387715159612)

('private boolean isNumericString ( String s ) { try { Integer . parseInt ( s , 10 ) ; return true ; } catch ( NumberFormatException e ) { } try { Integer . parseInt ( s , 8 ) ; return true ; } catch ( NumberFormatException e ) { } try { String tmp = s ; if ( s . startsWith ( "-" ) ) tmp = s . substring ( 1 ) ; if ( tmp . startsWith ( "0x" ) || tmp . startsWith ( "0X" ) ) { Integer . parseInt ( tmp . substring ( 2 ) , 16 ) ; return true ; } } catch ( NumberFormatException e ) { } try { Double . valueOf ( s ) ; return true ; } catch ( NumberFormatException e ) { } return false ; } \n', 0.3655319788929503)

('public boolean isNumeric ( Value val ) { switch ( val . getSQLType ( ) ) { case Types . DOUBLE : case Types . FLOAT : case Types . INTEGER : case Types . SMALLINT : case Types . BIGINT : case Types . NUMERIC : case Types . REAL : case Types . TINYINT : return true ; } return false ; } \n', 0.3606431774626639)

('private static boolean isNumericalArgument ( String argument ) { String args [ ] = argument . split ( "," ) ; boolean isNumericalArgument = true ; for ( String arg : args ) { try { Integer . parseInt ( arg ) ; } catch ( NumberFormatException nfe ) { isNumericalArgument = false ; break ; } } return isNumericalArgument ; } \n', 0.35976777135906135)

('static boolean isAlphaNumericString ( String s ) { int len = s . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! isAlphaNumeric ( s . charAt ( i ) ) ) { return false ; } } return true ; } \n', 0.35172596303655534)

('public static boolean isAlphaNumericString ( String s ) { boolean b = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isAlphaNumeric ( s . charAt ( i ) ) ) { b = false ; break ; } } return b ; } \n', 0.34927240150487426)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

('private Serializable copyObject ( Serializable o ) throws RemoteException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; byte [ ] ba = bos . toByteArray ( ) ; Method m = IxcRegistryImpl . getIxcClassLoader ( importer ) . getDeserializeMethod ( ) ; return ( Serializable ) m . invoke ( null , new Object [ ] { ba } ) ; } catch ( RemoteException ex ) { throw ex ; } catch ( Exception ex ) { throw new RemoteException ( "Cannot-copy-object" , ex ) ; } } \n', 0.40537060398417707)

('@ XmlElementDecl ( namespace = AMZN_NS , name = "CopyObject" ) public JAXBElement < CopyObject > createCopyObject ( CopyObject r ) { return Util . createGeneric ( r , CopyObject . class ) ; } \n', 0.40423278690176023)

('@ SuppressWarnings ( "unchecked" ) public static < T > T copyInstance ( T src ) { if ( src == null ) { throw new NullPointerException ( "src-cannot-be-null" ) ; } T copyInstance = null ; Class < T > srcClass = ( Class < T > ) src . getClass ( ) ; PropertyDescriptor [ ] props = retrievePropertyDescriptors ( srcClass ) ; try { copyInstance = ( T ) srcClass . newInstance ( ) ; for ( PropertyDescriptor pd : props ) { Method rm = pd . getReadMethod ( ) ; Method wm = pd . getWriteMethod ( ) ; if ( wm != null && rm != null ) { wm . invoke ( copyInstance , rm . invoke ( src ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return copyInstance ; } \n', 0.39487107591654114)

('public static < T > T copyObject ( final Class < T > clazz , final T sourceObject ) { try { final byte [ ] byteArray = toByteArray ( sourceObject ) ; return fromByteArray ( clazz , byteArray ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can-not-copy-" , e ) ; } } \n', 0.3917783189621187)

('public static Object deepCopy ( Object src ) throws InstantiationException , IllegalAccessException { Class < ? > clazz = src . getClass ( ) ; if ( Modifier . isFinal ( clazz . getModifiers ( ) ) ) { return src ; } Object dst = clazz . newInstance ( ) ; if ( src instanceof Calendar ) { ( ( Calendar ) dst ) . setTimeInMillis ( ( ( Calendar ) src ) . getTimeInMillis ( ) ) ; return dst ; } Field [ ] fields = clazz . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Object fObj = fields [ i ] . get ( src ) ; if ( fObj == null ) { continue ; } Class < ? > fRealType = fObj . getClass ( ) ; if ( ( ! fRealType . isPrimitive ( ) ) || ( ! fRealType . isEnum ( ) ) || fRealType . getPackage ( ) != JAVA_LANG_PKG ) { if ( fRealType . isArray ( ) ) { Object [ ] items = ( Object [ ] ) fObj ; fObj = Array . newInstance ( fRealType . getComponentType ( ) , items . length ) ; for ( int j = 0 ; j < items . length ; j ++ ) { Array . set ( fObj , j , deepCopy ( items [ j ] ) ) ; } } else { fObj = deepCopy ( fObj ) ; } } fields [ i ] . set ( dst , fObj ) ; } return dst ; } \n', 0.3884000434864907)

('public Object copyToNDJavaArray ( ) { Object javaArray ; try { javaArray = java . lang . reflect . Array . newInstance ( getElementType ( ) , getShape ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } IndexIterator iter = getIndexIterator ( ) ; reflectArrayCopyOut ( javaArray , this , iter ) ; return javaArray ; } \n', 0.3871508605741164)

('public static Object copyOf ( Object src ) { int srcLength = Array . getLength ( src ) ; Class < ? > srcComponentType = src . getClass ( ) . getComponentType ( ) ; Object dest = Array . newInstance ( srcComponentType , srcLength ) ; if ( srcComponentType . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( src ) ; i ++ ) { Array . set ( dest , i , copyOf ( Array . get ( src , i ) ) ) ; } } else { System . arraycopy ( src , 0 , dest , 0 , srcLength ) ; } return dest ; } \n', 0.3835520166607283)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('private void setRunTime ( Method method , Object target ) { if ( BaseRunTimer . isActive ( ) ) { long runningTime = System . currentTimeMillis ( ) - startTime ; BaseRunTimer . addTimer ( target . getClass ( ) . getName ( ) + "." + method . getName ( ) + "-run-" + runningTime + "-ms" ) ; } } \n', 0.3471635881988181)

('@ SuppressWarnings ( "unchecked" ) public static < T extends Iface > T recordMethodCallsAndAverageTimes ( final BlurMetrics metrics , final T t , Class < T > clazz ) { InvocationHandler handler = new InvocationHandler ( ) { @ Override public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { long start = System . nanoTime ( ) ; try { return method . invoke ( t , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } finally { long end = System . nanoTime ( ) ; MethodCall methodCall = metrics . methodCalls . get ( method . getName ( ) ) ; if ( methodCall == null ) { methodCall = new MethodCall ( ) ; metrics . methodCalls . put ( method . getName ( ) , methodCall ) ; } methodCall . invokes . incrementAndGet ( ) ; methodCall . times . addAndGet ( end - start ) ; } } } ; return ( T ) Proxy . newProxyInstance ( clazz . getClassLoader ( ) , new Class [ ] { clazz } , handler ) ; } \n', 0.3466681026219154)

('private void doTimedObjectProcessing ( Class ejbClass , EjbDescriptor ejbDesc ) { MethodDescriptor timeoutMethodDesc = null ; Class nextClass = ejbClass ; while ( ( nextClass != Object . class ) && ( nextClass != null ) && ( timeoutMethodDesc == null ) ) { Method [ ] methods = nextClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( ( m . getAnnotation ( Timeout . class ) != null ) ) { timeoutMethodDesc = new MethodDescriptor ( m , MethodDescriptor . TIMER_METHOD ) ; break ; } } nextClass = nextClass . getSuperclass ( ) ; } if ( ( timeoutMethodDesc == null ) && javax . ejb . TimedObject . class . isAssignableFrom ( ejbClass ) ) { timeoutMethodDesc = new MethodDescriptor ( "ejbTimeout" , "@Timeout-method" , new String [ ] { "javax.ejb.Timer" } , MethodDescriptor . TIMER_METHOD ) ; } if ( timeoutMethodDesc != null ) { ejbDesc . setEjbTimeoutMethod ( timeoutMethodDesc ) ; } return ; } \n', 0.3357506067777899)

('public static BenchmarkMethod createBenchmarkMethodFromTimeMethod ( BenchmarkClass benchmarkClass , Method timeMethod ) throws InvalidBenchmarkException { checkArgument ( isTimeMethod ( timeMethod ) ) ; Class < ? > [ ] parameterTypes = timeMethod . getParameterTypes ( ) ; if ( ! Arrays . equals ( parameterTypes , new Class < ? > [ ] { int . class } ) && ! Arrays . equals ( parameterTypes , new Class < ? > [ ] { long . class } ) ) { throw new InvalidBenchmarkException ( "Microbenchmark-methods-must-accept-a-single-int-parameter:-" + timeMethod . getName ( ) ) ; } if ( Util . isStatic ( timeMethod ) ) { throw new InvalidBenchmarkException ( "Microbenchmark-methods-must-not-be-static:-" + timeMethod . getName ( ) ) ; } String methodName = timeMethod . getName ( ) ; String shortName = methodName . substring ( "time" . length ( ) ) ; return new BenchmarkMethod ( benchmarkClass , timeMethod , shortName ) ; } \n', 0.33549803175228066)

('private static void executeViaReflection ( Order orderObject , int itrCount ) throws Exception { Method orderIdMethod = Order . class . getMethod ( functionToCall ) ; long start ; start = System . currentTimeMillis ( ) ; for ( int cnt = 0 ; cnt < itrCount ; cnt ++ ) { orderIdMethod . invoke ( orderObject ) ; } System . out . println ( String . format ( "%s-Function-Call-for-%s-calls-took-%s(ms)" , "Reflection" , itrCount , ( System . currentTimeMillis ( ) - start ) ) ) ; } \n', 0.3250837823649798)

('public long getExecutionTime ( ) { if ( _executeMultiple . get ( ) == false ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('public long getExecutionTime ( ) { if ( ! _executeMultiple . get ( ) ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('protected Date getBuildStartTime ( ) { try { Method getRequestMethod = session . getClass ( ) . getMethod ( "getRequest" ) ; Object mavenExecutionRequest = getRequestMethod . invoke ( session ) ; Method getStartTimeMethod = mavenExecutionRequest . getClass ( ) . getMethod ( "getStartTime" ) ; Date buildStartTime = ( Date ) getStartTimeMethod . invoke ( mavenExecutionRequest ) ; return buildStartTime ; } catch ( Exception e ) { getLog ( ) . debug ( "unable-to-get-start-time-for-the-current-build:-" + e . getMessage ( ) ) ; } return new Date ( ) ; } \n', 0.32364701771858695)

('private static void executeViaMethodHandle ( Order orderObject , int itrCount ) throws Throwable { MethodHandles . Lookup lookup = MethodHandles . lookup ( ) ; MethodHandle m = lookup . findVirtual ( Order . class , functionToCall , MethodType . methodType ( Integer . TYPE ) ) ; long start ; start = System . currentTimeMillis ( ) ; for ( int cnt = 0 ; cnt < itrCount ; cnt ++ ) { m . invoke ( orderObject ) ; } System . out . println ( String . format ( "%s-Function-Call-for-%s-calls-took-%s(ms)" , "JDK-7-Methodhandle" , itrCount , ( System . currentTimeMillis ( ) - start ) ) ) ; } \n', 0.3235504774248598)

('public Object executeTimed ( long timeout ) throws TimeOutException , InterruptedException , Throwable { executeAsync ( ) ; executeThread . join ( timeout ) ; if ( execException == null && ! finished ) { interrupt ( ) ; if ( ! finished ) { execException = new TimeOutException ( "execution-timed-out-(" + timeout + "ms)" ) ; } } if ( execException != null ) { throw execException ; } return retval ; } \n', 0.32027491869860314)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static String readFirstLineFromFile ( File file ) { BufferedReader reader = null ; try { try { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , "UTF-8" ) ) ; } catch ( UnsupportedEncodingException e ) { reader = new BufferedReader ( new FileReader ( file ) ) ; } String text = reader . readLine ( ) ; return text ; } catch ( IOException e ) { throw new PersistenceException ( e ) ; } finally { DBHelper . closeQuietly ( reader ) ; } } \n', 0.4285793071263141)

('public static String [ ] readFileLineByLine ( File file , boolean readComments ) { BufferedReader br = null ; String [ ] ret = null ; if ( file != null && file . exists ( ) ) { try { br = new BufferedReader ( new FileReader ( file ) ) ; String line ; ArrayList < String > linesArray = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { if ( readComments || ( ! line . equals ( "" ) && ! line . startsWith ( "#" ) ) ) { linesArray . add ( line ) ; } } if ( linesArray . size ( ) > 0 ) { ret = linesArray . toArray ( new String [ linesArray . size ( ) ] ) ; } else { ret = new String [ ] { "" } ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "Error-while-reading-from-file-" + file . getPath ( ) + "." , e ) ; ret = null ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , "Error-while-closing-file." , e ) ; ret = null ; } } } } return ret ; } \n', 0.4232999040489562)

('public static String [ ] readFileLineByLine ( File file , boolean readComments , Context context ) { BufferedReader br = null ; String [ ] ret = null ; if ( file != null && file . exists ( ) ) { try { br = new BufferedReader ( new FileReader ( file ) ) ; String line ; ArrayList < String > linesArray = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . equals ( "" ) && ( readComments || ! line . startsWith ( "#" ) ) ) { try { linesArray . add ( line ) ; } catch ( OutOfMemoryError e ) { Toast . makeText ( context , R . string . info_file_to_big , Toast . LENGTH_LONG ) . show ( ) ; return null ; } } } if ( linesArray . size ( ) > 0 ) { ret = linesArray . toArray ( new String [ linesArray . size ( ) ] ) ; } else { ret = new String [ ] { "" } ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "Error-while-reading-from-file-" + file . getPath ( ) + "." , e ) ; ret = null ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , "Error-while-closing-file." , e ) ; ret = null ; } } } } return ret ; } \n', 0.422379033946185)

('public String readTextLine ( String textFile ) { try { FileInputStream input = new FileInputStream ( textFile ) ; InputStreamReader streamReader = new InputStreamReader ( input , "gb2312" ) ; LineNumberReader reader = new LineNumberReader ( streamReader ) ; String line = null ; StringBuilder allLine = new StringBuilder ( ) ; while ( ( line = reader . readLine ( ) ) != null ) { allLine . append ( line ) ; allLine . append ( "-" ) ; } streamReader . close ( ) ; reader . close ( ) ; input . close ( ) ; return allLine . toString ( ) ; } catch ( Exception e ) { return "" ; } } \n', 0.4176964899367194)

('public String readLineOfText ( ) { String lineOfText = null ; try { lineOfText = inFile . readLine ( ) ; } catch ( Exception err ) { try { throw ( err ) ; } catch ( Exception e ) { } } return ( lineOfText ) ; } \n', 0.4169343667775761)

('public static ArrayList < String > readFileLineByLine ( InputStream inputStream ) throws IOException { ArrayList < String > lines = new ArrayList < String > ( ) ; if ( inputStream != null ) { InputStreamReader inputReader = new InputStreamReader ( inputStream ) ; BufferedReader bufferedReader = new BufferedReader ( inputReader ) ; String line ; do { line = bufferedReader . readLine ( ) ; if ( line != null ) { lines . add ( line ) ; } } while ( line != null ) ; inputStream . close ( ) ; } return lines ; } \n', 0.4169053623730436)

('public static String getLineOfTextFromFile ( ) throws IOException { return reader . readLine ( ) ; } \n', 0.4138493485793753)

('public String readLine ( ) throws IOException { if ( reader == null ) { return null ; } String line = reader . readLine ( ) ; if ( line == null ) { try { reader . close ( ) ; fileUsed ++ ; } catch ( IOException e ) { } while ( fileUsed < fileCount && ! fileList [ fileUsed ] . exists ( ) ) { fileUsed ++ ; } if ( fileUsed == fileCount ) { return null ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fileList [ fileUsed ] ) , encoding ) ) ; line = reader . readLine ( ) ; while ( line == null && fileUsed < fileCount ) { fileUsed ++ ; reader . close ( ) ; if ( fileUsed == fileCount ) break ; reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( fileList [ fileUsed ] ) , encoding ) ) ; logger . debug ( "File-" + fileList [ fileUsed ] . getAbsolutePath ( ) + "-opened." ) ; line = reader . readLine ( ) ; } } } return line ; } \n', 0.4135331620180462)

('public static LinkedList < String > readFileToTextLines ( String fileName , Logger log ) { LinkedList < String > result = new LinkedList < String > ( ) ; try { BufferedReader in = new BufferedReader ( new FileReader ( fileName ) ) ; String str ; while ( ( str = in . readLine ( ) ) != null ) { result . add ( str ) ; } in . close ( ) ; } catch ( IOException e ) { return result ; } return result ; } \n', 0.4096670437420744)

('public static String [ ] readFileLineByLine ( File file , boolean readComments , Context context ) { BufferedReader br = null ; String [ ] ret = null ; if ( file != null && isExternalStorageMounted ( ) && file . exists ( ) ) { try { br = new BufferedReader ( new FileReader ( file ) ) ; String line ; ArrayList < String > linesArray = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . equals ( "" ) && ( readComments || ! line . startsWith ( "#" ) ) ) { try { linesArray . add ( line ) ; } catch ( OutOfMemoryError e ) { Toast . makeText ( context , R . string . info_file_to_big , Toast . LENGTH_LONG ) . show ( ) ; return null ; } } } if ( linesArray . size ( ) > 0 ) { ret = linesArray . toArray ( new String [ linesArray . size ( ) ] ) ; } else { ret = new String [ ] { "" } ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "Error-while-reading-from-file-" + file . getPath ( ) + "." , e ) ; ret = null ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , "Error-while-closing-file." , e ) ; ret = null ; } } } } return ret ; } \n', 0.4023176585439362)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('public static List createSortedMethodList ( final Class klass ) { if ( klass == null ) { throw new IllegalArgumentException ( "class-to-sort-method-on-can-not-be-null" ) ; } java . lang . reflect . Method [ ] methods = klass . getMethods ( ) ; java . lang . reflect . Method [ ] privateMethods = klass . getDeclaredMethods ( ) ; List methodList = new ArrayList ( methods . length ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( ReflectHelper . isUserDefinedMethod ( method ) ) { methodList . add ( method ) ; } } for ( int i = 0 ; i < privateMethods . length ; i ++ ) { Method method = privateMethods [ i ] ; if ( ReflectHelper . isUserDefinedMethod ( method ) && ! methodList . contains ( method ) ) { methodList . add ( method ) ; } } Collections . sort ( methodList , MethodComparator . getInstance ( MethodComparator . NORMAL_METHOD ) ) ; return methodList ; } \n', 0.37134815573501023)

('public static List createInterfaceDefinedSortedMethodList ( final ClassInfo klass , final List interfaceDeclaredMethods ) { if ( klass == null ) { throw new IllegalArgumentException ( "class-to-sort-method-on-can-not-be-null" ) ; } List methodList = new ArrayList ( ) ; for ( Iterator iterator = createSortedMethodList ( klass ) . iterator ( ) ; iterator . hasNext ( ) ; ) { MethodInfo methodInfo = ( MethodInfo ) iterator . next ( ) ; if ( isDeclaredByInterface ( methodInfo , interfaceDeclaredMethods ) ) { methodList . add ( methodInfo ) ; } } return methodList ; } \n', 0.36483443496708573)

('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final int initialCapacity ) { return Util . makeArrayList ( initialCapacity ) ; } \n', 0.35593486389732854)

('public List createIntegerListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( BigInteger ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . INTEGER , item ) ) ; } return result ; } \n', 0.3438458900234413)

('public static List createInterfaceDefinedMethodList ( final ClassInfo klass , final List interfaceDeclaredMethods ) { if ( klass == null ) { throw new IllegalArgumentException ( "class-to-sort-method-on-can-not-be-null" ) ; } List methodList = new ArrayList ( ) ; for ( Iterator iterator = createMethodList ( klass ) . iterator ( ) ; iterator . hasNext ( ) ; ) { MethodInfo methodInfo = ( MethodInfo ) iterator . next ( ) ; if ( isDeclaredByInterface ( methodInfo , interfaceDeclaredMethods ) ) { methodList . add ( methodInfo ) ; } } return methodList ; } \n', 0.3438204427273678)

('public static AttributeList makeAttributeListFromKeywordAndValuePairs ( String arg [ ] , int offset , int length ) throws DicomException { createDictionaryifNecessary ( ) ; AttributeList list = new AttributeList ( ) ; while ( length > 0 ) { AttributeTag tag = dictionary . getTagFromName ( arg [ offset ] ) ; if ( tag == null ) { throw new DicomException ( "Keyword-not-in-dictionary-" + arg [ offset ] ) ; } list . replace ( tag , arg [ offset + 1 ] ) ; offset += 2 ; length -= 2 ; } return list ; } \n', 0.3437359627462564)

('public static final List < Plugin > createPluginsList ( final Class < ? extends Plugin > api , final ClassLoader loader ) { List < Plugin > result = new ArrayList < > ( ) ; ServiceLoader < Plugin > impl = PluginManagerCompanion . createServiceLoaderPlugin ( api , loader ) ; for ( Plugin createdImpl : impl ) { if ( createdImpl != null ) result . add ( createdImpl ) ; } return result ; } \n', 0.3376239282924437)

('protected List < Variable < C , PM >> variableDeclarationListCS ( List < VariableCS > variableDeclarationCS , Environment < PK , C , O , P , EL , PM , S , COA , SSA , CT , CLS , E > env , boolean addToEnvironment ) { List < Variable < C , PM >> variableDeclarations = new java . util . ArrayList < Variable < C , PM >> ( ) ; for ( VariableCS next : variableDeclarationCS ) { variableDeclarations . add ( variableDeclarationCS ( next , env , addToEnvironment ) ) ; } return variableDeclarations ; } \n', 0.33669624272095405)

('@ SuppressWarnings ( "unchecked" ) public List < QName > createTypeNameListType_1FromString ( EDataType eDataType , String initialValue ) { return ( List < QName > ) super . createFromString ( initialValue ) ; } \n', 0.3318991032082368)

('@ SuppressWarnings ( "unchecked" ) public List createListQExtendsEChildFromString ( EDataType eDataType , String initialValue ) { return ( List ) super . createFromString ( initialValue ) ; } \n', 0.33071366240287625)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('public static void appendToTextFile ( String fileName , String content ) throws IOException { Files . append ( content , new File ( fileName ) , Charset . defaultCharset ( ) ) ; } \n', 0.42733940959034317)

('public static void appendTextToFile ( String text , String fileLocation ) { try { File file = new File ( fileLocation ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } FileWriter fileWriter = new FileWriter ( file . getName ( ) , true ) ; BufferedWriter bufferWriter = new BufferedWriter ( fileWriter ) ; bufferWriter . write ( text ) ; bufferWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4125650818919089)

('public static void appendTextToHDFS ( Configuration conf , String pathName , String data ) throws IOException { FileSystem fs = FileSystem . get ( conf ) ; BufferedWriter out = new BufferedWriter ( new OutputStreamWriter ( fs . append ( new Path ( pathName ) ) ) ) ; out . write ( data + "-" ) ; out . close ( ) ; } \n', 0.41215032644557226)

('public static void appendTextToFile ( File file , String text ) throws IOException { PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( file , true ) , "UTF-8" ) ) ; pw . println ( text ) ; pw . close ( ) ; } \n', 0.4096557522749736)

('public static void appendLineToTextFile ( File file , String line ) throws IOException { boolean newLine = true ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; newLine = false ; } FileWriter fw = new FileWriter ( file . getAbsoluteFile ( ) , true ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; if ( newLine ) { bw . newLine ( ) ; } bw . write ( line ) ; bw . close ( ) ; } \n', 0.40936800345365626)

('public static final void appendTextToFile ( String file , String text ) { try { PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( file , true ) ) ) ; out . print ( text ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.4087415830487894)

('public static void AppendTextToFile ( String filePath , String text ) throws Exception { PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( filePath , true ) ) ) ; out . write ( text ) ; out . close ( ) ; } \n', 0.4060239352322367)

('public static String appendToText ( String textToAppend ) { File txtfile = new File ( "c:/Users/User/Desktop/Codes/RSSReaderStorage/testfile.txt" ) ; String data = textToAppend ; try { if ( ! txtfile . exists ( ) ) { txtfile . createNewFile ( ) ; } FileWriter fileAppender = new FileWriter ( txtfile , true ) ; BufferedWriter bufferedAppend = new BufferedWriter ( fileAppender ) ; bufferedAppend . write ( data + "-" ) ; bufferedAppend . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return "Text-Appended" ; } \n', 0.40452438923951317)

('public static void appendToTextFile ( final String fileName , final String text ) throws IOException { FileWriter writer = null ; try { writer = new FileWriter ( fileName , true ) ; writer . append ( text ) ; writer . flush ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } \n', 0.4009150872516225)

('public void appendText ( String filePath , String text , boolean encrypt ) { try { File file = new File ( filePath ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } BufferedWriter buf = new BufferedWriter ( new FileWriter ( file , true ) ) ; buf . append ( text ) ; buf . newLine ( ) ; buf . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.3980912233025665)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('private Date isoStringToDate ( String target ) throws ParseException { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss" ) ; formatter . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return formatter . parse ( target ) ; } \n', 0.44250340696245494)

('public static String dateToISODateString ( java . util . Date date , String pattern ) { String ret = "" ; if ( date != null ) { try { ret = new java . text . SimpleDateFormat ( pattern ) . format ( date ) ; } catch ( Exception e ) { } } return ret ; } \n', 0.4357837579527804)

('static Date toIsoDateOrNull ( String s ) throws ParseException { if ( s == null ) return null ; return ISO_TIMESTAMP_FORMAT . parse ( s ) ; } \n', 0.43555092857521654)

('public static Date convertStringToDate ( String dateString , String currentFormat ) throws ParseException { SimpleDateFormat dateFormat = new SimpleDateFormat ( currentFormat , Locale . getDefault ( ) ) ; return dateFormat . parse ( dateString ) ; } \n', 0.4347953475700476)

('static public Date convertISOStringToDate ( String isoDateString ) throws java . text . ParseException { DateTime isoDateTime = DateTime . parse ( isoDateString ) ; return isoDateTime . toDate ( ) ; } \n', 0.43398906574851803)

('public static String dateToUtcIsoString ( Date date ) { timeAndDateIsoFormatter . setTimeZone ( TIMEZONE_UTC ) ; return timeAndDateIsoFormatter . format ( date ) ; } \n', 0.43337174793835476)

('private String ISOStringToString ( String iso ) { if ( ! iso . equals ( "null" ) ) { DateTimeFormatter parser = ISODateTimeFormat . dateTimeNoMillis ( ) ; DateTime dt = parser . parseDateTime ( iso ) ; DateTimeFormatter formatter = DateTimeFormat . shortDateTime ( ) ; return formatter . print ( dt ) ; } return "null" ; } \n', 0.43304699260911217)

('@ NotNull public static String dateToIsoDateString ( @ Nullable Date date , @ NotNull DateFallback fallback ) throws IllegalArgumentException { if ( date != null ) { return new SimpleDateFormat ( "yyyy-MM-dd-HH:mm" ) . format ( date ) ; } else if ( fallback == DateFallback . EARLIEST ) { return getEarliestDateString ( ) ; } throw new IllegalArgumentException ( "date-is-null-and-fallback-parameter-is-invalid!" ) ; } \n', 0.4321622421507477)

('public static Date convertBirthdayStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( birthdayFormat ) ; try { DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.431824168089213)

('public final Date convertStringToGregorianDate ( final String dateString , final String format ) throws ParseException { DateFormat formatter ; formatter = new SimpleDateFormat ( format ) ; return ( Date ) formatter . parse ( dateString ) ; } \n', 0.43076190052265045)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('public Collection < IProductTypeQuickListFilterFactory > getProductQuickListFilterFactories ( ) throws EPProcessorException { checkProcessing ( ) ; List < IProductTypeQuickListFilterFactory > result = new ArrayList < IProductTypeQuickListFilterFactory > ( factories . values ( ) ) ; Collections . sort ( result , new Comparator < IProductTypeQuickListFilterFactory > ( ) { public int compare ( IProductTypeQuickListFilterFactory o1 , IProductTypeQuickListFilterFactory o2 ) { return Integer . valueOf ( o1 . getIndex ( ) ) . compareTo ( o2 . getIndex ( ) ) ; } } ) ; return result ; } \n', 0.3296734211890714)

('@ SuppressWarnings ( "unchecked" ) protected Set < Class < ? >> filterAndSelect ( Set < ? > subTypes , Class < ? > type , FilterType ... filters ) { Set < Class < ? >> selectedSubTypes = new HashSet < Class < ? >> ( ) ; String typePkg = type . getPackage ( ) . getName ( ) ; for ( Iterator < ? > it = subTypes . iterator ( ) ; it . hasNext ( ) ; ) { Class < ? > subType = ( Class < ? > ) it . next ( ) ; int modifiers = subType . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) ) { if ( areClosePkgs ( subType . getPackage ( ) . getName ( ) , typePkg ) ) { selectedSubTypes . add ( subType ) ; it . remove ( ) ; } } else { it . remove ( ) ; } } if ( CollectionUtils . existIn ( FilterType . CLOSED_SUBTYPES , filters ) ) { boolean noCloseSubTypes = selectedSubTypes . isEmpty ( ) ; for ( Iterator < ? > it = subTypes . iterator ( ) ; it . hasNext ( ) ; ) { Class < ? > subType = ( Class < ? > ) it . next ( ) ; if ( noCloseSubTypes || Randomness . weighedCoinFlip ( GentestConstants . PROBABILITY_OF_UNCLOSED_SUBTYPES ) ) { selectedSubTypes . add ( subType ) ; } } } else { selectedSubTypes . addAll ( ( Collection < ? extends Class < ? >> ) subTypes ) ; } return selectedSubTypes ; } \n', 0.32850498356247)

('public Collection < Trade > getFilteredTradeBySymbol ( final String stockSymbol , final int pastMinutes ) { Predicate < Trade > datePredicate = new Predicate < Trade > ( ) { public boolean apply ( Trade trade ) { Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . MINUTE , - pastMinutes ) ; if ( pastMinutes == 0 ) return true ; return trade . getTimestamp ( ) . after ( cal . getTime ( ) ) || trade . getTimestamp ( ) . equals ( cal . getTime ( ) ) ; } } ; Collection < Trade > p = trades . get ( stockSymbol ) ; return Collections2 . filter ( trades . get ( stockSymbol ) , datePredicate ) ; } \n', 0.3254317149712832)

('public static DependencyFilter classpathFilter ( Collection < String > classpathTypes ) { Collection < String > types = new HashSet < String > ( ) ; if ( classpathTypes != null ) { for ( String classpathType : classpathTypes ) { String [ ] tokens = classpathType . split ( "[+,]" ) ; for ( String token : tokens ) { token = token . trim ( ) ; if ( token . length ( ) > 0 ) { types . add ( token ) ; } } } } Collection < String > included = new HashSet < String > ( ) ; for ( String type : types ) { if ( JavaScopes . COMPILE . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM ) ; } else if ( JavaScopes . RUNTIME . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . RUNTIME ) ; } else if ( JavaScopes . TEST . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM , JavaScopes . RUNTIME , JavaScopes . TEST ) ; } else { included . add ( type ) ; } } Collection < String > excluded = new HashSet < String > ( ) ; Collections . addAll ( excluded , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM , JavaScopes . RUNTIME , JavaScopes . TEST ) ; excluded . removeAll ( included ) ; return new ScopeDependencyFilter ( null , excluded ) ; } \n', 0.32432553094411315)

('public List < Query > filterQueries ( Predicate < Query > predicate ) { return getQueries ( ) . stream ( ) . filter ( predicate ) . collect ( Collectors . < Query > toList ( ) ) ; } \n', 0.314775612235793)

('@ Override public List < CountryBean > filterCountryTableInDatabase ( String filterPrefix ) { if ( "" . equals ( filterPrefix ) || filterPrefix == null ) { return Collections . emptyList ( ) ; } List < CountryBean > result = new ArrayList < CountryBean > ( ) ; for ( CountryBean country : countryDatabaseTable ) { if ( country . getName ( ) . toLowerCase ( ) . startsWith ( filterPrefix ) ) { result . add ( country ) ; } } return result ; } \n', 0.31420604797794316)

('private static List < Account > getAccountList ( final Set < AccountType > types ) { final Engine engine = EngineFactory . getEngine ( EngineFactory . DEFAULT ) ; Objects . requireNonNull ( engine ) ; Set < Account > accountSet = engine . getAccountList ( ) . stream ( ) . filter ( a -> types . contains ( a . getAccountType ( ) ) ) . collect ( Collectors . toCollection ( TreeSet :: new ) ) ; return new ArrayList < > ( accountSet ) ; } \n', 0.31408596281977885)

('protected final void filterSortCopyAndUnwrap ( final LeafNode < T > node , final Predicate < RoutingTableEntry < T >> appliedFilter ) { final SortedSet < RoutingTableEntry < T >> sortedAndFiltered = new TreeSet < RoutingTableEntry < T >> ( sortComp ) ; if ( appliedFilter == null ) { sortedAndFiltered . addAll ( node . kBucket . values ( ) ) ; } else { CollectionHelpers . filter ( node . kBucket . values ( ) , sortedAndFiltered , appliedFilter ) ; } Iterator < RoutingTableEntry < T >> it = sortedAndFiltered . iterator ( ) ; while ( it . hasNext ( ) && result . size ( ) < numOfResults ) { result . add ( it . next ( ) . getContact ( ) ) ; } } \n', 0.31386976075988127)

('@ SafeVarargs public static < T > Collection < T > filter ( Collection < T > values , Supplier < Collection < T >> supplier , Predicate < T > ... predicates ) { Objects . requireNonNull ( values ) ; Objects . requireNonNull ( supplier ) ; Objects . requireNonNull ( predicates ) ; return values . stream ( ) . filter ( Stream . of ( predicates ) . reduce ( ( a , b ) -> a . and ( b ) ) . get ( ) ) . collect ( Collectors . toCollection ( supplier ) ) ; } \n', 0.3133358311715225)

('private Object [ ] searchR5Repository ( Repository osgiRepo ) { Object [ ] result ; Set < RepositoryResourceElement > resultSet = new LinkedHashSet < RepositoryResourceElement > ( ) ; Map < Requirement , Collection < Capability >> providers = osgiRepo . findProviders ( Collections . singleton ( requirementFilter ) ) ; for ( Entry < Requirement , Collection < Capability >> providersEntry : providers . entrySet ( ) ) { for ( Capability providerCap : providersEntry . getValue ( ) ) resultSet . add ( new RepositoryResourceElement ( providerCap . getResource ( ) ) ) ; } result = resultSet . toArray ( new Object [ resultSet . size ( ) ] ) ; return result ; } \n', 0.31290886512021177)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public static String trimSpacesBeginEnd ( String input , String charsToBeRemoved ) { String output = new String ( ) ; int begin = 0 ; int end = input . length ( ) - 1 ; boolean charFound = false ; boolean ok = true ; for ( int index = begin ; ( index < input . length ( ) ) && ok ; index ++ ) { charFound = false ; for ( int charsCount = 0 ; charsCount < charsToBeRemoved . length ( ) ; charsCount ++ ) if ( charsToBeRemoved . charAt ( charsCount ) == input . charAt ( index ) ) charFound = true ; if ( ! ( ( Character . isWhitespace ( input . charAt ( index ) ) ) || ( Character . isSpaceChar ( input . charAt ( index ) ) ) || ( charFound ) ) ) { begin = index ; ok = false ; } } ok = true ; for ( int index = end ; ( index >= 0 ) && ok ; index -- ) { charFound = false ; for ( int charsCount = 0 ; charsCount < charsToBeRemoved . length ( ) ; charsCount ++ ) if ( charsToBeRemoved . charAt ( charsCount ) == input . charAt ( index ) ) charFound = true ; if ( ! ( ( Character . isWhitespace ( input . charAt ( index ) ) ) || ( Character . isSpaceChar ( input . charAt ( index ) ) ) || ( charFound ) ) ) { end = index ; ok = false ; } } output = input . substring ( begin , end + 1 ) ; return output ; } \n', 0.4012172056508654)

('public static String trimTrailingWhitespace ( String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuffer buf = new StringBuffer ( str ) ; while ( buf . length ( ) > 0 && Character . isWhitespace ( buf . charAt ( buf . length ( ) - 1 ) ) ) { buf . deleteCharAt ( buf . length ( ) - 1 ) ; } return buf . toString ( ) ; } \n', 0.3980098746812118)

('public static String trimTrailingWhitespace ( final String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > 0 && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } \n', 0.39578649988206144)

('public static String trimTrailingWhitespace ( String str ) { if ( ! StringUtils . hasLength ( str ) ) { return str ; } final StringBuilder sb = new StringBuilder ( str ) ; while ( ( sb . length ( ) > 0 ) && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } \n', 0.39573597334260247)

('protected String removeWhitespace ( String s ) { if ( this . disableWhitespaceTrimming ) { return s ; } s = s . replace ( \'|r\' , \'-\' ) ; s = s . replace ( \'|n\' , \'-\' ) ; s = s . replace ( \'|t\' , \'-\' ) ; boolean repeatedSpacesExist = true ; while ( repeatedSpacesExist ) { int loc = s . indexOf ( "-" ) ; if ( loc < 0 ) { repeatedSpacesExist = false ; } else { StringBuilder buf = new StringBuilder ( ) ; buf . append ( s . substring ( 0 , loc ) ) ; buf . append ( "-" ) ; buf . append ( s . substring ( loc + 2 ) ) ; s = buf . toString ( ) ; } } return s . trim ( ) ; } \n', 0.38828797642055374)

('protected void popShouldStripWhitespace ( ) { if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWS = m_shouldStripWhitespaceStack . popAndTop ( ) ; } \n', 0.3867258015952437)

('public static String trimWhitespace ( String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuffer buf = new StringBuffer ( str ) ; while ( buf . length ( ) > 0 && Character . isWhitespace ( buf . charAt ( 0 ) ) ) { buf . deleteCharAt ( 0 ) ; } while ( buf . length ( ) > 0 && Character . isWhitespace ( buf . charAt ( buf . length ( ) - 1 ) ) ) { buf . deleteCharAt ( buf . length ( ) - 1 ) ; } return buf . toString ( ) ; } \n', 0.38392768975717223)

('public static String trimAllWhitespace ( String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuffer buf = new StringBuffer ( str ) ; int index = 0 ; while ( buf . length ( ) > index ) { if ( Character . isWhitespace ( buf . charAt ( index ) ) ) { buf . deleteCharAt ( index ) ; } else { index ++ ; } } return buf . toString ( ) ; } \n', 0.38162196212594446)

('public static String trimWhitespace ( final String str ) { if ( ! hasLength ( str ) ) { return str ; } StringBuilder sb = new StringBuilder ( str ) ; while ( sb . length ( ) > 0 && Character . isWhitespace ( sb . charAt ( 0 ) ) ) { sb . deleteCharAt ( 0 ) ; } while ( sb . length ( ) > 0 && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } \n', 0.37866642143426205)

('public static String trimWhitespace ( String str ) { if ( ! StringUtils . hasLength ( str ) ) { return str ; } final StringBuilder sb = new StringBuilder ( str ) ; while ( ( sb . length ( ) > 0 ) && Character . isWhitespace ( sb . charAt ( 0 ) ) ) { sb . deleteCharAt ( 0 ) ; } while ( ( sb . length ( ) > 0 ) && Character . isWhitespace ( sb . charAt ( sb . length ( ) - 1 ) ) ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; } \n', 0.37861450684893955)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('public static String [ ] splitStringUsingEmptySpaceCharacter ( String str ) { String [ ] splitted = null ; splitted = str . split ( "|s+" ) ; return splitted ; } \n', 0.4269523442786253)

("public static int splitWhitespace ( String aString , String [ ] tokens ) { int maxTokens = tokens . length ; int nTokens = 0 ; int start = 0 ; int tabEnd = aString . indexOf ( '|t' ) ; int spaceEnd = aString . indexOf ( '-' ) ; int end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; while ( ( end > 0 ) && ( nTokens < maxTokens ) ) { tokens [ nTokens ++ ] = aString . substring ( start , end ) ; start = end + 1 ; while ( start < aString . length ( ) && aString . charAt ( start ) == '-' ) { start ++ ; } tabEnd = aString . indexOf ( '|t' , start ) ; spaceEnd = aString . indexOf ( '-' , start ) ; end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; } if ( nTokens < maxTokens ) { String trailingString = aString . substring ( start ) ; tokens [ nTokens ++ ] = trailingString ; } return nTokens ; } \n", 0.40697705084442326)

('@ Override public Spliterator < Character > trySplit ( ) { int currentSize = string . length ( ) - currentChar ; if ( currentSize < 10 ) { return null ; } for ( int splitPos = currentSize / 2 + currentChar ; splitPos < string . length ( ) ; splitPos ++ ) { if ( Character . isWhitespace ( string . charAt ( splitPos ) ) ) { Spliterator < Character > spliterator = new WordCounterSpliterator ( string . substring ( currentChar , splitPos ) ) ; currentChar = splitPos ; return spliterator ; } } return null ; } \n', 0.37073499463714266)

('public static List < String > split ( final String value , final boolean removeEmptyEntries , final char [ ] delimiters ) { VerifyArgument . notNull ( value , "value" ) ; VerifyArgument . notNull ( delimiters , "delimiters" ) ; final int end = value . length ( ) ; final ArrayList < String > parts = new ArrayList < > ( ) ; if ( end == 0 ) { return parts ; } int start = 0 ; int i = start ; while ( i < end ) { final char ch = value . charAt ( i ) ; if ( contains ( delimiters , ch ) ) { if ( i != start || ! removeEmptyEntries ) { parts . add ( value . substring ( start , i ) ) ; } start = i + 1 ; } ++ i ; } if ( start < end ) { parts . add ( value . substring ( start , end ) ) ; } return parts ; } \n', 0.3666690351684972)

('public static List < String > splitQuotedStr ( String str , char delimiter , char quote , boolean trim ) { int startPos = 0 ; boolean insideQuotation = false ; List < String > result = new ArrayList < String > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( c == quote ) { insideQuotation = ! insideQuotation ; } if ( ! insideQuotation && c == delimiter ) { String subStr = str . substring ( startPos , i ) ; if ( trim ) { subStr = subStr . trim ( ) ; } result . add ( subStr ) ; startPos = i + 1 ; continue ; } } if ( startPos < str . length ( ) ) { String subStr = str . substring ( startPos , str . length ( ) ) ; if ( trim ) { subStr = subStr . trim ( ) ; } result . add ( subStr ) ; } return result ; } \n', 0.3647440224756153)

('public static List < String > splitInWhiteSpaces ( String string ) { ArrayList < String > ret = new ArrayList < String > ( ) ; int len = string . length ( ) ; int last = 0 ; char c = 0 ; for ( int i = 0 ; i < len ; i ++ ) { c = string . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( last != i ) { ret . add ( string . substring ( last , i ) ) ; } while ( Character . isWhitespace ( c ) && i < len - 1 ) { i ++ ; c = string . charAt ( i ) ; } last = i ; } } if ( ! Character . isWhitespace ( c ) ) { if ( last == 0 && len > 0 ) { ret . add ( string ) ; } else if ( last < len ) { ret . add ( string . substring ( last , len ) ) ; } } return ret ; } \n', 0.36292922305216324)

('public static final LinkedList splitWordsL ( String s , boolean splitOnWs , char [ ] delimiters ) { if ( s == null ) return null ; int cstart = - 1 , len = s . length ( ) ; LinkedList l = new LinkedList ( ) ; for ( int pos = 0 ; pos < len ; pos ++ ) { char ch = s . charAt ( pos ) ; if ( cstart < 0 ) { if ( splitOnWs && ( ch == 0x0a || Character . isSpaceChar ( ch ) ) ) continue ; if ( delimiters != null && Arrays . binarySearch ( delimiters , ch ) > - 1 ) continue ; cstart = pos ; } else { boolean endOfWord = false ; if ( splitOnWs && ( ( ch == 0x0a || Character . isSpaceChar ( ch ) ) ) ) { endOfWord = true ; } if ( delimiters != null && Arrays . binarySearch ( delimiters , ch ) > - 1 ) { endOfWord = true ; } if ( ! endOfWord ) { continue ; } l . add ( s . substring ( cstart , pos ) ) ; cstart = - 1 ; } } if ( cstart >= 0 ) l . add ( s . substring ( cstart ) ) ; return l ; } \n', 0.36207339767489155)

('private static List < String > splitHandleQuotes ( String s ) { ArrayList < String > results = new ArrayList < String > ( ) ; char delimiter = \',\' ; char quoteChar = \'"\' ; char escapeChar = \'|\' ; StringBuffer current = new StringBuffer ( "" ) ; boolean inQuotation = false ; boolean escaping = false ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( escaping ) { if ( s . charAt ( i ) == quoteChar ) current . append ( quoteChar ) ; else { current . append ( escapeChar ) ; current . append ( quoteChar ) ; } escaping = false ; } else { if ( s . charAt ( i ) == quoteChar ) { inQuotation = ! inQuotation ; } else if ( s . charAt ( i ) == escapeChar ) { escaping = true ; } else if ( ! inQuotation ) if ( s . charAt ( i ) == delimiter ) { results . add ( new String ( current ) ) ; current = new StringBuffer ( "" ) ; } else current . append ( s . charAt ( i ) ) ; else current . append ( s . charAt ( i ) ) ; } } results . add ( new String ( current ) ) ; return results ; } \n', 0.3603277766600089)

('String [ ] split ( String str , int size ) { int numStr = str . length ( ) / size ; String splitStr [ ] = new String [ numStr ] ; char chars [ ] = str . toCharArray ( ) ; for ( int i = 0 , h = 0 ; ( i < chars . length ) && ( h < splitStr . length ) ; h ++ ) { String newStr = "" ; for ( int j = 0 ; ( j < size ) && ( i < chars . length ) ; j ++ , i ++ ) newStr += chars [ i ] ; splitStr [ h ] = newStr ; } return splitStr ; } \n', 0.3597557987392418)

('public static String splitMultilinedString ( String string , int maxLineLength , String lineSeparator ) { char [ ] chars = string . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; char spaceChar = "-" . charAt ( 0 ) ; int count = 0 ; for ( char character : chars ) { if ( count >= maxLineLength && character == spaceChar ) { sb . append ( lineSeparator ) ; count = 0 ; } else { count ++ ; sb . append ( character ) ; } } return sb . toString ( ) ; } \n', 0.3595446292711838)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('private Size determineBestSize ( List < Size > sizes , int widthThreshold ) { Size bestSize = null ; Size size ; int numOfSizes = sizes . size ( ) ; for ( int i = 0 ; i < numOfSizes ; i ++ ) { size = sizes . get ( i ) ; boolean isDesireRatio = ( size . width / 4 ) == ( size . height / 3 ) ; boolean isBetterSize = ( bestSize == null ) || size . width > bestSize . width ; if ( isDesireRatio && isBetterSize ) { bestSize = size ; } } if ( bestSize == null ) { Log . d ( TAG , "cannot-find-the-best-camera-size" ) ; return sizes . get ( sizes . size ( ) - 1 ) ; } return bestSize ; } \n', 0.35958412336394674)

('protected NonUniqueResult determineKmerSizeAndNonUniques ( final int minKmerSize , final int maxKmerSize ) { final Collection < SequenceForKmers > withNonUniques = getAllPendingSequences ( ) ; final Set < Kmer > nonUniqueKmers = new HashSet < > ( ) ; int kmerSize = minKmerSize ; for ( ; kmerSize <= maxKmerSize ; kmerSize ++ ) { nonUniqueKmers . clear ( ) ; final Iterator < SequenceForKmers > it = withNonUniques . iterator ( ) ; while ( it . hasNext ( ) ) { final SequenceForKmers sequenceForKmers = it . next ( ) ; final Collection < Kmer > nonUniquesFromSeq = determineNonUniqueKmers ( sequenceForKmers , kmerSize ) ; if ( nonUniquesFromSeq . isEmpty ( ) ) { it . remove ( ) ; } else { nonUniqueKmers . addAll ( nonUniquesFromSeq ) ; } } if ( nonUniqueKmers . isEmpty ( ) ) break ; } return new NonUniqueResult ( nonUniqueKmers , Math . min ( kmerSize , maxKmerSize ) ) ; } \n', 0.29895424311235747)

('private NonUniqueResult determineKmerSizeAndNonUniques ( final int minKmerSize , final int maxKmerSize ) { final Collection < SequenceForKmers > withNonUniques = getAllPendingSequences ( ) ; final Set < Kmer > nonUniqueKmers = new HashSet < > ( ) ; for ( int kmerSize = minKmerSize ; kmerSize <= maxKmerSize ; kmerSize ++ ) { nonUniqueKmers . clear ( ) ; final Iterator < SequenceForKmers > it = withNonUniques . iterator ( ) ; while ( it . hasNext ( ) ) { final SequenceForKmers sequenceForKmers = it . next ( ) ; final Collection < Kmer > nonUniquesFromSeq = determineNonUniqueKmers ( sequenceForKmers , kmerSize ) ; if ( nonUniquesFromSeq . isEmpty ( ) ) { it . remove ( ) ; } else { nonUniqueKmers . addAll ( nonUniquesFromSeq ) ; } } if ( nonUniqueKmers . isEmpty ( ) ) { break ; } } return new NonUniqueResult ( nonUniqueKmers ) ; } \n', 0.29505801715627056)

('private static Map < String , Integer > determineAttributeSizes ( Bag geometries ) { Map < String , Integer > attributeSizes = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < geometries . size ( ) ; i ++ ) { MasonGeometry mg = ( MasonGeometry ) geometries . objs [ i ] ; for ( String attributeName : mg . getAttributes ( ) . keySet ( ) ) { Integer attributeSize = null ; try { AttributeValue av = ( AttributeValue ) mg . getAttribute ( attributeName ) ; if ( av . getValue ( ) instanceof Boolean ) { attributeSize = 1 ; } else { Object value = av . getValue ( ) ; String stringValue = value . toString ( ) ; byte [ ] rawValue = stringValue . getBytes ( "US-ASCII" ) ; if ( value instanceof String ) { attributeSize = Math . min ( rawValue . length , 256 ) ; } else if ( value instanceof Double ) { attributeSize = 19 ; } else { attributeSize = Math . min ( rawValue . length , 18 ) ; } } } catch ( UnsupportedEncodingException ex ) { Logger . getLogger ( ShapeFileExporter . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } if ( attributeSizes . containsKey ( attributeName ) ) { Integer storedSize = attributeSizes . get ( attributeName ) ; if ( storedSize < attributeSize ) { attributeSizes . put ( attributeName , attributeSize ) ; } } else { attributeSizes . put ( attributeName , attributeSize ) ; } } } return attributeSizes ; } \n', 0.2767898097895939)

('private int determineNumberOfSuccessorAtDeepestLevel ( int i , Concept currXBRLElement , String extendedLinkRole ) { List < ExtendedLinkElement > currXLinkElement = getTargetExtendedLinkElements ( currXBRLElement , extendedLinkRole ) ; if ( currXLinkElement . size ( ) == 0 ) { i ++ ; } else { Iterator < ExtendedLinkElement > currXLinkElementIterator = currXLinkElement . iterator ( ) ; while ( currXLinkElementIterator . hasNext ( ) ) { ExtendedLinkElement xLinkElementChild = ( ExtendedLinkElement ) currXLinkElementIterator . next ( ) ; if ( xLinkElementChild . isLocator ( ) ) { i = determineNumberOfSuccessorAtDeepestLevel ( i , ( ( Locator ) xLinkElementChild ) . getConcept ( ) , extendedLinkRole ) ; } } } return i ; } \n', 0.2629277126589905)

('public static final double [ ] determineObservationWeights ( String dataset , Map < String , Double > classWeights ) { List < String > observationClasses = determineObservationClasses ( dataset ) ; int numberOfObservations = observationClasses . size ( ) ; double [ ] weights = new double [ numberOfObservations ] ; for ( int i = 0 ; i < numberOfObservations ; i ++ ) { String classOfObs = observationClasses . get ( i ) ; weights [ i ] = classWeights . get ( classOfObs ) ; } return weights ; } \n', 0.24721169035689444)

('public void determineEveryIndividualFitness ( ) { try { executor . invokeAll ( actualizeGroupsOfIndividuals ( ) ) ; } catch ( InterruptedException ex ) { Logger . getLogger ( Population . class . getName ( ) ) . log ( Level . SEVERE , null , ex ) ; } } \n', 0.23481881539628582)

('public boolean determineValidMembershipToCreate ( MessageContext messageContext ) { if ( memberships . get ( current ) == null && indivsOfSocialGroup . size ( ) == 1 ) return true ; if ( memberships . size ( ) > 0 ) { if ( indivsOfSocialGroup . size ( ) == 1 || memberships . get ( current ) . size ( ) >= indivsOfSocialGroup . size ( ) - 1 ) { webFlowService . createMessage ( messageContext , "A-new-Membership-cannot-be-created-if-the-successor-is-the-only-member-of-the-Social-Group-or-if-all-members-within-the-Social-Group-have-been-assigned-new-relations-to-the-Group-Head." ) ; return false ; } } return true ; } \n', 0.2336993298003781)

('public static Multiset < Integer > scanDatabaseToDetermineFrequencyOfSingleItems ( final File inputFile ) throws IOException { final Multiset < Integer > singletons = HashMultiset . create ( ) ; final LineIterator it = FileUtils . lineIterator ( inputFile , "UTF-8" ) ; while ( it . hasNext ( ) ) { final String line = it . nextLine ( ) ; if ( line . isEmpty ( ) == true || line . charAt ( 0 ) == \'#\' || line . charAt ( 0 ) == \'%\' || line . charAt ( 0 ) == \'@\' ) { continue ; } final String [ ] lineSplit = line . split ( "-" ) ; for ( final String itemString : lineSplit ) { singletons . add ( Integer . parseInt ( itemString ) ) ; } } LineIterator . closeQuietly ( it ) ; return singletons ; } \n', 0.2281919196661602)

('private static void doDetermineShape ( final List < Integer > shape , final Object data ) { if ( data instanceof List ) { final List < ? > list = ( List < ? > ) data ; final int length = list . size ( ) ; shape . add ( length ) ; if ( length > 0 ) { final Object element = list . get ( 0 ) ; if ( element != null && element instanceof List ) doDetermineShape ( shape , element ) ; } } else if ( data . getClass ( ) . isArray ( ) ) { final int length = Array . getLength ( data ) ; shape . add ( length ) ; if ( length > 0 ) { final Object element = Array . get ( data , 0 ) ; if ( element != null && element . getClass ( ) . isArray ( ) ) doDetermineShape ( shape , element ) ; } } else throw new IllegalArgumentException ( "Expect-array,-got-" + data . getClass ( ) . getName ( ) ) ; } \n', 0.22660443406942554)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('public Object invokeMethodByName ( String methodName , Object ... args ) { Class < ? extends ResourceManager > thisClass = this . getClass ( ) ; Method [ ] methods = thisClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( m . getName ( ) . equals ( methodName ) ) { try { return ( Object ) m . invoke ( this , args ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { Trace . error ( e . getMessage ( ) ) ; } } } return null ; } \n', 0.3422176104928403)

('public static Object invokeMethodByName ( Object o , String methodName , Object ... args ) throws MethodNotFoundException { assert o != null ; assert methodName != null ; for ( Method m : o . getClass ( ) . getMethods ( ) ) { if ( methodName . equals ( m . getName ( ) ) ) { try { return m . invoke ( o , args ) ; } catch ( IllegalArgumentException e ) { assertMethodArgs ( m , args ) ; throw e ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } } throw new MethodNotFoundException ( String . format ( "Method-%s-not-found-in-class-%s" , methodName , o . getClass ( ) ) ) ; } \n', 0.3404126629350881)

('private static Object invokeByName ( Object o , String methodName , boolean setAccessibilityIfNeeded , Object ... args ) throws IllegalArgumentException , RuntimeException , MethodNotFoundException { assert o != null ; assert methodName != null ; Method [ ] methods = setAccessibilityIfNeeded ? o . getClass ( ) . getDeclaredMethods ( ) : o . getClass ( ) . getMethods ( ) ; for ( Method m : methods ) { if ( methodName . equals ( m . getName ( ) ) ) { try { if ( setAccessibilityIfNeeded ) { m . setAccessible ( true ) ; } return m . invoke ( o , args ) ; } catch ( IllegalArgumentException e ) { assertMethodArgs ( m , args ) ; throw e ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new WrapperException ( e . getCause ( ) ) ; } } } throw new MethodNotFoundException ( String . format ( "Method-%s-not-found-in-class-%s" , methodName , o . getClass ( ) . getName ( ) ) ) ; } \n', 0.317071891356824)

('public ObjectName makeObjectName ( Object source , String type ) throws MalformedObjectNameException , InvocationTargetException , IllegalAccessException { Hashtable < String , String > props = new Hashtable < String , String > ( ) ; ArrayList < Method > keyMethods = general . getKeyColumnGetters ( ) ; ArrayList < String > keyNames = general . getKeyColumnNames ( ) ; Object [ ] args = new Object [ 0 ] ; for ( int i = 0 ; i < keyMethods . size ( ) ; ++ i ) { Method m = keyMethods . get ( i ) ; String value = ( String ) m . invoke ( source , args ) ; props . put ( keyNames . get ( i ) , value ) ; } props . put ( "type" , type ) ; return new ObjectName ( domainName , props ) ; } \n', 0.31679197977960116)

('public static < T > T invokeMethodWithString ( T object , Map < String , String > properties ) { Class < ? > clazz = object . getClass ( ) ; for ( Entry < String , String > entry : properties . entrySet ( ) ) { try { Method method = clazz . getDeclaredMethod ( entry . getKey ( ) , String . class ) ; method . invoke ( object , entry . getValue ( ) ) ; } catch ( Exception e ) { log . error ( "Error-invoking-method-named-" + entry . getKey ( ) + "-with-value-" + entry . getValue ( ) , e ) ; return null ; } } return object ; } \n', 0.3031221563901568)

('public String invokePrivateMethods ( Object object ) { if ( object == null ) { return "" ; } StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Method method : object . getClass ( ) . getDeclaredMethods ( ) ) { if ( Modifier . isPrivate ( method . getModifiers ( ) ) ) { stringBuilder . append ( "invoke:" ) . append ( method . getName ( ) ) ; method . setAccessible ( true ) ; try { method . invoke ( object ) ; stringBuilder . append ( "---OK-" ) ; } catch ( ReflectiveOperationException e ) { stringBuilder . append ( "---Reflective-Exception-" ) ; LOGGER . log ( Level . SEVERE , "Unable-to-invoke-method-whit-reflection" , e ) ; } } } return stringBuilder . toString ( ) . trim ( ) ; } \n', 0.2966356924091025)

('public static Object invokeMethodWithString ( Object object , Map < String , String > properties ) { Class < ? extends Object > clazz = object . getClass ( ) ; for ( Entry < String , String > entry : properties . entrySet ( ) ) { try { Method method = clazz . getDeclaredMethod ( entry . getKey ( ) , String . class ) ; method . invoke ( object , entry . getValue ( ) ) ; } catch ( Exception e ) { log . error ( "Error-invoking-method-named-" + entry . getKey ( ) + "-with-value-" + entry . getValue ( ) , e ) ; return null ; } } return object ; } \n', 0.2943222118412164)

('public void invokeSettersAndGetters ( List < String > excludedMethodNames ) { Class < ? extends Object > targetClass = testTarget . getClass ( ) ; Method [ ] methods = targetClass . getMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; if ( excludedMethodNames . contains ( method . getName ( ) ) ) { continue ; } if ( method . getName ( ) . startsWith ( "set" ) ) { Class < ? > [ ] parameterTypes = method . getParameterTypes ( ) ; if ( parameterTypes . length == 1 ) { Object testValue = valueFactory . createValue ( parameterTypes [ 0 ] ) ; try { method . invoke ( testTarget , testValue ) ; if ( testValue instanceof Boolean ) { invokeGetter ( targetClass , testValue , "is" + method . getName ( ) . substring ( 3 ) ) ; } else { invokeGetter ( targetClass , testValue , "get" + method . getName ( ) . substring ( 3 ) ) ; } } catch ( IllegalAccessException ex ) { throw new RuntimeException ( "Failed-to-access-setter-method:-" + method . toString ( ) , ex ) ; } catch ( InvocationTargetException ex ) { throw new RuntimeException ( "Failed-to-invoke-setter-method:-" + method . toString ( ) , ex ) ; } } } } } \n', 0.28910094615465937)

('public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Class < ? > beanType ; Object toWrap = null ; String name = method . getName ( ) ; if ( name . equals ( "create" ) ) { beanType = ( Class < ? > ) args [ 0 ] ; if ( args . length == 2 ) { toWrap = args [ 1 ] ; } } else if ( name . equals ( "getEnum" ) ) { Class < ? > clazz = ( Class < ? > ) args [ 0 ] ; String token = ( String ) args [ 1 ] ; return getEnum ( clazz , token ) ; } else if ( name . equals ( "getToken" ) ) { Enum < ? > e = ( Enum < ? > ) args [ 0 ] ; return getToken ( e ) ; } else { ParameterizedType returnType = ( ParameterizedType ) method . getGenericReturnType ( ) ; beanType = ( Class < ? > ) returnType . getActualTypeArguments ( ) [ 0 ] ; if ( args != null && args . length == 1 ) { toWrap = args [ 0 ] ; } } ProxyAutoBean < Object > toReturn = ( ProxyAutoBean < Object > ) AutoBeanUtils . getAutoBean ( toWrap ) ; if ( toReturn == null ) { if ( toWrap == null ) { toReturn = new ProxyAutoBean < Object > ( ( AutoBeanFactory ) proxy , beanType , configuration ) ; } else { toReturn = new ProxyAutoBean < Object > ( ( AutoBeanFactory ) proxy , beanType , configuration , toWrap ) ; } } return toReturn ; } \n', 0.28886752787807257)

('public static void invokeSetters ( Object bean , NamedList initArgs ) { if ( initArgs == null ) return ; Class clazz = bean . getClass ( ) ; Method [ ] methods = clazz . getMethods ( ) ; Iterator < Map . Entry < String , Object >> iterator = initArgs . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , Object > entry = iterator . next ( ) ; String key = entry . getKey ( ) ; String setterName = "set" + String . valueOf ( Character . toUpperCase ( key . charAt ( 0 ) ) ) + key . substring ( 1 ) ; Method method = null ; try { for ( Method m : methods ) { if ( m . getName ( ) . equals ( setterName ) && m . getParameterTypes ( ) . length == 1 ) { method = m ; break ; } } if ( method == null ) { throw new RuntimeException ( "no-setter-corrresponding-to-\'" + key + "\'-in-" + clazz . getName ( ) ) ; } Class pClazz = method . getParameterTypes ( ) [ 0 ] ; Object val = entry . getValue ( ) ; method . invoke ( bean , val ) ; } catch ( InvocationTargetException e1 ) { throw new RuntimeException ( "Error-invoking-setter-" + setterName + "-on-class-:-" + clazz . getName ( ) , e1 ) ; } catch ( IllegalAccessException e1 ) { throw new RuntimeException ( "Error-invoking-setter-" + setterName + "-on-class-:-" + clazz . getName ( ) , e1 ) ; } } } \n', 0.2883515950312886)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('public static int getLine ( Step step ) { String context = step . getResolver ( ) . getContext ( step ) ; int colon = context . indexOf ( ":" ) ; if ( colon == 1 && Character . isLetter ( context . charAt ( 0 ) ) && Platform . isWindows ( ) && context . length ( ) > 2 ) colon = context . indexOf ( ":" , 2 ) ; context = context . substring ( colon + 1 ) ; try { return Integer . parseInt ( context ) ; } catch ( NumberFormatException e ) { return - 1 ; } } \n', 0.32609010522164056)

('private String getStatusLineText ( AntElementNode node ) { if ( node instanceof AntProjectNode ) { AntProjectNode project = ( AntProjectNode ) node ; StringBuffer message = new StringBuffer ( project . getBuildFileName ( ) ) ; String description = project . getDescription ( ) ; if ( description != null && description . length ( ) > 0 ) { message . append ( ":-" ) ; message . append ( description ) ; } return message . toString ( ) ; } else if ( node instanceof AntTargetNode ) { AntTargetNode target = ( AntTargetNode ) node ; StringBuffer message = new StringBuffer ( ) ; Enumeration depends = target . getTarget ( ) . getDependencies ( ) ; if ( depends . hasMoreElements ( ) ) { message . append ( AntViewMessages . AntView_3 ) ; message . append ( ( String ) depends . nextElement ( ) ) ; while ( depends . hasMoreElements ( ) ) { String dependancy = ( String ) depends . nextElement ( ) ; message . append ( \',\' ) . append ( dependancy ) ; } message . append ( \'|"\' ) ; } String description = target . getTarget ( ) . getDescription ( ) ; if ( description != null && description . length ( ) != 0 ) { message . append ( AntViewMessages . AntView_4 ) ; message . append ( description ) ; message . append ( \'|"\' ) ; } return message . toString ( ) ; } return null ; } \n', 0.28559830229064176)

('private static String getPlatform ( ) { String platform = "unknown" ; File platformFile = new File ( LC . zimbra_home . value ( ) , ".platform" ) ; if ( platformFile . exists ( ) ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( platformFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) > 0 ) { platform = line ; break ; } } } catch ( IOException e ) { System . err . println ( "Unable-to-determine-platform." ) ; e . printStackTrace ( System . err ) ; } finally { ByteUtil . closeReader ( reader ) ; } } else { System . err . format ( "Unable-to-determine-platform-because-%s-does-not-exist.-" , platformFile ) ; } return platform ; } \n', 0.26123369055429035)

('public File findPlatformFile ( ) { try { if ( platformFile == null ) { BufferedReader br = new BufferedReader ( new FileReader ( seriesMatrixFile ) ) ; String currentLine ; String platformName = "" ; while ( ( currentLine = br . readLine ( ) ) != null ) { if ( currentLine . contains ( "!Series_platform_id" ) ) { platformName = currentLine . substring ( currentLine . indexOf ( "G" ) , currentLine . lastIndexOf ( """ ) ) ; break ; } } platformFile = new File ( directory , platformName ) ; } if ( ! platformFile . exists ( ) ) { String URLname = "http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?targ=self&" + "form=text&view=data&acc=" + platformFile . getName ( ) ; Download . downlaodTextFile ( URLname , platformFile . getAbsolutePath ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; MessageDialog . openWarning ( main . getShell ( ) , "Download-failed!" , "ChiBE-could-not-download-the-file.-Check-your-parameters." ) ; } return platformFile ; } \n', 0.260307658412106)

('public static String fetchPlatformLog ( ) { final List < String > result = new ArrayList < String > ( ) ; final File log = Platform . getLogFileLocation ( ) . toFile ( ) ; try { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( log ) , "UTF-8" ) ) ; try { for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) { break ; } line = line . trim ( ) ; if ( line . length ( ) == 0 ) { continue ; } if ( line . startsWith ( "!SESSION-" ) ) { result . clear ( ) ; } result . add ( line ) ; } } finally { reader . close ( ) ; } } catch ( final Exception e ) { ErlLogger . warn ( e ) ; } final StringBuffer buf = new StringBuffer ( ) ; for ( final String s : result ) { buf . append ( s ) . append ( \'|n\' ) ; } return buf . toString ( ) ; } \n', 0.2087000104525314)

('private void processPlatformSensorTypeLine ( StringTokenizer tokenizer ) throws ParserException { String sensorTypeClass = tokenizer . nextToken ( ) ; Map < String , Object > settings = new HashMap < String , Object > ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { String parameterToken = tokenizer . nextToken ( ) ; StringTokenizer parameterTokenizer = new StringTokenizer ( parameterToken , "=" ) ; String leftSide = parameterTokenizer . nextToken ( ) ; String rightSide = parameterTokenizer . nextToken ( ) ; settings . put ( leftSide , rightSide ) ; } try { configurationStorage . addPlatformSensorType ( sensorTypeClass , settings ) ; } catch ( StorageException e ) { throw new ParserException ( "Could-not-add-the-platform-sensor-type-to-the-storage" , e ) ; } } \n', 0.20486201441089041)

('private void readPlatformFile ( ) { FileReader fr ; BufferedReader br ; String line = "" ; StringTokenizer tokenizer ; columnsPlatform . clear ( ) ; try { fr = new FileReader ( platformFile ) ; br = new BufferedReader ( fr ) ; do { line = br . readLine ( ) ; } while ( line != null && startsWithSpecialChar ( line ) ) ; if ( line != null ) { tokenizer = new StringTokenizer ( line , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { columnsPlatform . add ( tokenizer . nextToken ( ) ) ; } } mapTable = new ReferenceTable ( columnsPlatform , getPredictedMatches ( columnsPlatform ) ) ; } catch ( IOException e1 ) { e1 . printStackTrace ( ) ; } } \n', 0.19999555329328284)

('public static Platform [ ] getPlatformsForEclipsePlatform ( String eclipsePlatform ) { Platform [ ] result = NO_PLATFORMS ; if ( PLATFORM_MAP . containsKey ( eclipsePlatform ) ) { List < Platform > platforms = PLATFORM_MAP . get ( eclipsePlatform ) ; result = platforms . toArray ( new Platform [ platforms . size ( ) ] ) ; } return result ; } \n', 0.19794116736446216)

('public synchronized void platformManagement ( ) { Thread t = new Thread ( ) { public void run ( ) { while ( true ) { if ( gameON == true ) { int [ ] temp = currentLevel . getPlatPosX ( ) ; List < Integer > found = new ArrayList < Integer > ( ) ; onScreenPlatforms . clear ( ) ; for ( int i = 0 ; i < temp . length ; i ++ ) { if ( temp [ i ] <= mainCharacter . getxPos ( ) + 500 ) { found . add ( temp [ i ] ) ; } } onScreenPlatforms = Arrays . asList ( currentLevel . getPlatObjects ( found ) ) ; } } } } ; } \n', 0.19625001052396404)

('private static List < String > getLastNLinesOfFile ( int numberOfLinesToReturn ) { List < String > lastNLines = new ArrayList < String > ( ) ; java . io . RandomAccessFile fileHandler = null ; try { File file = getTodaysCountFile ( ) ; fileHandler = new java . io . RandomAccessFile ( file , "r" ) ; long totalNumberOfCharactersInFile = file . length ( ) - 1 ; StringBuilder sb = new StringBuilder ( ) ; int numberOfLinesRead = 0 ; for ( long currentCharacter = totalNumberOfCharactersInFile ; currentCharacter != - 1 ; currentCharacter -- ) { fileHandler . seek ( currentCharacter ) ; int readByte = fileHandler . readByte ( ) ; if ( readByte == LINE_FEED || readByte == CARRIAGE_RETURN ) { if ( numberOfLinesRead == numberOfLinesToReturn ) { break ; } numberOfLinesRead ++ ; String currentLine = sb . reverse ( ) . toString ( ) ; sb = new StringBuilder ( ) ; if ( StringUtils . isNotBlank ( currentLine ) ) { lastNLines . add ( currentLine ) ; } else { LOGGER . error ( "Read-line-does-not-contain-any-data" ) ; continue ; } } else { sb . append ( ( char ) readByte ) ; } } lastNLines . add ( sb . reverse ( ) . toString ( ) ) ; } catch ( Exception e ) { LOGGER . error ( "Can-not-find-today\'s-file" , e ) ; } finally { if ( fileHandler != null ) { try { fileHandler . close ( ) ; } catch ( IOException e ) { fileHandler = null ; } } } return lastNLines ; } \n', 0.18960768941783418)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public static < E > List < E > convertMapToList ( Map < ? , E > map ) { if ( ( map == null ) || ( map . size ( ) == 0 ) ) return new ArrayList < E > ( 0 ) ; List < E > list = new ArrayList < E > ( map . size ( ) ) ; for ( E e : map . values ( ) ) list . add ( e ) ; return list ; } \n', 0.45326748932659766)

('public static < T extends Object > List < T > convertMapToList ( Map < String , T > map ) { List < T > list = new ArrayList < T > ( ) ; for ( T t : map . values ( ) ) { list . add ( t ) ; } return list ; } \n', 0.44733325735105767)

('private List < WarningUnit > convertMapToList ( final Map < Integer , WarningUnit > resultMap ) { List < WarningUnit > resultList = new ArrayList < WarningUnit > ( ) ; Collection < WarningUnit > col = resultMap . values ( ) ; resultList . addAll ( col ) ; return resultList ; } \n', 0.4472048636880249)

('public static < K , T > List < T > convertMapToList ( Map < K , T > map ) { if ( map == null ) return null ; return new ArrayList < T > ( map . values ( ) ) ; } \n', 0.44691073869822795)

('public static List < Object > convertMapToList ( Map < ? , ? > map ) { List < Object > list = new ArrayList < Object > ( map . size ( ) ) ; list . addAll ( map . values ( ) ) ; return list ; } \n', 0.4432093287056925)

('@ Override public < T > List < T > convertListOfMapsToObjects ( List < Map > list , Class < T > componentType ) { List < Object > newList = new ArrayList < > ( list . size ( ) ) ; for ( Object obj : list ) { if ( obj instanceof Value ) { obj = ( ( Value ) obj ) . toValue ( ) ; } if ( obj instanceof Map ) { Map map = ( Map ) obj ; if ( map instanceof ValueMapImpl ) { newList . add ( fromValueMap ( ( Map < String , Value > ) map , componentType ) ) ; } else { newList . add ( fromMap ( map , componentType ) ) ; } } else { newList . add ( Conversions . coerce ( componentType , obj ) ) ; } } return ( List < T > ) newList ; } \n', 0.43184688676906285)

('public static < V > Map < V , V > convertListToMap ( List < V > list ) { Map < V , V > map = new HashMap < V , V > ( ) ; if ( list . size ( ) % 2 != 0 ) throw new RuntimeException ( "Failed-to-convert-list-to-map." ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { map . put ( list . get ( i ) , list . get ( i + 1 ) ) ; } return map ; } \n', 0.4290770335208028)

('public static List < String [ ] > convertMapToList ( final Map < String , String > map ) { List < String [ ] > result = new ArrayList < > ( ) ; for ( Entry < String , String > entry : map . entrySet ( ) ) { String [ ] newEntry = new String [ ] { entry . getKey ( ) , entry . getValue ( ) } ; result . add ( newEntry ) ; } return result ; } \n', 0.42671487165619143)

('private List < ProjectDetail > convertFromMapToListOfProjectDetail ( Map < String , ProjectDetail > projectDetailMap ) { Iterator < String > iterator = projectDetailMap . keySet ( ) . iterator ( ) ; List < ProjectDetail > ideaDetailList = new ArrayList < ProjectDetail > ( ) ; while ( iterator . hasNext ( ) ) { ideaDetailList . add ( projectDetailMap . get ( iterator . next ( ) ) ) ; } return ideaDetailList ; } \n', 0.4245936915369853)

('public static Map convertListToMap ( List list ) { Map map = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { LabelValue option = ( LabelValue ) it . next ( ) ; map . put ( option . getLabel ( ) , option . getValue ( ) ) ; } return map ; } \n', 0.42196354940068215)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.3627