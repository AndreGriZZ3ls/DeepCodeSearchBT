########################## 1 #################################
('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

('public String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4086881582715446)

('private static String convertReaderToString ( Reader reader ) throws IOException { if ( reader != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40778385592006827)

('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40742499525401854)

('private String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) { try { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } catch ( IOException e ) { throw new RuntimeException ( "Did-not-expect-this-one..." , e ) ; } } \n', 0.4074249952540185)

('private String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 8192 ] ; try { Reader reader = new InputStreamReader ( is , "UTF-8" ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) writer . write ( buffer , 0 , n ) ; } finally { is . close ( ) ; writer . close ( ) ; } return writer . toString ( ) ; } \n', 0.4053342062002965)

('public String convertToString ( InputStream inputStream ) throws IOException { if ( inputStream != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( inputStream , "UTF-8" ) , 1024 ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { inputStream . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.3849547887906778)

('public String convertStreamToString ( InputStream is , String encoding ) throws IOException { if ( is != null ) { StringBuilder sb = new StringBuilder ( ) ; String line ; try { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; while ( ( line = reader . readLine ( ) ) != null ) { sb . append ( line ) . append ( NEW_LINE ) ; } } finally { is . close ( ) ; } return sb . toString ( ) ; } else { return "" ; } } \n', 0.379921339656947)

('public String convertResourceToString ( final InputStream in ) throws IOException { String s = null ; if ( in != null ) { final Writer writer = new StringBuilderWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( in , this . charset ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } s = writer . toString ( ) ; } finally { in . close ( ) ; } } return s ; } \n', 0.378534583597691)FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('public ArrayList < ArrayList < Double >> createTestList ( int num_points , boolean integers , boolean negative ) { ArrayList < ArrayList < Double >> test_list = new ArrayList ( ) ; for ( int i = 0 ; i < num_points ; i ++ ) { ArrayList < Double > temp_arraylist = new ArrayList ( ) ; double temp_val1 = Math . random ( ) * scale_x ; double temp_val2 = Math . random ( ) * scale_y ; if ( integers ) { temp_val1 = Math . floor ( temp_val1 ) ; temp_val2 = Math . floor ( temp_val2 ) ; } if ( negative ) { temp_val1 = temp_val1 * 2 - scale_x ; temp_val2 = temp_val2 * 2 - scale_y ; } temp_arraylist . add ( temp_val1 ) ; temp_arraylist . add ( temp_val2 ) ; test_list . add ( temp_arraylist ) ; } return test_list ; } \n', 0.32433913586832874)

('private ArrayList < String > arrayToArrayList ( String [ ] array ) { ArrayList < String > arraylist = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { arraylist . add ( array [ i ] ) ; } return arraylist ; } \n', 0.31113449677079336)

('public ArrayList < String > inferredOrthologsToArrayList ( final String seq_name , double threshold_orthologs ) { HashMap < String , Integer > o_hashmap = null ; String name = null ; double o = 0.0 ; final ArrayList < String > arraylist = new ArrayList < String > ( ) ; if ( _o_hash_maps == null ) { throw new IllegalStateException ( "Orthologs-have-not-been-calculated-(successfully)." ) ; } if ( threshold_orthologs < 0.0 ) { threshold_orthologs = 0.0 ; } else if ( threshold_orthologs > 100.0 ) { threshold_orthologs = 100.0 ; } o_hashmap = getInferredOrthologs ( seq_name ) ; if ( o_hashmap == null ) { throw new IllegalStateException ( "Orthologs-for-" + seq_name + "-were-not-established." ) ; } if ( _seq_names . length > 0 ) { I : for ( int i = 0 ; i < _seq_names . length ; ++ i ) { name = _seq_names [ i ] ; if ( name . equals ( seq_name ) ) { continue I ; } o = getBootstrapValueFromHash ( o_hashmap , name ) ; if ( o < threshold_orthologs ) { continue I ; } arraylist . add ( name ) ; } } return arraylist ; } \n', 0.29810528098606914)

('private static ArrayList < byte [ ] > splitByteArray ( byte [ ] byteArray ) { int counterA = 0 ; ArrayList < byte [ ] > arraylist = new ArrayList < byte [ ] > ( ) ; while ( counterA < byteArray . length ) { byte [ ] tempByteArray = new byte [ 8 ] ; if ( ( byteArray . length - counterA ) < 8 ) { tempByteArray = new byte [ byteArray . length - counterA ] ; for ( int i = 0 ; i < tempByteArray . length ; i ++ ) { tempByteArray [ i ] = byteArray [ counterA ] ; counterA ++ ; } } else { for ( int i = 0 ; i < 8 ; i ++ ) { tempByteArray [ i ] = byteArray [ counterA ] ; counterA ++ ; } } arraylist . add ( tempByteArray ) ; } return arraylist ; } \n', 0.2816622211472439)

('public static List getListOfStringsFromIterableMatchingLastWord ( String [ ] par0ArrayOfStr , Iterable par1Iterable ) { String s = par0ArrayOfStr [ par0ArrayOfStr . length - 1 ] ; ArrayList arraylist = new ArrayList ( ) ; Iterator iterator = par1Iterable . iterator ( ) ; while ( iterator . hasNext ( ) ) { String s1 = ( String ) iterator . next ( ) ; if ( doesStringStartWith ( s , s1 ) ) { arraylist . add ( s1 ) ; } } return arraylist ; } \n', 0.2802199272800526)

('public static ArrayList < DeptEnum > list ( ) { ArrayList < DeptEnum > arraylist = new ArrayList < DeptEnum > ( ) ; arraylist . add ( NONE_SELECTED ) ; arraylist . add ( ACCT ) ; arraylist . add ( SALES ) ; arraylist . add ( PLANT ) ; return arraylist ; } \n', 0.2695283238134567)

('public ArrayList < Integer > loadIntegerArrayListPref ( String key , ArrayList < Integer > defValue ) { try { String stringvalue = loadPref ( KEY_INTEGER + KEY_DELIMITER + KEY_ARRAYLIST + KEY_DELIMITER + key , "" ) ; if ( stringvalue . length ( ) == 0 ) return defValue ; String string_array [ ] = stringvalue . split ( value_delimiter , - 1 ) ; int length = string_array . length ; ArrayList < Integer > value = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { value . add ( Integer . parseInt ( string_array [ i ] ) ) ; } return value ; } catch ( Exception e ) { if ( debug ) Log . e ( TAG , "Error-loading-" + key ) ; if ( PRINT_E ) Log . e ( TAG , "Exception" , e ) ; } return defValue ; } \n', 0.26537880184776824)

('public ArrayList < Byte > loadByteArrayListPref ( String key , ArrayList < Byte > defValue ) { try { String stringvalue = loadPref ( KEY_BYTE + KEY_DELIMITER + KEY_ARRAYLIST + KEY_DELIMITER + key , "" ) ; if ( stringvalue . length ( ) == 0 ) return defValue ; String string_array [ ] = stringvalue . split ( value_delimiter , - 1 ) ; int length = string_array . length ; ArrayList < Byte > value = new ArrayList < Byte > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { value . add ( Byte . parseByte ( string_array [ i ] ) ) ; } return value ; } catch ( Exception e ) { if ( debug ) Log . e ( TAG , "Error-loading-" + key ) ; if ( PRINT_E ) Log . e ( TAG , "Exception" , e ) ; } return defValue ; } \n', 0.2567028255251528)

('public ArrayList < Short > loadShortArrayListPref ( String key , ArrayList < Short > defValue ) { try { String stringvalue = loadPref ( KEY_SHORT + KEY_DELIMITER + KEY_ARRAYLIST + KEY_DELIMITER + key , "" ) ; if ( stringvalue . length ( ) == 0 ) return defValue ; String string_array [ ] = stringvalue . split ( value_delimiter , - 1 ) ; int length = string_array . length ; ArrayList < Short > value = new ArrayList < Short > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { value . add ( Short . parseShort ( string_array [ i ] ) ) ; } return value ; } catch ( Exception e ) { if ( debug ) Log . e ( TAG , "Error-loading-" + key ) ; if ( PRINT_E ) Log . e ( TAG , "Exception" , e ) ; } return defValue ; } \n', 0.25428364851224416)

('public ArrayList < Long > loadLongArrayListPref ( String key , ArrayList < Long > defValue ) { try { String stringvalue = loadPref ( KEY_LONG + KEY_DELIMITER + KEY_ARRAYLIST + KEY_DELIMITER + key , "" ) ; if ( stringvalue . length ( ) == 0 ) return defValue ; String string_array [ ] = stringvalue . split ( value_delimiter , - 1 ) ; int length = string_array . length ; ArrayList < Long > value = new ArrayList < Long > ( ) ; for ( int i = 0 ; i < length ; i ++ ) { value . add ( Long . parseLong ( string_array [ i ] ) ) ; } return value ; } catch ( Exception e ) { if ( debug ) Log . e ( TAG , "Error-loading-" + key ) ; if ( PRINT_E ) Log . e ( TAG , "Exception" , e ) ; } return defValue ; } \n', 0.2517674149550139)FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('public < T extends Iterable < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList ( iterables . length ) ; for ( T iterable : iterables ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3500509165733183)

('public < T extends Iterable < ? extends Key >> JoinIterator ( Aggregator < Key , Value > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = new Comparator < Key > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public int compare ( Key o1 , Key o2 ) { return ( ( Comparable < Key > ) o1 ) . compareTo ( o2 ) ; } } ; for ( T iterable : iterables ) { final Entry entry = new Entry ( size ++ , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; } } \n', 0.34550463930287495)

('public final HashMap collectCachebyAccess ( int rate ) { HashMap resultmap = new HashMap ( ) ; int expectSize = maxSize * rate / 100 ; while ( size > expectSize ) { String key = null ; if ( accessList . getLast ( ) != null ) { key = ( String ) accessList . getLast ( ) . object ; } if ( key != null ) { resultmap . put ( key , hashmap . get ( key ) ) ; remove ( ( String ) accessList . getLast ( ) . object ) ; } else { remove ( ( String ) emptyList . getLast ( ) . object ) ; } } System . out . println ( "rate-is-:-" + size * 100 / maxSize ) ; return resultmap ; } \n', 0.3387688714683485)

('private Iterable < Tile > makeMapIteratorIterable ( final MapIterator m ) { return new Iterable < Tile > ( ) { public Iterator < Tile > iterator ( ) { return new Iterator < Tile > ( ) { public boolean hasNext ( ) { return m . hasNext ( ) ; } public Tile next ( ) { return getTile ( m . next ( ) ) ; } public void remove ( ) { m . remove ( ) ; } } ; } } ; } \n', 0.33329208623876416)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final Indexable indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('private Iterator < Annotation > getAnnotationIterator ( boolean cleanup , boolean recurse ) { Iterator < Annotation > iter = getAnnotationIterator ( cleanup ) ; if ( ! recurse || fAttachments . isEmpty ( ) ) return iter ; List < Iterator < Annotation >> iterators = new ArrayList < > ( fAttachments . size ( ) + 1 ) ; iterators . add ( iter ) ; Iterator < Object > it = fAttachments . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) iterators . add ( fAttachments . get ( it . next ( ) ) . getAnnotationIterator ( ) ) ; return new MetaIterator < > ( iterators . iterator ( ) ) ; } \n', 0.3319734088313099)

('public Iterable < ? extends Key > iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public Iterable < ? extends Key > iterate ( final Indexable indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public net . varkhan . base . containers . Iterable < ? extends Key > iterate ( final long [ ] indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('public static int getRandomInRange ( int min , int max ) throws IllegalArgumentException { if ( min > max ) { throw new IllegalArgumentException ( "Minimum-cannot-be-larger-than-maximum" ) ; } if ( min == max ) { return min ; } int ret = new Random ( ) . nextInt ( max + 1 - min ) + min ; if ( ret < min || ret > max ) { throw new IllegalStateException ( "Programmer-messed-up:-Value-" + ret + "is-not-within-range-of-" + min + "-and-" + max ) ; } return ret ; } \n', 0.44109220995939147)

('double randomInRange ( double min , double max ) { Random random = new Random ( ) ; double range = max - min ; double scaled = random . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.4260948867782801)

('public static double randomDoubleInRange ( double rangeMin , double rangeMax ) { Random r = new Random ( ) ; double doubleInRange = rangeMin + ( rangeMax - rangeMin ) * r . nextDouble ( ) ; return doubleInRange ; } \n', 0.42378763477641407)

('public static double randomInRange ( double min , double max ) { double range = max - min ; double scaled = random . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42228709003799836)

('protected Bid getRandomBidInRange ( double lowerBound , double upperBound ) throws Exception { ArrayList < Bid > bidsInRange = getBidsInRange ( lowerBound , upperBound ) ; int index = ( new Random ( ) ) . nextInt ( bidsInRange . size ( ) - 1 ) ; return bidsInRange . get ( index ) ; } \n', 0.4220003412024551)

('public double randomInRange ( double min , double max ) { double range = max - min ; double scaled = randomNumGenerator_ . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42066172439532096)

('private static int [ ] getRandomRange ( int end ) { int [ ] range = new int [ end ] ; Random random = new Random ( ) ; for ( int i = 0 ; i < end ; i ++ ) { range [ i ] = random . nextInt ( end ) ; } return range ; } \n', 0.4148010251496685)

('private double randomInRange ( double min , double max ) { double range = ( max - min ) + 1 ; return ( Math . round ( Math . random ( ) * range ) + min + 0.5 ) ; } \n', 0.4128431624918978)

('private int randomInRange ( int min , int max ) { int range = ( max - min ) + 1 ; return ( int ) ( Math . round ( Math . random ( ) * range ) + min ) ; } \n', 0.4128431624918978)

('public static int randomWithRange ( int min , int max ) { int range = Math . abs ( max - min ) + 1 ; return ( int ) ( Math . random ( ) * range ) + ( min <= max ? min : max ) ; } \n', 0.4083084540570455)FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('public static int convertStringToInteger ( String number , int defaultValue ) { try { return Integer . parseInt ( number ) ; } catch ( Exception e ) { } return defaultValue ; } \n', 0.4334646601001463)

('public static Integer convertStringToInt ( String original ) throws NumberFormatException { Integer conv = null ; conv = Integer . parseInt ( original ) ; return conv ; } \n', 0.42885237183470204)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.42556612403100647)

('public static int convertStringToInt ( String str ) throws BookStoreException { int returnValue = 0 ; try { returnValue = Integer . parseInt ( str ) ; } catch ( Exception ex ) { throw new BookStoreException ( ex ) ; } return returnValue ; } \n', 0.42450212508579)

('public static int convertStringToInt ( String str ) throws Exception { int returnValue = 0 ; try { returnValue = Integer . parseInt ( str ) ; } catch ( Exception ex ) { throw new AccountManagerException ( ex ) ; } return returnValue ; } \n', 0.42450212508579)

('public static int convertStringToInt ( String stringValue ) throws NumberFormatException { int intValue = Integer . parseInt ( stringValue ) ; return intValue ; } \n', 0.42450212508579)

('public static int convertStringToIntDef ( String string , int defaultValue ) { try { return Integer . parseInt ( string ) ; } catch ( NumberFormatException e ) { return defaultValue ; } } \n', 0.4149517042983897)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.40614039395713675)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.4042160832634376)

('public static Integer convertStringToInteger ( String strParaConvert ) { if ( strParaConvert == null ) return new Integer ( 0 ) ; if ( strParaConvert . trim ( ) . equalsIgnoreCase ( "" ) ) return new Integer ( 0 ) ; try { int aux = Integer . parseInt ( strParaConvert ) ; return new Integer ( aux ) ; } catch ( Exception e ) { return new Integer ( 0 ) ; } } \n', 0.40208926219319296)FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('@ Override public double [ ] initial ( ) { double [ ] initial = new double [ domainDimension ( ) ] ; if ( backpropTraining ) { learnedParamsMapping = new int [ domainDimension ( ) ] [ 3 ] ; int index = 0 ; for ( ; index < numLopExpert ; index ++ ) { initial [ index ] = 1.0 ; } for ( int i = 0 ; i < numLopExpert ; i ++ ) { List < Integer > featureIndicesList = featureIndicesListArray . get ( i ) ; double [ ] [ ] expertWeights2D = lopExpertWeights2D [ i ] ; for ( int fIndex : featureIndicesList ) { for ( int j = 0 ; j < expertWeights2D [ fIndex ] . length ; j ++ ) { initial [ index ] = expertWeights2D [ fIndex ] [ j ] ; learnedParamsMapping [ index ] = new int [ ] { i , fIndex , j } ; index ++ ; } } } } else { Arrays . fill ( initial , 1.0 ) ; } return initial ; } \n', 0.34813765998572366)

('public void arrayInitializer ( int length ) { ArrayInitializer ai = new ArrayInitializer ( ) ; if ( length != 0 ) { this . expressionPtr -= length ; System . arraycopy ( this . expressionStack , this . expressionPtr + 1 , ai . expressions = new Expression [ length ] , 0 , length ) ; } pushOnExpressionStack ( ai ) ; ai . sourceEnd = this . endStatementPosition ; ai . sourceStart = this . intStack [ this . intPtr -- ] ; } \n', 0.331068692723141)

('protected void consumeArrayInitializer ( ) { arrayInitializer ( this . expressionLengthStack [ this . expressionLengthPtr -- ] ) ; } \n', 0.33083559057939516)

('private JArrayInitializer arrayInitializer ( Type type ) { int line = scanner . token ( ) . line ( ) ; ArrayList < JExpression > initials = new ArrayList < JExpression > ( ) ; mustBe ( LCURLY ) ; if ( have ( RCURLY ) ) { return new JArrayInitializer ( line , type , initials ) ; } initials . add ( variableInitializer ( type . componentType ( ) ) ) ; while ( have ( COMMA ) ) { initials . add ( see ( RCURLY ) ? null : variableInitializer ( type . componentType ( ) ) ) ; } mustBe ( RCURLY ) ; return new JArrayInitializer ( line , type , initials ) ; } \n', 0.3206230520027176)

('protected final void initialize ( int w , int h , int bpp , TwTwoReadStream stream , int [ ] pixels , boolean isPhotoCodec ) { if ( bpp != 16 && bpp != 24 ) throw new IllegalArgumentException ( "Invalid-depth-:" + bpp ) ; this . isPhotoCodec = isPhotoCodec ; isMultiColorSection = true ; pixelZero = PIXEL_ZERO_INITIAL_STATE ; pixelOne = PIXEL_ONE_INITIAL_STATE ; super . initialize ( w , h , bpp , stream ) ; output = pixels ; if ( initialScanLine . length < w ) { initialScanLine = new int [ w ] ; for ( int i = 0 ; i < w ; i ++ ) { initialScanLine [ i ] = PIXEL_ZERO_INITIAL_STATE ; } } if ( isPhotoCodec ) { photographicWeighting = INITIAL_PHOTOGRAPHIC_WEIGHTING ; int [ ] initialPixelCache = ( bpp == 16 ) ? initialPixelCache16 : initialPixelCache24 ; System . arraycopy ( initialPixelCache , 0 , pixelCache , 0 , pixelCache . length ) ; } } \n', 0.3180843057215118)

('private void init ( Vec2f point1 , Vec2f point2 , Vec2f point3 , Vec2f point4 ) { start = _points [ 0 ] = point1 ; ctrl_one = _points [ 1 ] = point2 ; ctrl_two = _points [ 2 ] = point3 ; end = _points [ 3 ] = point4 ; this . setLocation ( start ) ; this . updateSegs ( ) ; _pois = new ArrayList < Vec2f > ( ) ; _drawBorder = false ; _drawDots = new ArrayList < CircleShape > ( ) ; _drawLines = new ArrayList < LineSegment > ( ) ; } \n', 0.3149690118851459)

('private void setupInitialization ( ArrayList < Token > tokens , Line line ) { ArrayList < Token > typeTokens = getTypeName ( config , tokens , 0 ) ; String type = concatenate ( typeTokens ) ; String name = tokens . get ( typeTokens . size ( ) ) . getToken ( ) ; isNameValid ( name , line ) ; ParseTreeNode tree = Parser . getParseTree ( this , line , tokens , typeTokens . size ( ) + 2 ) ; line . setStatment ( Statement . INITIALIZATION ) ; line . setData ( new Object [ ] { type , name , tree } ) ; } \n', 0.3127287838351404)

('private void initializeRandomCentroids ( ) { centroids = new ArrayList < List < Double >> ( ) ; System . out . println ( "Initialing-random-centroids..." ) ; for ( int i = 0 ; i < SharedClass . K_VALUE ; i ++ ) { List < Double > tempOneCentroid = new ArrayList < > ( ) ; for ( int j = 0 ; j < SharedClass . VECTOR_LENGTH ; j ++ ) { tempOneCentroid . add ( SharedClass . randomInRange ( 0.0 , 1.0 ) ) ; } centroids . add ( tempOneCentroid ) ; } copyOfInitialCentroids = centroids ; System . out . println ( "Random-centroids-initialied!!!-" ) ; } \n', 0.31138344889779124)

('protected synchronized String _readLine ( boolean removeLine ) { int p = 0 ; while ( ( p < super . count ) && ! IsNL ( super . buf [ p ] ) ) { p ++ ; } if ( ( p < super . count ) && IsNL ( super . buf [ p ] ) ) { p ++ ; } if ( p == 0 ) { return null ; } else { int ofs = 0 ; String s = new String ( super . buf , ofs , p ) ; if ( removeLine ) { int newcount = super . count - p ; System . arraycopy ( super . buf , p , super . buf , 0 , newcount ) ; super . count = newcount ; } return s ; } } \n', 0.31009773076693825)

('final void setInitialValues ( final float [ ] initialValues , final int diagonal ) { if ( Debug . DEBUGCODE && ( ( Math . min ( this . height , this . width ) - diagonal <= 0 ) || ( diagonal < 0 ) ) ) { throw new IllegalStateException ( ) ; } boolean b = diagonal % 2 != 0 ; int i = 0 , j = 0 ; for ( ; i <= diagonal ; i ++ ) { b = ! b ; if ( b ) { System . arraycopy ( initialValues , j ++ * 2 * this . stateNumber , this . line , i * this . stateNumber , this . stateNumber * 2 ) ; } else { System . arraycopy ( initialValues , j ++ * 2 * this . stateNumber , this . line , i * this . stateNumber + this . line . length / 2 , this . stateNumber * 2 ) ; } } if ( ! b ) { System . arraycopy ( initialValues , j * 2 * this . stateNumber , this . line , i * this . stateNumber , this . stateNumber ) ; } else { System . arraycopy ( initialValues , j * 2 * this . stateNumber , this . line , i * this . stateNumber + this . line . length / 2 , this . stateNumber ) ; } } \n', 0.30608696295805593)FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

('private static boolean containsCheckOnDoubleArray ( double [ ] array , Double compareTest ) { double test = compareTest . doubleValue ( ) ; for ( double d : array ) if ( d == test ) return true ; return false ; } \n', 0.3602336326876485)

('private static boolean containsCheckOnShortArray ( short [ ] array , Short compareTest ) { short test = compareTest . shortValue ( ) ; for ( short s : array ) if ( s == test ) return true ; return false ; } \n', 0.34824413533627085)

('private static boolean containsCheckOnFloatArray ( float [ ] array , Float compareTest ) { float test = compareTest . floatValue ( ) ; for ( float f : array ) if ( f == test ) return true ; return false ; } \n', 0.3390590700170038)

('private static boolean containsCheckOnLongArray ( long [ ] array , Long compareTest ) { long test = compareTest . longValue ( ) ; for ( long l : array ) if ( l == test ) return true ; return false ; } \n', 0.3370525576539741)

('public void verifyValues ( ) { List known = new ArrayList ( confirmed . values ( ) ) ; List test = new ArrayList ( values ) ; int size = confirmed . size ( ) ; boolean empty = confirmed . isEmpty ( ) ; assertEquals ( "values-should-be-same-size-as-HashMap\'s" + "-Test:-" + test + "-Real:-" + known , size , values . size ( ) ) ; assertEquals ( "values-should-be-empty-if-HashMap-is" + "-Test:-" + test + "-Real:-" + known , empty , values . isEmpty ( ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , test . containsAll ( known ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , known . containsAll ( test ) ) ; for ( Iterator it = known . iterator ( ) ; it . hasNext ( ) ; ) { boolean removed = test . remove ( it . next ( ) ) ; assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , removed ) ; } assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , test . isEmpty ( ) ) ; } \n', 0.3342096505976902)

('private static boolean containsCheckOnIntArray ( int [ ] array , Integer compareTest ) { int test = compareTest . intValue ( ) ; for ( int i : array ) if ( i == test ) return true ; return false ; } \n', 0.3298072455044525)

('private static boolean containsCheckOnBooleanArray ( boolean [ ] array , Boolean compareTest ) { boolean test = compareTest . booleanValue ( ) ; for ( boolean b : array ) if ( b == test ) return true ; return false ; } \n', 0.3021065535564248)

('public static void assertContains ( String [ ] stringSet , String ... values ) { Set < String > set = new HashSet < String > ( Arrays . asList ( stringSet ) ) ; for ( String value : values ) { ScopeTestHelper . assertTrue ( set . contains ( value ) ) ; } } \n', 0.29607026461450126)

('public void testSortByValues ( ) { Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( "b" , 2000 ) ; map . put ( "a" , 1000 ) ; map . put ( "c" , 4000 ) ; map . put ( "d" , 3000 ) ; Map < String , Integer > sorted = CollectionUtil . sortByValues ( map ) ; assertNotNull ( sorted ) ; assertEquals ( map . size ( ) , sorted . size ( ) ) ; assert ( map . keySet ( ) . containsAll ( sorted . keySet ( ) ) ) ; assert ( map . values ( ) . containsAll ( sorted . values ( ) ) ) ; List < String > list = new ArrayList < String > ( sorted . keySet ( ) ) ; assertEquals ( "a" , list . get ( 0 ) ) ; Collections . reverse ( list ) ; assertEquals ( "c" , list . get ( 0 ) ) ; } \n', 0.2949996348742437)FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('protected Map < String , Object > getEnumValues ( final Class < ? > clazz , final String allPrefix ) { if ( clazz . isEnum ( ) ) { final ClassLoader classLoader = ClassUtils . getClassLoader ( clazz ) ; if ( ! CACHE . containsKey ( classLoader ) ) { CACHE . put ( classLoader , new ConcurrentHashMap < Class < ? > , Map < String , Object >> ( ) ) ; } final ConcurrentMap < Class < ? > , Map < String , Object >> cache = CACHE . get ( classLoader ) ; final Map < String , Object > enums ; if ( cache . containsKey ( clazz ) ) { enums = cache . get ( clazz ) ; } else { enums = new EnumHashMap < String , Object > ( clazz ) ; for ( Object value : clazz . getEnumConstants ( ) ) { Enum < ? > currentEnum = ( Enum < ? > ) value ; enums . put ( currentEnum . name ( ) , currentEnum ) ; } enums . put ( allPrefix , clazz . getEnumConstants ( ) ) ; cache . put ( clazz , enums ) ; } return enums ; } else { throw new FacesException ( "Class-\'" + clazz + "\'-is-not-an-enum." ) ; } } \n', 0.3351886374581573)

('public static < E extends Enum < E >> E lookup ( Class < E > enumClass , String enumName ) { try { return Enum . valueOf ( enumClass , getEnumName ( enumName ) ) ; } catch ( Exception ex ) { log . warn ( "Did-not-find-an-" + enumClass . getSimpleName ( ) + "-for-value-\'" + enumName + "\'" ) ; return null ; } } \n', 0.33234903741761446)

('public static int enumValue ( String target , String [ ] enums , int [ ] vals ) throws IllegalArgumentException { int base = 0 ; int limit = enums . length - 1 ; while ( base <= limit ) { int cur = ( base + limit ) >> 1 ; int diff = target . compareTo ( enums [ cur ] ) ; if ( diff < 0 ) { limit = cur - 1 ; } else if ( diff > 0 ) { base = cur + 1 ; } else if ( vals != null ) { return vals [ cur ] ; } else { return cur ; } } throw new IllegalArgumentException ( "Target-value-"" + target + ""-not-found-in-enumeration" ) ; } \n', 0.32279320684471646)

('public static < T extends Enum < T >> T convertEnum ( Class < T > clazz , String value ) { try { return Enum . valueOf ( clazz , value ) ; } catch ( IllegalArgumentException e ) { throw new ConstrettoConversionException ( value , clazz , e ) ; } } \n', 0.3143236627627224)

('String enumLookup ( StructureMembers . Member m , Number val ) { Variable v = struct . findVariable ( m . getName ( ) ) ; return v . lookupEnumString ( val . intValue ( ) ) ; } \n', 0.3102097733920717)

('private static Enum < ? > convertStringToEnumValue ( Field attribute , String valueString ) { Class < ? > enumType = attribute . getType ( ) ; Enum < ? > value = null ; for ( Object enumConstant : enumType . getEnumConstants ( ) ) { boolean isWantedConstant = enumConstant . toString ( ) . equals ( valueString ) ; if ( isWantedConstant ) { value = ( Enum < ? > ) enumConstant ; } } if ( value == null ) { throw new IllegalStateException ( "Could-not-convert-the-string-value-\'" + valueString + "\'-to-an-enum-value." ) ; } return value ; } \n', 0.3058044917955871)

('public String convertFieldEnumValueToActualValue ( String fieldValue ) { String retval = "" ; if ( enumValues . containsKey ( fieldValue . toUpperCase ( ) ) ) { retval = enumValues . get ( fieldValue . toUpperCase ( ) ) . toString ( ) ; } return retval ; } \n', 0.3015494847685253)

('private ObjectLookupMethod determineDefaultObjectLookupMethod ( ) { String objectLookupMethod = configurationProperties . getProperty ( Environment . OBJECT_LOOKUP_METHOD ) ; if ( objectLookupMethod == null ) { return ObjectLookupMethod . SKIP ; } else { try { return Enum . valueOf ( ObjectLookupMethod . class , objectLookupMethod . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { throw log . invalidPropertyValue ( objectLookupMethod , Environment . OBJECT_LOOKUP_METHOD ) ; } } } \n', 0.293558660749653)

('private Object attemptToConvertStringToEnum ( Class < ? > requiredType , String trimmedValue , Object currentConvertedValue ) { Object convertedValue = currentConvertedValue ; if ( Enum . class == requiredType ) { int index = trimmedValue . lastIndexOf ( "." ) ; if ( index > - 1 ) { String enumType = trimmedValue . substring ( 0 , index ) ; String fieldName = trimmedValue . substring ( index + 1 ) ; ClassLoader cl = this . targetObject . getClass ( ) . getClassLoader ( ) ; try { Class < ? > enumValueType = ClassUtils . forName ( enumType , cl ) ; Field enumField = enumValueType . getField ( fieldName ) ; convertedValue = enumField . get ( null ) ; } catch ( ClassNotFoundException ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Enum-class-[" + enumType + "]-cannot-be-loaded" , ex ) ; } } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + fieldName + "]-isn\'t-an-enum-value-for-type-[" + enumType + "]" , ex ) ; } } } } if ( convertedValue == currentConvertedValue ) { try { Field enumField = requiredType . getField ( trimmedValue ) ; convertedValue = enumField . get ( null ) ; } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + convertedValue + "]-isn\'t-an-enum-value" , ex ) ; } } } return convertedValue ; } \n', 0.2931613188213217)

('private Map < String , String > convertEnumStringToMap ( String enums ) { final Map < String , String > enumsMap ; enumsMap = new HashMap < String , String > ( ) ; if ( enums . length ( ) == 0 ) return enumsMap ; String [ ] theEnums = enums . split ( "[|]" ) ; for ( int i = 0 ; i < theEnums . length ; i ++ ) { String name = null ; String value = null ; String anEnum = theEnums [ i ] ; String [ ] front = anEnum . split ( "<" ) ; value = front [ 0 ] ; if ( front . length > 1 ) { String between = front [ 1 ] ; String [ ] back = between . split ( ">" ) ; name = back [ 0 ] ; } if ( name != null ) enumsMap . put ( value , name ) ; else enumsMap . put ( value , value ) ; } return enumsMap ; } \n', 0.28855975706292875)FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('protected void recursiveNestedJoin ( EventBean lookupEvent , int nestingOrderIndex , EventBean [ ] currentPath , Collection < EventBean [ ] > result , ExprEvaluatorContext exprEvaluatorContext ) { List < EventBean [ ] > nestedResult = new LinkedList < EventBean [ ] > ( ) ; ExecNode nestedExecNode = childNodes . get ( nestingOrderIndex ) ; nestedExecNode . process ( lookupEvent , currentPath , nestedResult , exprEvaluatorContext ) ; boolean isLastStream = ( nestingOrderIndex == nestingOrderLength - 1 ) ; if ( ! isLastStream ) { for ( EventBean [ ] row : nestedResult ) { EventBean lookup = row [ nestedStreams [ nestingOrderIndex ] ] ; recursiveNestedJoin ( lookup , nestingOrderIndex + 1 , row , result , exprEvaluatorContext ) ; } return ; } for ( EventBean [ ] row : nestedResult ) { result . add ( row ) ; } } \n', 0.3494762225854692)

('public void visitForeachLoop ( JCEnhancedForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStat ( tree . var , loopEnv ) ; Type exprType = types . upperBound ( attribExpr ( tree . expr , loopEnv ) ) ; chk . checkNonVoid ( tree . pos ( ) , exprType ) ; Type elemtype = types . elemtype ( exprType ) ; if ( elemtype == null ) { Type base = types . asSuper ( exprType , syms . iterableType . tsym ) ; if ( base == null ) { log . error ( tree . expr . pos ( ) , "foreach.not.applicable.to.type" , exprType , diags . fragment ( "type.req.array.or.iterable" ) ) ; elemtype = types . createErrorType ( exprType ) ; } else { List < Type > iterableParams = base . allparams ( ) ; elemtype = iterableParams . isEmpty ( ) ? syms . objectType : types . upperBound ( iterableParams . head ) ; } } chk . checkType ( tree . expr . pos ( ) , elemtype , tree . var . sym . type ) ; loopEnv . tree = tree ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.31910015986070384)

('public void visitForStatement ( GNode n ) { final boolean scope = hasScope ; hasScope = false ; final String name = table . freshName ( "forloop" ) ; table . enter ( name ) ; table . mark ( n ) ; dispatch ( n . getNode ( 0 ) ) ; if ( null != n . get ( 1 ) ) { Node n2 = n . getNode ( 1 ) ; ensureScalar ( n2 , c ( ) . pointerize ( ( Type ) dispatch ( n2 ) ) ) ; } dispatch ( n . getNode ( 2 ) ) ; loops . add ( Boolean . TRUE ) ; dispatch ( n . getNode ( 3 ) ) ; loops . remove ( loops . size ( ) - 1 ) ; table . exit ( ) ; hasScope = scope ; } \n', 0.3062786518123426)

('private NestedLoops ( final Vector2D [ ] loop ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; surrounded = new ArrayList < NestedLoops > ( ) ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( previous ) . getX ( ) , line . toSubSpace ( current ) . getX ( ) ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.3025557593544445)

('public IdentityHashtable collectAndPrepareObjectsForNestedMerge ( ) { IdentityHashtable changedObjects = new IdentityHashtable ( 1 + getCloneMapping ( ) . size ( ) ) ; discoverAllUnregisteredNewObjects ( ) ; for ( Enumeration clonesEnum = getCloneMapping ( ) . keys ( ) ; clonesEnum . hasMoreElements ( ) ; ) { Object clone = clonesEnum . nextElement ( ) ; changedObjects . put ( clone , clone ) ; } for ( Enumeration unregisteredNewObjectsEnum = getUnregisteredNewObjects ( ) . keys ( ) ; unregisteredNewObjectsEnum . hasMoreElements ( ) ; ) { Object newObject = unregisteredNewObjectsEnum . nextElement ( ) ; changedObjects . put ( newObject , newObject ) ; } return changedObjects ; } \n', 0.30032458176050947)

('public void visitWhileLoop ( JCWhileLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || ! tree . cond . type . isTrue ( ) ; } \n', 0.29932897137891834)

('public void visitForLoop ( JCForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStats ( tree . init , loopEnv ) ; if ( tree . cond != null ) attribExpr ( tree . cond , loopEnv , syms . booleanType ) ; loopEnv . tree = tree ; attribStats ( tree . step , loopEnv ) ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.2981734140170164)

('private void writeIterationResultsToFile ( ) throws IOException { int index = 0 ; float correlation = 0.0f ; boolean exitLoops = false ; boolean secondLoopFirstInit = true ; for ( int i = lastIndexXPreviousWriting ; i < totalRows - 1 ; i ++ ) { if ( firstLoopFirstInit ) { firstLoopFirstInit = false ; outOstream . writeInt ( i ) ; } for ( int j = ( secondLoopFirstInit ) ? lastIndexYPreviousWriting : ( i + 1 ) ; j < totalRows ; j ++ ) { if ( secondLoopFirstInit ) secondLoopFirstInit = false ; if ( exitLoops = ( ++ index > N ) ) { break ; } else { correlation = dataResultsGPU . get ( index - 1 ) ; if ( correlation >= threshold ) { outOstream . writeInt ( j ) ; outOstream . writeFloat ( correlation ) ; } } } if ( exitLoops ) break ; firstLoopFirstInit = true ; outOstream . writeInt ( i ) ; } } \n', 0.2961855193223988)

('public void addNestedPos ( ExtractionPos loop ) { nested_loops . add ( loop ) ; } \n', 0.2955534288106427)

('private void removeLoopWithExitNode ( Map < CfgBlock , Set < CfgBlock >> loops , CfgBlock header , Set < CfgBlock > body , CfgBlock headerExitBlock ) { CfgBlock headerClone = null ; for ( CfgBlock b : new HashSet < CfgBlock > ( body ) ) { if ( method . containsEdge ( b , header ) ) { method . removeEdge ( method . getEdge ( b , header ) ) ; if ( headerClone == null ) { headerClone = header . deepCopy ( ) ; addBlockToLoops ( header , headerClone , loops ) ; method . addEdge ( headerClone , headerExitBlock ) ; } method . addEdge ( b , headerClone ) ; } } } \n', 0.29077522927152594)FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('private static List < Quadruple > declareArray ( String name , ArrayType type ) throws IntermediateCodeGeneratorException { List < Quadruple > decl = new LinkedList < > ( ) ; String length = "#" + type . getLength ( ) ; Quadruple level = new QuadrupleImpl ( Operator . DECLARE_ARRAY , length , name ) ; decl . add ( level ) ; decl . addAll ( QuadrupleFactory . declare ( "!" , type . getInnerType ( ) ) ) ; return decl ; } \n', 0.32635731927474465)

('public void createSumArrayPut ( long term , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( term ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.27748677358546037)

('public static Bodies [ ] createArrays ( Vector allBodies ) { Bodies [ ] array = new Bodies [ allBodies . size ( ) ] ; allBodies . copyInto ( array ) ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] . createArrays ( ) ; return array ; } \n', 0.26676445164995854)

('public void createSumArrayPut ( long word , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( word ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.262212797449038)

('public static ArrayList < AVector > createSparseArray ( Iterator < AVector > vecIterator ) { AVector v0 = vecIterator . next ( ) ; int len = v0 . length ( ) ; ArrayList < AVector > vecList = new ArrayList < AVector > ( ) ; vecList . add ( v0 ) ; while ( vecIterator . hasNext ( ) ) { AVector v = vecIterator . next ( ) ; if ( ( v == null ) || ( v . isZero ( ) ) ) v = Vectorz . createZeroVector ( len ) ; else v = v . sparseClone ( ) ; vecList . add ( v . sparseClone ( ) ) ; } return vecList ; } \n', 0.2534039371513054)

('public IArray createArrayNoCopy ( final Object javaArray ) { int rank = 0 ; Class < ? > componentType = javaArray . getClass ( ) ; while ( componentType . isArray ( ) ) { rank ++ ; componentType = componentType . getComponentType ( ) ; } int count = 0 ; int [ ] shape = new int [ rank ] ; Object jArray = javaArray ; Class < ? > cType = jArray . getClass ( ) ; while ( cType . isArray ( ) ) { shape [ count ++ ] = java . lang . reflect . Array . getLength ( jArray ) ; jArray = java . lang . reflect . Array . get ( jArray , 0 ) ; cType = jArray . getClass ( ) ; } return createArray ( componentType , shape , javaArray ) ; } \n', 0.24542351040092777)

('public static IArray createArrayNoCopy ( Object javaArray ) { int rank = 0 ; Class < ? > componentType = javaArray . getClass ( ) ; while ( componentType . isArray ( ) ) { rank ++ ; componentType = componentType . getComponentType ( ) ; } int count = 0 ; int [ ] shape = new int [ rank ] ; Object jArray = javaArray ; Class < ? > cType = jArray . getClass ( ) ; while ( cType . isArray ( ) ) { shape [ count ++ ] = java . lang . reflect . Array . getLength ( jArray ) ; jArray = java . lang . reflect . Array . get ( jArray , 0 ) ; cType = jArray . getClass ( ) ; } return createArray ( componentType , shape , javaArray ) ; } \n', 0.24432627512638572)

('private static Object createArrayAndFill ( Class < ? > type , final List < String > stringValues ) throws ConfException { assert ( type != null ) ; assert ( stringValues != null ) ; Object array = Array . newInstance ( type , stringValues . size ( ) ) ; int index = 0 ; for ( String argument : stringValues ) { Object value = valueFromString ( type , argument ) ; Array . set ( array , index ++ , value ) ; } return array ; } \n', 0.24040525593701143)

('public static ArrayList < Integer > initializeAArrayWithValue ( Integer numberToInitialize ) { ArrayList < Integer > arrToIntialize = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= numberToInitialize ; i ++ ) { arrToIntialize . add ( i ) ; } return arrToIntialize ; } \n', 0.23256766087467656)

('private void initObjectsFromArray ( ) { List < EngineObject > newObjects = new ArrayList < EngineObject > ( ) ; for ( int i = 0 ; i < this . objects . length ; i ++ ) { EngineObject obj = objects [ i ] ; if ( obj . placementMask == null ) { initObject ( obj , EngineObject . Placement . CENTER ) ; newObjects . add ( obj ) ; } else { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( obj . placementMask . get ( j ) ) { EngineObject clone = new EngineObject ( obj ) ; initObject ( clone , j ) ; newObjects . add ( clone ) ; } } } } this . originalObjects = new ArrayList < EngineObject > ( Arrays . asList ( objects ) ) ; this . objects = ( EngineObject [ ] ) newObjects . toArray ( new EngineObject [ newObjects . size ( ) ] ) ; } \n', 0.232055198698846)FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('public static String getRandomString ( int numberOfLetters , char [ ] alphabet , boolean includeNumbers ) { StringBuilder builder = new StringBuilder ( ) ; int upperRange = alphabet . length - 1 ; builder . append ( alphabet [ generator . nextInt ( upperRange ) ] ) ; if ( includeNumbers ) { upperRange += NUMBERS . length ; } for ( int i = 1 ; i < numberOfLetters ; i ++ ) { int letterIndex = generator . nextInt ( upperRange ) ; if ( letterIndex > alphabet . length - 1 ) { builder . append ( NUMBERS [ letterIndex - alphabet . length ] ) ; } else { builder . append ( alphabet [ letterIndex ] ) ; } } return builder . toString ( ) ; } \n', 0.43680242601884034)

('public static String getRandomString ( int length ) { StringBuffer buffer = new StringBuffer ( "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" ) ; StringBuffer sb = new StringBuffer ( ) ; Random r = new Random ( ) ; int range = buffer . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( buffer . charAt ( r . nextInt ( range ) ) ) ; } return sb . toString ( ) ; } \n', 0.4343604745315537)

('public static String generateRandomString ( ) { String allowedChars = "0123456789abcdefghijklmnopqrstuvwxyz" ; Random random = new Random ( ) ; return generateRandomString ( allowedChars , random ) ; } \n', 0.42864136447512524)

('protected String generateRandomString ( int length ) { Random random = new Random ( ) ; StringBuilder randomStringBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { randomStringBuilder . append ( Integer . toHexString ( random . nextInt ( 0x10 ) ) ) ; } return randomStringBuilder . toString ( ) ; } \n', 0.42714600374995665)

("public static String generateRandomString ( int length ) { char [ ] characters = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char start , end ; switch ( random . nextInt ( 4 ) ) { case 0 : start = 'A' ; end = 'Z' ; case 1 : start = '0' ; end = '9' ; default : start = 'a' ; end = 'z' ; } characters [ i ] = ( char ) ( start + random . nextInt ( end - start ) ) ; } return new String ( characters ) ; } \n", 0.4237233491623514)

('public String generateRandomString ( final int length , final String notThis ) { final int maxTry = 777 ; int numOfTry = 0 ; String randomString = notThis ; while ( notThis . startsWith ( randomString ) && numOfTry < maxTry ) { randomString = generateRandomString ( length ) ; numOfTry ++ ; } if ( numOfTry >= maxTry ) { Assert . fail ( "Could-not-generate-" + length + "-length-random-string-that-differs-from-\'" + notThis + "\'-within-" + numOfTry + "trials.-Go-and-buy-a-lottery!" ) ; } return randomString ; } \n', 0.4230566730728814)

('private static String generateRandomString ( int length ) { String allowedChars = "0123456789abcdefghijklmnopqrstuvwxyz" ; Random random = new Random ( ) ; int max = allowedChars . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int value = random . nextInt ( max ) ; buffer . append ( allowedChars . charAt ( value ) ) ; } return buffer . toString ( ) ; } \n', 0.42009728664531476)

('private static String generateRandomString ( int length ) { StringBuilder result = new StringBuilder ( length ) ; byte [ ] bytes = new byte [ length ] ; random . nextBytes ( bytes ) ; for ( int i = 0 ; i < bytes . length ; i ++ ) { result . append ( BASE64_ALPHABET [ bytes [ i ] & 0x3F ] ) ; } return result . toString ( ) ; } \n', 0.4186660656578442)

('public static String generateRandomString ( int count ) { Random random = new Random ( ) ; StringBuffer buffer = new StringBuffer ( ) ; while ( count -- != 0 ) { char ch = ( char ) ( random . nextInt ( 96 ) + 32 ) ; buffer . append ( ch ) ; } return buffer . toString ( ) ; } \n', 0.41864125499838556)

('static String generateRandomString ( int size , Long seed ) { char [ ] alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" . toCharArray ( ) ; java . util . Random rand = new java . util . Random ( seed ) ; StringBuilder huge = new StringBuilder ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { huge . append ( alphabet [ rand . nextInt ( alphabet . length ) ] ) ; } return huge . toString ( ) ; } \n', 0.41812216490441545)FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public static String printArray ( byte [ ] array ) { return printArray ( array , false ) ; } \n', 0.34633338623158627)

('public void printBitArrays ( ) { for ( ArrayList < Integer > bitArray : bitArrays ) { for ( Integer bit : bitArray ) { System . out . print ( bit . intValue ( ) ) ; } System . out . println ( ) ; } } \n', 0.33993759585503436)

('public static final String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

('public static String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

('public static String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

('public static final String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

('private void printArrayProperty ( final StringBuffer sb , final String prefix , final Object array ) { final int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i ++ ) { final Object obj = Array . get ( array , i ) ; printProperty ( sb , String . format ( "%s[%s]" , prefix , i ) , obj ) ; } } \n', 0.3253721760862642)

('protected void printObjectArrayContents ( Object objectArrayToPrint ) { Object [ ] arrayToPrint = ( Object [ ] ) objectArrayToPrint ; System . out . print ( "-RESULT:-" ) ; for ( int i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( i > 0 ) { System . out . print ( ",-" ) ; } System . out . print ( arrayToPrint [ i ] ) ; } System . out . println ( "-" ) ; } \n', 0.3253158161385643)

('public void printIntArray ( int [ ] someArray ) { for ( int i = 0 ; i < someArray . length ; i ++ ) { System . out . print ( String . valueOf ( someArray [ i ] ) + "-" ) ; } System . out . println ( ) ; } \n', 0.31951465703922133)

('public static void printArray ( int [ ] a ) { printArray ( null , a ) ; } \n', 0.31926721743453024)FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

('public static < K , V extends Comparable < ? super V >> List < Map . Entry < K , V >> SortMapByValue ( Map < K , V > map ) { List < Map . Entry < K , V >> infoIds = new ArrayList < Map . Entry < K , V >> ( map . entrySet ( ) ) ; Comparator < Map . Entry < K , V >> c = new Comparator < Map . Entry < K , V >> ( ) { public int compare ( Map . Entry < K , V > o1 , Map . Entry < K , V > o2 ) { return o2 . getValue ( ) . compareTo ( o1 . getValue ( ) ) ; } } ; Collections . sort ( infoIds , c ) ; return infoIds ; } \n', 0.46335070684231483)

('public static < K , V extends Comparable < ? super V >> List < Pair < K , V >> sortMapByValue ( Map < K , V > map ) { List < Pair < K , V >> result = new ArrayList < Pair < K , V >> ( ) ; for ( Map . Entry < K , V > e : map . entrySet ( ) ) result . add ( new Pair < K , V > ( e . getKey ( ) , e . getValue ( ) ) ) ; Util . sortPairsBySecondElement ( result ) ; return result ; } \n', 0.4616939645497932)

('public static < K , V extends Comparable < ? super V >> Map < K , V > sortMapByValues ( final Map < K , V > mapToSort ) { ArrayList < Map . Entry < K , V >> entries = new ArrayList < Map . Entry < K , V >> ( mapToSort . size ( ) ) ; entries . addAll ( mapToSort . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < K , V >> ( ) { @ Override public int compare ( final Map . Entry < K , V > entry1 , final Map . Entry < K , V > entry2 ) { return entry2 . getValue ( ) . compareTo ( entry1 . getValue ( ) ) ; } } ) ; Map < K , V > sortedMap = new LinkedHashMap < K , V > ( ) ; for ( Map . Entry < K , V > entry : entries ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46044583584318677)

('public < K , V extends Comparable < ? super V >> Map < K , V > sortMapByValues ( final Map < K , V > mapToSort ) { List < Map . Entry < K , V >> entries = new ArrayList < Map . Entry < K , V >> ( mapToSort . size ( ) ) ; entries . addAll ( mapToSort . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < K , V >> ( ) { public int compare ( final Map . Entry < K , V > entry1 , final Map . Entry < K , V > entry2 ) { return entry1 . getValue ( ) . compareTo ( entry2 . getValue ( ) ) ; } } ) ; Map < K , V > sortedMap = new LinkedHashMap < K , V > ( ) ; for ( Map . Entry < K , V > entry : entries ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46044583584318677)

('public static < K , V > LinkedHashMap < K , V > sortMapEntriesByValueAndByKey ( final Map < K , V > map ) { LinkedHashMap < K , V > result = new LinkedHashMap < K , V > ( map . size ( ) ) ; LinkedHashMap < K , V > orderedSubMapWithDifferentValues = sortMapByValue ( getSubMapWithDifferentValues ( map ) , SortingOrder . ASCENDING ) ; List < Map . Entry < K , V >> subSetWithDifferentValues = new LinkedList < Map . Entry < K , V >> ( orderedSubMapWithDifferentValues . entrySet ( ) ) ; for ( Map . Entry < K , V > entry : subSetWithDifferentValues ) { V value = entry . getValue ( ) ; LinkedHashMap < K , V > orderedSubMapWithGivenValue = sortMapByKey ( getSubMapWithGivenValue ( map , value ) , SortingOrder . ASCENDING ) ; List < Map . Entry < K , V >> subSetWithGivenValue = new LinkedList < Map . Entry < K , V >> ( orderedSubMapWithGivenValue . entrySet ( ) ) ; for ( Map . Entry < K , V > orderedEntry : subSetWithGivenValue ) { K orderedEntryKey = orderedEntry . getKey ( ) ; V orderedEntryValue = orderedEntry . getValue ( ) ; result . put ( orderedEntryKey , orderedEntryValue ) ; } } return result ; } \n', 0.46019222423325123)

('public final static < K , V > LinkedHashMap < K , V > sortMapByValue ( Map < K , V > unsortedMap , final Comparator < V > comparator ) { if ( unsortedMap . size ( ) <= 1 ) return new LinkedHashMap < K , V > ( unsortedMap ) ; List < Map . Entry < K , V >> entryList = new ArrayList < Map . Entry < K , V >> ( unsortedMap . entrySet ( ) ) ; Collections . sort ( entryList , new Comparator < Map . Entry < K , V >> ( ) { @ Override public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return comparator . compare ( o1 . getValue ( ) , o2 . getValue ( ) ) ; } } ) ; LinkedHashMap < K , V > sortedMap = new LinkedHashMap < K , V > ( unsortedMap . size ( ) ) ; for ( Map . Entry < K , V > entry : entryList ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.459700214909065)

('public < K , V extends Comparable < ? super V >> Map < K , V > sortMapByValue ( final Map < K , V > mapToSort ) { List < Map . Entry < K , V >> entries = new ArrayList < Map . Entry < K , V >> ( mapToSort . size ( ) ) ; entries . addAll ( mapToSort . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < K , V >> ( ) { public int compare ( final Map . Entry < K , V > entry1 , final Map . Entry < K , V > entry2 ) { return entry1 . getValue ( ) . compareTo ( entry2 . getValue ( ) ) ; } } ) ; Map < K , V > sortedMap = new LinkedHashMap < K , V > ( ) ; for ( Map . Entry < K , V > entry : entries ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.45576209530566925)

('public static List sortMapByValue ( Map < String , Integer > map ) { List list = new ArrayList < Entry > ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { Entry obj1 = ( Entry ) o1 ; Entry obj2 = ( Entry ) o2 ; return ( ( Integer ) obj2 . getValue ( ) ) . compareTo ( ( Integer ) obj1 . getValue ( ) ) ; } } ) ; return list ; } \n', 0.45214780601538956)

('public static List < Entry < Team , Double >> sortMapWithValues ( Map < Team , Double > map ) { List < Entry < Team , Double >> list = new ArrayList < > ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Entry < Team , Double >> ( ) { public int compare ( Entry < Team , Double > one , Entry < Team , Double > two ) { return one . getValue ( ) . compareTo ( two . getValue ( ) ) ; } } ) ; return list ; } \n', 0.45042077040977474)FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
('public String doSquareRootsMath ( ArrayList < String > mathSymbolsToCompute , ArrayList < Double > mathNumbersToCompute , int isThereASquareRoot ) { double myNumberToTakeSquareRootOf = mathNumbersToCompute . get ( isThereASquareRoot ) ; if ( myNumberToTakeSquareRootOf < 0 ) return ( "ERROR" ) ; else { double mySquareRootedNumber = Math . sqrt ( myNumberToTakeSquareRootOf ) ; double myTruncatedSquareRootedNumber = truncateMyDecimal ( mySquareRootedNumber ) ; mathSymbolsToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . add ( isThereASquareRoot , mySquareRootedNumber ) ; return ( String . valueOf ( myTruncatedSquareRootedNumber ) ) ; } } \n', 0.2772193949730584)

('public RealMatrix getSquareRoot ( ) { if ( ! isSymmetric ) { throw new MathUnsupportedOperationException ( ) ; } final double [ ] sqrtEigenValues = new double [ realEigenvalues . length ] ; for ( int i = 0 ; i < realEigenvalues . length ; i ++ ) { final double eigen = realEigenvalues [ i ] ; if ( eigen <= 0 ) { throw new MathUnsupportedOperationException ( ) ; } sqrtEigenValues [ i ] = FastMath . sqrt ( eigen ) ; } final RealMatrix sqrtEigen = MatrixUtils . createRealDiagonalMatrix ( sqrtEigenValues ) ; final RealMatrix v = getV ( ) ; final RealMatrix vT = getVT ( ) ; return v . multiply ( sqrtEigen ) . multiply ( vT ) ; } \n', 0.2488529753303889)

('private void resetSquareStates ( int screenWidth , int screenHeight ) { for ( int x = getDrawIndexX ( ) ; x < squares . length && x * Square . SQUARE_DIMENSION + baseX < screenWidth ; x ++ ) { for ( int y = getDrawIndexY ( ) ; y < squares [ x ] . length && y * Square . SQUARE_DIMENSION + baseY < screenHeight ; y ++ ) { squares [ x ] [ y ] . setState ( Button . STATE_IDLE ) ; } } } \n', 0.22996006092020027)

('public static double logRootMeanSquare ( double [ ] samples ) { assert samples . length > 0 ; double sumOfSquares = 0.0f ; for ( double sample : samples ) { sumOfSquares += sample * sample ; } double rootMeanSquare = Math . sqrt ( sumOfSquares / samples . length ) ; rootMeanSquare = Math . max ( rootMeanSquare , 1 ) ; return ( LogMath . log10 ( ( float ) rootMeanSquare ) * 20 ) ; } \n', 0.2191175718171015)

('private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.21810060821739316)

('private static RealMatrix squareRoot ( final RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.21810060821739316)

('private int determine ( TreeNode root ) { if ( root == null ) { return 0 ; } else { int leftDepth = determine ( root . left ) ; int rightDepth = determine ( root . right ) ; if ( leftDepth < 0 || rightDepth < 0 || Math . abs ( leftDepth - rightDepth ) > 1 ) return - 1 ; return Math . max ( leftDepth , rightDepth ) + 1 ; } } \n', 0.2150927644903356)

('private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.20787253667564554)

('private static RealMatrix squareRoot ( final RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i ++ ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \n', 0.2078725366756455)

('public final double rootMeanPriorSquaredError ( ) { return m_delegate . rootMeanPriorSquaredError ( ) ; } \n', 0.20315402344283728)FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
('public byte [ ] concatenateTwoByteArrays ( byte [ ] a , byte [ ] b ) { byte [ ] c = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } \n', 0.34917792092265965)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , final Object [ ] three , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 3 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; matrix [ 2 ] = three ; return concatArrays ( matrix ) ; } \n', 0.34365154097903006)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 2 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; return concatArrays ( matrix ) ; } \n', 0.32860896141681817)

('public static < A extends Comparable < A > , B > void sortTwoArrays ( A [ ] firstArray , B [ ] secondArray ) { if ( firstArray . length != secondArray . length ) { throw new RuntimeException ( "Both-arrays-must-be-of-the-same-length" ) ; } class element { public A first ; public B second ; } element [ ] elements = new element [ firstArray . length ] ; Arrays . sort ( elements , new Comparator < element > ( ) { public int compare ( element a , element b ) { return a . first . compareTo ( b . first ) ; } } ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { firstArray [ i ] = elements [ i ] . first ; secondArray [ i ] = elements [ i ] . second ; } } \n', 0.3259440797441201)

('private String [ ] concatenateArraysForInput ( String [ ] param , String [ ] value ) { String [ ] array = ( String [ ] ) Array . newInstance ( param [ 0 ] . getClass ( ) , param . length + value . length ) ; int j = 0 ; if ( param . length == value . length ) { for ( int i = 0 ; i < param . length ; i ++ ) { if ( i == 0 ) j = j + i ; else j = j + 1 ; array [ j ] = param [ i ] ; j = j + 1 ; array [ j ] = value [ i ] ; } } else { logger . warn ( "WARNING:-Check-your-array-size" ) ; } return array ; } \n', 0.3249121396561949)

('public static void sortBubbleTwo ( int [ ] array ) { try { for ( int end = 0 ; end < array . length - 1 ; end ++ ) { for ( int index = 0 ; index < array . length - end - 1 ; index ++ ) { if ( array [ index ] > array [ index + 1 ] ) { int temp = array [ index ] ; array [ index ] = array [ index + 1 ] ; array [ index + 1 ] = temp ; System . out . println ( Arrays . toString ( array ) ) ; } } } } catch ( NullPointerException e ) { System . out . println ( "Array-is-empty!" ) ; } System . out . println ( ) ; } \n', 0.3212984501886853)

('public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( Objects . isEmpty ( array1 ) ) { return array2 ; } if ( Objects . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArr , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArr , array1 . length , array2 . length ) ; return newArr ; } \n', 0.31814045405613983)

('public static < T > T [ ] concatenateArrays ( T [ ] first , T [ ] ... rest ) { int totalLength = first . length ; for ( T [ ] array : rest ) { totalLength += array . length ; } T [ ] result = Arrays . copyOf ( first , totalLength ) ; int offset = first . length ; for ( T [ ] array : rest ) { System . arraycopy ( array , 0 , result , offset , array . length ) ; offset += array . length ; } return result ; } \n', 0.31546183172548464)

('private static < T > void concatenateArrays ( Iterable < T [ ] > arraysToConcatenate , T [ ] destination ) { int nextStartIndexToUse = 0 ; for ( T [ ] array : arraysToConcatenate ) { System . arraycopy ( array , 0 , destination , nextStartIndexToUse , array . length ) ; nextStartIndexToUse += array . length ; } } \n', 0.31076428099890496)

('public static java . lang . Object concatenateArrays ( Class < ? > resultClass , java . lang . Object arr1 , java . lang . Object arr2 ) throws ArrayStoreException { if ( arr1 == null ) { return arr2 ; } else if ( arr2 == null ) { return arr1 ; } java . lang . Object newArray = Array . newInstance ( resultClass , Array . getLength ( arr1 ) + Array . getLength ( arr2 ) ) ; System . arraycopy ( arr1 , 0 , newArray , 0 , Array . getLength ( arr1 ) ) ; System . arraycopy ( arr2 , 0 , newArray , Array . getLength ( arr1 ) , Array . getLength ( arr2 ) ) ; return newArray ; } \n', 0.30608763426169416)FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public static IFile createFile ( IFile file , String contents ) throws CoreException { if ( contents == null ) { contents = "" ; } InputStream inputStream = new ByteArrayInputStream ( contents . getBytes ( ) ) ; file . create ( inputStream , true , NULL_MONITOR ) ; resourcesCreated . add ( file ) ; return file ; } \n', 0.3275443751617292)

('public void createDefaultDescriptor ( String templateString , String version ) { String content = MessageFormat . format ( templateString , version , version . replace ( \'.\' , \'_\' ) ) ; try { this . file . create ( new ByteArrayInputStream ( content . getBytes ( "UTF-8" ) ) , IResource . FORCE , null ) ; } catch ( Exception e ) { LiferayCore . logError ( e ) ; } } \n', 0.325752171618943)

("static File createTempFileWithContent ( @ NotNull String namePrefix , @ NotNull String nameSuffix , @ NotNull String content ) throws IOException { namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '|' ) + 1 ) ; namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '/' ) + 1 ) ; namePrefix = namePrefix . replace ( '.' , '_' ) ; File tempFile = File . createTempFile ( namePrefix , nameSuffix ) ; tempFile . deleteOnExit ( ) ; final BufferedOutputStream stream = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; stream . write ( content . getBytes ( ) ) ; stream . close ( ) ; return tempFile ; } \n", 0.32362114274295406)

('public void writeRequiredString ( final File rootDir , final String fileName , final String content ) throws NLBIOException , NLBFileManipulationException , NLBVCSException { ByteArrayInputStream inputStream = null ; try { try { final File file = new File ( rootDir , fileName ) ; final boolean newFile = ! file . exists ( ) ; if ( content != null ) { inputStream = ( new ByteArrayInputStream ( content . getBytes ( Constants . UNICODE_ENCODING ) ) ) ; writeFile ( file , inputStream ) ; addToVCS ( file , newFile ) ; } else { createFile ( file , "Cannot-create-file-with-name-" + fileName ) ; } } finally { if ( inputStream != null ) inputStream . close ( ) ; } } catch ( IOException e ) { throw new NLBIOException ( "IOException-occured" , e ) ; } } \n', 0.32185125644468643)

('public static IClassFileReader createDefaultClassFileReader ( String fileName , int decodingFlag ) { try { return new ClassFileReader ( Util . getFileByteContent ( new File ( fileName ) ) , decodingFlag ) ; } catch ( ClassFormatException e ) { return null ; } catch ( IOException e ) { return null ; } } \n', 0.3214545314844175)

('private ByteArrayInputStream createFileContents ( File CFML ) { StringBuffer buf = new StringBuffer ( ) ; writeCFMLString ( CFML , buf , 0 ) ; return new ByteArrayInputStream ( buf . toString ( ) . getBytes ( ) ) ; } \n', 0.32052405286943625)

('private static void createFile ( File f , String s ) throws IOException { InputStream is = new ByteArrayInputStream ( s . getBytes ( ) ) ; FileOutputStream fos = new FileOutputStream ( f ) ; IOUtils . copyBytes ( is , fos , s . length ( ) , true ) ; } \n', 0.3198852405716093)

('private byte [ ] createGraphAsByteArray ( String command , File workDir ) throws IOException , RrdException { String [ ] commandArray = StringUtils . createCommandArray ( command ) ; Process process ; try { process = Runtime . getRuntime ( ) . exec ( commandArray , null , workDir ) ; } catch ( IOException e ) { IOException newE = new IOException ( "IOException-thrown-while-executing-command-\'" + command + "\'-in-" + workDir . getAbsolutePath ( ) + ":-" + e ) ; newE . initCause ( e ) ; throw newE ; } byte [ ] byteArray = FileCopyUtils . copyToByteArray ( process . getInputStream ( ) ) ; String errors = FileCopyUtils . copyToString ( new InputStreamReader ( process . getErrorStream ( ) ) ) ; if ( errors . length ( ) > 0 && errors . contains ( IGNORABLE_LIBART_WARNING_STRING ) ) { LOG . debug ( "Ignoring-libart-warning-message-in-rrdtool-stderr-stream:-{}" , IGNORABLE_LIBART_WARNING_STRING ) ; errors = errors . replaceAll ( IGNORABLE_LIBART_WARNING_REGEX , "" ) ; } if ( errors . length ( ) > 0 ) { throw new RrdException ( errors ) ; } return byteArray ; } \n', 0.311991109445073)

('public static IFile createFile ( IFile file , String contents ) throws CoreException { if ( contents == null ) { contents = "" ; } InputStream inputStream = new ByteArrayInputStream ( contents . getBytes ( ) ) ; file . create ( inputStream , true , NULL_MONITOR ) ; resourcesCreated . add ( file ) ; return file ; } \n', 0.3117839236525898)

('public AttachedFile createAttachedFile ( String filename , ReagentAttachedFileType fileType , LocalDate fileDate , String fileContents ) throws IOException { return createAttachedFile ( filename , fileType , fileDate , new ByteArrayInputStream ( fileContents . getBytes ( ) ) ) ; } \n', 0.3113049658613942)FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

('static String convertStackTrace ( Throwable t , boolean appendOutputError ) { StackTraceWriter writer = new StackTraceWriter ( appendOutputError ) ; t . printStackTrace ( new PrintWriter ( writer ) ) ; return writer . toString ( ) . replaceAll ( "%" , "%%" ) ; } \n', 0.43406566344828357)

('private static String toStackTraceString ( Throwable t ) { if ( t == null ) { return "" ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; t . printStackTrace ( ps ) ; ps . close ( ) ; return baos . toString ( ) ; } \n', 0.41839505334547444)

('public static String stackTraceToString ( Exception e ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; e . printStackTrace ( ps ) ; return baos . toString ( ) ; } \n', 0.41468458470020025)

('public String stackTraceToString ( Exception e ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( bos ) ; e . printStackTrace ( ps ) ; return bos . toString ( ) ; } \n', 0.41434265053008845)

('public static String stackTraceToString ( final Exception e ) { ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; PrintStream p = new PrintStream ( b ) ; e . printStackTrace ( p ) ; p . flush ( ) ; return b . toString ( ) ; } \n', 0.413917990863644)

('public static String stackTraceToString ( Throwable e ) { if ( e == null ) { return "" ; } ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; PrintWriter writer = new PrintWriter ( stream ) ; e . printStackTrace ( writer ) ; writer . flush ( ) ; return stream . toString ( ) ; } \n', 0.4138649935804521)

('public static String stackTraceToString ( Exception ex ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pwWriter = new PrintWriter ( baos , true ) ; ex . printStackTrace ( pwWriter ) ; return baos . toString ( ) ; } \n', 0.413770755558009)

('public static String stackTraceToString ( final Throwable th ) { ByteArrayOutputStream baos = null ; try { baos = new ByteArrayOutputStream ( 1000 ) ; final PrintStream ps = new PrintStream ( baos ) ; th . printStackTrace ( ps ) ; return baos . toString ( ) ; } finally { if ( baos != null ) { try { baos . flush ( ) ; baos . close ( ) ; } catch ( final IOException e ) { ignoreException ( e , "doesn\'t-make-sense-to-report-at-close" ) ; } } } } \n', 0.4137372974662509)

('public static final String stackTraceToString ( Throwable t ) { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; PrintStream out = new PrintStream ( buf ) ; t . printStackTrace ( out ) ; out . flush ( ) ; return ( buf . toString ( ) ) ; } \n', 0.41298986204811183)FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('private static int compareStringForChinese ( String s1 , String s2 ) { String m_s1 = null , m_s2 = null ; try { m_s1 = new String ( s1 . getBytes ( "GB2312" ) , "GBK" ) ; m_s2 = new String ( s2 . getBytes ( "GB2312" ) , "GBK" ) ; } catch ( Exception ex ) { LOGGER . error ( "compareStringForChineseError" , ex ) ; return s1 . compareTo ( s2 ) ; } int res = chineseCompareTo ( m_s1 , m_s2 ) ; return res ; } \n', 0.33881479899367073)

('private static int compareIntString ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) { return 0 ; } try { int i1 = Integer . parseInt ( s1 ) ; int i2 = Integer . parseInt ( s2 ) ; return compareInts ( i1 , i2 ) ; } catch ( Exception e ) { return s1 . compareToIgnoreCase ( s2 ) ; } } \n', 0.33263121036324106)

('private static boolean compareStringInt ( String string , int val ) { try { if ( Integer . valueOf ( string ) >= val ) { return true ; } } catch ( Exception e ) { } return false ; } \n', 0.3264600298998179)

('public static int compareVersions ( String version1 , String version2 ) { List < Object > version1Parts = splitVersion ( version1 ) ; List < Object > version2Parts = splitVersion ( version2 ) ; int i = 0 ; for ( ; i < version1Parts . size ( ) || i < version2Parts . size ( ) ; i ++ ) { Object version1Part = i < version1Parts . size ( ) ? convertPreReleaseVersion ( version1Parts . get ( i ) ) : BigInteger . ZERO ; Object version2Part = i < version2Parts . size ( ) ? convertPreReleaseVersion ( version2Parts . get ( i ) ) : BigInteger . ZERO ; if ( version1Part . getClass ( ) == version2Part . getClass ( ) ) { @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) int comparison = ( ( Comparable ) version1Part ) . compareTo ( version2Part ) ; if ( comparison != 0 ) { return comparison ; } } else if ( version1Part instanceof String ) { return 1 ; } else { return - 1 ; } } return 0 ; } \n', 0.314596342425417)

('static int compareIntStrings ( String int1 , String int2 ) throws NumberFormatException { if ( int1 . equals ( int2 ) ) return 0 ; Integer i1 = NumberUtil . parseInt ( int1 ) ; Integer i2 = NumberUtil . parseInt ( int2 ) ; return i1 . compareTo ( i2 ) ; } \n', 0.3102125338138299)

('private static int compareConverted ( Object track1 , Object track2 ) { if ( track1 instanceof Long ) { if ( track2 instanceof Long ) { return ( ( Long ) track1 ) . compareTo ( ( Long ) track2 ) ; } else if ( track2 instanceof String ) { return 1 ; } else { throw new IllegalArgumentException ( "track2-must-be-an-instance-of-String-or-Long" ) ; } } else if ( track1 instanceof String ) { if ( track2 instanceof Long ) { return - 1 ; } else if ( track2 instanceof String ) { return ( ( String ) track1 ) . compareTo ( ( String ) track2 ) ; } else { throw new IllegalArgumentException ( "track2-must-be-an-instance-of-String-or-Long" ) ; } } else { throw new IllegalArgumentException ( "track1-must-be-an-instance-of-String-or-Long" ) ; } } \n', 0.30499477773396944)

('private static boolean compareArray ( String str , int comparator , Object [ ] objArr ) { for ( int i2 = 0 ; i2 < objArr . length ; i2 ++ ) { Object obj = objArr [ i2 ] ; if ( obj instanceof String ) { if ( compareString ( str , comparator , ( String ) obj ) ) { return true ; } } else if ( obj instanceof Number ) { if ( compareNumber ( str , comparator , ( Number ) obj ) ) { return true ; } } else if ( ( obj instanceof Comparable ) && compareReflective ( str , comparator , ( Comparable ) obj ) ) { return true ; } } return false ; } \n', 0.30420597704890984)

('private int comparePrefixed ( final Method m1 , final Method m2 ) { try { if ( m1 . equals ( m2 ) ) return 0 ; final String [ ] m1Tokens = Strings . splitString ( m1 . getName ( ) , TransformationUtil . DELIMITER ) ; final String [ ] m2Tokens = Strings . splitString ( m2 . getName ( ) , TransformationUtil . DELIMITER ) ; final String m1Name = m1Tokens [ 1 ] ; final String m2Name = m2Tokens [ 1 ] ; if ( ! m1Name . equals ( m2Name ) ) { return m1Name . compareTo ( m2Name ) ; } final Class [ ] args1 = m1 . getParameterTypes ( ) ; final Class [ ] args2 = m2 . getParameterTypes ( ) ; if ( args1 . length < args2 . length ) return - 1 ; if ( args1 . length > args2 . length ) return 1 ; for ( int i = 0 ; i < args1 . length ; i ++ ) { int result = TypeConverter . convertTypeToJava ( args1 [ i ] ) . compareTo ( TypeConverter . convertTypeToJava ( args2 [ i ] ) ) ; if ( result != 0 ) return result ; } } catch ( Throwable e ) { throw new WrappedRuntimeException ( e ) ; } java . lang . System . err . println ( m1 . getName ( ) ) ; java . lang . System . err . println ( m2 . getName ( ) ) ; throw new Error ( "should-be-unreachable" ) ; } \n', 0.292587361883906)

('private int compareStrings ( final String segment1 , final String segment2 , final boolean numeric1 , final boolean numeric2 ) { int stringCompare = segment1 . compareTo ( segment2 ) ; if ( stringCompare == 0 ) { return stringCompare ; } else { if ( numeric1 && numeric2 ) { return new BigInteger ( segment1 ) . compareTo ( new BigInteger ( segment2 ) ) ; } else { return stringCompare ; } } } \n', 0.2912280828237811)

('public boolean compareString ( final Object comp1 , final String comp2 ) throws WmiException { if ( comp1 instanceof String ) { try { final DateFormat fmt2 = new SimpleDateFormat ( "MM/dd/yyyy-HH:mm:ss" ) ; final Date date1 = WmiClient . convertWmiDate ( ( String ) comp1 ) ; final Date date2 = fmt2 . parse ( comp2 ) ; return compareToDate ( date1 , date2 ) ; } catch ( ParseException e ) { } return compareToString ( ( String ) comp1 , comp2 ) ; } else if ( comp1 instanceof Integer ) { final Integer compInt1 = ( Integer ) comp1 ; final Integer compInt2 = Integer . parseInt ( comp2 ) ; return compareToInteger ( compInt1 , compInt2 ) ; } else if ( comp1 instanceof Boolean ) { final Boolean bool1 = ( Boolean ) comp1 ; final Boolean bool2 = Boolean . parseBoolean ( comp2 ) ; return compareToBoolean ( bool1 , bool2 ) ; } else if ( comp1 instanceof Float ) { final Float fl1 = ( Float ) comp1 ; final Float fl2 = Float . parseFloat ( comp2 ) ; return compareToFloat ( fl1 , fl2 ) ; } else if ( comp1 instanceof Date ) { final DateFormat fmt = new SimpleDateFormat ( "MM/dd/yyyy-HH:mm:ss" ) ; final Date date1 = ( Date ) comp1 ; Date date2 ; try { date2 = fmt . parse ( comp2 ) ; } catch ( ParseException e ) { throw new WmiException ( "Parsing-date-\'" + comp2 + "\'-failed:-" + e . getMessage ( ) , e ) ; } return compareToDate ( date1 , date2 ) ; } return false ; } \n', 0.2910659296410715)FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public static String [ ] splitByDelimiter ( String toSplit , int numPieces ) { String [ ] pieces = toSplit . split ( BidirectionalConverter . DELIMITER ) ; if ( pieces . length > numPieces ) { throw new IllegalArgumentException ( "Cannot-convert-string-"" + toSplit + ""-with-an-invalid-number-of-properties." ) ; } else if ( pieces . length < numPieces ) { String [ ] allPieces = new String [ numPieces ] ; int i = 0 ; for ( String piece : pieces ) { allPieces [ i ] = piece ; i ++ ; } for ( ; i < numPieces ; i ++ ) { allPieces [ i ] = "" ; } return allPieces ; } return pieces ; } \n', 0.3769382912414708)

('public static String [ ] split ( String input ) { if ( input . startsWith ( "{" ) && input . endsWith ( "}" ) ) { List < String > result = new ArrayList < > ( ) ; int openBracket = 0 ; Integer lastStartIdx = null ; for ( int i = 0 ; i < input . length ( ) ; i ++ ) { char c = input . charAt ( i ) ; if ( c == \'{\' ) { openBracket ++ ; if ( lastStartIdx == null ) { lastStartIdx = i ; } } if ( c == \'}\' ) { openBracket -- ; if ( openBracket == 0 && lastStartIdx != null ) { String substring = input . substring ( lastStartIdx , i + 1 ) ; result . add ( substring ) ; lastStartIdx = null ; } } } return result . toArray ( new String [ result . size ( ) ] ) ; } return Strings . split ( input , \',\' ) ; } \n', 0.36912785073642684)

('public static int [ ] splitInts ( String str ) throws IllegalArgumentException { StringTokenizer tokenizer = new StringTokenizer ( str , "," ) ; int n = tokenizer . countTokens ( ) ; int [ ] list = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String token = tokenizer . nextToken ( ) ; list [ i ] = Integer . parseInt ( token ) ; } return list ; } \n', 0.3662529916951369)

('private int [ ] splitStringToInt ( String input , String delimiter ) { if ( input == null || delimiter == null ) { return null ; } String strArray [ ] = input . split ( delimiter ) ; try { int intArray [ ] = new int [ strArray . length ] ; for ( int i = 0 ; i < strArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( strArray [ i ] ) ; } return intArray ; } catch ( NumberFormatException e ) { } return null ; } \n', 0.36229797872006)

('public static int [ ] splitToInt ( String source , String by ) { if ( source == null || by == null ) return null ; String [ ] strs = source . split ( by ) ; int [ ] ints = new int [ strs . length ] ; for ( int i = 0 ; i < strs . length ; i ++ ) ints [ i ] = Integer . parseInt ( strs [ i ] ) ; return ints ; } \n', 0.3476891382090288)

('public static int [ ] splitToIntArray ( String contatenatedValue , String separator ) throws NumberFormatException { if ( TextUtils . isEmpty ( contatenatedValue ) ) return new int [ 0 ] ; String [ ] values = contatenatedValue . split ( separator ) ; int [ ] converted = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { int value = Integer . parseInt ( values [ i ] ) ; converted [ i ] = value ; } return converted ; } \n', 0.34736573150017513)

('public static long [ ] splitToLong ( String source , String by ) { if ( source == null || source . trim ( ) . length ( ) == 0 || by == null || by . trim ( ) . length ( ) == 0 ) return null ; String [ ] strs = source . split ( by ) ; long [ ] longs = new long [ strs . length ] ; for ( int i = 0 ; i < strs . length ; i ++ ) { longs [ i ] = Long . parseLong ( strs [ i ] ) ; } return longs ; } \n', 0.34575171036972574)

('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.3421195191429003)

('public static String [ ] regSplit ( String data ) { try { byte [ ] utf8 = data . getBytes ( "UTF8" ) ; String converted = new String ( utf8 , "UTF8" ) ; return converted . split ( "|s*[^0-9a-zA-Z\']+|s*" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.3385111259790645)

('private String [ ] splitValue ( String value ) { String [ ] splitted = value . split ( SubmissionLookupService . SEPARATOR_VALUE_REGEX ) ; String [ ] result = new String [ 6 ] ; result [ 0 ] = splitted [ 0 ] ; result [ 2 ] = "-1" ; result [ 3 ] = "-1" ; result [ 4 ] = "-1" ; if ( splitted . length > 1 ) { result [ 5 ] = "splitted" ; if ( StringUtils . isNotBlank ( splitted [ 1 ] ) ) { result [ 1 ] = splitted [ 1 ] ; } if ( splitted . length > 2 ) { result [ 2 ] = String . valueOf ( Integer . parseInt ( splitted [ 2 ] ) ) ; if ( splitted . length > 3 ) { result [ 3 ] = String . valueOf ( Integer . parseInt ( splitted [ 3 ] ) ) ; if ( splitted . length > 4 ) { result [ 4 ] = String . valueOf ( Integer . parseInt ( splitted [ 4 ] ) ) ; } } } } return result ; } \n', 0.33830439746741525)FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public void createOutputFile ( String fileName , String encoding , char separatorCharacter ) throws IOException { this . fileName = null ; this . fileEncoding = encoding ; this . separatorCharacter = separatorCharacter ; printStream = new PrintStream ( byteArrayOutputStream , true , encoding ) ; } \n', 0.36679149431844554)

('public static File createFileFromByteArray ( byte [ ] bytes , String pathAndFileName ) throws IOException { File outputFile = new File ( pathAndFileName ) ; FileOutputStream outputStream = null ; try { outputStream = new FileOutputStream ( outputFile ) ; outputStream . write ( bytes ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } finally { if ( outputStream != null ) { outputStream . close ( ) ; } } return outputFile ; } \n', 0.3435716880140346)

('public static void createFileFromByteArray ( byte [ ] fileBytes , String path , String name , String extension , boolean isImageFile ) throws Exception { if ( COMPILE_FOR_JAVA ) { String filename ; BufferedImage bufferedImage = null ; if ( fileBytes != null ) { try { if ( isImageFile ) { ByteArrayInputStream inputImage = new ByteArrayInputStream ( fileBytes ) ; bufferedImage = ImageIO . read ( inputImage ) ; filename = path + File . separatorChar + name + "." + ImageType . JPG . getType ( ) ; } else filename = path + File . separatorChar + name + "." + extension ; System . out . println ( "Creating-the-file:-" + filename ) ; FileOutputStream out = new FileOutputStream ( filename ) ; if ( isImageFile ) ImageIO . write ( bufferedImage , ImageType . JPG . getType ( ) , out ) ; else out . write ( fileBytes ) ; out . close ( ) ; } catch ( IOException ioE ) { System . err . println ( "-Received-an-unknown-object-type" ) ; } } else System . err . println ( "-Received-a-null-object-type-for-image" ) ; } else System . err . println ( ERROR_MESSAGE ) ; } \n', 0.339912530582718)

('private static boolean createJsonFile ( Context context , int type , File jsonFile ) { boolean result = false ; Writer writer = null ; PrintWriter pw = null ; try { if ( jsonFile . createNewFile ( ) ) { writer = new OutputStreamWriter ( new FileOutputStream ( jsonFile ) , "UTF-8" ) ; pw = new PrintWriter ( writer ) ; pw . println ( "{" ) ; pw . println ( "-"" + getArrayName ( type ) + "":[" ) ; pw . println ( "-]" ) ; pw . println ( "}" ) ; return true ; } else { LogUtil . e ( LogUtil . LOG_TAG , "JsonUtil.createJsonFile-:-create-error" ) ; } } catch ( IOException e ) { LogUtil . e ( LogUtil . LOG_TAG , "JsonUtil.createJsonFile-:-" + e . toString ( ) ) ; } finally { try { if ( pw != null ) { pw . close ( ) ; } if ( writer != null ) { writer . close ( ) ; } } catch ( IOException e ) { LogUtil . e ( LogUtil . LOG_TAG , "JsonUtil.createJsonFile-:-" + e . toString ( ) ) ; } } LogUtil . d ( LogUtil . LOG_TAG , "JsonUtil.writeToFile-result-:-" + result ) ; return result ; } \n', 0.32950587030440326)

('public boolean createStoredFile ( Context context , byte [ ] content , String mimeType ) { ByteArrayInputStream is = null ; try { is = new ByteArrayInputStream ( content ) ; return createStoredFile ( context , is , mimeType ) ; } catch ( FileNotFoundException e ) { Log . e ( "File-not-found-while-storing-file." , e ) ; } catch ( IOException e ) { Log . a ( "Error-storing-file." , e ) ; } finally { Util . ensureClosed ( is ) ; } return false ; } \n', 0.32684391014767666)

('private String createKeystoreFile ( ) throws IOException , FileOperationFailedException { InputStream keystoreFileStream = LDAPServer . class . getResourceAsStream ( DEFAULT_KEYSTORE_FILE ) ; byte [ ] keystoreData = IOUtils . toByteArray ( keystoreFileStream ) ; ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; outputStream . write ( keystoreData ) ; String keyStoreDirName = getDefaultKeyStoreDirPath ( ) ; File keystoreDir = new File ( keyStoreDirName ) ; if ( ! keystoreDir . exists ( ) ) { if ( ! keystoreDir . mkdirs ( ) ) { throw new FileOperationFailedException ( "create" , "directory" , keyStoreDirName ) ; } } keystoreDir . deleteOnExit ( ) ; _log . debug ( "Keystore-file-{}" , keyStoreDirName + DEFAULT_KEYSTORE_FILE ) ; File keystoreFile = new File ( keyStoreDirName + DEFAULT_KEYSTORE_FILE ) ; if ( keystoreFile . exists ( ) ) { if ( ! keystoreFile . delete ( ) ) { throw new FileOperationFailedException ( "delete" , "file" , keystoreFile . getAbsolutePath ( ) ) ; } } if ( ! keystoreFile . createNewFile ( ) ) { throw new FileOperationFailedException ( "create" , "file" , keystoreFile . getAbsolutePath ( ) ) ; } keystoreFile . setWritable ( true ) ; keystoreFile . deleteOnExit ( ) ; FileOutputStream keyStoreFileOutStream = new FileOutputStream ( keystoreFile ) ; outputStream . writeTo ( keyStoreFileOutStream ) ; outputStream . close ( ) ; keyStoreFileOutStream . close ( ) ; return keystoreFile . getAbsolutePath ( ) ; } \n', 0.3224187761238445)

('private String createStoreFile ( ) { String nameStoreFile = "Results" + "/" + this . userId + ".txt" ; File storeFile = new File ( nameStoreFile ) ; if ( ! storeFile . exists ( ) ) { try { storeFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; System . err . println ( "It-was-not-possible-to-create-a-file-where-to-store-the-results." ) ; System . exit ( 0 ) ; } try { Writer writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( storeFile , true ) , "UTF8" ) ) ; writer . write ( "NumberDevice" + "-" + "UserId" + "-" + "Block" + "-" + "Sequence" + "-" + "NumberClicks" + "-" + "NumberCircles" + "-" + "CircleID" + "-" + "DistanceCenter" + "-" + "PixelStartCircleX" + "-" + "PixelStartCircleY" + "-" + "PixelEndCircleX" + "-" + "PixelEndCircleY" + "-" + "TargetWidth" + "-" + "ElapsedTime" + "-" + "MouseX" + "-" + "MouseY" + "-" ) ; writer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( "It-was-not-possible-to-generate-the-header.-Now-exitting." ) ; System . exit ( 0 ) ; } } return nameStoreFile ; } \n', 0.31918397232730317)

('private static void writeClassFileByteToFileSystem ( byte [ ] toByteArray ) { File targetFile = new File ( "/home/heipacker/test.class" ) ; if ( ! targetFile . exists ( ) ) { try { if ( ! targetFile . createNewFile ( ) ) { throw new RuntimeException ( "create-" + targetFile . getAbsolutePath ( ) + "-file-failed" ) ; } } catch ( IOException e ) { logger . error ( "create-file-{}-failed" , targetFile . getAbsolutePath ( ) , e ) ; } } BufferedOutputStream bufferedOutputStream = null ; try { bufferedOutputStream = new BufferedOutputStream ( new FileOutputStream ( targetFile ) ) ; bufferedOutputStream . write ( toByteArray ) ; } catch ( IOException e ) { logger . error ( "write-data-to-file-{}-failed" , targetFile . getAbsolutePath ( ) , e ) ; } finally { try { if ( bufferedOutputStream != null ) { bufferedOutputStream . close ( ) ; } } catch ( IOException e ) { logger . error ( "close-file-{}-failed" , targetFile . getAbsolutePath ( ) , e ) ; } } } \n', 0.31495818435493583)

('public static void createFileFromByteArray ( byte [ ] fileByteArray , String url ) throws IOException { Path path = Paths . get ( url ) ; Files . write ( path , fileByteArray ) ; } \n', 0.3124853964681469)

('public static void writeStatsToFile ( Dolphin [ ] dolphins , String filename ) throws IOException { Dolphin [ ] dolphins2 = new Dolphin [ 62 ] ; System . arraycopy ( dolphins , 0 , dolphins2 , 0 , 62 ) ; Arrays . sort ( dolphins2 ) ; File output = new File ( filename ) ; FileWriter o = new FileWriter ( output ) ; PrintWriter out = new PrintWriter ( o ) ; int count = 0 ; int size = dolphins2 [ 0 ] . sizeOfNetwork ( ) ; for ( int i = 0 ; i < 62 ; i ++ ) { if ( dolphins2 [ i ] . sizeOfNetwork ( ) == size ) { count ++ ; } else { out . println ( size + "-" + count ) ; count = 1 ; size = dolphins [ i ] . sizeOfNetwork ( ) ; } } out . close ( ) ; } \n', 0.31017596426329275)FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

('protected void initialise ( Connection connection ) { if ( ! initialised ) { synchronized ( this ) { if ( ! initialised ) { Set accessorsToRemove = new HashSet ( ) ; Iterator i = accessorMutatorMap . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Method accessor = ( Method ) i . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; Object value = null ; try { value = accessor . invoke ( connection , null ) ; if ( value != null ) { defaultValues . put ( mutator , value ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Remembering-default-value:-" + accessor . getName ( ) + "()-=-" + value ) ; } } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + accessor . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } try { Object [ ] args = { value } ; mutator . invoke ( connection , args ) ; } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + mutator . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } } Iterator j = accessorsToRemove . iterator ( ) ; while ( j . hasNext ( ) ) { Method accessor = ( Method ) j . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; accessorMutatorMap . remove ( accessor ) ; defaultValues . remove ( mutator ) ; } initialised = true ; } } } } \n', 0.3899768502441775)

('public static Context initialise ( final Map environment ) throws NamingException { Context context ; if ( environment != null && environment . size ( ) > 0 ) { context = new InitialContext ( new Hashtable ( environment ) ) ; } else { context = new InitialContext ( ) ; } return context ; } \n', 0.38813912680444246)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.3795221908993608)

('private static void initialise ( ) { exitCodes = new HashSet < ExitCode > ( ) ; Map < String , String > resources = Resources . get ( ExitStatus . class ) ; for ( String key : resources . keySet ( ) ) { String mnemonic = key . substring ( 0 , key . indexOf ( ( int ) FULL_STOP ) ) ; String numericForm = key . substring ( key . indexOf ( ( int ) FULL_STOP ) + 1 ) ; String description = resources . get ( key ) ; int number = Integer . parseInt ( numericForm ) ; exitCodes . add ( new ExitCode ( number , mnemonic , description ) ) ; } } \n', 0.3787476293033488)

('protected void initialiseCommonFeatures ( Map < Integer , FeatureData > initialMap ) { super . initialiseFeatureMap ( initialMap ) ; commonFeaturesMap . putAll ( initialMap ) ; } \n', 0.3759403677907467)

('@ Override protected void doInitialise ( ) throws InitialisationException { authentications = new ConcurrentHashMap < String , Authentication > ( ) ; } \n', 0.37380482700435735)

('private void initialiseMetricMap ( ) { metricMap = new HashMap < EMethodMetricName , Integer > ( 50 ) ; EMethodMetricName [ ] metrics = EMethodMetricName . values ( ) ; for ( EMethodMetricName metric : metrics ) metricMap . put ( metric , 0 ) ; } \n', 0.3681996314523418)

('protected void initialiseFeatureMap ( Map < Integer , FeatureData > initialMap ) { featureMap . putAll ( initialMap ) ; } \n', 0.3664933131352133)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.36489232472833166)FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('private List < Exit > removeLoopExits ( Exit . Reason reason , String label ) { List < Exit > result = new ArrayList < Exit > ( ) ; for ( Iterator < Exit > i = currentExits . iterator ( ) ; i . hasNext ( ) ; ) { Exit exit = i . next ( ) ; if ( exit . reason == reason && ( exit . getLabel ( ) == null || exit . getLabel ( ) . equals ( label ) ) ) { i . remove ( ) ; result . add ( exit ) ; } } return result ; } \n', 0.3481193344252727)

('public void endAvoidNotify ( ) { avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.33474174737464607)

('public void endAvoidNotify ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.3324344539289146)

('protected static void processHopcountRemovalLists ( String outputName , IRepositoryConnector connector , IRepositoryConnection connection , IJobManager jobManager , List < QueuedDocument > hopcountremoveList , IIncrementalIngester ingester , Long jobID , String [ ] legalLinkTypes , OutputActivity ingestLogger , int hopcountMethod , IReprioritizationTracker rt , long currentTime ) throws ManifoldCFException { hopcountremoveList = removeFromIndex ( outputName , connection . getName ( ) , jobManager , hopcountremoveList , ingester , ingestLogger ) ; processJobQueueHopcountRemovals ( hopcountremoveList , connector , connection , jobManager , jobID , legalLinkTypes , hopcountMethod , rt , currentTime ) ; } \n', 0.33015115291897673)

('public Collection < Stmt > targetsOfLoopExit ( Stmt loopExit ) { assert getLoopExits ( ) . contains ( loopExit ) ; List < Unit > succs = g . getSuccsOf ( loopExit ) ; Collection < Stmt > res = new HashSet < Stmt > ( ) ; for ( Unit u : succs ) { Stmt s = ( Stmt ) u ; res . add ( s ) ; } res . removeAll ( loopStatements ) ; return res ; } \n', 0.3286593377256622)

('@ Override public final void exitLoopBody ( @ NotNull JetLoopExpression expression ) { LoopInfo info = loopInfo . pop ( ) ; elementToBlockInfo . remove ( expression ) ; allBlocks . pop ( ) ; bindLabel ( info . getBodyExitPoint ( ) ) ; } \n', 0.325965596626709)

('private BundleDescription [ ] internalGetRemovalPending ( ) { synchronized ( this . monitor ) { Iterator < BundleDescription > removed = removalPendings . iterator ( ) ; BundleDescription [ ] result = new BundleDescription [ removalPendings . size ( ) ] ; int i = 0 ; while ( removed . hasNext ( ) ) result [ i ++ ] = getBundle ( removed . next ( ) . getBundleId ( ) ) ; return result ; } } \n', 0.32542763232038174)

('protected static void processHopcountRemovalLists ( IPipelineConnections pipelineConnections , IRepositoryConnector connector , IRepositoryConnection connection , IJobManager jobManager , List < QueuedDocument > hopcountremoveList , IIncrementalIngester ingester , Long jobID , String [ ] legalLinkTypes , OutputActivity ingestLogger , int hopcountMethod , IReprioritizationTracker rt , long currentTime ) throws ManifoldCFException { hopcountremoveList = removeFromIndex ( pipelineConnections , connection . getName ( ) , jobManager , hopcountremoveList , ingester , ingestLogger ) ; processJobQueueHopcountRemovals ( hopcountremoveList , connector , connection , jobManager , jobID , legalLinkTypes , hopcountMethod , rt , currentTime ) ; } \n', 0.3244858569208755)

('protected static < T extends StoredObject > List < T > stripMarkedForRemoval ( List < T > list ) { for ( Iterator < T > i = list . iterator ( ) ; i . hasNext ( ) ; ) { T node = i . next ( ) ; if ( node . isMarkedForRemoval ( ) ) { i . remove ( ) ; } } return list ; } \n', 0.32162203877969087)

('public final void removeLoopExit ( LoopExitChord loopExit ) { if ( loopExit == null ) return ; if ( loopExits == loopExit ) { loopExits = null ; return ; } if ( loopExits instanceof Vector ) { @ SuppressWarnings ( "unchecked" ) Vector < LoopExitChord > c = ( Vector < LoopExitChord > ) loopExits ; if ( c . removeElement ( loopExit ) ) { int l = c . size ( ) ; if ( l == 0 ) loopExits = null ; else if ( l == 1 ) loopExits = c . elementAt ( 0 ) ; return ; } } throw new scale . common . InternalError ( "Not-a-loop-exit-" + loopExit + "-of-" + this ) ; } \n', 0.32114893119375504)FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('private String generateMd5 ( String message ) { String digest = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( message . getBytes ( "UTF-8" ) ) ; StringBuilder sb = new StringBuilder ( 2 * hash . length ) ; for ( byte b : hash ) { sb . append ( String . format ( "%02x" , b & 0xff ) ) ; } digest = sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } return digest ; } \n', 0.41984533143908476)

('public static String getSaltedMd5Hash ( String payload ) throws UnsupportedEncodingException , NoSuchAlgorithmException { final char [ ] saltRange = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" . toCharArray ( ) ; final StringBuilder sb = new StringBuilder ( ) ; final Random random = new Random ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { char c = saltRange [ random . nextInt ( saltRange . length ) ] ; sb . append ( c ) ; } final String salt = sb . toString ( ) ; return getMd5Hash ( salt + payload ) + ":" + salt ; } \n', 0.40422199249057467)

('private String generateRandomToken ( ) { Md5PasswordEncoder enconde = new Md5PasswordEncoder ( ) ; enconde . setEncodeHashAsBase64 ( true ) ; Long rawPass = new Date ( ) . getTime ( ) * new Random ( ) . nextLong ( ) ; return enconde . encodePassword ( rawPass . toString ( ) , null ) ; } \n', 0.3955433609408866)

('private static String generateMd5 ( final String value ) throws Exception { final byte [ ] digest = MESSAGE_DIGEST . get ( ) . digest ( value . getBytes ( UTF_8 ) ) ; Formatter formatter = null ; try { formatter = new Formatter ( ) ; for ( byte b : digest ) { formatter . format ( "%02x" , b ) ; } return formatter . toString ( ) . toLowerCase ( ) ; } finally { if ( formatter != null ) { formatter . close ( ) ; } } } \n', 0.39339220364584215)

('public static String generateNewMd5Salt ( ) { return MAGIC + generateNewSalt ( 8 ) + "$" ; } \n', 0.391791644595068)

('private Stack < CryptoCredit > generateHashChain ( final int length ) { final Stack < CryptoCredit > hashchain = new Stack < CryptoCredit > ( ) ; final MessageDigest mdb ; try { mdb = MessageDigest . getInstance ( HASH_ALGORITHM ) ; } catch ( final Exception e ) { System . err . println ( "Unable-to-create-hash-chain." ) ; if ( DEBUG_ERROR_TRACE ) e . printStackTrace ( ) ; return null ; } final SecureRandom random = new SecureRandom ( ) ; final byte [ ] hashChainSeed = new byte [ HASHCHAIN_SEED_BYTES ] ; random . nextBytes ( hashChainSeed ) ; byte [ ] nextValueToHash = hashChainSeed ; while ( hashchain . size ( ) < length ) { final CryptoCredit nextCredit = new CryptoCredit ( ) ; nextCredit . hash = mdb . digest ( nextValueToHash ) ; nextValueToHash = nextCredit . hash ; hashchain . push ( nextCredit ) ; } if ( DEBUG_GENERAL ) System . out . println ( "Generated-a-hash-chain-of-length-" + length + "-with-top-hash-of-"" + Utility . getHexValue ( nextValueToHash ) + ""." ) ; return hashchain ; } \n', 0.39140253818016446)

('private static String generateRandomString ( String algorithm ) { SecureRandom rand = new SecureRandom ( ) ; int random = rand . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; long id = Thread . currentThread ( ) . getId ( ) ; MessageDigest md = null ; String result = null ; try { md = MessageDigest . getInstance ( algorithm ) ; String input = random + time + id + SALT ; byte [ ] hashed = md . digest ( input . getBytes ( "UTF-8" ) ) ; result = new BigInteger ( 1 , hashed ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { log . error ( "cannot-generate-random-string" , e ) ; } catch ( UnsupportedEncodingException e ) { log . error ( "cannot-generate-random-string" , e ) ; } return result ; } \n', 0.3910866056352784)

('public static Guid generateGuidUsingMd5 ( String ... args ) { StringBuilder builder = new StringBuilder ( ) ; for ( String arg : args ) { builder . append ( arg ) ; } byte [ ] hash ; try { hash = MessageDigest . getInstance ( MD5_SECURITY_ALGORITHM ) . digest ( builder . toString ( ) . getBytes ( ) ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return new Guid ( hash , true ) ; } \n', 0.3834649939307847)

('public static String generateMd5 ( String parameters ) { try { return ! isBlank ( parameters ) ? new String ( Base64 . encodeBase64 ( DigestUtils . md5 ( parameters . getBytes ( CHARSET ) ) ) , CHARSET ) : null ; } catch ( Exception e ) { return null ; } } \n', 0.3827655639742661)

('protected String generateHash ( String message ) { try { if ( this . getId ( ) == null ) throw new IllegalStateException ( "Unable-to-use-a-password-on-an-unpersisted-person-object.-You-*must*-call-save-before-attepmting-to-set-or-verify-a-password." ) ; byte [ ] salt = new byte [ 24 ] ; Random random = new Random ( Long . valueOf ( this . getId ( ) ) ) ; random . nextBytes ( salt ) ; MessageDigest md = MessageDigest . getInstance ( HASH_ALGORITHM ) ; md . update ( salt ) ; byte [ ] byteHash = md . digest ( message . getBytes ( ) ) ; StringBuffer hash = new StringBuffer ( ) ; for ( int i = 0 ; i < byteHash . length ; i ++ ) { hash . append ( Integer . toString ( ( byteHash [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } return hash . toString ( ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new IllegalStateException ( "Unable-to-generate-password-hash-because-no-such-algorithm-exists-for:-" + HASH_ALGORITHM , nsae ) ; } } \n', 0.37204319235802213)FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('protected List < StackTraceElement > getStackTrace ( ) { StackTraceElement [ ] stackTraces = Thread . currentThread ( ) . getStackTrace ( ) ; List < StackTraceElement > elems = new ArrayList < StackTraceElement > ( ) ; for ( int i = 1 ; i < stackTraces . length ; i ++ ) { if ( stackTraces [ i ] . getClassName ( ) != this . getClass ( ) . getName ( ) ) { elems . add ( stackTraces [ i ] ) ; } } return elems ; } \n', 0.39567325858148694)

('private String getStackTrace ( final Throwable exception , final boolean isCritical ) { final Writer stackTrace = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( stackTrace ) ; final String dateString = DefaultConversionUtils . convert ( new Date ( ) ) ; if ( isCritical ) { printWriter . append ( String . format ( CRITICAL_EXCEPTION_SEPARATOR , dateString ) ) ; } else { printWriter . append ( String . format ( SEPARATOR , dateString ) ) ; } exception . printStackTrace ( printWriter ) ; printWriter . close ( ) ; return stackTrace . toString ( ) ; } \n', 0.3955450700815193)

('public static String getStackTrace ( ) { if ( ! ConfigurationParameters . printStackTrace ) return "" ; StackTraceElement stackTraces [ ] = new Throwable ( ) . getStackTrace ( ) ; StringBuffer sb = new StringBuffer ( "-at-" ) ; sb . append ( stackTraces [ 4 ] ) ; return sb . toString ( ) ; } \n', 0.3950523215723613)

('public String getStackTrace ( Element currException ) throws MbException { StringBuffer sb = new StringBuffer ( ) ; while ( currException != null && currException . getNodeName ( ) . endsWith ( "Exception" ) ) { MbException currMBE = convert2MbException ( currException ) ; sb . append ( currMBE . getMessage ( ) ) ; sb . append ( "-" ) ; currException = ( Element ) currException . getLastChild ( ) ; } return sb . toString ( ) ; } \n', 0.3819052333894509)

('public static String getStackTrace ( final Throwable t ) { final ByteArrayOutputStream bas = new ByteArrayOutputStream ( ) ; final PrintWriter pw = new PrintWriter ( bas ) ; t . printStackTrace ( pw ) ; pw . close ( ) ; return bas . toString ( ) ; } \n', 0.3796493265862798)

('public static String getStackTrace ( Throwable throwable ) { if ( throwable == null ) return null ; final ByteArrayOutputStream bas = new ByteArrayOutputStream ( ) ; final PrintWriter pw = new PrintWriter ( bas ) ; throwable . printStackTrace ( pw ) ; pw . close ( ) ; return bas . toString ( ) ; } \n', 0.3793493183048107)

('public static String getStackTrace ( Throwable e ) { try { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( baos ) ) ; e . printStackTrace ( pw ) ; pw . close ( ) ; return baos . toString ( ) ; } catch ( Throwable ignore ) { return "" ; } } \n', 0.3776697614746003)

('private String getTruncatedStackTrace ( Throwable t ) { StackTraceElement [ ] stack = t . getStackTrace ( ) ; ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( b ) ; boolean tooDeep = false ; for ( int i = 0 ; ! tooDeep && i < stack . length ; i ++ ) { StackTraceElement element = stack [ i ] ; if ( element . getClassName ( ) . contains ( "catalina" ) ) { tooDeep = true ; ps . print ( "-..." ) ; } else { ps . print ( "-at-" ) ; ps . print ( element ) ; } } if ( t . getCause ( ) != null ) { ps . print ( "-caused-by:-" + t . getCause ( ) + "-" + getTruncatedStackTrace ( t . getCause ( ) ) ) ; } ps . flush ( ) ; return b . toString ( ) ; } \n', 0.37708069658471854)

('private final String getStackTraceFromThrowableAsString ( final Throwable _throwable ) { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final PrintStream ps = new PrintStream ( baos ) ; _throwable . printStackTrace ( ps ) ; ps . close ( ) ; return baos . toString ( ) ; } \n', 0.3765132639165958)

('public static String getStackTraceOf ( Exception e ) { ByteArrayOutputStream err = new ByteArrayOutputStream ( ) ; e . printStackTrace ( new PrintStream ( err ) ) ; return err . toString ( ) ; } \n', 0.37526797233679055)FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

('public static Object [ ] sortOnProperty ( Object [ ] data , String PropName ) { Class ArrayClass = data . getClass ( ) . getComponentType ( ) ; ClassProperty TheProp = ClassAnalyzer . getClassProperty ( ArrayClass , PropName ) ; Method getMethod = TheProp . getGetMethod ( ) ; Object [ ] testData = ( Object [ ] ) Array . newInstance ( getMethod . getReturnType ( ) , data . length ) ; try { for ( int i = 0 ; i < data . length ; i ++ ) { Object Added = getMethod . invoke ( data [ i ] , EMPTY_OBJECT_ARRAY ) ; testData [ i ] = Added ; } } catch ( IllegalAccessException ex ) { throw new IllegalArgumentException ( "IllegalAccessException-getter-for-" + PropName + "-not-found" ) ; } catch ( InvocationTargetException ex ) { throw new IllegalArgumentException ( "InvokationTargetException-getter-for-" + PropName + "-not-found" ) ; } int [ ] order = getSortOrder ( testData ) ; if ( true ) throw new UnsupportedOperationException ( "Fix-This" ) ; Object [ ] ret = null ; for ( int i = 0 ; i < order . length ; i ++ ) ret [ i ] = data [ order [ i ] ] ; return ( ret ) ; } \n', 0.4152134705390136)

('public Collection sort ( Object object , String property ) { List properties = new ArrayList ( 1 ) ; properties . add ( property ) ; if ( object instanceof Collection ) { return sort ( ( Collection ) object , properties ) ; } else if ( object instanceof Object [ ] ) { return sort ( ( Object [ ] ) object , properties ) ; } else if ( object instanceof Map ) { return sort ( ( Map ) object , properties ) ; } return null ; } \n', 0.41263685074800294)

('public static < O > List < O > sort ( List < O > objects , List < String > properties ) { LinkedHashSet < String > propertiesSet = new LinkedHashSet < String > ( ) ; for ( String property : properties ) { propertiesSet . add ( property ) ; } return sort ( objects , propertiesSet ) ; } \n', 0.40241167183293286)

('private Element sortProperties ( Element el ) throws JDOMException { XPath xp = XPath . newInstance ( "//m:properties" ) ; xp . addNamespace ( "m" , "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata" ) ; for ( Object pNode : xp . selectNodes ( el ) ) { Element node = ( Element ) pNode ; final List < Element > props = new ArrayList < Element > ( ) ; for ( Object pChild : new ArrayList < Object > ( node . getChildren ( ) ) ) { Element child = ( Element ) pChild ; props . add ( ( Element ) child . clone ( ) ) ; child . detach ( ) ; } Collections . sort ( props , new Comparator < Element > ( ) { public int compare ( Element o1 , Element o2 ) { return o1 . getName ( ) . compareTo ( o2 . getName ( ) ) ; } } ) ; for ( Element prop : props ) { node . addContent ( ( Content ) prop ) ; } } return el ; } \n', 0.3951366370347644)

('@ Override public void setSortProperties ( Container . Sortable container , Object [ ] propertyId , boolean [ ] ascending ) { this . container = container ; final List < Object > ids = new ArrayList < Object > ( ) ; final List < Boolean > orders = new ArrayList < Boolean > ( ) ; final Collection < ? > sortable = container . getSortableContainerPropertyIds ( ) ; for ( int i = 0 ; i < propertyId . length ; i ++ ) { if ( sortable . contains ( propertyId [ i ] ) ) { ids . add ( propertyId [ i ] ) ; orders . add ( Boolean . valueOf ( i < ascending . length ? ascending [ i ] : true ) ) ; } } sortPropertyIds = ids . toArray ( ) ; sortDirections = new boolean [ orders . size ( ) ] ; for ( int i = 0 ; i < sortDirections . length ; i ++ ) { sortDirections [ i ] = ( orders . get ( i ) ) . booleanValue ( ) ; } } \n', 0.3939231167346853)

('public static PropertyListComparator propertyListComparatorWithGuideArray ( Object [ ] guideArray ) { if ( guideArray != null && guideArray . length > 0 ) { Object [ ] sortedArray = guideArray . clone ( ) ; Arrays . sort ( sortedArray , AscendingInsensitivePropertyListComparator ) ; if ( ! Arrays . equals ( guideArray , sortedArray ) ) { PropertyListComparator result = new PropertyListComparator ( true ) ; int size = guideArray . length ; if ( size > 0 ) { result . guideMap = new HashMap ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { Object origEntry = guideArray [ i ] ; Object oneEntry = origEntry ; if ( origEntry instanceof Map ) { Object name = ( ( Map ) origEntry ) . get ( "name" ) ; if ( name == null ) { name = ( ( Map ) origEntry ) . get ( "prototypeName" ) ; } if ( name != null ) { oneEntry = name ; } } if ( oneEntry != null ) { result . guideMap . put ( oneEntry , Integer . valueOf ( i ) ) ; } } } return result ; } } return AscendingInsensitivePropertyListComparator ; } \n', 0.37947371287242776)

('public void sort ( ) { String property = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getRequestParameterMap ( ) . get ( SORT_PROPERTY_PARAMETER ) ; if ( property != null ) { SortOrder currentPropertySortOrder = sortsOrders . get ( property ) ; if ( multipleSorting ) { if ( ! sortPriorities . contains ( property ) ) { sortPriorities . add ( property ) ; } } else { sortsOrders . clear ( ) ; } if ( currentPropertySortOrder == null || currentPropertySortOrder . equals ( SortOrder . descending ) ) { sortsOrders . put ( property , SortOrder . ascending ) ; } else { sortsOrders . put ( property , SortOrder . descending ) ; } } } \n', 0.36445560103268604)

('public void sort ( List < MockInMemoryResource > resources , String property , boolean ascending ) { Collections . sort ( resources , new Comparator < MockInMemoryResource > ( ) { @ Override public int compare ( MockInMemoryResource resource1 , MockInMemoryResource resource2 ) { Object prop1 = resource1 . properties . get ( property ) ; Object prop2 = resource2 . properties . get ( property ) ; if ( prop1 instanceof Comparable && prop2 instanceof Comparable ) { Integer compared = ( ( Comparable ) prop1 ) . compareTo ( ( Comparable ) prop2 ) ; if ( ascending ) { return compared ; } else { return ( - 1 * compared ) ; } } else { return 0 ; } } } ) ; } \n', 0.3579404399579889)

('@ Override public void sort ( Object [ ] propertyId , boolean [ ] ascending ) { if ( sortableContainer == null ) { new UnsupportedOperationException ( "Wrapped-container-is-not-Sortable" ) ; } if ( propertyId . length == 0 ) { sortableContainer . sort ( propertyId , ascending ) ; return ; } List < Object > actualSortProperties = new ArrayList < Object > ( ) ; List < Boolean > actualSortDirections = new ArrayList < Boolean > ( ) ; for ( int i = 0 ; i < propertyId . length ; ++ i ) { Object property = propertyId [ i ] ; SortDirection direction ; boolean isAscending = i < ascending . length ? ascending [ i ] : true ; if ( isAscending ) { direction = SortDirection . ASCENDING ; } else { direction = SortDirection . DESCENDING ; } if ( propertyGenerators . containsKey ( property ) ) { for ( SortOrder s : propertyGenerators . get ( property ) . getSortProperties ( new SortOrder ( property , direction ) ) ) { actualSortProperties . add ( s . getPropertyId ( ) ) ; actualSortDirections . add ( s . getDirection ( ) == SortDirection . ASCENDING ) ; } } else { actualSortProperties . add ( property ) ; actualSortDirections . add ( isAscending ) ; } } boolean [ ] actualAscending = new boolean [ actualSortDirections . size ( ) ] ; for ( int i = 0 ; i < actualAscending . length ; ++ i ) { actualAscending [ i ] = actualSortDirections . get ( i ) ; } sortableContainer . sort ( actualSortProperties . toArray ( ) , actualAscending ) ; } \n', 0.35617975599991586)FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('public static double roundToDecimalPlaces ( final double val , final int decimalPlaces ) { String zeros = "1" ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { zeros += "0" ; } int decimal = Integer . valueOf ( zeros ) . intValue ( ) ; if ( ! isNullOrZero ( val ) ) { return ( double ) Math . round ( val * decimal ) / decimal ; } return val ; } \n', 0.47474848012569243)

('public static Double roundToDecimalPlaces ( final Double val , final int decimalPlaces ) { if ( ! isNullOrZero ( val ) ) { return Double . valueOf ( roundToDecimalPlaces ( val . doubleValue ( ) , decimalPlaces ) ) ; } return val ; } \n', 0.4708190755488689)

('public static float roundDecimal ( float value , double places ) { double multiplier = Math . pow ( 10 , places ) ; value *= multiplier ; return ( float ) ( Math . round ( value ) / multiplier ) ; } \n', 0.46927089065622263)

('public static Double roundToNDecimalPlaces ( Double toBeFormatted , int nDecimalPlaces ) { double decPlacesFact = Math . pow ( 10 , nDecimalPlaces ) ; return ( double ) Math . round ( toBeFormatted * decPlacesFact ) / decPlacesFact ; } \n', 0.46764733215472787)

('public static float roundFloat ( float number , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( String . valueOf ( number ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } catch ( Exception e ) { logger . error ( e ) ; return number ; } } \n', 0.46368390074375193)

('protected double roundToDecimalPlaces ( double number , int decimalPlace , boolean place ) { int temp = 1 ; for ( int i = 0 ; i < decimalPlace ; i ++ ) { temp = temp * 10 ; } if ( place ) { number = number / temp ; number = Math . round ( number ) ; number = number * temp ; } else { number = number * temp ; number = Math . round ( number ) ; number = number / temp ; } return number ; } \n', 0.462814356628056)

('public static double roundBigDecimalDouble ( double d , int decimalPlaces ) { BigDecimal bd = new BigDecimal ( Double . toString ( d ) ) ; bd = bd . setScale ( decimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . doubleValue ( ) ; } \n', 0.46216983525252214)

('public static float round ( float num , int decimalPlaces ) { float digit = 1 ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { digit *= 10 ; } return Math . round ( num * digit ) / digit ; } \n', 0.4608344527940348)

('public static float round ( float valueToRound , int numDecimalPlaces ) { BigDecimal bd = new BigDecimal ( Float . toString ( valueToRound ) ) ; bd = bd . setScale ( numDecimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } \n', 0.4595635904307136)

('public static double roundDouble ( double number , int decimalPlace ) { double numberRound ; if ( ! Double . isInfinite ( number ) && ( ! Double . isNaN ( number ) ) ) { BigDecimal bd = new BigDecimal ( number ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_UP ) ; numberRound = bd . doubleValue ( ) ; return numberRound ; } else return number ; } \n', 0.4559023944253502)FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

('@ NonNull public static String leftPadWithZeros ( @ Nullable final String toPad , final int finalSize ) { final StringBuilder temp = new StringBuilder ( ) ; if ( CoreLibConstants . IS_PARAMETER_CHECKING_ENABLED ) { if ( finalSize < 0 ) { throw new IllegalArgumentException ( "finalSize-cannot-be-negative" ) ; } } if ( null != toPad ) { temp . append ( toPad ) ; } if ( temp . length ( ) < finalSize ) { do { temp . insert ( 0 , \'0\' ) ; } while ( finalSize != temp . length ( ) ) ; } return temp . toString ( ) ; } \n', 0.4060354117236279)

('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40178837872132317)

('public static String leftPad ( final String str , final int size , final char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > StringUtils . PAD_LIMIT ) { return StringUtils . leftPad ( str , size , String . valueOf ( padChar ) ) ; } return StringUtils . padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40175002810435456)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( new Integer ( size ) , substring ) ; } \n', 0.3974942111254081)

('public static final byte [ ] leftPad ( byte [ ] value , int length , int padByte ) { byte [ ] left = new byte [ length ] ; Arrays . fill ( left , ( byte ) padByte ) ; System . arraycopy ( value , 0 , left , length - value . length , value . length ) ; return left ; } \n', 0.39301718397741947)

('public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isNullOrEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.3913625230645047)

("public static String leftPad ( String str , int length ) { return ( leftPad ( str , length , '-' ) ) ; } \n", 0.39082311992471847)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( Integer . valueOf ( size ) , substring ) ; } \n', 0.3873597474059222)

('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return repeat ( padChar , pads ) . concat ( str ) ; } \n', 0.3855200469850956)FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('public void constructGenerationSpecificSorters ( final Collection < JGeneration > generations ) { generationSpecificComparators = new HashMap < JGeneration , Map < Class < ? > , Comparator < Individual >>> ( generations . size ( ) ) ; final IndividualSorters indSorterInstance = IndividualSorters . getInstance ( ) ; for ( JGeneration thisGen : generations ) { final Map < Class < ? > , Comparator < Individual >> classCompMap = new HashMap < Class < ? > , Comparator < Individual >> ( ) ; generationSpecificComparators . put ( thisGen , classCompMap ) ; final Comparator < Individual > genSpecComp2 = indSorterInstance . new PartnerCountSorter ( thisGen ) ; classCompMap . put ( genSpecComp2 . getClass ( ) , genSpecComp2 ) ; } } \n', 0.2697203214491459)

('public static Animal [ ] createAnimalArray ( int animalCount , int animalMaxAge ) throws IllegalArgumentException { if ( animalMaxAge <= 0 ) throw new IllegalArgumentException ( "animalMaxAge-must-be-positive" ) ; List < Animal > animalList = new ArrayList < Animal > ( ) ; Random randomGenerator = new Random ( ) ; for ( int i = 0 ; i < animalCount ; i ++ ) { int age = randomGenerator . nextInt ( animalMaxAge ) ; animalList . add ( new Animal ( age ) ) ; } return animalList . toArray ( new Animal [ animalList . size ( ) ] ) ; } \n', 0.26816321181268676)

('@ SafeVarargs public static < T > TestDataGenerator < ArrayList < T >> arrayListGenerator ( final T ... elements ) { return new TestDataGenerator < ArrayList < T >> ( ) { @ Override public ArrayList < T > generate ( ) { return new ArrayList < T > ( Arrays . asList ( elements ) ) ; } } ; } \n', 0.2646186274142995)

('private List < Generator < ? >> generatorsForRawClass ( Class < ? > clazz , boolean allowMixedTypes ) { Set < Generator < ? >> matches = generators . get ( clazz ) ; if ( ! allowMixedTypes ) { Generator < ? > match = choose ( matches , random ) ; matches = new HashSet < > ( ) ; matches . add ( match ) ; } List < Generator < ? >> copies = new ArrayList < > ( ) ; for ( Generator < ? > each : matches ) copies . add ( copyOf ( each ) ) ; return copies ; } \n', 0.2627732226508381)

('private List < QuasiImportPackage > wrapImportPackageSpecifications ( ImportPackageSpecification [ ] importPackageSpecifications ) { List < QuasiImportPackage > quasiImportPackages = new ArrayList < QuasiImportPackage > ( ) ; for ( ImportPackageSpecification importPackageSpecification : importPackageSpecifications ) { quasiImportPackages . add ( new StandardQuasiImportPackage ( importPackageSpecification , this ) ) ; } return Collections . unmodifiableList ( quasiImportPackages ) ; } \n', 0.2626467528859781)

('static int [ ] createRandomArraySorted ( int size ) { int [ ] array = new int [ size ] ; Random random = new Random ( ) ; for ( int i = 0 ; i < size ; i ++ ) { array [ i ] = random . nextInt ( Integer . MAX_VALUE ) ; } Arrays . sort ( array ) ; return array ; } \n', 0.2593818171623413)

('public static int [ ] generateSortedUniqueRandomIntArray ( int size , int bound ) { if ( size > bound ) { throw new IllegalArgumentException ( "The-value-of-size-must-be-equal-or-less-than-bound-value" ) ; } Set < Integer > uniqueNumbers = new HashSet < Integer > ( ) ; Random random = new Random ( ) ; while ( true ) { uniqueNumbers . add ( random . nextInt ( bound ) ) ; if ( size == uniqueNumbers . size ( ) ) { break ; } } Object [ ] objArr = uniqueNumbers . toArray ( ) ; int [ ] numbers = new int [ objArr . length ] ; for ( int i = 0 ; i < numbers . length ; i ++ ) { numbers [ i ] = ( Integer ) objArr [ i ] ; } Arrays . sort ( numbers ) ; return numbers ; } \n', 0.2536193714289433)

('public static int [ ] createRandomArray ( int length ) { Random NUMBER_GENERATOR = new Random ( 10 ) ; int [ ] array = new int [ length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = NUMBER_GENERATOR . nextInt ( 1000000 ) ; } return array ; } \n', 0.25270213754434173)

('public static int [ ] arrayFromStringOfIntegers ( String str ) throws IllegalArgumentException { StringTokenizer tokenizer = new StringTokenizer ( str , "," ) ; int n = tokenizer . countTokens ( ) ; int [ ] list = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String token = tokenizer . nextToken ( ) ; list [ i ] = Integer . parseInt ( token ) ; } return list ; } \n', 0.24921958074366873)

('@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) GenericPrincipal createGenericPrincipal ( String username , String password , List < String > roles ) { Class klass = null ; try { klass = Class . forName ( "org.apache.catalina.realm.GenericPrincipal" ) ; } catch ( ClassNotFoundException ex ) { LOGR . log ( Level . SEVERE , ex . getMessage ( ) ) ; } Constructor [ ] ctors = klass . getConstructors ( ) ; Class firstParamType = ctors [ 0 ] . getParameterTypes ( ) [ 0 ] ; Class [ ] paramTypes = new Class [ ] { Realm . class , String . class , String . class , List . class } ; Object [ ] ctorArgs = new Object [ ] { this , username , password , roles } ; GenericPrincipal principal = null ; try { if ( Realm . class . isAssignableFrom ( firstParamType ) ) { Constructor ctor = klass . getConstructor ( paramTypes ) ; principal = ( GenericPrincipal ) ctor . newInstance ( ctorArgs ) ; } else { Constructor ctor = klass . getConstructor ( Arrays . copyOfRange ( paramTypes , 1 , paramTypes . length ) ) ; principal = ( GenericPrincipal ) ctor . newInstance ( Arrays . copyOfRange ( ctorArgs , 1 , ctorArgs . length ) ) ; } } catch ( Exception ex ) { LOGR . log ( Level . WARNING , ex . getMessage ( ) ) ; } return principal ; } \n', 0.24763740011241622)FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('public String readTextFile ( String fileName ) { try { InputStream in = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( fileName ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ BUFFER_SIZE ] ; int count ; while ( ( count = in . read ( data , 0 , BUFFER_SIZE ) ) != - 1 ) { out . write ( data , 0 , count ) ; } log . info ( "Read-" + out . size ( ) + "-bytes-from-" + fileName ) ; return out . toString ( ) ; } catch ( IOException e ) { log . error ( "Unable-to-read-file-" + fileName + "!-" + e . getMessage ( ) , e ) ; return "" ; } } \n', 0.4170094223201088)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.41573641785888943)

('public static PrefixEncodedLexicographicallySortedDictionary loadFromPlainTextFile ( Path path , FileSystem fs , int window ) throws IOException { LOG . info ( "Reading-from-" + path ) ; LineReader reader = new LineReader ( fs . open ( path ) ) ; PrefixEncodedLexicographicallySortedDictionary terms = new PrefixEncodedLexicographicallySortedDictionary ( window ) ; int cnt = 0 ; Text t = new Text ( ) ; while ( reader . readLine ( t ) > 0 ) { String term = t . toString ( ) ; if ( term . contains ( "-" ) ) { term = term . split ( "|t" ) [ 0 ] ; } terms . add ( term ) ; cnt ++ ; if ( cnt % 1000000 == 0 ) { LOG . info ( "read-" + cnt + "-lines" ) ; } } LOG . info ( "Finished-reading-from-" + path ) ; LOG . info ( "compression-ratio:-" + terms . getCompresssionRatio ( ) ) ; return terms ; } \n', 0.40723575545112345)

('public static String [ ] readTextFileAsStringArray ( final File file , final String charSet ) throws IOException { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , charSet ) ) ; final List < String > readString = new ArrayList < String > ( 256 ) ; try { while ( true ) { final String line = reader . readLine ( ) ; if ( line == null ) { break ; } readString . add ( line ) ; } } finally { silentlyClose ( reader ) ; } return readString . toArray ( new String [ readString . size ( ) ] ) ; } \n', 0.40581668997213727)

('public static String loadTextFileFromAssets ( Context context , String fileName ) throws IOException { InputStream inputStream = context . getAssets ( ) . open ( fileName ) ; try { OutputStream outputStream = new ByteArrayOutputStream ( ) ; try { byte [ ] buffer = new byte [ DEFAULT_BUFFER_SIZE ] ; for ( int n ; ( n = inputStream . read ( buffer ) ) >= 0 ; ) { outputStream . write ( buffer , 0 , n ) ; } return outputStream . toString ( ) ; } finally { outputStream . close ( ) ; } } finally { inputStream . close ( ) ; } } \n', 0.4011426512659648)

('public static List < String > readLargerTextFile ( String aFileName ) throws IOException { List < String > files = new ArrayList < > ( ) ; File fileDir = new File ( aFileName ) ; for ( final File fileEntry : fileDir . listFiles ( ) ) { StringBuilder sb = new StringBuilder ( ) ; Path path = Paths . get ( aFileName + "/" + fileEntry . getName ( ) ) ; try ( Scanner scanner = new Scanner ( path , ENCODING . name ( ) ) ) { while ( scanner . hasNextLine ( ) ) { sb . append ( scanner . nextLine ( ) ) . append ( "-" ) ; } } String result = sb . toString ( ) ; files . add ( result ) ; } return files ; } \n', 0.3994594845122906)

('public List < String > readSmallTextFile ( String aFileName ) throws IOException { Path path = Paths . get ( aFileName ) ; List < String > returnList = new ArrayList < > ( ) ; try { returnList = Files . readAllLines ( path , ENCODING ) ; } catch ( MalformedInputException mie ) { } return returnList ; } \n', 0.396022731873784)

('public static String loadTextFile ( BufferedReader iStream ) throws IOException { StringWriter buffer = null ; PrintWriter writer = null ; try { buffer = new StringWriter ( ) ; writer = new PrintWriter ( buffer ) ; String line = null ; while ( ( line = iStream . readLine ( ) ) != null ) writer . println ( line ) ; writer . flush ( ) ; } catch ( IOException exc ) { throw exc ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( Exception e ) { } } } return buffer . toString ( ) ; } \n', 0.3959059315961151)

('public static String ReadStringFromFile ( String sFileName ) { if ( TextUtils . isEmpty ( sFileName ) ) return null ; String sDest = null ; File f = new File ( sFileName ) ; if ( ! f . exists ( ) ) { return null ; } try { FileInputStream is = new FileInputStream ( f ) ; ByteArrayOutputStream bais = new ByteArrayOutputStream ( ) ; try { byte [ ] buffer = new byte [ 1 ] ; while ( is . read ( buffer ) != - 1 ) { bais . write ( buffer ) ; } sDest = bais . toString ( ) . trim ( ) ; } catch ( IOException ioex ) { LogUtil . e ( "Excetion-:-ioexception-at-read-string-from-file!-" ) ; } finally { is . close ( ) ; bais . close ( ) ; } } catch ( Exception ex ) { LogUtil . e ( "Exception-:-read-string-from-file!" + ex . getMessage ( ) ) ; } return sDest ; } \n', 0.39225626808136804)

('public void loadTextArchiveReadMeFile ( BufferedReader in ) { try { keyValues = new LinkedHashMap < String , String > ( ) ; String line ; ArrayList < String > comments = new ArrayList < String > ( ) ; while ( ( line = in . readLine ( ) ) != null ) { line = line . trim ( ) ; if ( line . length ( ) == 0 ) { continue ; } if ( line . startsWith ( "#" ) ) { comments . add ( line ) ; } else { Matcher mat = KEY_VALUE_SPLITTER . matcher ( line ) ; if ( mat . matches ( ) == false ) { throw new IOException ( "Error-in-parsing-archiveReadMe.txt-file.-Found-a-non-comment-and-non-key-=-value-line.-Bad-line-->-\'" + line ) ; } keyValues . put ( mat . group ( 1 ) , mat . group ( 2 ) ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; USeqUtilities . safeClose ( in ) ; } } \n', 0.3857415046371886)FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('private void visitArrayElements ( AnnotationVisitor arrayVisitor , Class arrayElementType , Object [ ] arrayElements ) { if ( arrayElementType . isEnum ( ) ) { String enumDescriptor = Type . getType ( arrayElementType ) . getDescriptor ( ) ; for ( Object value : arrayElements ) { arrayVisitor . visitEnum ( null , enumDescriptor , value . toString ( ) ) ; } } else if ( arrayElementType . equals ( Class . class ) ) { for ( Object value : arrayElements ) { Class < ? > clazz = ( Class < ? > ) value ; arrayVisitor . visit ( null , Type . getType ( clazz ) ) ; } } else if ( arrayElementType . isAnnotation ( ) ) { for ( Object annotation : arrayElements ) { AnnotationVisitor nestedAnnotationVisitor = arrayVisitor . visitAnnotation ( null , Type . getType ( arrayElementType ) . getDescriptor ( ) ) ; visitAnnotationValues ( ( Annotation ) annotation , nestedAnnotationVisitor ) ; nestedAnnotationVisitor . visitEnd ( ) ; } } else { for ( Object value : arrayElements ) { arrayVisitor . visit ( null , value ) ; } } } \n', 0.3302915030358894)

('private List < String > getEnumNames ( Class < T > optionsEnumClass ) { return FluentIterable . from ( Arrays . asList ( optionsEnumClass . getEnumConstants ( ) ) ) . transform ( Enums . stringConverter ( optionsEnumClass ) . reverse ( ) ) . toList ( ) ; } \n', 0.31719139408488584)

('private List < Action > generateLeaveActionsForSinglevar ( State s , Transition t , Event e ) { List < Action > ret = new ArrayList < Action > ( ) ; List < AbstractNode > target = Utils . getSuperStates ( s ) ; target . removeAll ( Utils . getSuperStates ( t . getTarget ( ) ) ) ; for ( AbstractNode node : target ) { if ( node instanceof State ) ret . addAll ( enum_superState2leaveActions ( ( State ) node , t , e ) ) ; } for ( Statemachine sm : s . getStatemachines ( ) ) { if ( ! ( Utils . isLocalToSource ( t ) && ! Utils . contains ( sm , t . getTarget ( ) ) ) ) { ret . addAll ( enum_statemachine2leaveActions ( sm , t , e ) ) ; } } if ( Utils . hasExit ( rootSM , t ) ) ret . add ( enum_statemachine2leaveAction ( rootSM , e ) ) ; return ret ; } \n', 0.2947442001107401)

('public static < T > T [ ] convertStringsToEnumArray ( String [ ] value , Class < T > enumType ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( value == null ) return null ; Object retvalue = Array . newInstance ( enumType , value . length ) ; int i = 0 ; Method valueof = enumType . getMethod ( "valueOf" , String . class ) ; for ( String v : value ) { Array . set ( retvalue , i , valueof . invoke ( null , value [ i ] ) ) ; i ++ ; } return ( T [ ] ) retvalue ; } \n', 0.29002931867872517)

('public Object submitConverted ( final Rewrite event , final EvaluationContext context , final Object value ) { String convertedName = getParameterConvertedName ( property ) ; if ( ! context . containsKey ( property ) ) { if ( value != null && value . getClass ( ) . isArray ( ) ) storeValue ( event , context , convertedName , value ) ; else storeValue ( event , context , convertedName , new Object [ ] { value } ) ; } else { Object [ ] values = ( Object [ ] ) context . get ( convertedName ) ; List < Object > list = Arrays . asList ( values ) ; if ( value . getClass ( ) . isArray ( ) ) list . addAll ( Arrays . asList ( ( Object [ ] ) value ) ) ; else list . add ( value ) ; storeValue ( event , context , convertedName , list . toArray ( ) ) ; } return null ; } \n', 0.28900875273920523)

('private Relation getProcessedRelationObject ( Relation relation , Hashtable < String , String > record , String clsName ) { Enumeration < String > keys = record . keys ( ) ; String key = "" ; String value = "" ; Hashtable < String , Type > typeTable = getAttributeTypeTable ( clsName ) ; ArrayList < String > attrList = getAttributeListFrmClassName ( clsName ) ; Object convertedValue = null ; Type attributeType ; while ( keys . hasMoreElements ( ) ) { key = ( String ) keys . nextElement ( ) ; if ( typeTable != null && attrList != null ) { attributeType = typeTable . get ( key ) ; if ( attrList . contains ( key ) ) { value = ( String ) record . get ( key ) ; if ( Type . INTEGER . equals ( attributeType ) ) { relation . setIntProperty ( key , Integer . parseInt ( value ) ) ; } else if ( Type . ENUM . equals ( attributeType ) ) { relation . setIntProperty ( key , Integer . parseInt ( value ) ) ; } else if ( Type . DATE . equals ( attributeType ) ) { try { SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss\'Z\'" ) ; Date date = format . parse ( value ) ; relation . setDateProperty ( key , date ) ; } catch ( ParseException e ) { throw new UcmdbException ( "Cannot-parse-the-date-field-" + value ) ; } } else { relation . setPropertyValue ( key , value ) ; } } } } return relation ; } \n', 0.28735641422366376)

('public void getEnumeratedValuesForSimpleType ( XSDTypeDefinition type , List result ) { List enumerationFacets = ( ( XSDSimpleTypeDefinition ) type ) . getEnumerationFacets ( ) ; for ( Iterator i = enumerationFacets . iterator ( ) ; i . hasNext ( ) ; ) { XSDEnumerationFacet enumFacet = ( XSDEnumerationFacet ) i . next ( ) ; List values = enumFacet . getValue ( ) ; for ( Iterator j = values . iterator ( ) ; j . hasNext ( ) ; ) { Object o = j . next ( ) ; if ( o != null ) { if ( ! result . contains ( o ) ) { result . add ( o . toString ( ) ) ; } } } } } \n', 0.2863345140939182)

('private Object mapArrayToArray ( Object srcObj , Object srcCollectionValue , FieldMap fieldMap , Object destObj ) { Class destEntryType = fieldMap . getDestFieldType ( destObj . getClass ( ) ) . getComponentType ( ) ; Class srcEntryType = srcCollectionValue . getClass ( ) . getComponentType ( ) ; int size = Array . getLength ( srcCollectionValue ) ; CopyByReferenceContainer copyByReferences = globalConfiguration . getCopyByReferences ( ) ; boolean isPrimitiveArray = CollectionUtils . isPrimitiveArray ( srcCollectionValue . getClass ( ) ) ; boolean isFinal = Modifier . isFinal ( srcEntryType . getModifiers ( ) ) ; boolean isCopyByReference = copyByReferences . contains ( srcEntryType ) ; if ( destEntryType . isAssignableFrom ( srcEntryType ) && isFinal && ( isPrimitiveArray || isCopyByReference ) ) { return addArrayContentCopy ( fieldMap , size , srcCollectionValue , destObj , destEntryType ) ; } else if ( isPrimitiveArray ) { return addToPrimitiveArray ( srcObj , fieldMap , size , srcCollectionValue , destObj , destEntryType ) ; } else { List < ? > list = Arrays . asList ( ( Object [ ] ) srcCollectionValue ) ; List < ? > returnList ; if ( ! destEntryType . getName ( ) . equals ( BASE_CLASS ) ) { returnList = addOrUpdateToList ( srcObj , fieldMap , list , destObj , destEntryType ) ; } else { returnList = addOrUpdateToList ( srcObj , fieldMap , list , destObj , null ) ; } return CollectionUtils . convertListToArray ( returnList , destEntryType ) ; } } \n', 0.2859155581759137)

('private AbstractNamingEnumeration ( SimpleNamingContext context , String proot ) throws NamingException { if ( ! "" . equals ( proot ) && ! proot . endsWith ( "/" ) ) { proot = proot + "/" ; } String root = context . root + proot ; Map < String , T > contents = new HashMap < String , T > ( ) ; for ( String boundName : context . boundObjects . keySet ( ) ) { if ( boundName . startsWith ( root ) ) { int startIndex = root . length ( ) ; int endIndex = boundName . indexOf ( \'/\' , startIndex ) ; String strippedName = ( endIndex != - 1 ? boundName . substring ( startIndex , endIndex ) : boundName . substring ( startIndex ) ) ; if ( ! contents . containsKey ( strippedName ) ) { try { contents . put ( strippedName , createObject ( strippedName , context . lookup ( proot + strippedName ) ) ) ; } catch ( NameNotFoundException ex ) { } } } } if ( contents . size ( ) == 0 ) { throw new NamingException ( "Invalid-root:-[" + context . root + proot + "]" ) ; } this . iterator = contents . values ( ) . iterator ( ) ; } \n', 0.2854049225130144)

('public static List convertEnumsToLabelBeans ( List enums ) { List res = new ArrayList ( enums . size ( ) ) ; for ( Iterator i = enums . iterator ( ) ; i . hasNext ( ) ; ) { HypericEnum e = ( HypericEnum ) i . next ( ) ; res . add ( new LabelValueBean ( e . getValue ( ) , e . getCode ( ) + "" ) ) ; } return res ; } \n', 0.28407021508462504)FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('public boolean checkProtocol ( String string , boolean start ) { boolean bool = false ; int i = 0 ; if ( start ) { while ( ( i < allowedProtocols . length ) && ( ! bool ) ) { bool = string . regionMatches ( true , 0 , allowedProtocols [ i ] , 0 , allowedProtocols [ i ] . length ( ) ) ; i ++ ; } } else { while ( ( ! bool ) && ( i < allowedProtocols . length ) ) { bool = string . equals ( allowedProtocols [ i ] ) ; i ++ ; } } return bool ; } \n', 0.3496840904323101)

('public static void checkLoaded ( ) { if ( LOAD_ERROR != null ) { throw LOAD_ERROR ; } BigInteger two = BigInteger . valueOf ( 2 ) ; BigInteger three = BigInteger . valueOf ( 3 ) ; BigInteger five = BigInteger . valueOf ( 5 ) ; BigInteger answer ; answer = modPowInsecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowInsecure-returned-the-wrong-answer" ) ; } answer = modPowSecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowSecure-returned-the-wrong-answer" ) ; } } \n', 0.3468051299255108)

('private static final boolean checkShort ( String s ) { try { short val = Short . parseShort ( s ) ; if ( DebugValueChecking ) { DAPNode . log . debug ( "Attribute.checkShort()---string:-\'" + s + "\'-value:-" + val ) ; } return true ; } catch ( NumberFormatException e ) { return false ; } } \n', 0.34602751018518485)

('@ Override public boolean isMaybeTrueButNotFalse ( ) { checkNotPolymorphicOrUnknown ( ) ; return ( flags & BOOL ) == BOOL_TRUE ; } \n', 0.34290363574970867)

('protected boolean determineShouldBeAtLeastGrayChecked ( Object treeElement ) { List checked = ( List ) checkedStateStore . get ( treeElement ) ; if ( checked != null && ( ! checked . isEmpty ( ) ) ) { return true ; } Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } return false ; } \n', 0.3412439028260299)

('public < E > void assertHasAtLeastOneElementOfType ( AssertionInfo info , E [ ] actual , Class < ? > type ) { Objects . instance ( ) . assertNotNull ( info , actual ) ; boolean found = false ; for ( Object o : actual ) { if ( ! type . isInstance ( o ) ) continue ; found = true ; break ; } if ( ! found ) throw failures . failure ( info , shouldHaveAtLeastOneElementOfType ( actual , type ) ) ; } \n', 0.337571886370023)

('public boolean checkIfTechnologyHasAtLeastOneComponent ( final StateChangeContext stateContext ) { Entity technology = stateContext . getOwner ( ) ; final Entity savedTechnology = technology . getDataDefinition ( ) . get ( technology . getId ( ) ) ; final EntityTree operations = savedTechnology . getTreeField ( TechnologyFields . OPERATION_COMPONENTS ) ; if ( operations != null && ! operations . isEmpty ( ) ) { for ( Entity operation : operations ) { if ( L_OPERATION . equals ( operation . getStringField ( TechnologyOperationComponentFields . ENTITY_TYPE ) ) ) { return true ; } } } stateContext . addValidationError ( "technologies.technology.validate.global.error.emptyTechnologyTree" ) ; return false ; } \n', 0.3366891141230456)

('protected boolean determineShouldBeAtLeastGrayChecked ( final Object treeElement ) { final List < Object > checked = checkedStateStore . get ( treeElement ) ; if ( checked != null && ! checked . isEmpty ( ) ) { return true ; } if ( expandedTreeNodes . contains ( treeElement ) ) { final Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } } return false ; } \n', 0.3365821331317027)

('private static final boolean checkInt ( String s ) { try { int val = Integer . parseInt ( s ) ; if ( DebugValueChecking ) { DAPNode . log . debug ( "Attribute.checkInt()---string:-\'" + s + "\'-value:-" + val ) ; } return true ; } catch ( NumberFormatException e ) { return false ; } } \n', 0.3365533575114247)

('private boolean determineShouldBeAtLeastGrayChecked ( Object treeElement ) { List checked = ( List ) checkedStateStore . get ( treeElement ) ; if ( checked != null && ( ! checked . isEmpty ( ) ) ) { return true ; } if ( expandedTreeNodes . contains ( treeElement ) ) { Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } } return false ; } \n', 0.33530429924291366)FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.38881819720642374)

('static int [ ] convertStringToIntArray ( String str ) { String [ ] strArray = str . split ( "," ) ; System . out . println ( "str:-" + str ) ; int [ ] intArray = new int [ strArray . length ] ; for ( int i = 0 ; i < strArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( strArray [ i ] ) ; } return intArray ; } \n', 0.3856660090213297)

('private static int [ ] convertStringArrayToIntArray ( String [ ] arr ) { try { if ( arr == null ) return null ; int [ ] intArr = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { intArr [ i ] = Integer . parseInt ( arr [ i ] ) ; } return intArr ; } catch ( Exception e ) { return null ; } } \n', 0.38355787460310664)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.37820241142063793)

('public static int [ ] convertIndexStr2IntArr ( String strValue ) { String indexStr [ ] = strValue . split ( "," ) ; int arr [ ] = new int [ indexStr . length ] ; for ( int i = 0 ; i < indexStr . length ; i ++ ) { arr [ i ] = Integer . parseInt ( indexStr [ i ] ) ; } return arr ; } \n', 0.37359369797444825)

('public static final int [ ] convertStringToIntArray ( final String sInput , final String sDelimiter ) { StringTokenizer tokenize = new StringTokenizer ( sInput , sDelimiter ) ; int [ ] resultIntArray = new int [ tokenize . countTokens ( ) ] ; for ( int i = 0 ; tokenize . hasMoreTokens ( ) ; i ++ ) { resultIntArray [ i ] = Integer . valueOf ( tokenize . nextToken ( ) ) . intValue ( ) ; } return resultIntArray ; } \n', 0.3685692725882034)

('public static List < Integer > convertStringToIntegerArray ( String line , String separator ) { Guard . check ( line , separator ) ; ArrayList < Integer > result = new ArrayList < Integer > ( ) ; String [ ] values = line . split ( separator ) ; for ( int i = 0 ; i < values . length ; i ++ ) { Integer number = Integer . valueOf ( values [ i ] ) ; result . add ( number ) ; } return result ; } \n', 0.3597217940145427)

('public Short convert ( final String input ) throws EventParsingException { try { final Long value = numberConverter . convert ( input ) ; if ( value < Short . MIN_VALUE || value > Short . MAX_VALUE ) { throw new EventParsingException ( String . format ( "Value-out-of-range(%d,-%d).-Value:"%s"" , Short . MIN_VALUE , Short . MAX_VALUE , input ) ) ; } return value . shortValue ( ) ; } catch ( NumberFormatException e ) { throw new EventParsingException ( String . format ( "cannot-convert-%s-to-Byte" , input ) , e ) ; } } \n', 0.3580168715973951)

('public static int [ ] convertStringListToIntArray ( List < String > list , String [ ] convertFrom , int [ ] convertTo ) { if ( list == null ) { return null ; } List < Integer > convertedList = convertStringListToIntList ( list , convertFrom , convertTo ) ; int [ ] returnArray = new int [ convertedList . size ( ) ] ; for ( int i = 0 ; i < returnArray . length ; ++ i ) { returnArray [ i ] = convertedList . get ( i ) ; } return returnArray ; } \n', 0.3544161313950388)

('public Integer convert ( final String input ) throws EventParsingException { try { final Long value = numberConverter . convert ( input ) ; if ( value < Integer . MIN_VALUE || value > Integer . MAX_VALUE ) { throw new EventParsingException ( String . format ( "Value-out-of-range(%d,-%d).-Value:"%s"" , Integer . MIN_VALUE , Integer . MAX_VALUE , input ) ) ; } return value . intValue ( ) ; } catch ( NumberFormatException e ) { throw new EventParsingException ( String . format ( "cannot-convert-%s-to-Integer" , input ) , e ) ; } } \n', 0.3446526748188858)FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

('@ NotNull public static CharSequence convertToBytesIfAsciiString ( @ NotNull CharSequence name ) { int length = name . length ( ) ; if ( length == 0 ) return "" ; byte [ ] bytes = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char c = name . charAt ( i ) ; if ( c >= 128 ) { return new String ( name . toString ( ) ) ; } bytes [ i ] = ( byte ) c ; } return new ByteArrayCharSequence ( bytes ) ; } \n', 0.35798380207931746)

('public String convert ( CharSequence chars , int offset , int count ) { if ( offset < 0 ) { throw new StringIndexOutOfBoundsException ( offset ) ; } if ( count < 0 ) { throw new StringIndexOutOfBoundsException ( count ) ; } int end = offset + count ; if ( end > chars . length ( ) ) { throw new StringIndexOutOfBoundsException ( offset + count ) ; } StringBuffer buffer = new StringBuffer ( ) ; for ( int i = offset ; i < end ; i ++ ) { buffer . append ( convert ( chars . charAt ( i ) ) ) ; } return buffer . toString ( ) ; } \n', 0.3523151005408147)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.34732607717293607)

('public static String convertToUTF8 ( String s ) { String converted = null ; if ( s != null ) { byte [ ] bytes = new byte [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { bytes [ i ] = ( byte ) s . charAt ( i ) ; } try { converted = new String ( bytes , "UTF-8" ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Converted-\'" + s + "\'-to-UTF-8-\'" + converted + "\'." ) ; } } catch ( UnsupportedEncodingException ue ) { log . error ( "Unable-to-set-UTF-8-character-encoding-for-string-\'" + s + "\'!" , ue ) ; } } return converted ; } \n', 0.3422764898672679)

('protected Character convertObjectToChar ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { if ( ( ( String ) sourceObject ) . length ( ) < 1 ) { return null ; } return new Character ( ( ( String ) sourceObject ) . charAt ( 0 ) ) ; } if ( sourceObject instanceof Number ) { return new Character ( ( char ) ( ( Number ) sourceObject ) . byteValue ( ) ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . CHAR ) ; } \n', 0.3419930522480763)

('private String convertToUnicodeString ( String input ) throws Exception { assert input . length ( ) % 6 == 0 ; assert input . startsWith ( "|u" ) ; String output = "" ; String [ ] chars = input . split ( "||u" ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] . length ( ) != 0 ) output += convertToUnicodeChar ( chars [ i ] ) ; } return output ; } \n', 0.3419322964241026)

('public String convertUnicode ( String emo ) { try { if ( emo == null || emo . length ( ) == 0 ) { return null ; } if ( ! emo . contains ( "_" ) ) { return new String ( Character . toChars ( Integer . parseInt ( emo , 16 ) ) ) ; } String [ ] emos = emo . split ( "_" ) ; char [ ] char0 = Character . toChars ( Integer . parseInt ( emos [ 0 ] , 16 ) ) ; char [ ] char1 = Character . toChars ( Integer . parseInt ( emos [ 1 ] , 16 ) ) ; char [ ] emoji = new char [ char0 . length + char1 . length ] ; for ( int i = 0 ; i < char0 . length ; i ++ ) { emoji [ i ] = char0 [ i ] ; } for ( int i = char0 . length ; i < emoji . length ; i ++ ) { emoji [ i ] = char1 [ i - char0 . length ] ; } return new String ( emoji ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return null ; } \n', 0.3362117890594527)

('public static byte [ ] convertToByteArray ( String s ) { try { return s . getBytes ( "UTF8" ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; throw new Error ( "Platform-doesn\'t-support-UTF8-encoding" ) ; } } \n', 0.3313940648771572)

('@ SuppressWarnings ( "boxing" ) protected Character convertCharacter ( Object value ) throws BadInputException { if ( value instanceof Character ) { return ( Character ) value ; } if ( value instanceof Number ) { int primitive = ( ( Number ) value ) . intValue ( ) ; if ( primitive != ( ( Number ) value ) . longValue ( ) || ( primitive > 0xFFFF ) ) throw new BadInputException ( "Input-did-not-fit-in-char" ) ; return Character . valueOf ( ( char ) primitive ) ; } if ( value instanceof String && ( ( String ) value ) . length ( ) == 1 ) { return ( ( String ) value ) . charAt ( 0 ) ; } throw new BadInputException ( "Could-not-convert!" ) ; } \n', 0.32925361696399685)FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('public static void checkCanWrite ( File targetFile ) throws BuildException { if ( ! targetFile . exists ( ) ) { try { targetFile . createNewFile ( ) ; } catch ( Exception err ) { throw ( new BuildException ( ERROR_CANNOT_WRITE + targetFile ) ) ; } } else if ( ! targetFile . canWrite ( ) ) { throw ( new BuildException ( ERROR_CANNOT_WRITE + targetFile ) ) ; } } \n', 0.3372202094214589)

('public static File checkOutputFile ( String name ) throws IOException { File file = new File ( name ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } if ( ! ( file . isFile ( ) && file . canWrite ( ) ) ) { String msg = "File-missing-or-incorrect:-" + name ; throw new IllegalArgumentException ( msg ) ; } return file ; } \n', 0.3174055611754631)

('private void checkFileExist ( File file ) { if ( file . exists ( ) ) { readFileContentIntoStorageArray ( file ) ; } else { createNewFile ( file ) ; isMissing = true ; } } \n', 0.3113425714440071)

('private static void checkFile ( File f ) throws IOException { if ( f == null ) { throw new IllegalArgumentException ( "input-\'f\'-may-not-be-null" ) ; } final String msg ; if ( f . exists ( ) ) { msg = null ; } else { f . createNewFile ( ) ; msg = ",-even-after-creation-attempt." ; } if ( ! f . exists ( ) ) { String err = "File-does-not-exist-@-\'" + f . getAbsolutePath ( ) + "\'" ; if ( msg != null ) { err += msg ; } throw new IOException ( err ) ; } if ( ! f . canWrite ( ) ) { throw new IOException ( "Cannot-write-to-file-(\'" + f . getAbsolutePath ( ) + "\')" ) ; } } \n', 0.30801284000019524)

('private boolean ensureFileExists ( Uri uri , String path ) { File file = new File ( path ) ; if ( file . exists ( ) ) { return true ; } else { try { checkAccess ( uri , file , ParcelFileDescriptor . MODE_READ_WRITE | ParcelFileDescriptor . MODE_CREATE ) ; } catch ( FileNotFoundException e ) { return false ; } int secondSlash = path . indexOf ( \'/\' , 1 ) ; if ( secondSlash < 1 ) return false ; String directoryPath = path . substring ( 0 , secondSlash ) ; File directory = new File ( directoryPath ) ; if ( ! directory . exists ( ) ) return false ; file . getParentFile ( ) . mkdirs ( ) ; try { return file . createNewFile ( ) ; } catch ( IOException ioe ) { Log . e ( TAG , "File-creation-failed" , ioe ) ; } return false ; } } \n', 0.3078485682502542)

('private void checkDatastoreFileAccessAndCreate ( ) throws DatastoreFileException { if ( _datastoreFile . isDirectory ( ) ) { throw new DatastoreFileException ( String . format ( "A-directory-exists-at-the-datastore-file-path-\'%s\'" , _datastoreFile ) ) ; } if ( ! _datastoreFile . exists ( ) ) { try { if ( ! _datastoreFile . createNewFile ( ) ) { throw new DatastoreFileException ( String . format ( "Another-process-already-created-the-new-datastore-file-\'%s\'" , _datastoreFile ) ) ; } } catch ( IOException e ) { throw new DatastoreFileException ( String . format ( "Failed-to-create-new-datastore-file-\'%s\'" , _datastoreFile ) , e ) ; } } else if ( ! _datastoreFile . canRead ( ) ) { throw new DatastoreFileException ( String . format ( "File-permissions-don\'t-allow-reading-datastore-file-path-\'%s\'" , _datastoreFile ) ) ; } else if ( ! _datastoreFile . canWrite ( ) ) { throw new DatastoreFileException ( String . format ( "File-permissions-don\'t-allow-writing-datastore-file-path-\'%s\'" , _datastoreFile ) ) ; } } \n', 0.30444630775650094)

('public static File checkFile ( String fileName , boolean renew ) throws IOException { if ( fileName . indexOf ( "|" ) == - 1 && fileName . indexOf ( "/" ) == - 1 ) { fileName = Constants . TXTFILEPATH + fileName ; } File file = new File ( fileName ) ; if ( renew ) { if ( file . exists ( ) ) { if ( file . canWrite ( ) ) { file . delete ( ) ; } else { throw new IOException ( "file-" + fileName + "-can-not-be-written!" ) ; } } else { boolean success = file . createNewFile ( ) ; if ( success ) { System . out . println ( "Created-the-file:-" + file . getName ( ) ) ; } else { System . err . println ( "Failed-to-create-file:-" + file . getName ( ) ) ; } } } else { if ( file . exists ( ) ) { return file ; } else { throw new IOException ( "No-such-file:-" + fileName ) ; } } return file ; } \n', 0.3042036506416881)

('public static void checkFiles ( ArrayList < String > list ) throws ErrorMessage { for ( int i = 0 ; i < list . size ( ) ; ++ i ) { File file = new File ( list . get ( i ) ) ; if ( ! file . exists ( ) ) throw new ErrorMessage ( "File-not-found:-" + file ) ; if ( ! file . isFile ( ) ) throw new ErrorMessage ( "Not-a-normal-file:-" + file ) ; if ( ! file . canRead ( ) ) throw new ErrorMessage ( "No-read-permissions:-" + file ) ; } } \n', 0.30299570146514687)

('private File [ ] checkFiles ( File [ ] fileArray ) throws FileNotFoundException { if ( fileArray == null ) { throw new NullPointerException ( ) ; } for ( int i = 0 ; i < fileArray . length ; i ++ ) { File file = fileArray [ i ] ; if ( file == null ) { throw new NullPointerException ( ) ; } if ( file . exists ( ) ) { if ( file . isDirectory ( ) ) { throw new FileNotFoundException ( "File-Cannot-be-a-Directory" ) ; } } else { throw new FileNotFoundException ( ) ; } } return fileArray ; } \n', 0.30197217270155596)

('private void checkFile ( boolean createParent , boolean create , boolean canRead , boolean canWrite ) throws PageException { if ( file == null ) throw new ApplicationException ( "attribute-file-is-not-defined-for-tag-file" ) ; securityManager . checkFileLocation ( pageContext . getConfig ( ) , file , serverPassword ) ; if ( ! file . exists ( ) ) { if ( create ) { Resource parent = file . getParentResource ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( createParent ) parent . mkdirs ( ) ; else throw new ApplicationException ( "parent-directory-for-[" + file + "]-doesn\'t-exist" ) ; } try { file . createFile ( false ) ; } catch ( IOException e ) { throw new ApplicationException ( "invalid-file-[" + file + "]" , e . getMessage ( ) ) ; } } else if ( ! file . isFile ( ) ) throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-is-not-a-file" ) ; else throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-doesn\'t-exist" ) ; } else if ( ! file . isFile ( ) ) throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-is-not-a-file" ) ; else if ( canRead && ! file . canRead ( ) ) throw new ApplicationException ( "no-read-access-to-source-file-[" + file . toString ( ) + "]" ) ; else if ( canWrite && ! file . canWrite ( ) ) throw new ApplicationException ( "no-write-access-to-source-file-[" + file . toString ( ) + "]" ) ; } \n', 0.3007664293847666)FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('public static String convertGoodDataDateToString ( String value ) { DateTime dt ; try { int l = Integer . parseInt ( value ) ; if ( l == 0 ) return "" ; dt = base . plusDays ( l - 1 ) ; } catch ( NumberFormatException e ) { return "" ; } return baseFmt . print ( dt ) ; } \n', 0.41857168856235183)

('public static List < String > convertDatesToString ( List < DateTime > dates , DateTimeFormatter formatter ) { List < String > dateString = new ArrayList < > ( ) ; formatter . withZoneUTC ( ) ; for ( DateTime date : dates ) { dateString . add ( formatter . print ( date ) ) ; } return dateString ; } \n', 0.41768728144833595)

('public static String convertGoodDataDateToString ( Number value ) { DateTime dt ; try { int l = value . intValue ( ) ; if ( l == 0 ) return "" ; dt = base . plusDays ( l - 1 ) ; } catch ( NumberFormatException e ) { return "" ; } return baseFmt . print ( dt ) ; } \n', 0.4086972705522483)

('public static java . util . Date stringDateToJavaDate ( String newDate ) { if ( newDate == null || newDate . equals ( "" ) ) { return null ; } String [ ] parts = newDate . split ( "-" ) ; String [ ] date = parts [ 0 ] . split ( "-" ) ; String [ ] time = null ; if ( parts . length > 1 ) { time = parts [ 1 ] . split ( ":" ) ; time [ 2 ] = time [ 2 ] . replaceAll ( "|.0" , "" ) ; } else { time = "00:00:00" . split ( ":" ) ; } GregorianCalendar cal = ( GregorianCalendar ) Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( new Integer ( date [ 0 ] ) . intValue ( ) , ( new Integer ( date [ 1 ] ) . intValue ( ) - 1 ) , new Integer ( date [ 2 ] ) . intValue ( ) , new Integer ( time [ 0 ] ) . intValue ( ) , new Integer ( time [ 1 ] ) . intValue ( ) , new Integer ( time [ 2 ] ) . intValue ( ) ) ; return cal . getTime ( ) ; } \n', 0.40725082876363206)

('protected Object convertToDate ( Class type , Object value ) { DateFormat df = new SimpleDateFormat ( TS_FORMAT ) ; if ( value instanceof String ) { try { if ( StringUtils . isEmpty ( value . toString ( ) ) ) { return null ; } return df . parse ( ( String ) value ) ; } catch ( Exception pe ) { throw new ConversionException ( "Error-converting-String-to-Timestamp" ) ; } } throw new ConversionException ( "Could-not-convert-" + value . getClass ( ) . getName ( ) + "-to-" + type . getName ( ) ) ; } \n', 0.4065326479483031)

('public static java . sql . Date dateFromString ( String dateString ) throws ConversionException { int year ; int month ; int day ; StringTokenizer dateStringTokenizer ; if ( dateString . indexOf ( \'/\' ) != - 1 ) { dateStringTokenizer = new StringTokenizer ( dateString , "/" ) ; } else if ( dateString . indexOf ( \'-\' ) != - 1 ) { dateStringTokenizer = new StringTokenizer ( dateString , "--" ) ; } else { throw ConversionException . incorrectDateFormat ( dateString ) ; } try { year = Integer . parseInt ( dateStringTokenizer . nextToken ( ) ) ; month = Integer . parseInt ( dateStringTokenizer . nextToken ( ) ) ; day = Integer . parseInt ( dateStringTokenizer . nextToken ( ) ) ; } catch ( NumberFormatException exception ) { throw ConversionException . incorrectDateFormat ( dateString ) ; } month = month - 1 ; return dateFromYearMonthDate ( year , month , day ) ; } \n', 0.40298973705834484)

('public java . sql . Date convertStringToDate ( String d ) { String [ ] dateParts = d . split ( "/" ) ; try { int day = Integer . parseInt ( dateParts [ 0 ] ) ; int month = Integer . parseInt ( dateParts [ 1 ] ) ; int year = Integer . parseInt ( dateParts [ 2 ] ) ; if ( year > 1900 ) year -= 1900 ; return new java . sql . Date ( year , month , day ) ; } catch ( NumberFormatException e ) { System . out . println ( "Invalid-date-format:-" + d ) ; System . out . println ( "Should-be-dd/mm/yyyy" ) ; return null ; } catch ( IndexOutOfBoundsException e ) { System . out . println ( "Invalid-date-format:-" + d ) ; System . out . println ( "Should-be-dd/mm/yyyy" ) ; return null ; } } \n', 0.4023004584288348)

('protected Object convertToDate ( final Class < ? > type , final Object value , final String pattern ) { final DateFormat df = new SimpleDateFormat ( pattern ) ; if ( value instanceof String ) { try { if ( StringUtils . isEmpty ( value . toString ( ) ) ) { return null ; } final Date date = df . parse ( ( String ) value ) ; if ( type . equals ( Timestamp . class ) ) { return new Timestamp ( date . getTime ( ) ) ; } return date ; } catch ( final Exception e ) { throw new ConversionException ( "Error-converting-String-to-Date" , e ) ; } } throw new ConversionException ( "Could-not-convert-" + value . getClass ( ) . getName ( ) + "-to-" + type . getName ( ) ) ; } \n', 0.40195887397354624)

('public static Date convertStringToDate ( String dateString ) { String [ ] date = dateString . split ( "|" + DATE_SEPARATOR ) ; Calendar calendar = new GregorianCalendar ( ) ; calendar . set ( Calendar . DAY_OF_MONTH , Integer . valueOf ( date [ 0 ] ) ) ; calendar . set ( Calendar . MONTH , Integer . valueOf ( date [ 1 ] ) - 1 ) ; calendar . set ( Calendar . YEAR , Integer . valueOf ( date [ 2 ] ) ) ; calendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; calendar . set ( Calendar . MINUTE , 0 ) ; calendar . set ( Calendar . SECOND , 0 ) ; return calendar . getTime ( ) ; } \n', 0.3990748813558159)

('public String convertSqlDateToString ( String inputDate ) { String strDate = "" ; String dateArray [ ] = inputDate . split ( "-" ) ; if ( ! dateArray . equals ( "" ) ) { strDate = dateArray [ 1 ] + "/" + dateArray [ 2 ] + "/" + dateArray [ 0 ] ; } return strDate ; } \n', 0.3967577750908048)FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('private static ByteArrayInputStream convertToByteArrayInputStream ( InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; return byteArrayInputStream ; } \n', 0.4039060814012379)

('@ NonNull private static ByteArrayInputStream convertToByteArrayInputStream ( @ NonNull final InputStream inputStream ) throws IOException { if ( inputStream instanceof ByteArrayInputStream ) { return ( ByteArrayInputStream ) inputStream ; } final ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; final byte [ ] buffer = new byte [ 10240 ] ; int readBytes = 0 ; while ( ( readBytes = inputStream . read ( buffer ) ) >= 0 ) { outputStream . write ( buffer , 0 , readBytes ) ; } return new ByteArrayInputStream ( outputStream . toByteArray ( ) ) ; } \n', 0.4039000299514178)

('@ Converter public static byte [ ] convertToByteArray ( StreamCache cache , Exchange exchange ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; cache . writeTo ( os ) ; return os . toByteArray ( ) ; } \n', 0.39872405219597484)

('public static byte [ ] convertToByteArray ( InputStream inputStream ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; FileCopyUtils . copy ( inputStream , out ) ; return out . toByteArray ( ) ; } \n', 0.39225606519718825)

('public static byte [ ] convertToByteArray ( final InputStream is , int length , boolean close ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out , is , length , close ) ; out . close ( ) ; return out . toByteArray ( ) ; } \n', 0.38982828577891115)

('protected ByteArrayInputStream convertToByteArrayInputStream ( Source source ) throws TransformerException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; transform ( source , new StreamResult ( bos ) ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } \n', 0.38975845952977056)

('private ByteArrayInputStream convertToByteArrayInputStream ( Source source ) throws TransformerException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; transform ( source , new StreamResult ( bos ) ) ; return new ByteArrayInputStream ( bos . toByteArray ( ) ) ; } \n', 0.38975845952977056)

('public static byte [ ] convertToByteArray ( final InputStream is , int length ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out , is , length ) ; return out . toByteArray ( ) ; } \n', 0.38880788876088657)

('public static Object convertByteArrayToObject ( byte [ ] bytesArray ) throws UDPDatagramPacketException { if ( bytesArray == null ) { return null ; } ByteArrayInputStream byteStream = new ByteArrayInputStream ( bytesArray ) ; ObjectInputStream oInStream = null ; Object objectReceived = null ; try { BufferedInputStream bufferIn = new BufferedInputStream ( byteStream ) ; try { oInStream = new ObjectInputStream ( bufferIn ) ; } catch ( StreamCorruptedException scex ) { objectReceived = new String ( bytesArray , 0 , bytesArray . length ) ; return objectReceived ; } objectReceived = oInStream . readObject ( ) ; oInStream . close ( ) ; } catch ( IOException ioex ) { throw new UDPDatagramPacketException ( ioex ) ; } catch ( ClassNotFoundException cnfex ) { throw new UDPDatagramPacketException ( cnfex ) ; } return objectReceived ; } \n', 0.38727401034532)

('private ByteArrayOutputStream convertInputStreamIntoByteArrayOutputStream ( InputStream inputStream ) throws IOException { if ( inputStream == null ) { return null ; } byte [ ] byteChunk = new byte [ 1024 ] ; int length = - 1 ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( ( length = inputStream . read ( byteChunk ) ) != - 1 ) { baos . write ( byteChunk , 0 , length ) ; } baos . flush ( ) ; baos . close ( ) ; return baos ; } \n', 0.380722086729662)FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
("private static int checkNumericZone ( String s ) throws UnknownHostException { int percent = s . indexOf ( '%' ) ; int slen = s . length ( ) ; int digit , zone = 0 ; if ( percent == - 1 ) { return - 1 ; } for ( int i = percent + 1 ; i < slen ; i ++ ) { char c = s . charAt ( i ) ; if ( c == ']' ) { if ( i == percent + 1 ) { return - 1 ; } break ; } if ( ( digit = Character . digit ( c , 10 ) ) < 0 ) { return - 1 ; } zone = ( zone * 10 ) + digit ; } return zone ; } \n", 0.3721387715159612)

('private static boolean isNumericalArgument ( String argument ) { String args [ ] = argument . split ( "," ) ; boolean isNumericalArgument = true ; for ( String arg : args ) { try { Integer . parseInt ( arg ) ; } catch ( NumberFormatException nfe ) { isNumericalArgument = false ; break ; } } return isNumericalArgument ; } \n', 0.3610348847296667)

('private static void checkIntegerOrBoundInterval ( String arg , String name , int lowEnd , int highEnd ) throws Exception { if ( ! arg . contains ( "_" ) ) { int argInt = Integer . parseInt ( arg ) ; if ( argInt < lowEnd || argInt > highEnd ) { String msg = "ERROR:-The-" + name + "-value-should-be-between-" + lowEnd + "-and-" + highEnd ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } } else { String [ ] argInterval = arg . split ( "_" ) ; if ( argInterval . length != 2 ) { String msg = "ERROR:-The-" + name + "-interval-should-be-two-integers-separated-by-an-underscore-(\'_\')-" ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } int arg1 = Integer . parseInt ( argInterval [ 0 ] ) ; if ( arg1 < lowEnd || arg1 > highEnd ) { String msg = "ERROR:-The-" + name + "-interval-values-should-be-" + "between-" + lowEnd + "-and-" + highEnd ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } int arg2 = Integer . parseInt ( argInterval [ 1 ] ) ; if ( arg2 < lowEnd || arg2 > highEnd ) { String msg = "ERROR:-The-" + name + "-interval-values-should-be-" + "between-" + lowEnd + "-and-" + highEnd ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } if ( arg1 >= arg2 ) { String msg = "ERROR:-The-" + name + "-interval-should-consist-of-two-numbers-a_b-with-a-<-b" ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } } } \n', 0.3577364490949704)

('private static void checkIntegerOrInterval ( String arg , String name ) throws Exception { if ( ! arg . contains ( "_" ) ) { Integer . parseInt ( arg ) ; } else { String [ ] argInterval = arg . split ( "_" ) ; if ( argInterval . length != 2 ) { String msg = "ERROR:-The-" + name + "-interval-should-be-two-integers-separated-by-an-underscore-(\'_\')-" ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } int a = Integer . parseInt ( argInterval [ 0 ] ) ; int b = Integer . parseInt ( argInterval [ 1 ] ) ; if ( a >= b ) { String msg = "ERROR:-The-" + name + "-interval-should-consist-of-two-numbers-a_b-with-a-<-b" ; LOG . error ( msg ) ; throw new Exception ( msg ) ; } } } \n', 0.3448554282255697)

('protected boolean checkNumeric ( String in ) { try { new Integer ( in ) ; return true ; } catch ( NumberFormatException e ) { return false ; } } \n', 0.34213886003719235)

('private static boolean isNumericValue ( String value ) { try { int pos = Integer . parseInt ( value ) ; } catch ( NumberFormatException nfe ) { return false ; } return true ; } \n', 0.33956400005802023)

('protected void checkNumericControlWord ( MutableAttributeSet currentAttributes , AttributeSet newAttributes , Object attrName , String controlWord , float dflt , float scale ) throws IOException { Object parm ; if ( ( parm = attrDiff ( currentAttributes , newAttributes , attrName , MagicToken ) ) != null ) { float targ ; if ( parm == MagicToken ) targ = dflt ; else targ = ( ( Number ) parm ) . floatValue ( ) ; writeControlWord ( controlWord , Math . round ( targ * scale ) ) ; } } \n', 0.324069438629297)

('public static boolean isNumeric ( String str , Class < ? extends Number > clazz ) { try { if ( clazz . equals ( Byte . class ) ) { Byte . parseByte ( str ) ; } else if ( clazz . equals ( Double . class ) ) { Double . parseDouble ( str ) ; } else if ( clazz . equals ( Float . class ) ) { Float . parseFloat ( str ) ; } else if ( clazz . equals ( Integer . class ) ) { Integer . parseInt ( str ) ; } else if ( clazz . equals ( Long . class ) ) { Long . parseLong ( str ) ; } else if ( clazz . equals ( Short . class ) ) { Short . parseShort ( str ) ; } } catch ( NumberFormatException nfe ) { return false ; } return true ; } \n', 0.32294820296247995)

('private String checkReservedKeyword ( String attr ) { if ( attr != null && attr . length ( ) > 0 && attr . contains ( "." ) ) { String [ ] splits = attr . split ( "[.]" ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < splits . length ; i ++ ) { sb . append ( checkReservedKeyword ( splits [ i ] ) + "." ) ; } if ( sb . length ( ) <= 1 ) { attr = sb . toString ( ) ; } else { attr = sb . substring ( 0 , sb . length ( ) - 1 ) ; } } else if ( DefaultQuery . reservedKeywords . contains ( attr . toLowerCase ( ) ) ) { attr = """ + attr + """ ; } return attr ; } \n', 0.28907947174870563)

('public static boolean isNumerical ( final Object rawObject ) { boolean result = true ; if ( rawObject == null || rawObject instanceof String ) return false ; if ( rawObject instanceof Collection ) { for ( Object obj : ( Collection < ? > ) rawObject ) { if ( ! isNumerical ( obj ) ) { result = false ; break ; } } } else { if ( rawObject instanceof Number || Integer . TYPE . isInstance ( rawObject ) || Double . TYPE . isInstance ( rawObject ) || Byte . TYPE . isInstance ( rawObject ) || Short . TYPE . isInstance ( rawObject ) || Long . TYPE . isInstance ( rawObject ) || Float . TYPE . isInstance ( rawObject ) ) { } else { result = false ; } } return result ; } \n', 0.2869700380139094)FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

('private Serializable copyObject ( Serializable o ) throws RemoteException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; byte [ ] ba = bos . toByteArray ( ) ; Method m = IxcRegistryImpl . getIxcClassLoader ( importer ) . getDeserializeMethod ( ) ; return ( Serializable ) m . invoke ( null , new Object [ ] { ba } ) ; } catch ( RemoteException ex ) { throw ex ; } catch ( Exception ex ) { throw new RemoteException ( "Cannot-copy-object" , ex ) ; } } \n', 0.40537060398417707)

('@ XmlElementDecl ( namespace = AMZN_NS , name = "CopyObject" ) public JAXBElement < CopyObject > createCopyObject ( CopyObject r ) { return Util . createGeneric ( r , CopyObject . class ) ; } \n', 0.40423278690176023)

('@ SuppressWarnings ( "unchecked" ) public static < T > T copyInstance ( T src ) { if ( src == null ) { throw new NullPointerException ( "src-cannot-be-null" ) ; } T copyInstance = null ; Class < T > srcClass = ( Class < T > ) src . getClass ( ) ; PropertyDescriptor [ ] props = retrievePropertyDescriptors ( srcClass ) ; try { copyInstance = ( T ) srcClass . newInstance ( ) ; for ( PropertyDescriptor pd : props ) { Method rm = pd . getReadMethod ( ) ; Method wm = pd . getWriteMethod ( ) ; if ( wm != null && rm != null ) { wm . invoke ( copyInstance , rm . invoke ( src ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return copyInstance ; } \n', 0.39487107591654114)

('public static < T > T copyObject ( final Class < T > clazz , final T sourceObject ) { try { final byte [ ] byteArray = toByteArray ( sourceObject ) ; return fromByteArray ( clazz , byteArray ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can-not-copy-" , e ) ; } } \n', 0.3917783189621187)

('public static Object deepCopy ( Object src ) throws InstantiationException , IllegalAccessException { Class < ? > clazz = src . getClass ( ) ; if ( Modifier . isFinal ( clazz . getModifiers ( ) ) ) { return src ; } Object dst = clazz . newInstance ( ) ; if ( src instanceof Calendar ) { ( ( Calendar ) dst ) . setTimeInMillis ( ( ( Calendar ) src ) . getTimeInMillis ( ) ) ; return dst ; } Field [ ] fields = clazz . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Object fObj = fields [ i ] . get ( src ) ; if ( fObj == null ) { continue ; } Class < ? > fRealType = fObj . getClass ( ) ; if ( ( ! fRealType . isPrimitive ( ) ) || ( ! fRealType . isEnum ( ) ) || fRealType . getPackage ( ) != JAVA_LANG_PKG ) { if ( fRealType . isArray ( ) ) { Object [ ] items = ( Object [ ] ) fObj ; fObj = Array . newInstance ( fRealType . getComponentType ( ) , items . length ) ; for ( int j = 0 ; j < items . length ; j ++ ) { Array . set ( fObj , j , deepCopy ( items [ j ] ) ) ; } } else { fObj = deepCopy ( fObj ) ; } } fields [ i ] . set ( dst , fObj ) ; } return dst ; } \n', 0.3884000434864907)

('public Object copyToNDJavaArray ( ) { Object javaArray ; try { javaArray = java . lang . reflect . Array . newInstance ( getElementType ( ) , getShape ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } IndexIterator iter = getIndexIterator ( ) ; reflectArrayCopyOut ( javaArray , this , iter ) ; return javaArray ; } \n', 0.3871508605741164)

('public static Object copyOf ( Object src ) { int srcLength = Array . getLength ( src ) ; Class < ? > srcComponentType = src . getClass ( ) . getComponentType ( ) ; Object dest = Array . newInstance ( srcComponentType , srcLength ) ; if ( srcComponentType . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( src ) ; i ++ ) { Array . set ( dest , i , copyOf ( Array . get ( src , i ) ) ) ; } } else { System . arraycopy ( src , 0 , dest , 0 , srcLength ) ; } return dest ; } \n', 0.3835520166607283)FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('public long getExecutionTimeMillis ( ) { return result . getExecutionTimeMillis ( ) ; } \n', 0.3491162998252478)

('public long scheduledExecutionTime ( ) { synchronized ( lock ) { switch ( executionType ) { case FIXED_RATE : return System . currentTimeMillis ( ) + rate ; case FIXED_DELAY : return nextExecutionTime + rate ; case FIXED_DELAY_POST_EXECUTION : return nextExecutionTime + rate ; } return ( rate < 0 ? nextExecutionTime + rate : nextExecutionTime - rate ) ; } } \n', 0.3455840684646044)

('public long getExecutionTime ( TimeUnit unit ) { return unit . convert ( executionNanos , TimeUnit . NANOSECONDS ) ; } \n', 0.3386946954794139)

('public String getExecutionTime ( ) { return result . getExecutionTime ( ) ; } \n', 0.33792865755999557)

('private static void saveLastExecutionTime ( Task task ) { TaskDefinition taskDefinition = null ; try { if ( task . getTaskDefinition ( ) != null ) { SchedulerService schedulerService = Context . getSchedulerService ( ) ; taskDefinition = task . getTaskDefinition ( ) ; taskDefinition . setLastExecutionTime ( new Date ( ) ) ; schedulerService . saveTask ( taskDefinition ) ; } else { log . warn ( "Unable-to-save-the-last-execution-time-for-task.-Task.taskDefinition-is-null-in-" + task . getClass ( ) ) ; } } catch ( Exception e ) { log . warn ( "Unable-to-save-the-last-execution-time-for-task-" , e ) ; } } \n', 0.3312954449737842)

('public static long measureExecutionTime ( Runnable r ) { long before = System . currentTimeMillis ( ) ; r . run ( ) ; long after = System . currentTimeMillis ( ) ; return ( after - before ) ; } \n', 0.3292402524514107)

('public long getExecutionTime ( TimeUnit unit ) { return unit . convert ( executionMillis , TimeUnit . MILLISECONDS ) ; } \n', 0.3260543365791999)

('public static long time ( Runnable runnable , int n ) { long before = System . nanoTime ( ) ; for ( int i = 0 ; i < n ; i ++ ) { runnable . run ( ) ; } return ( System . nanoTime ( ) - before ) / n ; } \n', 0.32535553820872576)

('public long getExecutionTime ( ) { if ( _executeMultiple . get ( ) == false ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('public long getExecutionTime ( ) { if ( ! _executeMultiple . get ( ) ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static List < String > readFileByLineAsStringList ( File source , int numOfIngnoredLine ) { List < String > list = new ArrayList < String > ( ) ; if ( source == null || ! source . exists ( ) ) return list ; FileReader fr = null ; BufferedReader br = null ; try { fr = new FileReader ( source ) ; br = new BufferedReader ( fr ) ; String data = "" ; int cnt = numOfIngnoredLine ; while ( ( data = br . readLine ( ) ) != null ) { if ( cnt < 1 ) { list . add ( data ) ; } else { cnt -- ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fr != null ) fr . close ( ) ; if ( br != null ) br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return list ; } \n', 0.4252874498575151)

('public static List < String > readTextFileLines ( String configFile , String encoding ) throws IOException { if ( encoding == null ) encoding = "UTF-8" ; BufferedReader fi = new BufferedReader ( new InputStreamReader ( getConfigFileStream ( configFile ) , encoding ) ) ; List < String > lines = new ArrayList < String > ( ) ; String line = null ; while ( ( line = fi . readLine ( ) ) != null ) { lines . add ( line ) ; } fi . close ( ) ; return lines ; } \n', 0.3818575531981472)

('public static String [ ] readDirLineByLine ( File dir ) throws IOException { ArrayList < String > data = new ArrayList < String > ( ) ; if ( dir . isDirectory ( ) ) { File [ ] fileArr = dir . listFiles ( ) ; for ( File file : fileArr ) { String [ ] fileData = UtilityFiles . readLineByLine ( file ) ; List < String > stringList = Arrays . asList ( fileData ) ; data . addAll ( stringList ) ; } } return data . toArray ( new String [ ] { } ) ; } \n', 0.3796484483189375)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.37919295296501615)

('public static String [ ] getTextFileLinesAsArray ( String textFileAddress , Boolean printMessage ) { String [ ] output = new String [ tools . util . File . getTextFileLineCount ( textFileAddress , false ) ] ; int lines = 0 ; BufferedReader reader ; try { reader = new BufferedReader ( new FileReader ( textFileAddress ) ) ; String newLine ; while ( ( newLine = reader . readLine ( ) ) != null ) { output [ lines ] = newLine ; lines ++ ; } reader . close ( ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } if ( printMessage ) System . out . println ( tools . util . File . getName ( textFileAddress ) + "-have-" + lines + "-Line" ) ; return output ; } \n', 0.37355295687184176)

('public static String [ ] readTextFileAsStringArray ( final File file , final String charSet ) throws IOException { final BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( file ) , charSet ) ) ; final List < String > readString = new ArrayList < String > ( 256 ) ; try { while ( true ) { final String line = reader . readLine ( ) ; if ( line == null ) { break ; } readString . add ( line ) ; } } finally { silentlyClose ( reader ) ; } return readString . toArray ( new String [ readString . size ( ) ] ) ; } \n', 0.37038337509192415)

('public static String [ ] readTextFile ( String filePath ) { File textFile = new File ( filePath ) ; LinkedList < String > textLines = new LinkedList < > ( ) ; if ( textFile . exists ( ) ) { try { Scanner scanner = new Scanner ( new FileInputStream ( textFile ) ) ; while ( scanner . hasNext ( ) ) { String textLine = scanner . nextLine ( ) ; if ( textLine != null ) { textLines . add ( textLine ) ; } } scanner . close ( ) ; return textLines . toArray ( new String [ textLines . size ( ) ] ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return new String [ ] { } ; } \n', 0.36934766920866813)

('private ArrayList < String > readTextFile ( String TXTFilePath , String TXTFilename ) throws IOException { ArrayList < String > lineList = new ArrayList < String > ( ) ; File inFile = new File ( TXTFilePath ) ; if ( ! inFile . exists ( ) ) { System . out . println ( "Cannot-find-" + TXTFilePath ) ; System . exit ( 0 ) ; } Scanner myFile = new Scanner ( inFile ) ; for ( int i = 0 ; myFile . hasNext ( ) ; i ++ ) { lineList . add ( myFile . nextLine ( ) ) ; } myFile . close ( ) ; return lineList ; } \n', 0.3597354509301418)

('private static void problemOneBufferedReader ( ) { System . out . println ( "...-using-BufferedReader-with-an-ArrayList<String>..." ) ; ArrayList < String > myInput = new ArrayList < String > ( ) ; for ( int i = 0 ; i < numTimesToRead ; i ++ ) { try { BufferedReader theBuffer = new BufferedReader ( new FileReader ( theFileName ) ) ; String textIn = "" ; while ( ( textIn = ( String ) theBuffer . readLine ( ) ) != null ) { myInput . add ( textIn ) ; } theBuffer . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } for ( int i = myInput . size ( ) - 1 ; i >= myInput . size ( ) - numLinesToPrint ; i -- ) { System . out . println ( i + "-" + myInput . get ( i ) ) ; } } \n', 0.35577143505983855)

('static List < PhEntry > readDictTextFile ( String dictTextFilePath , String delimiter ) throws FileNotFoundException { List < PhEntry > entries = new ArrayList < PhEntry > ( ) ; File f = new File ( dictTextFilePath ) ; if ( ! f . exists ( ) || f . isDirectory ( ) || ! f . canRead ( ) ) { throw new FileNotFoundException ( "Can\'t-resolve-(or-read)-dictFilePath:-" + dictTextFilePath ) ; } try { Scanner scanner = new Scanner ( new BufferedInputStream ( new FileInputStream ( f ) ) ) ; String word = "" ; StringBuilder ipa = new StringBuilder ( ) ; while ( scanner . hasNextLine ( ) ) { Scanner scanner2 = new Scanner ( scanner . nextLine ( ) ) ; scanner2 . useDelimiter ( delimiter ) ; if ( ! scanner2 . hasNext ( ) ) { continue ; } word = scanner2 . next ( ) ; if ( ! scanner2 . hasNext ( ) ) { continue ; } ipa . append ( scanner2 . next ( ) ) ; entries . add ( new PhEntry ( word , ipa . toString ( ) ) ) ; ipa . setLength ( 0 ) ; } } catch ( FileNotFoundException fnfE ) { } return entries ; } \n', 0.3512516566194673)FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('static < T > List < T > makeAbstractColumnList ( T [ ] array ) { List < T > result = Lists . newArrayListWithExpectedSize ( array . length ) ; result . addAll ( Arrays . asList ( array ) ) ; return result ; } \n', 0.3689043307455845)

('public static List < CMLChemFile > wrapAtomContainerListInChemModelList ( List < IAtomContainer > atomContainers ) { List < CMLChemFile > cmlChemfileList = new ArrayList < CMLChemFile > ( ) ; for ( int i = 0 ; i < atomContainers . size ( ) ; i ++ ) { cmlChemfileList . add ( wrapAtomContainerInChemModel ( atomContainers . get ( i ) ) ) ; } return cmlChemfileList ; } \n', 0.33560044361775043)

('@ SuppressWarnings ( "unchecked" ) public < Q , T extends Collection < Q >> T javaListFromPList ( T theCollectionToFillOrNull , Class < Q > theElementRequiredClass ) { return javaListFromPList ( theCollectionToFillOrNull , theElementRequiredClass , false ) ; } \n', 0.3253128079398513)

('public static List resourceListAsLabelValueBeanList ( List resourceList ) { List l = new ArrayList ( ) ; Resource r ; for ( Iterator i = resourceList . iterator ( ) ; i . hasNext ( ) ; ) { r = ( Resource ) i . next ( ) ; l . add ( new LabelValueBean ( r . getResourceName ( ) , String . valueOf ( r . getResourceId ( ) ) ) ) ; } return l ; } \n', 0.3222140465532856)

('protected static List < LinkedList < Relationship >> constructAllPathsToNodeAsRelationshipLinkedLists ( Node node , Map < Node , List < Relationship >> predecessors , boolean backwards ) { List < LinkedList < Relationship >> paths = new LinkedList < LinkedList < Relationship >> ( ) ; List < Relationship > current = predecessors . get ( node ) ; if ( current != null ) { for ( Relationship r : current ) { Node n = r . getOtherNode ( node ) ; List < LinkedList < Relationship >> newPaths = constructAllPathsToNodeAsRelationshipLinkedLists ( n , predecessors , backwards ) ; paths . addAll ( newPaths ) ; for ( LinkedList < Relationship > path : newPaths ) { if ( backwards ) { path . addFirst ( r ) ; } else { path . addLast ( r ) ; } } } } if ( paths . isEmpty ( ) ) { paths . add ( new LinkedList < Relationship > ( ) ) ; } return paths ; } \n', 0.3186910264168714)

('protected static List < LinkedList < Node >> constructAllPathsToNodeAsNodeLinkedLists ( Node node , Map < Node , List < Relationship >> predecessors , boolean includeNode , boolean backwards ) { List < LinkedList < Node >> paths = new LinkedList < LinkedList < Node >> ( ) ; List < Relationship > current = predecessors . get ( node ) ; if ( current != null ) { for ( Relationship r : current ) { Node n = r . getOtherNode ( node ) ; paths . addAll ( constructAllPathsToNodeAsNodeLinkedLists ( n , predecessors , true , backwards ) ) ; } } if ( paths . isEmpty ( ) ) { paths . add ( new LinkedList < Node > ( ) ) ; } if ( includeNode ) { for ( LinkedList < Node > path : paths ) { if ( backwards ) { path . addFirst ( node ) ; } else { path . addLast ( node ) ; } } } return paths ; } \n', 0.3152086967438753)

('public static ArrayList < String > CreateStringListFromIntegerList ( ArrayList < Integer > values ) { ArrayList < String > stringList = new ArrayList < String > ( ) ; for ( Integer value : values ) if ( value . equals ( Integer . MIN_VALUE ) ) stringList . add ( "NA" ) ; else stringList . add ( String . valueOf ( value ) ) ; return stringList ; } \n', 0.3086479046587048)

('public static < T extends Comparable < T >> List < T > mergeListsToUniqueList ( Collection < ? extends Collection < T >> inputLists ) { List < T > resultList = new ArrayList < T > ( ) ; HashSet < T > hs = new HashSet < T > ( ) ; for ( Collection < T > selectionList : inputLists ) { hs . addAll ( selectionList ) ; } resultList . addAll ( hs ) ; Collections . sort ( resultList , Collections . reverseOrder ( ) ) ; return resultList ; } \n', 0.30862933159155026)

('public static List < String > stringListFromPreferenceList ( List < ParticipantId > preferenceList ) { if ( preferenceList == null ) { return Collections . emptyList ( ) ; } return Lists . transform ( new ArrayList < ParticipantId > ( preferenceList ) , new Function < ParticipantId , String > ( ) { @ Override public String apply ( ParticipantId participantId ) { return participantId . stringify ( ) ; } } ) ; } \n', 0.3050333982372091)

('public CancelReservedInstancesListingResult withReservedInstancesListings ( java . util . Collection < ReservedInstancesListing > reservedInstancesListings ) { if ( reservedInstancesListings == null ) { this . reservedInstancesListings = null ; } else { java . util . List < ReservedInstancesListing > reservedInstancesListingsCopy = new java . util . ArrayList < ReservedInstancesListing > ( reservedInstancesListings . size ( ) ) ; reservedInstancesListingsCopy . addAll ( reservedInstancesListings ) ; this . reservedInstancesListings = reservedInstancesListingsCopy ; } return this ; } \n', 0.3045483181142228)FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('public boolean AppendStringToFile ( String path , String text ) { file = new File ( path ) ; if ( ! file . exists ( ) ^ ! file . canWrite ( ) ) { return false ; } String n = System . getProperty ( "line.separator" ) ; text = text . replaceAll ( "-" , n ) ; String [ ] lines = text . split ( n ) ; int l = lines . length ; try { printWriter = new PrintWriter ( new FileWriter ( file , true ) , true ) ; fileWriter = new BufferedWriter ( printWriter ) ; for ( int i = 0 ; i < l ; i ++ ) { fileWriter . write ( lines [ i ] . toString ( ) , 0 , lines [ i ] . length ( ) ) ; fileWriter . write ( n . toString ( ) , 0 , n . length ( ) ) ; } fileWriter . close ( ) ; } catch ( IOException e1 ) { return false ; } return true ; } \n', 0.3831025638752881)

('public boolean AppendStringArrayToFile ( String path , String [ ] lines ) { file = new File ( path ) ; if ( ! file . exists ( ) ^ ! file . canWrite ( ) ) { return false ; } int l = lines . length ; String n = System . getProperty ( "line.separator" ) ; try { printWriter = new PrintWriter ( new FileWriter ( file , true ) , true ) ; fileWriter = new BufferedWriter ( printWriter ) ; for ( int i = 0 ; i < l ; i ++ ) { fileWriter . write ( lines [ i ] . toString ( ) , 0 , lines [ i ] . length ( ) ) ; fileWriter . write ( n . toString ( ) , 0 , n . length ( ) ) ; } fileWriter . close ( ) ; } catch ( IOException e1 ) { return false ; } return true ; } \n', 0.3574369194853959)

('public static void writeText ( String filePath , String text ) throws IOException { createIfNotExist ( filePath ) ; File file = new File ( filePath ) ; if ( file . exists ( ) ) file . delete ( ) ; Formatter formatter = new Formatter ( new FileWriter ( file , true ) ) ; formatter . out ( ) . append ( text ) . append ( "-" ) ; formatter . close ( ) ; } \n', 0.3098333646458814)

('public TextFileWriter ( final String fileName , final boolean append ) throws ApplicationException { try { this . fileName = fileName ; final File file = new File ( fileName ) ; if ( ! file . exists ( ) ) { file . createNewFile ( ) ; } if ( ! file . isFile ( ) || ! file . canWrite ( ) ) { final ErrorDescription ed = new ErrorDescription ( "1000028" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } this . exists = file . exists ( ) ; this . canWrite = file . canWrite ( ) ; printWriter = new PrintWriter ( new FileOutputStream ( file , append ) , true ) ; } catch ( final FileNotFoundException fnfe ) { final ErrorDescription ed = new ErrorDescription ( "1000029" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } catch ( final IOException ioe ) { final ErrorDescription ed = new ErrorDescription ( "1000029" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } } \n', 0.2882880088181378)

('public static boolean writeChangedTextFile ( String content , File file , String encoding ) throws IOException { if ( ! file . exists ( ) ) { writeTextFile ( content , file , encoding ) ; return true ; } ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; OutputStreamWriter writer = new OutputStreamWriter ( out , encoding ) ; writer . write ( content ) ; writer . close ( ) ; byte [ ] outBytes = out . toByteArray ( ) ; byte [ ] inBytes = readBytes ( file ) ; if ( ! Arrays . equals ( outBytes , inBytes ) ) { writeBytes ( outBytes , file ) ; return true ; } else return false ; } \n', 0.2878914997136328)

('public static void copyFile ( File src , File trg ) { if ( src == null || trg == null || ! src . exists ( ) || ! src . isFile ( ) ) { throw new IllegalArgumentException ( "Null-of-invalid-arguments-in-FileUtil.copyFile()" ) ; } boolean trgExists = false ; if ( trg . exists ( ) ) { backup ( trg ) ; trgExists = true ; } FileInputStream sis = null ; FileOutputStream tos = null ; try { sis = new FileInputStream ( src ) ; if ( ! trg . exists ( ) ) { trg . createNewFile ( ) ; } tos = new FileOutputStream ( trg ) ; int n = BUFSIZE ; byte [ ] b = new byte [ BUFSIZE ] ; while ( n > 0 ) { n = sis . read ( b , 0 , BUFSIZE ) ; if ( n > 0 ) { tos . write ( b , 0 , n ) ; } } } catch ( Exception ex ) { if ( trgExists ) { try { File file = new File ( trg . getAbsolutePath ( ) + ".bak" ) ; file . renameTo ( trg ) ; } catch ( Exception ignored ) { } } throw new MdmiException ( ex , "Copy-file-fails" ) ; } finally { try { if ( sis != null ) { sis . close ( ) ; } } catch ( Exception ignored ) { } try { if ( tos != null ) { tos . close ( ) ; } } catch ( Exception ignored ) { } } } \n', 0.2860232652714334)

('public static void createTextFile ( File file , Binding binding , Object value ) throws IOException { try { if ( file . exists ( ) ) file . delete ( ) ; file . createNewFile ( ) ; String txt = binding . printValueDefinition ( value , false ) ; FileOutputStream fos = new FileOutputStream ( file , false ) ; try { OutputStreamWriter os = new OutputStreamWriter ( fos , UTF8 . CHARSET ) ; os . append ( txt ) ; os . flush ( ) ; os . close ( ) ; } finally { fos . close ( ) ; } } catch ( BindingException e ) { throw new IOException ( e ) ; } } \n', 0.2833766634981195)

('@ SuppressWarnings ( "unchecked" ) public static void writeStringToFile ( File file , String ... strings ) throws IOException { createCheck ( file ) ; Files . write ( file . toPath ( ) , Arrays . asList ( strings ) , Charset . defaultCharset ( ) , StandardOpenOption . WRITE , StandardOpenOption . TRUNCATE_EXISTING ) ; } \n', 0.28197551797662107)

('public TextFileWriter ( final String fileName , final boolean append , final boolean overWrite ) throws ApplicationException { try { this . fileName = fileName ; final File file = new File ( fileName ) ; this . exists = file . exists ( ) ; LogService . info ( "File-exists=" + this . exists ) ; if ( this . exists == true && overWrite == false ) { final ErrorDescription ed = new ErrorDescription ( "1000030" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } if ( ! file . exists ( ) ) { file . createNewFile ( ) ; this . exists = file . exists ( ) ; } this . canWrite = file . canWrite ( ) ; if ( this . canWrite == false ) { final ErrorDescription ed = new ErrorDescription ( "1000030" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } printWriter = new PrintWriter ( new FileOutputStream ( file , append ) , true ) ; } catch ( final FileNotFoundException fnfe ) { final ErrorDescription ed = new ErrorDescription ( "1000029" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } catch ( final IOException ioe ) { final ErrorDescription ed = new ErrorDescription ( "1000029" , new String [ ] { fileName } ) ; throw new ApplicationException ( ed ) ; } } \n', 0.2817311686746995)

('private void addComment ( String [ ] p_args ) throws Exception { if ( p_args . length < 9 ) { printUsage ( ) ; return ; } long objectId = Long . parseLong ( p_args [ 5 ] ) ; int objectType = Integer . parseInt ( p_args [ 6 ] ) ; String userId = p_args [ 7 ] ; String commentText = p_args [ 8 ] ; List files = new ArrayList ( ) ; List accessList = new ArrayList ( ) ; int index = 9 ; while ( index < p_args . length ) { String filePath = p_args [ index ] ; File f = new File ( filePath ) ; if ( f . exists ( ) ) { files . add ( filePath ) ; index ++ ; if ( index < p_args . length ) { String access = p_args [ index ] ; if ( "R" . equals ( access ) ) { accessList . add ( "Restricted" ) ; } else { accessList . add ( "General" ) ; } } else { accessList . add ( "General" ) ; } } else { System . err . println ( "File-" + filePath + "-doesn\'t-exist-to-attach-to-comment." ) ; return ; } index ++ ; } String rv = m_ambassador . addComment ( m_accessToken , objectId , objectType , userId , commentText , files . toArray ( ) , accessList . toArray ( ) ) ; System . out . println ( rv ) ; } \n', 0.280312809784034)FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('static public Date convertISOStringToDate ( String isoDateString ) throws java . text . ParseException { DateTime isoDateTime = DateTime . parse ( isoDateString ) ; return isoDateTime . toDate ( ) ; } \n', 0.43398906574851803)

('private String ISOStringToString ( String iso ) { if ( ! iso . equals ( "null" ) ) { DateTimeFormatter parser = ISODateTimeFormat . dateTimeNoMillis ( ) ; DateTime dt = parser . parseDateTime ( iso ) ; DateTimeFormatter formatter = DateTimeFormat . shortDateTime ( ) ; return formatter . print ( dt ) ; } return "null" ; } \n', 0.43304699260911217)

('public static String convertStringDate ( String s , String formatIn , String formatOut ) { try { if ( s . equals ( "now" ) ) { return ( new SimpleDateFormat ( formatOut ) . format ( new java . util . Date ( ) ) ) ; } else { return ( new SimpleDateFormat ( formatOut ) ) . format ( ( new SimpleDateFormat ( formatIn ) ) . parse ( s , new ParsePosition ( 0 ) ) ) ; } } catch ( Exception e ) { return "" ; } } \n', 0.4318859834721639)

('public static Date convertBirthdayStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( birthdayFormat ) ; try { DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } catch ( IllegalArgumentException e ) { return null ; } } \n', 0.431824168089213)

('public static Date convertISODateString ( String date ) { if ( date != null ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd" ) ; try { return df . parse ( date ) ; } catch ( ParseException e ) { } } return null ; } \n', 0.43075864249313045)

('private static String convertDateElementToString ( Date currentDate , String format ) { SimpleDateFormat dateFormat ; String valueToPrint = "" ; dateFormat = new SimpleDateFormat ( DATE_OUTPUT_FORMAT_STRINGS . get ( format ) ) ; dateFormat . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; if ( currentDate . getTime ( ) != 0 ) { valueToPrint = dateFormat . format ( currentDate . getTime ( ) ) ; } return valueToPrint ; } \n', 0.4284342807048358)

('public static Date convertStringToDate ( String userDateString ) { DateTimeFormatter dateTimeConvert = DateTimeFormat . forPattern ( inputFormat ) ; DateTime dateTimeParser = dateTimeConvert . parseDateTime ( userDateString ) ; return dateTimeParser . toDate ( ) ; } \n', 0.4267889105621368)

('public static Calendar convertStringToCalendar ( String str ) throws ParseException { Date date = DateConverter . dateFormatter . parse ( str ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } \n', 0.42618858227106465)

('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.42394657253575907)

('public static List < String > convertDatesToString ( List < DateTime > dates , DateTimeFormatter formatter ) { List < String > dateString = new ArrayList < > ( ) ; formatter . withZoneUTC ( ) ; for ( DateTime date : dates ) { dateString . add ( formatter . print ( date ) ) ; } return dateString ; } \n', 0.42361262835403035)FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('@ Override public List < Converter > filter ( List < Converter > converters , DataType < ? > source , DataType < ? > result ) { if ( converters . size ( ) == 0 ) { return Collections . emptyList ( ) ; } List < TransformerWeighting > weightings = getTransformerWeightings ( converters , source . getType ( ) , result . getType ( ) ) ; TransformerWeighting transformerWeighting = weightings . get ( weightings . size ( ) - 1 ) ; int index = weightings . size ( ) - 2 ; List < Converter > heaviestConverter = new LinkedList < Converter > ( ) ; heaviestConverter . add ( ( Converter ) transformerWeighting . getTransformer ( ) ) ; for ( ; index > - 1 ; -- index ) { if ( weightings . get ( index ) . compareTo ( transformerWeighting ) < 0 ) { break ; } else { heaviestConverter . add ( ( Converter ) weightings . get ( index ) . getTransformer ( ) ) ; } } return heaviestConverter ; } \n', 0.3024243098331326)

('public static ControlledVoc getBestSpeciesMatch ( ArrayList < String > searchStrings ) throws ConversionWarningException { if ( searchStrings == null || searchStrings . size ( ) == 0 ) return ITRDBTaxonConverter . getControlledVocFromCode ( "UNKN" ) ; HashSet < String > codelist = new HashSet < String > ( ) ; for ( String str : searchStrings ) { if ( str == null ) continue ; if ( str . length ( ) == 0 ) continue ; if ( ! getNameFromCode ( str ) . equals ( str . toUpperCase ( ) ) ) { codelist . add ( str ) ; } else if ( ! getCodeFromName ( str ) . equals ( str ) ) { codelist . add ( getCodeFromName ( str ) ) ; } } if ( codelist . size ( ) == 0 ) { if ( searchStrings . size ( ) == 1 ) { return getControlledVocFromName ( searchStrings . get ( 0 ) ) ; } else { throw new ConversionWarningException ( new ConversionWarning ( WarningType . AMBIGUOUS , "Ambiguous-taxon-information-supplied." ) ) ; } } else if ( codelist . size ( ) == 2 && codelist . contains ( "UNKN" ) ) { codelist . remove ( "UNKN" ) ; } else if ( codelist . size ( ) > 1 ) { throw new ConversionWarningException ( new ConversionWarning ( WarningType . AMBIGUOUS , "Ambiguous-taxon-information-supplied." ) ) ; } Iterator < String > itr = codelist . iterator ( ) ; return getControlledVocFromCode ( itr . next ( ) ) ; } \n', 0.293303573662976)

('@ SuppressWarnings ( { "rawtypes" , "unchecked" } ) private Object getFilterFromString ( String filterText , IDisplayConverter converter ) throws InstantiationException , IllegalAccessException , ClassNotFoundException { if ( filterText . startsWith ( FILTER_COLLECTION_PREFIX ) ) { int indexEndCollSpec = filterText . indexOf ( ")" ) ; String collectionSpec = filterText . substring ( filterText . indexOf ( "(" ) + 1 , indexEndCollSpec ) ; Collection filterCollection = ( Collection ) Class . forName ( collectionSpec ) . newInstance ( ) ; filterText = filterText . substring ( indexEndCollSpec + 2 , filterText . length ( ) - 1 ) ; String [ ] filterSplit = filterText . split ( IPersistable . VALUE_SEPARATOR ) ; for ( String filterString : filterSplit ) { filterCollection . add ( converter . displayToCanonicalValue ( filterString ) ) ; } return filterCollection ; } return converter . displayToCanonicalValue ( filterText ) ; } \n', 0.2874380692254263)

('private void convertWildCardIntoFilter ( List < Filter > filters ) { ArrayList < Filter > newFilters = new ArrayList < Filter > ( ) ; for ( Iterator < Filter > iterator = filters . iterator ( ) ; iterator . hasNext ( ) ; ) { Filter filter = ( Filter ) iterator . next ( ) ; if ( filter . isWildCard ( ) ) { iterator . remove ( ) ; newFilters . addAll ( WildCardToFilterConverter . convert ( filter . getAttribute ( ) , entityClass ) ) ; } } filters . addAll ( newFilters ) ; } \n', 0.28440246743379516)

('private List < Class < ? >> getTestClassesInBundle ( final Bundle bundle , final Iterable < String > bundleNames , final Iterable < String > packageBlackList , final Iterable < String > testClassFilters , final String commonFilterSuffix ) { final Enumeration < ? > allClassNames = bundle . findEntries ( "/" , "*.class" , true ) ; if ( allClassNames != null ) { final List < Class < ? >> testClassesInBundle = new ArrayList < Class < ? >> ( ) ; while ( allClassNames . hasMoreElements ( ) ) { final String classPath = findPathAndConvertToClassName ( ( URL ) allClassNames . nextElement ( ) ) ; final int packageRootStartIndex = getPackageRoot ( classPath , bundleNames ) ; if ( packageRootStartIndex == - 1 ) { continue ; } String className = classPath . substring ( packageRootStartIndex ) ; className = className . substring ( 0 , className . length ( ) - ".class" . length ( ) ) ; final Class < ? > testClass = loadClass ( bundle , className ) ; if ( testClass != null ) { if ( checkForValidTest ( testClassFilters , commonFilterSuffix , packageBlackList , testClass ) ) { testClassesInBundle . add ( testClass ) ; } } } return testClassesInBundle ; } return Collections . emptyList ( ) ; } \n', 0.28075520467601844)

('public static < TO , FROM > List < TO > mapFilterNulls ( Function < FROM , TO > converter , Collection < FROM > fromCollection ) { ArrayList < TO > toList = new ArrayList < > ( fromCollection . size ( ) ) ; for ( FROM from : fromCollection ) { TO converted = converter . apply ( from ) ; if ( converted != null ) { toList . add ( converted ) ; } } return toList ; } \n', 0.2757182963660134)

('private List search ( DirContext ctx , String rootDN , String scope , String filter , String [ ] attributes ) { try { List listResults = new ArrayList ( ) ; SearchControls constraints = new SearchControls ( ) ; constraints . setSearchScope ( convertSearchScope ( scope ) ) ; constraints . setReturningAttributes ( attributes ) ; try { if ( scope != null && scope . toUpperCase ( ) . equals ( "ALLLEVELS" ) ) { String [ ] levels = rootDN . split ( "," ) ; for ( int i = 0 ; i < levels . length ; i ++ ) { String [ ] currentLevels = new String [ levels . length - i ] ; System . arraycopy ( levels , i , currentLevels , 0 , levels . length - i ) ; String levelRootDN = StringUtils . join ( currentLevels , "," ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( "LDAP-Search-on-level-" + levelRootDN ) ; NamingEnumeration results = ctx . search ( levelRootDN , filter , constraints ) ; for ( ; results . hasMore ( ) ; ) { SearchResult result = ( SearchResult ) results . next ( ) ; listResults . add ( result ) ; } } } else { NamingEnumeration results = ctx . search ( rootDN , filter , constraints ) ; for ( ; results . hasMore ( ) ; ) { SearchResult result = ( SearchResult ) results . next ( ) ; listResults . add ( result ) ; } } } catch ( NameNotFoundException e ) { } return listResults ; } catch ( NamingException e ) { throw new OXFException ( "LDAP-Search-Failed" , e ) ; } } \n', 0.2729898200800868)

('static MultiQueryBuilder splitQuery ( Query query , Collection < QuerySplitter > splitters ) { List < FilterPredicate > remainingFilters = new LinkedList < FilterPredicate > ( query . getFilterPredicates ( ) ) ; List < QuerySplitComponent > components = new ArrayList < QuerySplitComponent > ( ) ; Set < EntityFilter > entityFilters = new HashSet < EntityFilter > ( ) ; for ( QuerySplitter splitter : splitters ) { components . addAll ( splitter . split ( remainingFilters , query . getSortPredicates ( ) , entityFilters ) ) ; } if ( components . size ( ) > 0 ) { return new MultiQueryBuilder ( query , remainingFilters , entityFilters , convertComponents ( components , query . getSortPredicates ( ) . size ( ) ) ) ; } return null ; } \n', 0.27075228804243734)

('public void refreshBestOfFiles ( ) { Log . debug ( "Invoking-Refresh-of-BestOf-Files" ) ; alBestofFiles . clear ( ) ; int iNbBestofFiles = Integer . parseInt ( Conf . getString ( Const . CONF_BESTOF_TRACKS_SIZE ) ) ; List < File > alEligibleFiles = new ArrayList < File > ( iNbBestofFiles ) ; List < Track > tracks = TrackManager . getInstance ( ) . getTracks ( ) ; CollectionUtils . filter ( tracks , new JajukPredicates . BannedTrackPredicate ( ) ) ; for ( Track track : tracks ) { File file = track . getBestFile ( Conf . getBoolean ( Const . CONF_OPTIONS_HIDE_UNMOUNTED ) ) ; if ( file != null ) { alEligibleFiles . add ( file ) ; } } Collections . sort ( alEligibleFiles , rateComparator ) ; int i = 0 ; while ( i < alEligibleFiles . size ( ) && i < iNbBestofFiles ) { File file = alEligibleFiles . get ( i ) ; alBestofFiles . add ( file ) ; i ++ ; } } \n', 0.2702593540035626)

('public static < T > Set < T > excludeMatching ( Collection < T > values , StringConverter < T > converter , Collection < String > filters , boolean exactMatch ) { if ( values == null ) throw new NullPointerException ( "values-cannot-be-null" ) ; if ( converter == null ) throw new NullPointerException ( "converter-cannot-be-null" ) ; if ( filters == null ) throw new NullPointerException ( "filters-cannot-be-null" ) ; Set < String > unpackedFilters = unpackSet ( filters ) ; Set < T > filteredValues = new LinkedHashSet < T > ( ) ; filteredValues . addAll ( values ) ; Collection < Pattern > patterns = null ; if ( ! exactMatch ) patterns = compilePatterns ( unpackedFilters ) ; for ( T value : values ) { String converted = converter . convert ( value ) ; if ( unpackedFilters . contains ( converted ) ) { filteredValues . remove ( value ) ; } else if ( ! exactMatch ) { for ( Pattern pattern : patterns ) if ( pattern . matcher ( converted ) . find ( ) ) filteredValues . remove ( value ) ; } } return filteredValues ; } \n', 0.2626839459000794)FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public byte [ ] convertSchemaBase64ToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { StringTokenizer tokenizer = new StringTokenizer ( ( String ) sourceObject ) ; StringBuilder builder = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { builder . append ( tokenizer . nextToken ( ) ) ; } byte [ ] bytes = Base64 . base64Decode ( builder . toString ( ) . getBytes ( ) ) ; return bytes ; } return convertObjectToByteArray ( sourceObject ) ; } \n', 0.22653712605644086)

('@ Override public byte [ ] convertSchemaBase64ToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { StringTokenizer tokenizer = new StringTokenizer ( ( String ) sourceObject ) ; StringBuilder builder = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { builder . append ( tokenizer . nextToken ( ) ) ; } byte [ ] bytes = Base64 . base64Decode ( builder . toString ( ) . getBytes ( ) ) ; return bytes ; } return convertObjectToByteArray ( sourceObject ) ; } \n', 0.22653712605644077)

('private String convertTabsToSpaces ( IDocument document , String text , int offset , String indentString ) throws BadLocationException { if ( text . indexOf ( "-" ) != - 1 ) { if ( text . equals ( "-" ) ) { deleteWhitespaceAfter ( document , offset ) ; text = indentString ; } else { char [ ] chars = text . toCharArray ( ) ; FastStringBuffer newText = new FastStringBuffer ( ) ; for ( int count = 0 ; count < chars . length ; count ++ ) { if ( chars [ count ] == \'|t\' ) { newText . append ( indentString ) ; } else { newText . append ( chars [ count ] ) ; } } text = newText . toString ( ) ; } } return text ; } \n', 0.20037882476411673)

('private Throwable convertString ( final ListIterator < String > lines , final boolean removeCausedBy ) { String firstLine = lines . next ( ) ; if ( removeCausedBy ) { firstLine = firstLine . substring ( CAUSED_BY_STRING_LENGTH ) ; } final int colon = firstLine . indexOf ( ":" ) ; String throwableClassName ; String message = null ; if ( colon > 1 ) { throwableClassName = firstLine . substring ( 0 , colon ) ; if ( firstLine . length ( ) > colon + 1 ) { message = firstLine . substring ( colon + 1 ) . trim ( ) ; } } else { throwableClassName = firstLine ; } final List < StackTraceElement > stackTrace = new ArrayList < > ( ) ; Throwable cause = null ; while ( lines . hasNext ( ) ) { final String line = lines . next ( ) ; if ( line . startsWith ( "Caused-by-" ) ) { lines . previous ( ) ; cause = convertString ( lines , true ) ; break ; } stackTrace . add ( StackTraceElementAttributeConverter . convertString ( line . trim ( ) . substring ( 3 ) . trim ( ) ) ) ; } return this . getThrowable ( throwableClassName , message , cause , stackTrace . toArray ( new StackTraceElement [ stackTrace . size ( ) ] ) ) ; } \n', 0.1701845045281182)

('protected void doneParsing ( ) throws SAXException { super . doneParsing ( ) ; final Properties properties = getResult ( ) ; final ArrayList list = new ArrayList ( ) ; final Iterator entries = properties . entrySet ( ) . iterator ( ) ; while ( entries . hasNext ( ) ) { final Map . Entry o = ( Map . Entry ) entries . next ( ) ; final String key = ( String ) o . getKey ( ) ; final String value = ( String ) o . getValue ( ) ; try { int index = Integer . parseInt ( key ) ; if ( index < 0 ) { throw new ParseException ( "Failed-to-parse-array-index" , getLocator ( ) ) ; } list . ensureCapacity ( index ) ; while ( list . size ( ) < ( index + 1 ) ) { list . add ( null ) ; } list . set ( index , ObjectConverterFactory . convert ( componentType , value , getLocator ( ) ) ) ; } catch ( NumberFormatException nfe ) { throw new ParseException ( "Failed-to-parse-array-index" , getLocator ( ) ) ; } } retval = list . toArray ( ) ; } \n', 0.16100166304165)

("public static String convertString ( byte [ ] bytes , int start , int count ) throws UnsupportedEncodingException { String s = new String ( bytes , start , count , ArUtil . US_ASCII ) ; int index = s . indexOf ( '-' ) ; if ( index == - 1 ) { return s ; } s = s . substring ( 0 , index ) ; return s ; } \n", 0.16024286651085795)

('private SingleByteCharsetConverter ( String encodingName ) throws UnsupportedEncodingException { String allBytesString = new String ( allBytes , 0 , BYTE_RANGE , encodingName ) ; int allBytesLen = allBytesString . length ( ) ; System . arraycopy ( unknownCharsMap , 0 , this . charToByteMap , 0 , this . charToByteMap . length ) ; for ( int i = 0 ; i < BYTE_RANGE && i < allBytesLen ; i ++ ) { char c = allBytesString . charAt ( i ) ; this . byteToChars [ i ] = c ; this . charToByteMap [ c ] = allBytes [ i ] ; } } \n', 0.15933192230605453)

('public static int [ ] splitToIntArray ( String contatenatedValue , String separator ) throws NumberFormatException { if ( TextUtils . isEmpty ( contatenatedValue ) ) return new int [ 0 ] ; String [ ] values = contatenatedValue . split ( separator ) ; int [ ] converted = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { int value = Integer . parseInt ( values [ i ] ) ; converted [ i ] = value ; } return converted ; } \n', 0.15684191507761042)

('public final static long parseByteSize ( String size ) { String s = size ; long result = 0 ; if ( isSet ( s ) ) { int byteConvert = 1 ; String [ ] split = s . split ( "|D" ) ; String bytes = split [ 0 ] ; if ( bytes . length ( ) != s . length ( ) ) { String unit = s . substring ( bytes . length ( ) , bytes . length ( ) + 1 ) ; if ( unit . equalsIgnoreCase ( "k" ) ) { byteConvert = 1024 ; } else if ( unit . equalsIgnoreCase ( "m" ) ) { byteConvert = 1024 * 1024 ; } else if ( unit . equalsIgnoreCase ( "g" ) ) { byteConvert = 1024 * 1024 * 1024 ; } } try { result = Long . parseLong ( bytes ) * byteConvert ; } catch ( NumberFormatException e ) { } } return result ; } \n', 0.15555831566537828)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.14564378103656933)FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('private int [ ] splitStringToInt ( String input , String delimiter ) { if ( input == null || delimiter == null ) { return null ; } String strArray [ ] = input . split ( delimiter ) ; try { int intArray [ ] = new int [ strArray . length ] ; for ( int i = 0 ; i < strArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( strArray [ i ] ) ; } return intArray ; } catch ( NumberFormatException e ) { } return null ; } \n', 0.30487693112779934)

('public static int [ ] splitToIntArray ( String contatenatedValue , String separator ) throws NumberFormatException { if ( TextUtils . isEmpty ( contatenatedValue ) ) return new int [ 0 ] ; String [ ] values = contatenatedValue . split ( separator ) ; int [ ] converted = new int [ values . length ] ; for ( int i = 0 ; i < values . length ; i ++ ) { int value = Integer . parseInt ( values [ i ] ) ; converted [ i ] = value ; } return converted ; } \n', 0.3021739628488614)

('public String ucWords ( String wordsToConvert ) { wordsToConvert = wordsToConvert . toLowerCase ( ) ; Boolean ucChar = false ; String convertedString = "" ; for ( int i = 0 ; i < wordsToConvert . length ( ) ; i ++ ) { if ( i == 0 | ucChar ) { convertedString += Character . toUpperCase ( wordsToConvert . charAt ( i ) ) ; } else { convertedString += Character . toString ( wordsToConvert . charAt ( i ) ) ; } if ( Character . isWhitespace ( wordsToConvert . charAt ( i ) ) ) { ucChar = true ; } else { ucChar = false ; } } return convertedString ; } \n', 0.2975540550551912)

('public static String [ ] splitByDelimiter ( String toSplit , int numPieces ) { String [ ] pieces = toSplit . split ( BidirectionalConverter . DELIMITER ) ; if ( pieces . length > numPieces ) { throw new IllegalArgumentException ( "Cannot-convert-string-"" + toSplit + ""-with-an-invalid-number-of-properties." ) ; } else if ( pieces . length < numPieces ) { String [ ] allPieces = new String [ numPieces ] ; int i = 0 ; for ( String piece : pieces ) { allPieces [ i ] = piece ; i ++ ; } for ( ; i < numPieces ; i ++ ) { allPieces [ i ] = "" ; } return allPieces ; } return pieces ; } \n', 0.28820260209527426)

('public static byte [ ] [ ] splitAndGetPathComponents ( String str ) { try { final int len ; if ( str == null || ( ( len = str . length ( ) ) == 0 ) || str . charAt ( 0 ) != Path . SEPARATOR_CHAR ) { return null ; } char [ ] charArray = UTF8 . getCharArray ( len ) ; str . getChars ( 0 , len , charArray , 0 ) ; List < byte [ ] > componentByteList = new ArrayList < byte [ ] > ( 20 ) ; boolean canFastConvert = true ; int startIndex = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( charArray [ i ] == Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , i , charArray , canFastConvert ) ) ; startIndex = i + 1 ; canFastConvert = true ; } else if ( charArray [ i ] > UTF8 . MAX_ASCII_CODE ) { canFastConvert = false ; } } if ( charArray [ len - 1 ] != Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , len , charArray , canFastConvert ) ) ; } int last = componentByteList . size ( ) ; while ( -- last >= 1 && componentByteList . get ( last ) . length == 0 ) { componentByteList . remove ( last ) ; } return componentByteList . toArray ( new byte [ last + 1 ] [ ] ) ; } catch ( UnsupportedEncodingException e ) { return null ; } } \n', 0.2494414971206559)

('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.2493496268573035)

("@ Override public short [ ] fromString ( String str ) { List < Short > shorts = Lists . newArrayList ( ) ; EscapeAwareSplitter splitter = new EscapeAwareSplitter ( CharMatcher . WHITESPACE . or ( CharMatcher . is ( ',' ) ) , EscapeAwareSplitter . NO_ESCAPE_LEXER_SUPPLIER ) ; Iterator < String > split = splitter . split ( str . substring ( 1 , str . length ( ) - 1 ) ) ; while ( split . hasNext ( ) ) { shorts . add ( Short . parseShort ( split . next ( ) ) ) ; } short [ ] ret = new short [ shorts . size ( ) ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { ret [ i ] = shorts . get ( i ) ; } return ret ; } \n", 0.24248866098053268)

("@ Override public int [ ] fromString ( String str ) { List < Integer > ints = Lists . newArrayList ( ) ; EscapeAwareSplitter splitter = new EscapeAwareSplitter ( CharMatcher . WHITESPACE . or ( CharMatcher . is ( ',' ) ) , EscapeAwareSplitter . NO_ESCAPE_LEXER_SUPPLIER ) ; Iterator < String > split = splitter . split ( str . substring ( 1 , str . length ( ) - 1 ) ) ; while ( split . hasNext ( ) ) { ints . add ( Integer . parseInt ( split . next ( ) ) ) ; } int [ ] ret = new int [ ints . size ( ) ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { ret [ i ] = ints . get ( i ) ; } return ret ; } \n", 0.2391191438377971)

("@ Override public long [ ] fromString ( String str ) { List < Long > longs = Lists . newArrayList ( ) ; EscapeAwareSplitter splitter = new EscapeAwareSplitter ( CharMatcher . WHITESPACE . or ( CharMatcher . is ( ',' ) ) , EscapeAwareSplitter . NO_ESCAPE_LEXER_SUPPLIER ) ; Iterator < String > split = splitter . split ( str . substring ( 1 , str . length ( ) - 1 ) ) ; while ( split . hasNext ( ) ) { longs . add ( Long . parseLong ( split . next ( ) ) ) ; } long [ ] ret = new long [ longs . size ( ) ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { ret [ i ] = longs . get ( i ) ; } return ret ; } \n", 0.23010433447912837)

("@ Override public byte [ ] fromString ( String str ) { List < Byte > bytes = Lists . newArrayList ( ) ; EscapeAwareSplitter splitter = new EscapeAwareSplitter ( CharMatcher . WHITESPACE . or ( CharMatcher . is ( ',' ) ) , EscapeAwareSplitter . NO_ESCAPE_LEXER_SUPPLIER ) ; Iterator < String > split = splitter . split ( str . substring ( 1 , str . length ( ) - 1 ) ) ; while ( split . hasNext ( ) ) { bytes . add ( Byte . parseByte ( split . next ( ) ) ) ; } byte [ ] ret = new byte [ bytes . size ( ) ] ; for ( int i = 0 ; i < ret . length ; i ++ ) { ret [ i ] = bytes . get ( i ) ; } return ret ; } \n", 0.22864059354652666)FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('private BidiStringConverter buildRecentFilesSizeConverter ( ) { return new BidiStringConverter ( ) { public String convertToString ( Object o ) { return ( o == null ) ? null : ( ( Integer ) o ) . toString ( ) ; } public Object convertToObject ( String s ) { if ( s == null ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } Integer i = new Integer ( s ) ; if ( i . intValue ( ) < 0 || i . intValue ( ) > RecentFilesManager . MAX_MAX_SIZE ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } return i ; } public String toString ( ) { return "RecentFilesManager-IntegerStringConverter" ; } } ; } \n', 0.24714493843839652)

('private static Set < String > evaluateListPartition ( exprNodeDesc desc , ObjectInspector partKeysInpsector , ObjectInspectorConverters . Converter converter , Map < String , List < String >> partSpace , int level , int numPartitionLevels ) throws HiveException { ExprNodeEvaluator evaluator = ExprNodeEvaluatorFactory . get ( desc ) ; ObjectInspector evaluateResultOI = evaluator . initialize ( partKeysInpsector ) ; Set < String > targetPartitions = new TreeSet < String > ( ) ; ArrayList < Object > partObjects = new ArrayList < Object > ( numPartitionLevels ) ; for ( int i = 0 ; i < numPartitionLevels ; i ++ ) { partObjects . add ( null ) ; } for ( Entry < String , List < String >> entry : partSpace . entrySet ( ) ) { List < String > partValues = entry . getValue ( ) ; for ( String partVal : partValues ) { Object pv = converter . convert ( partVal ) ; partObjects . set ( level , pv ) ; Object evaluateResultO = evaluator . evaluate ( partObjects ) ; Boolean r = ( Boolean ) ( ( PrimitiveObjectInspector ) evaluateResultOI ) . getPrimitiveJavaObject ( evaluateResultO ) ; if ( r == null ) { return new TreeSet < String > ( ) ; } else { if ( Boolean . TRUE . equals ( r ) ) { targetPartitions . add ( entry . getKey ( ) ) ; } } } } return targetPartitions ; } \n', 0.20877144738651848)

('public boolean loadRealFromLists ( ArrayList < String > names , ArrayList < ArrayList < ArrayList < Double >>> conf , ArrayList < ArrayList < ArrayList < Integer >>> vis ) { if ( algorithm . equals ( "" ) ) { algorithm = "epics.ai.auctionSchedules.ActiveAuctionSchedule" ; } int maxObj = 0 ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { CameraSettings cs = new CameraSettings ( names . get ( i ) , conf . get ( i ) , vis . get ( i ) , algorithm , communication , customComm , this . getFixLimit ( ) ) ; if ( conf . get ( i ) . size ( ) > maxObj ) { maxObj = conf . get ( i ) . size ( ) ; } cameras . add ( cs ) ; } for ( int i = 0 ; i < maxObj ; i ++ ) { TrObjectSettings tos = new TrObjectSettings ( 0 , 0 , 0 , 0 , i , new ArrayList < Point2D > ( ) , 0 , 1 , "epics.movement.Straight" ) ; objects . add ( tos ) ; } return true ; } \n', 0.20369993905683728)

('private void grabPixels ( int y ) { Raster sourceLine = null ; if ( indexed ) { sourceLine = srcRas . createChild ( sourceXOffset , sourceYOffset + y , sourceWidth , 1 , 0 , 0 , new int [ ] { 0 } ) ; boolean forceARGB = ( indexCM . getTransparency ( ) != Transparency . OPAQUE ) ; BufferedImage temp = indexCM . convertToIntDiscrete ( sourceLine , forceARGB ) ; sourceLine = temp . getRaster ( ) ; } else { sourceLine = srcRas . createChild ( sourceXOffset , sourceYOffset + y , sourceWidth , 1 , 0 , 0 , srcBands ) ; } if ( convertTosRGB ) { if ( debug ) { System . out . println ( "Converting-to-sRGB" ) ; } converted = convertOp . filter ( sourceLine , converted ) ; sourceLine = converted ; } raster . setRect ( sourceLine ) ; if ( ( y > 7 ) && ( y % 8 == 0 ) ) { processImageProgress ( ( float ) y / ( float ) sourceHeight * 100.0F ) ; } } \n', 0.20208989589627116)

('private static List < UniqueId > determineBestWay ( UniqueId x , List < UniqueId > way , AIGraph graph ) { System . out . println ( ) ; System . out . println ( "--Besten-Weg-bestimmen." ) ; int dist = Integer . MAX_VALUE ; List < UniqueId > bestDistance = new ArrayList < UniqueId > ( ) ; for ( int i = 1 ; i < way . size ( ) ; i ++ ) { List < UniqueId > temp = new ArrayList < UniqueId > ( ) ; temp . clear ( ) ; temp . addAll ( way ) ; temp . add ( i , x ) ; int tempDistance = determineLengthOfGivenPath ( temp , graph ) ; if ( tempDistance < dist ) { bestDistance = temp ; dist = tempDistance ; } } System . out . println ( ) ; System . out . print ( "--Bester-Weg-ist-" ) ; printVertexesWithNames ( graph , bestDistance ) ; System . out . println ( "--Bester-Weg-hat-die-Distanz-" + dist ) ; return bestDistance ; } \n', 0.20014529426208888)

('public int merge ( int to , float value , Operation op ) { int tidx = Arrays . binarySearch ( tos , 0 , size , to ) ; if ( tidx < 0 ) { if ( size >= ( capacity - 1 ) ) { grow ( size + 1 ) ; } tidx = - tidx - 1 ; Arrays . insert ( tos , size , tidx , to ) ; Arrays . insert ( values , size , tidx , value ) ; size ++ ; changed = true ; return 1 ; } else { values [ tidx ] = op . calculate ( values [ tidx ] , value ) ; changed |= value != values [ tidx ] ; return 0 ; } } \n', 0.19903752672423303)

('public static ArrayList < TestedObject > searchTestedObjectByDiscription ( String discription , boolean caseInsensitive ) { String SQLName = null ; try { ResultSet rs ; if ( caseInsensitive ) { rs = stat . executeQuery ( "select-*-from-testedObject-where-lower(discription)-like-\'%" + discription + "%\'" ) ; } else { rs = stat . executeQuery ( "select-*-from-testedObject-where-discription-like-\'%" + discription + "%\'" ) ; } ArrayList < TestedObject > tos = new ArrayList < TestedObject > ( ) ; while ( rs . next ( ) ) { SQLName = rs . getString ( "discription" ) ; tos . add ( new TestedObject ( Long . parseLong ( rs . getString ( "id" ) ) , rs . getString ( "date" ) , rs . getString ( "username" ) , rs . getString ( "workername" ) , Long . parseLong ( rs . getString ( "tonnage" ) ) , SQLName ) ) ; } return tos ; } catch ( SQLException e ) { System . err . println ( "There-was-an-error-while-asking-for-the-tested-objects" ) ; } catch ( NumberFormatException e ) { System . err . println ( "There-was-an-faulty-id-stored-in-the-database-for-tested-object-with-discription:-" + SQLName ) ; } return new ArrayList < TestedObject > ( ) ; } \n', 0.19866630354726644)

('private Object convertArrayOfPrimitive ( Object parameter ) { int length = Array . getLength ( parameter ) ; Object convertedValues = Array . newInstance ( parameter . getClass ( ) . getComponentType ( ) , length ) ; for ( int i = 0 ; i < length ; i ++ ) Array . set ( convertedValues , i , convertParameter ( Array . get ( parameter , i ) ) ) ; return convertedValues ; } \n', 0.19627952512974794)

('public int getInterpreterFrameExpressionStackSize ( ) { return ( int ) ( 1 + ( getInterpreterFrameExpressionStackDirection ( ) * ( addressOfInterpreterFrameTOS ( ) . minus ( addressOfInterpreterFrameExpressionStack ( ) ) ) ) ) ; } \n', 0.19443561208779336)

('private Split findBestSplitKey ( Job job , String inputPath ) throws IOException { String splitKey = null ; Configuration conf = job . getConfiguration ( ) ; String splitSelectionStrategy = conf . get ( "split.selection.strategy" , "best" ) ; String candidateSplitsPath = Utility . getSiblingPath ( inputPath , "splits/part-r-00000" ) ; if ( debugOn ) System . out . println ( "candidateSplitsPath:" + candidateSplitsPath ) ; conf . set ( "candidate.splits.path" , candidateSplitsPath ) ; List < String > lines = Utility . getFileLines ( conf , "candidate.splits.path" ) ; Split [ ] splits = new Split [ lines . size ( ) ] ; int i = 0 ; for ( String line : lines ) { splits [ i ] = new Split ( line , i ) ; ++ i ; } Arrays . sort ( splits ) ; int splitIndex = 0 ; if ( splitSelectionStrategy . equals ( "best" ) ) { } else if ( splitSelectionStrategy . equals ( "randomFromTop" ) ) { int numSplits = conf . getInt ( "num.top.splits" , 5 ) ; splitIndex = ( int ) ( Math . random ( ) * numSplits ) ; } Split split = splits [ splitIndex ] ; int splitAttribute = split . getAttributeOrdinal ( ) ; conf . setInt ( "split.attribute" , splitAttribute ) ; if ( debugOn ) System . out . println ( "splitAttribute:" + splitAttribute ) ; splitKey = split . getSplitKey ( ) ; if ( debugOn ) System . out . println ( "splitKey:" + splitKey ) ; conf . set ( "split.key" , splitKey ) ; return split ; } \n', 0.19107930144230828)FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('public String convertArrayClassName ( String className , int bracketIndex ) { String dimensions = "" ; String brackets = className . substring ( bracketIndex ) . trim ( ) ; char [ ] chars = brackets . toCharArray ( ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { if ( chars [ i ] == \'[\' ) { dimensions = dimensions + \'[\' ; } } String arrayType = className . substring ( 0 , bracketIndex ) . trim ( ) ; char prefixChar = \'L\' ; Class < ? > clazz = cPrimativeClasses . get ( arrayType ) ; if ( clazz != null ) { arrayType = "" ; if ( clazz == boolean . class ) { prefixChar = \'Z\' ; } else if ( clazz == char . class ) { prefixChar = \'C\' ; } else if ( clazz == byte . class ) { prefixChar = \'B\' ; } else if ( clazz == short . class ) { prefixChar = \'S\' ; } else if ( clazz == int . class ) { prefixChar = \'I\' ; } else if ( clazz == float . class ) { prefixChar = \'F\' ; } else if ( clazz == double . class ) { prefixChar = \'D\' ; } else if ( clazz == long . class ) { prefixChar = \'J\' ; } else if ( clazz == void . class ) { return null ; } } else { arrayType = arrayType + \';\' ; } return dimensions + prefixChar + arrayType ; } \n', 0.266655522088064)

('private Object convertToArray ( String pType , String pValue ) { String t = pType . substring ( 1 , 2 ) ; Class valueType ; if ( t . equals ( "L" ) ) { String oType = pType . substring ( 2 , pType . length ( ) - 1 ) . replace ( \'/\' , \'.\' ) ; valueType = ClassUtil . classForName ( oType ) ; if ( valueType == null ) { throw new IllegalArgumentException ( "No-class-of-type-" + oType + "found" ) ; } } else { valueType = TYPE_SIGNATURE_MAP . get ( t ) ; if ( valueType == null ) { throw new IllegalArgumentException ( "Cannot-convert-to-unknown-array-type-" + t ) ; } } String [ ] values = EscapeUtil . splitAsArray ( pValue , EscapeUtil . PATH_ESCAPE , "," ) ; Object ret = Array . newInstance ( valueType , values . length ) ; int i = 0 ; for ( String value : values ) { Array . set ( ret , i ++ , value . equals ( "[null]" ) ? null : convertFromString ( valueType . getCanonicalName ( ) , value ) ) ; } return ret ; } \n', 0.24002640382750623)

('private static Object coerce ( CommandSession session , Class < ? > type , Object arg , int [ ] convert ) { if ( arg == null ) { return null ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) ) { return arg ; } if ( type . isArray ( ) ) { return NO_MATCH ; } if ( type . isPrimitive ( ) && arg instanceof Long ) { Number num = ( Number ) arg ; if ( type == short . class ) { return num . shortValue ( ) ; } if ( type == int . class ) { return num . intValue ( ) ; } if ( type == long . class ) { return num . longValue ( ) ; } } convert [ 0 ] += 2 ; Object converted = session . convert ( type , arg ) ; if ( converted != null ) { return converted ; } String string = arg . toString ( ) ; if ( type . isAssignableFrom ( String . class ) ) { return string ; } if ( type . isPrimitive ( ) ) { type = primitiveToObject ( type ) ; } try { return type . getConstructor ( String . class ) . newInstance ( string ) ; } catch ( Exception e ) { } if ( type == Character . class && string . length ( ) == 1 ) { return string . charAt ( 0 ) ; } return NO_MATCH ; } \n', 0.22866172408944951)

('public static void validateMethods ( String httpMethods ) { String [ ] sa = Converters . convertStringToStringArray ( httpMethods , RouteConstants . PROPERTY_SYMBOL_ARRAY_ITEMS_DELIMITER ) ; if ( sa == null ) return ; int length = sa . length ; for ( int i = 0 ; i < length ; i ++ ) { String m = sa [ i ] ; if ( m != null && RouteConstants . ROUTE_HTTP_ALL_METHODS . indexOf ( m . toUpperCase ( ) ) == - 1 ) { throw new IllegalArgumentException ( "Method-"" + m + ""-in-string-"" + httpMethods + ""-is-not-a-supported-HTTP-methods." ) ; } } } \n', 0.21067726013752736)

('public static List < Tuple > getTuplesFromConstantTupleStringAsByteArray ( String [ ] tupleConstants ) throws ParserException , ExecException { List < Tuple > tuples = getTuplesFromConstantTupleStrings ( tupleConstants ) ; for ( Tuple t : tuples ) { convertStringToDataByteArray ( t ) ; } return tuples ; } \n', 0.2059151544045063)

('public static Object fromString ( String string , Class < ? > clazz , ConverterContext context ) { ObjectConverter converter = getConverter ( clazz , context ) ; if ( converter != null && converter . supportFromString ( string , context ) ) { Object value = converter . fromString ( string , context ) ; if ( value != null && clazz != null && ! clazz . isAssignableFrom ( value . getClass ( ) ) ) { if ( TypeUtils . isNumericType ( clazz ) && value instanceof Number ) { clazz = TypeUtils . convertPrimitiveToWrapperType ( clazz ) ; if ( clazz == Double . class ) { return ( ( Number ) value ) . doubleValue ( ) ; } if ( clazz == Byte . class ) { return ( ( Number ) value ) . byteValue ( ) ; } if ( clazz == Short . class ) { return ( ( Number ) value ) . shortValue ( ) ; } if ( clazz == Integer . class ) { return ( ( Number ) value ) . intValue ( ) ; } if ( clazz == Long . class ) { return ( ( Number ) value ) . longValue ( ) ; } if ( clazz == Float . class ) { return ( ( Number ) value ) . floatValue ( ) ; } } } return value ; } else { return null ; } } \n', 0.19844941807089717)

("private FormatConverter getExternalConverter ( String fileName ) { int dotPos = fileName . lastIndexOf ( '.' ) ; if ( dotPos < 0 ) { return null ; } String extension = fileName . substring ( dotPos + 1 ) ; FormatConverter converter = converters . get ( extension ) ; if ( converter == null ) { String converterClassName = registry . get ( extension ) ; if ( converterClassName != null ) { try { converter = ( ( Class < ? extends FormatConverter > ) Class . forName ( converterClassName ) ) . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } return converter ; } \n", 0.1976550723404125)

('public Object invokeOperation ( Map < String , String [ ] > parameterMap ) throws JMException { MBeanParameterInfo [ ] parameterInfoArray = operationInfo . getSignature ( ) ; Object [ ] values = new Object [ parameterInfoArray . length ] ; String [ ] types = new String [ parameterInfoArray . length ] ; MBeanValueConverter valueConverter = createMBeanValueConverter ( parameterMap ) ; for ( int parameterNum = 0 ; parameterNum < parameterInfoArray . length ; parameterNum ++ ) { MBeanParameterInfo parameterInfo = parameterInfoArray [ parameterNum ] ; String type = parameterInfo . getType ( ) ; types [ parameterNum ] = type ; values [ parameterNum ] = valueConverter . convertParameterValue ( parameterInfo . getName ( ) , type ) ; } return mBeanServer . invoke ( objectName , operationInfo . getName ( ) , values , types ) ; } \n', 0.19234686152154346)

('public static boolean isStrictMethodInvocationConvertible ( Class formal , Class actual , boolean possibleVarArg ) { if ( actual == null && ! formal . isPrimitive ( ) ) { return true ; } if ( formal . isAssignableFrom ( actual ) ) { return true ; } if ( formal . isPrimitive ( ) ) { if ( formal == Short . TYPE && ( actual == Byte . TYPE ) ) return true ; if ( formal == Integer . TYPE && ( actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Long . TYPE && ( actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Float . TYPE && ( actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; if ( formal == Double . TYPE && ( actual == Float . TYPE || actual == Long . TYPE || actual == Integer . TYPE || actual == Short . TYPE || actual == Byte . TYPE ) ) return true ; } if ( possibleVarArg && formal . isArray ( ) ) { if ( actual . isArray ( ) ) { actual = actual . getComponentType ( ) ; } return isStrictMethodInvocationConvertible ( formal . getComponentType ( ) , actual , false ) ; } return false ; } \n', 0.18885968112946144)

('public Object fromString ( String string , Class < ? > clazz , ConverterContext context ) { ObjectConverter converter = getConverter ( clazz , context ) ; if ( converter != null ) { Object value ; try { if ( converter instanceof RequiringConverterManager ) { context . getProperties ( ) . put ( ConverterContext . PROPERTY_OBJECT_CONVERTER_MANAGER , this ) ; } value = converter . fromString ( string , context ) ; } finally { if ( converter instanceof RequiringConverterManager ) { context . getProperties ( ) . remove ( ConverterContext . PROPERTY_OBJECT_CONVERTER_MANAGER ) ; } } if ( value != null && clazz != null && ! clazz . isAssignableFrom ( value . getClass ( ) ) ) { if ( TypeUtils . isNumericType ( clazz ) && value instanceof Number ) { clazz = TypeUtils . convertPrimitiveToWrapperType ( clazz ) ; if ( clazz == Double . class ) { return ( ( Number ) value ) . doubleValue ( ) ; } if ( clazz == Byte . class ) { return ( ( Number ) value ) . byteValue ( ) ; } if ( clazz == Short . class ) { return ( ( Number ) value ) . shortValue ( ) ; } if ( clazz == Integer . class ) { return ( ( Number ) value ) . intValue ( ) ; } if ( clazz == Long . class ) { return ( ( Number ) value ) . longValue ( ) ; } if ( clazz == Float . class ) { return ( ( Number ) value ) . floatValue ( ) ; } } } return value ; } else { return null ; } } \n', 0.1862558139698965)FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('private boolean isStackTraceLineFiltred ( boolean isFirstLine , String line ) { if ( ! isFirstLine && stackTraceFilterAction . isChecked ( ) ) { for ( String pattern : STACK_TRACE_FILTER_PATTERNS ) { if ( pattern . charAt ( pattern . length ( ) - 1 ) == \'*\' ) { pattern = pattern . substring ( 0 , pattern . length ( ) - 1 ) ; } else if ( Character . isUpperCase ( pattern . charAt ( 0 ) ) ) { pattern = "at-" + pattern + \'.\' ; } else { int lastDotIndex = pattern . lastIndexOf ( \'.\' ) ; if ( ( lastDotIndex != - 1 ) && ( lastDotIndex != pattern . length ( ) - 1 ) && Character . isUpperCase ( pattern . charAt ( lastDotIndex + 1 ) ) ) { pattern += \'.\' ; } } if ( line . indexOf ( pattern ) > 0 ) { return true ; } } } return false ; } \n', 0.2351593979412823)

('@ Nullable private static StackTraceElement parseStackTraceLine ( @ NotNull String line ) { Matcher matcher = STACK_TRACE_ELEMENT_PATTERN . matcher ( line ) ; if ( matcher . matches ( ) ) { String declaringClass = matcher . group ( 1 ) ; String methodName = matcher . group ( 2 ) ; String fileName = matcher . group ( 3 ) ; String lineNumber = matcher . group ( 4 ) ; return new StackTraceElement ( declaringClass , methodName , fileName , Integer . parseInt ( lineNumber ) ) ; } return null ; } \n', 0.22986420813182712)

('private static StackTraceElement parseStackTrackLine ( String oneLine ) { StringTokenizer stInner = new StringTokenizer ( oneLine , "!" ) ; return new StackTraceElement ( stInner . nextToken ( ) , stInner . nextToken ( ) , stInner . nextToken ( ) , Integer . parseInt ( stInner . nextToken ( ) ) ) ; } \n', 0.21499201983507552)

('private String getFirstLineOfStackTrace ( Exception ex ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; ex . printStackTrace ( pw ) ; LineNumberReader lnr = new LineNumberReader ( new StringReader ( sw . toString ( ) ) ) ; try { String lineOne = lnr . readLine ( ) ; String lineTwo = lnr . readLine ( ) ; return lineOne + "-" + lineTwo ; } catch ( IOException e ) { return null ; } } \n', 0.20896755595219269)

('public String getScriptStackTrace ( FilenameFilter filter ) { List interpreterStack ; Evaluator interpreter = Context . createInterpreter ( ) ; if ( interpreter != null ) interpreterStack = interpreter . getScriptStack ( this ) ; else interpreterStack = new ArrayList ( ) ; int interpreterStackIndex = 0 ; StringBuffer buffer = new StringBuffer ( ) ; String lineSeparator = SecurityUtilities . getSystemProperty ( "line.separator" ) ; StackTraceElement [ ] stack = getStackTrace ( ) ; for ( int i = 0 ; i < stack . length ; i ++ ) { StackTraceElement e = stack [ i ] ; String name = e . getFileName ( ) ; if ( e . getLineNumber ( ) > - 1 && name != null && filter . accept ( null , name ) ) { buffer . append ( "-at-" ) ; buffer . append ( e . getFileName ( ) ) ; buffer . append ( \':\' ) ; buffer . append ( e . getLineNumber ( ) ) ; buffer . append ( lineSeparator ) ; } else if ( interpreterStack != null && "org.mozilla.javascript.Interpreter" . equals ( e . getClassName ( ) ) && "interpretLoop" . equals ( e . getMethodName ( ) ) ) { buffer . append ( interpreterStack . get ( interpreterStackIndex ++ ) ) ; } } return buffer . toString ( ) ; } \n', 0.20656300067697278)

('public List < List < String >> getStackTraces ( ) { List < List < String >> stackTraces = new ArrayList < List < String >> ( ) ; for ( String urlString : taskLogUrls ) { URL taskAttemptLogUrl ; try { taskAttemptLogUrl = new URL ( urlString ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( "Bad-task-log-url" , e ) ; } BufferedReader in ; try { in = new BufferedReader ( new InputStreamReader ( taskAttemptLogUrl . openStream ( ) ) ) ; String inputLine ; String lastLine = null ; boolean lastLineMatched = false ; List < String > stackTrace = null ; Pattern stackTracePattern = Pattern . compile ( "^-at-.*" , Pattern . CASE_INSENSITIVE ) ; Pattern endStackTracePattern = Pattern . compile ( "^-...-[0-9]+-more.*" , Pattern . CASE_INSENSITIVE ) ; while ( ( inputLine = in . readLine ( ) ) != null ) { if ( stackTracePattern . matcher ( inputLine ) . matches ( ) || endStackTracePattern . matcher ( inputLine ) . matches ( ) ) { if ( stackTrace == null ) { stackTrace = new ArrayList < String > ( ) ; stackTrace . add ( lastLine ) ; } else if ( ! lastLineMatched ) { stackTrace . add ( lastLine ) ; } stackTrace . add ( inputLine ) ; lastLineMatched = true ; } else { if ( ! lastLineMatched && stackTrace != null ) { stackTraces . add ( stackTrace ) ; stackTrace = null ; } lastLineMatched = false ; } lastLine = inputLine ; } in . close ( ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error-while-reading-from-task-log-url" , e ) ; } } return stackTraces ; } \n', 0.1977701080969882)

('private static String getStackTraceAsHtml ( Throwable e ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream out = new PrintStream ( baos ) ; e . printStackTrace ( out ) ; out . close ( ) ; try { baos . close ( ) ; } catch ( IOException e1 ) { } String text = baos . toString ( ) ; return "<code>" + text + "</code>" ; } \n', 0.18092826590378458)

('private void convertLinkTab ( String filename , boolean index ) { BufferedReader br = null ; BufferedWriter bw = null ; Vector < String > rptnames = new Vector < String > ( ) ; try { br = new BufferedReader ( new FileReader ( filename ) ) ; String line = null ; StringBuilder contents = new StringBuilder ( ) ; while ( ( line = br . readLine ( ) ) != null ) { int i = 0 , j = 0 ; while ( index && ( i = line . indexOf ( "gsea_report_for" , j ) ) > - 1 ) { j = line . indexOf ( "\'>" , i ) ; String rptname = line . substring ( i , j ) ; if ( rptname . endsWith ( ".html" ) ) { rptnames . add ( resultBase + rptname ) ; } } if ( line . contains ( "<a-href" ) ) line = line . replaceAll ( "<a-href" , "<a-target="_blank"-href" ) ; contents . append ( line ) ; contents . append ( System . getProperty ( "line.separator" ) ) ; } bw = new BufferedWriter ( new FileWriter ( filename ) ) ; bw . write ( contents . toString ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { br . close ( ) ; bw . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } for ( String rptname : rptnames ) convertLinkTab ( rptname , false ) ; } \n', 0.17661242804579672)

('private String formatStackTrace ( Throwable throwable ) { StringWriter w = new StringWriter ( ) ; throwable . printStackTrace ( new PrintWriter ( w ) ) ; String [ ] lineArray = w . toString ( ) . split ( "|n" ) ; List < String > lines = new ArrayList < String > ( Arrays . asList ( lineArray ) ) ; boolean removing = true ; for ( int i = lines . size ( ) - 1 ; i > 0 ; i -- ) { String line = lines . get ( i ) ; if ( removing ) { if ( line . matches ( "|s*[|.|s|d]+more|s*" ) || line . contains ( "at-" + VitroTestRunner . class . getName ( ) ) || line . contains ( "at-org.junit." ) || line . contains ( "at-java.lang.reflect." ) || line . contains ( "at-sun.reflect." ) ) { lines . remove ( line ) ; } else { removing = false ; } } else { if ( line . contains ( "Caused-by:-" ) ) { removing = true ; } } } StringBuilder result = new StringBuilder ( ) ; for ( String line : lines ) { result . append ( line ) . append ( \'|n\' ) ; } return result . toString ( ) . trim ( ) ; } \n', 0.17630779008775832)

('private void addIgnoreStackTraceLine ( String ignoredStackTraceLine ) { if ( ignoredStackTraceLines == null ) { ignoredStackTraceLines = new ArrayList < String > ( ) ; } ignoredStackTraceLines . add ( ignoredStackTraceLine ) ; } \n', 0.1660653243951413)FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('private ArrayList < String > convertMapToListInt ( HashMap < String , Integer > map ) { HashMap < String , Double > convertedMap = new HashMap < String , Double > ( ) ; for ( String key : map . keySet ( ) ) { convertedMap . put ( key , map . get ( key ) . doubleValue ( ) ) ; } return convertMapToList ( convertedMap ) ; } \n', 0.4123906371189145)

('public static Map < String , Map < String , String >> convertTripleListToMaps ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , Map < String , String >> results = new HashMap < > ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 3 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 3 ) { String role = list . get ( count ) ; String key = list . get ( count + 1 ) ; String val = list . get ( count + 2 ) ; Map < String , String > roleMap = results . get ( role ) ; if ( roleMap == null ) { roleMap = new HashMap < > ( ) ; results . put ( role , roleMap ) ; } if ( roleMap . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-for-key-" + key + "-under-" + role ) ; } roleMap . put ( key , val ) ; } } return results ; } \n', 0.4053320917563058)

('public static Map < String , Map < String , String >> convertTripleListToMaps ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , Map < String , String >> results = new HashMap < String , Map < String , String >> ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 3 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 3 ) { String role = list . get ( count ) ; String key = list . get ( count + 1 ) ; String val = list . get ( count + 2 ) ; Map < String , String > roleMap = results . get ( role ) ; if ( roleMap == null ) { roleMap = new HashMap < String , String > ( ) ; results . put ( role , roleMap ) ; } if ( roleMap . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-for-key-" + key + "-under-" + role ) ; } roleMap . put ( key , val ) ; } } return results ; } \n', 0.3923345746619985)

('public static Map < String , String > convertTupleListToMap ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , String > results = new HashMap < String , String > ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 2 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 2 ) { String key = list . get ( count ) ; String val = list . get ( count + 1 ) ; if ( results . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-" + key ) ; } results . put ( key , val ) ; } } return results ; } \n', 0.3858308548055216)

('public static List < MavenArtifact > convertArtifacts ( Collection < Artifact > artifacts , Map < Artifact , MavenArtifact > nativeToConvertedMap , File localRepository ) { if ( artifacts == null ) return new ArrayList < MavenArtifact > ( ) ; List < MavenArtifact > result = new ArrayList < MavenArtifact > ( artifacts . size ( ) ) ; for ( Artifact each : artifacts ) { result . add ( convertArtifact ( each , nativeToConvertedMap , localRepository ) ) ; } return result ; } \n', 0.3796793398401933)

('private List < Binding > convertBindingList ( List < BindingInfo > bindings ) { List < Binding > convertedBindings = new ArrayList < Binding > ( ) ; for ( BindingInfo bi : bindings ) { convertedBindings . add ( convert ( bi ) ) ; } return convertedBindings ; } \n', 0.3783641351198158)

('private static List < Object > convertToBytesRefListIfStringList ( Iterable < ? > objs ) { if ( objs == null ) { return null ; } List < Object > newObjs = new ArrayList < > ( ) ; for ( Object obj : objs ) { newObjs . add ( convertToBytesRefIfString ( obj ) ) ; } return newObjs ; } \n', 0.37104133910321274)

('protected static List convertToValue ( MapiPropertyType mapiPropType , Iterator < String > strings ) throws Exception { EwsUtilities . validateParam ( strings , "strings" ) ; MapiTypeConverterMapEntry typeConverter = getMapiTypeConverterMap ( ) . get ( mapiPropType ) ; List array = new ArrayList ( ) ; int index = 0 ; while ( strings . hasNext ( ) ) { Object value = typeConverter . ConvertToValueOrDefault ( strings . next ( ) ) ; array . add ( index , value ) ; } return array ; } \n', 0.3615719876158464)

('private static Collection < String > convertJSONArrayToList ( JSONArray jsonArray ) throws JSONException { List < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i ++ ) { list . add ( ( String ) jsonArray . get ( i ) ) ; } return list ; } \n', 0.35892636936653144)

('private static List < Map . Entry < String , Integer >> convertAdditionalContextList ( Map < String , String > source ) { if ( source == null ) { return null ; } final List < Map . Entry < String , Integer >> dataList = new ArrayList < Map . Entry < String , Integer >> ( source . size ( ) ) ; for ( final Map . Entry < String , String > en : source . entrySet ( ) ) { final int refValue = JsObjectBase . parseRefId ( en . getValue ( ) ) ; Map . Entry < String , Integer > convertedEntry = new Map . Entry < String , Integer > ( ) { public String getKey ( ) { return en . getKey ( ) ; } public Integer getValue ( ) { return refValue ; } public Integer setValue ( Integer value ) { throw new UnsupportedOperationException ( ) ; } } ; dataList . add ( convertedEntry ) ; } return dataList ; } \n', 0.35490422664259913)FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.33885934442652293