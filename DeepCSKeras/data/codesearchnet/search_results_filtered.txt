########################## 1 #################################
('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.42189944410094926)

('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

('public String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4086881582715446)

('private static String convertReaderToString ( Reader reader ) throws IOException { if ( reader != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40778385592006827)

('private String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) { try { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } catch ( IOException e ) { throw new RuntimeException ( "Did-not-expect-this-one..." , e ) ; } } \n', 0.4074249952540185)

('private static String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

('public String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } \n', 0.4074249952540185)

('public static String convertStreamToString ( final InputStream is ) throws IOException { if ( is == null ) { throw new IOException ( "Empty-stream" ) ; } else { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } } \n', 0.40742241077751923)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 2 #################################
('protected static final < O extends Object > Interval < O > createFromList ( List < IntervalData < O >> intervals ) { Interval < O > newInterval = new Interval < O > ( ) ; if ( intervals . size ( ) == 1 ) { IntervalData < O > middle = intervals . get ( 0 ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; newInterval . add ( middle ) ; return newInterval ; } int half = intervals . size ( ) / 2 ; IntervalData < O > middle = intervals . get ( half ) ; newInterval . center = ( ( middle . start + middle . end ) / 2 ) ; List < IntervalData < O >> leftIntervals = new ArrayList < IntervalData < O >> ( ) ; List < IntervalData < O >> rightIntervals = new ArrayList < IntervalData < O >> ( ) ; for ( IntervalData < O > interval : intervals ) { if ( interval . end < newInterval . center ) { leftIntervals . add ( interval ) ; } else if ( interval . start > newInterval . center ) { rightIntervals . add ( interval ) ; } else { newInterval . add ( interval ) ; } } if ( leftIntervals . size ( ) > 0 ) newInterval . left = createFromList ( leftIntervals ) ; if ( rightIntervals . size ( ) > 0 ) newInterval . right = createFromList ( rightIntervals ) ; return newInterval ; } \n', 0.337776059959168)

('public ArrayList < ArrayList < Double >> createTestList ( int num_points , boolean integers , boolean negative ) { ArrayList < ArrayList < Double >> test_list = new ArrayList ( ) ; for ( int i = 0 ; i < num_points ; i ++ ) { ArrayList < Double > temp_arraylist = new ArrayList ( ) ; double temp_val1 = Math . random ( ) * scale_x ; double temp_val2 = Math . random ( ) * scale_y ; if ( integers ) { temp_val1 = Math . floor ( temp_val1 ) ; temp_val2 = Math . floor ( temp_val2 ) ; } if ( negative ) { temp_val1 = temp_val1 * 2 - scale_x ; temp_val2 = temp_val2 * 2 - scale_y ; } temp_arraylist . add ( temp_val1 ) ; temp_arraylist . add ( temp_val2 ) ; test_list . add ( temp_arraylist ) ; } return test_list ; } \n', 0.32433913586832874)

('private static ArrayList < SmsMessage > createMessageListFromRawRecords ( List < SmsRawData > records ) { ArrayList < SmsMessage > messages = new ArrayList < SmsMessage > ( ) ; if ( records != null ) { int count = records . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SmsRawData data = records . get ( i ) ; if ( data != null ) { SmsMessage sms = SmsMessage . createFromEfRecord ( i + 1 , data . getBytes ( ) ) ; if ( sms != null ) { messages . add ( sms ) ; } } } } return messages ; } \n', 0.32180324625878154)

('public static List < Track > createListFromResultSet ( final ResultSet rs ) throws SQLException { final List < Track > tracks = new ArrayList < Track > ( ) ; while ( rs . next ( ) ) tracks . add ( Track . createFromResultSet ( rs ) ) ; return tracks ; } \n', 0.3149692570249006)

('public List createIntegerListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( BigInteger ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . INTEGER , item ) ) ; } return result ; } \n', 0.31496377986000623)

('private ArrayList < String > arrayToArrayList ( String [ ] array ) { ArrayList < String > arraylist = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { arraylist . add ( array [ i ] ) ; } return arraylist ; } \n', 0.31113449677079336)

('protected List < MusicIndex > createIndexesFromExpression ( String expr ) { List < MusicIndex > result = new ArrayList < MusicIndex > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( expr , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { MusicIndex index = createIndexFromExpression ( tokenizer . nextToken ( ) ) ; result . add ( index ) ; } return result ; } \n', 0.30197965752895306)

('public ArrayList < String > inferredOrthologsToArrayList ( final String seq_name , double threshold_orthologs ) { HashMap < String , Integer > o_hashmap = null ; String name = null ; double o = 0.0 ; final ArrayList < String > arraylist = new ArrayList < String > ( ) ; if ( _o_hash_maps == null ) { throw new IllegalStateException ( "Orthologs-have-not-been-calculated-(successfully)." ) ; } if ( threshold_orthologs < 0.0 ) { threshold_orthologs = 0.0 ; } else if ( threshold_orthologs > 100.0 ) { threshold_orthologs = 100.0 ; } o_hashmap = getInferredOrthologs ( seq_name ) ; if ( o_hashmap == null ) { throw new IllegalStateException ( "Orthologs-for-" + seq_name + "-were-not-established." ) ; } if ( _seq_names . length > 0 ) { I : for ( int i = 0 ; i < _seq_names . length ; ++ i ) { name = _seq_names [ i ] ; if ( name . equals ( seq_name ) ) { continue I ; } o = getBootstrapValueFromHash ( o_hashmap , name ) ; if ( o < threshold_orthologs ) { continue I ; } arraylist . add ( name ) ; } } return arraylist ; } \n', 0.29810528098606914)

('public List createDoubleListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( Double ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . DOUBLE , item ) ) ; } return result ; } \n', 0.2971617146950231)

('private void initObjectsFromArray ( ) { List < EngineObject > newObjects = new ArrayList < EngineObject > ( ) ; for ( int i = 0 ; i < this . objects . length ; i ++ ) { EngineObject obj = objects [ i ] ; if ( obj . placementMask == null ) { initObject ( obj , EngineObject . Placement . CENTER ) ; newObjects . add ( obj ) ; } else { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( obj . placementMask . get ( j ) ) { EngineObject clone = new EngineObject ( obj ) ; initObject ( clone , j ) ; newObjects . add ( clone ) ; } } } } this . originalObjects = new ArrayList < EngineObject > ( Arrays . asList ( objects ) ) ; this . objects = ( EngineObject [ ] ) newObjects . toArray ( new EngineObject [ newObjects . size ( ) ] ) ; } \n', 0.2961794279584901)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 3 #################################
('public < T extends Iterable < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList ( iterables . length ) ; for ( T iterable : iterables ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3500509165733183)

('public < T extends Iterable < ? extends Key >> JoinIterator ( Aggregator < Key , Value > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = new Comparator < Key > ( ) { @ SuppressWarnings ( "unchecked" ) @ Override public int compare ( Key o1 , Key o2 ) { return ( ( Comparable < Key > ) o1 ) . compareTo ( o2 ) ; } } ; for ( T iterable : iterables ) { final Entry entry = new Entry ( size ++ , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; } } \n', 0.34550463930287495)

('public final HashMap collectCachebyAccess ( int rate ) { HashMap resultmap = new HashMap ( ) ; int expectSize = maxSize * rate / 100 ; while ( size > expectSize ) { String key = null ; if ( accessList . getLast ( ) != null ) { key = ( String ) accessList . getLast ( ) . object ; } if ( key != null ) { resultmap . put ( key , hashmap . get ( key ) ) ; remove ( ( String ) accessList . getLast ( ) . object ) ; } else { remove ( ( String ) emptyList . getLast ( ) . object ) ; } } System . out . println ( "rate-is-:-" + size * 100 / maxSize ) ; return resultmap ; } \n', 0.3387688714683485)

('private Iterable < Tile > makeMapIteratorIterable ( final MapIterator m ) { return new Iterable < Tile > ( ) { public Iterator < Tile > iterator ( ) { return new Iterator < Tile > ( ) { public boolean hasNext ( ) { return m . hasNext ( ) ; } public Tile next ( ) { return getTile ( m . next ( ) ) ; } public void remove ( ) { m . remove ( ) ; } } ; } } ; } \n', 0.33329208623876416)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('public Iterable < ? extends Entry < Key , Value >> iterate ( final Indexable indexes ) { return new Iterable < Entry < Key , Value >> ( ) { public Iterator < Entry < Key , Value >> iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Entry < Key , Value >> ( ) { final Iterator < ? extends Entry < Key , Value >> iterator = map . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Entry < Key , Value > next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return new SyncEntry ( iterator . next ( ) ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.3324935216220324)

('private Iterator < Annotation > getAnnotationIterator ( boolean cleanup , boolean recurse ) { Iterator < Annotation > iter = getAnnotationIterator ( cleanup ) ; if ( ! recurse || fAttachments . isEmpty ( ) ) return iter ; List < Iterator < Annotation >> iterators = new ArrayList < > ( fAttachments . size ( ) + 1 ) ; iterators . add ( iter ) ; Iterator < Object > it = fAttachments . keySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) iterators . add ( fAttachments . get ( it . next ( ) ) . getAnnotationIterator ( ) ) ; return new MetaIterator < > ( iterators . iterator ( ) ) ; } \n', 0.3319734088313099)

('public Iterable < ? extends Key > iterate ( final java . lang . Iterable < Long > indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public Iterable < ? extends Key > iterate ( final Indexable indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

('public net . varkhan . base . containers . Iterable < ? extends Key > iterate ( final long [ ] indexes ) { return new Iterable < Key > ( ) { public Iterator < Key > iterator ( ) { rlock . lock ( ) ; try { return new Iterator < Key > ( ) { final Iterator < ? extends Key > iterator = set . iterate ( indexes ) . iterator ( ) ; private long exid = opid ; public boolean hasNext ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . hasNext ( ) ; } finally { rlock . unlock ( ) ; } } public Key next ( ) { rlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; return iterator . next ( ) ; } finally { rlock . unlock ( ) ; } } public void remove ( ) { wlock . lock ( ) ; try { if ( exid != opid ) throw new ConcurrentModificationException ( ) ; exid = ++ opid ; iterator . remove ( ) ; } finally { wlock . unlock ( ) ; } } } ; } finally { rlock . unlock ( ) ; } } } ; } \n', 0.32642407347169744)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 4 #################################
('public static int getRandomInRange ( int min , int max ) throws IllegalArgumentException { if ( min > max ) { throw new IllegalArgumentException ( "Minimum-cannot-be-larger-than-maximum" ) ; } if ( min == max ) { return min ; } int ret = new Random ( ) . nextInt ( max + 1 - min ) + min ; if ( ret < min || ret > max ) { throw new IllegalStateException ( "Programmer-messed-up:-Value-" + ret + "is-not-within-range-of-" + min + "-and-" + max ) ; } return ret ; } \n', 0.44109220995939147)

('double randomInRange ( double min , double max ) { Random random = new Random ( ) ; double range = max - min ; double scaled = random . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.4260948867782801)

('public static double randomDoubleInRange ( double rangeMin , double rangeMax ) { Random r = new Random ( ) ; double doubleInRange = rangeMin + ( rangeMax - rangeMin ) * r . nextDouble ( ) ; return doubleInRange ; } \n', 0.42378763477641407)

('public static double randomInRange ( double min , double max ) { double range = max - min ; double scaled = random . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42228709003799836)

('protected Bid getRandomBidInRange ( double lowerBound , double upperBound ) throws Exception { ArrayList < Bid > bidsInRange = getBidsInRange ( lowerBound , upperBound ) ; int index = ( new Random ( ) ) . nextInt ( bidsInRange . size ( ) - 1 ) ; return bidsInRange . get ( index ) ; } \n', 0.4220003412024551)

('public double randomInRange ( double min , double max ) { double range = max - min ; double scaled = randomNumGenerator_ . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.42066172439532096)

('private static int [ ] getRandomRange ( int end ) { int [ ] range = new int [ end ] ; Random random = new Random ( ) ; for ( int i = 0 ; i < end ; i ++ ) { range [ i ] = random . nextInt ( end ) ; } return range ; } \n', 0.4148010251496685)

('private double randomInRange ( double min , double max ) { double range = ( max - min ) + 1 ; return ( Math . round ( Math . random ( ) * range ) + min + 0.5 ) ; } \n', 0.4128431624918978)

('private int randomInRange ( int min , int max ) { int range = ( max - min ) + 1 ; return ( int ) ( Math . round ( Math . random ( ) * range ) + min ) ; } \n', 0.4128431624918978)

('private static int randomWithRange ( int min , int max ) { int range = Math . abs ( max - min ) + 1 ; return ( int ) ( Math . random ( ) * range ) + ( min <= max ? min : max ) ; } \n', 0.4083084540570455)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 5 #################################
('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.42556612403100647)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.42457246965468176)

('public static int convertStringToIntDef ( String string , int defaultValue ) { try { return Integer . parseInt ( string ) ; } catch ( NumberFormatException e ) { return defaultValue ; } } \n', 0.4149517042983897)

('private String convertLongToString ( Long val ) { String ret = null ; if ( val != null ) { ret = Long . toString ( val . longValue ( ) ) ; } return ret ; } \n', 0.4082949089511342)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.4081503043985538)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.40780405246205736)

('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; value = value . replaceAll ( "|," , "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( value ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( value ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( value ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( value ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( value ) ; } } catch ( NumberFormatException nfe ) { } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.40751204187907863)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.40614039395713686)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.40470804593981363)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.4042160832634376)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 6 #################################
('public List < String > initializeTexts ( ) { List < String > ret = new ArrayList < String > ( ) ; BufferedReader reader = null ; files = getJavaFiles ( ) ; try { for ( String oneFile : files ) { File file = new File ( oneFile ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; StringBuilder stringBuilder = new StringBuilder ( ) ; String ls = ExperimentDataUtil . EOL ; while ( ( line = reader . readLine ( ) ) != null ) { stringBuilder . append ( line ) ; stringBuilder . append ( ls ) ; } reader . close ( ) ; String data = stringBuilder . toString ( ) ; String name = oneFile . substring ( oneFile . indexOf ( SRC_TOKEN ) + SRC_TOKEN . length ( ) ) ; name = name . substring ( 0 , name . indexOf ( JAVA_FILE_TYPE ) ) ; name = name . replace ( "|" , "." ) ; fileNames . add ( name ) ; ret . add ( data ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return ret ; } \n', 0.3713574990046598)

('private JArrayInitializer arrayInitializer ( Type type ) { int line = scanner . token ( ) . line ( ) ; ArrayList < JExpression > initials = new ArrayList < JExpression > ( ) ; mustBe ( LCURLY ) ; if ( have ( RCURLY ) ) { return new JArrayInitializer ( line , type , initials ) ; } initials . add ( variableInitializer ( type . componentType ( ) ) ) ; while ( have ( COMMA ) ) { initials . add ( see ( RCURLY ) ? null : variableInitializer ( type . componentType ( ) ) ) ; } mustBe ( RCURLY ) ; return new JArrayInitializer ( line , type , initials ) ; } \n', 0.3206230520027176)

('protected final void initialize ( int w , int h , int bpp , TwTwoReadStream stream , int [ ] pixels , boolean isPhotoCodec ) { if ( bpp != 16 && bpp != 24 ) throw new IllegalArgumentException ( "Invalid-depth-:" + bpp ) ; this . isPhotoCodec = isPhotoCodec ; isMultiColorSection = true ; pixelZero = PIXEL_ZERO_INITIAL_STATE ; pixelOne = PIXEL_ONE_INITIAL_STATE ; super . initialize ( w , h , bpp , stream ) ; output = pixels ; if ( initialScanLine . length < w ) { initialScanLine = new int [ w ] ; for ( int i = 0 ; i < w ; i ++ ) { initialScanLine [ i ] = PIXEL_ZERO_INITIAL_STATE ; } } if ( isPhotoCodec ) { photographicWeighting = INITIAL_PHOTOGRAPHIC_WEIGHTING ; int [ ] initialPixelCache = ( bpp == 16 ) ? initialPixelCache16 : initialPixelCache24 ; System . arraycopy ( initialPixelCache , 0 , pixelCache , 0 , pixelCache . length ) ; } } \n', 0.3180843057215118)

('private void init ( Vec2f point1 , Vec2f point2 , Vec2f point3 , Vec2f point4 ) { start = _points [ 0 ] = point1 ; ctrl_one = _points [ 1 ] = point2 ; ctrl_two = _points [ 2 ] = point3 ; end = _points [ 3 ] = point4 ; this . setLocation ( start ) ; this . updateSegs ( ) ; _pois = new ArrayList < Vec2f > ( ) ; _drawBorder = false ; _drawDots = new ArrayList < CircleShape > ( ) ; _drawLines = new ArrayList < LineSegment > ( ) ; } \n', 0.3149690118851459)

('private void setupInitialization ( ArrayList < Token > tokens , Line line ) { ArrayList < Token > typeTokens = getTypeName ( config , tokens , 0 ) ; String type = concatenate ( typeTokens ) ; String name = tokens . get ( typeTokens . size ( ) ) . getToken ( ) ; isNameValid ( name , line ) ; ParseTreeNode tree = Parser . getParseTree ( this , line , tokens , typeTokens . size ( ) + 2 ) ; line . setStatment ( Statement . INITIALIZATION ) ; line . setData ( new Object [ ] { type , name , tree } ) ; } \n', 0.3127287838351404)

('private void initializeRandomCentroids ( ) { centroids = new ArrayList < List < Double >> ( ) ; System . out . println ( "Initialing-random-centroids..." ) ; for ( int i = 0 ; i < SharedClass . K_VALUE ; i ++ ) { List < Double > tempOneCentroid = new ArrayList < > ( ) ; for ( int j = 0 ; j < SharedClass . VECTOR_LENGTH ; j ++ ) { tempOneCentroid . add ( SharedClass . randomInRange ( 0.0 , 1.0 ) ) ; } centroids . add ( tempOneCentroid ) ; } copyOfInitialCentroids = centroids ; System . out . println ( "Random-centroids-initialied!!!-" ) ; } \n', 0.31138344889779124)

('private JArrayInitializer arrayInitializer ( Type type ) { final int line = this . scanner . token ( ) . line ( ) ; final ArrayList < JExpression > initials = new ArrayList < JExpression > ( ) ; this . mustBe ( LCURLY ) ; if ( this . have ( RCURLY ) ) { return new JArrayInitializer ( line , type , initials ) ; } initials . add ( this . variableInitializer ( type . componentType ( ) ) ) ; while ( this . have ( COMMA ) ) { initials . add ( this . see ( RCURLY ) ? null : this . variableInitializer ( type . componentType ( ) ) ) ; } this . mustBe ( RCURLY ) ; return new JArrayInitializer ( line , type , initials ) ; } \n', 0.29710785738742523)

('protected String prepareAndCleanMultiCommandsLine ( String strFullCmdLine ) { int iCommentAt = strFullCmdLine . indexOf ( getCommentPrefix ( ) ) ; String strComment = "" ; if ( iCommentAt >= 0 ) { strComment = strFullCmdLine . substring ( iCommentAt ) ; strFullCmdLine = strFullCmdLine . substring ( 0 , iCommentAt ) ; } if ( strFullCmdLine . contains ( "" + getCommandDelimiter ( ) ) ) { ArrayList < String > astrMulti = new ArrayList < String > ( ) ; astrMulti . addAll ( Arrays . asList ( strFullCmdLine . split ( "" + getCommandDelimiter ( ) ) ) ) ; for ( int i = 0 ; i < astrMulti . size ( ) ; i ++ ) { astrMulti . set ( i , astrMulti . get ( i ) . trim ( ) + ( strComment . isEmpty ( ) ? "" : commentToAppend ( strComment ) ) + commentToAppend ( "SplitCmdLine" ) ) ; } addCmdListOneByOneToQueue ( astrMulti , true , true ) ; return RESTRICTED_CMD_SKIP_CURRENT_COMMAND . toString ( ) ; } astrCmdAndParams . clear ( ) ; astrCmdAndParams . addAll ( convertToCmdParamsList ( strFullCmdLine ) ) ; return String . join ( "-" , astrCmdAndParams ) ; } \n', 0.2962101402356588)

('private static Term ArrayInitializer ( ) { Term z ; Term b = Empty . term ; Expect ( 28 ) ; if ( StartOf ( 19 ) ) { b = ArrayInitializerList ( ) ; } Expect ( 29 ) ; z = new ArrayInitializer ( b ) ; return z ; } \n', 0.28928035917298994)

('@ Override protected void init ( ) { State initial ; for ( int line = 0 ; line < this . numberOfLines ; line ++ ) { for ( int column = 0 ; column < this . numberOfColumns ; column ++ ) { Position position = new Position ( line , column ) ; if ( Math . random ( ) > ON_RATIO ) { initial = State . ON ; this . numberOfLightsOn ++ ; } else { initial = State . OFF ; } grid [ line ] [ column ] = new Lamp ( initial , position ) ; } } } \n', 0.2882171330511711)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 7 #################################
('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

('private static boolean containsCheckOnDoubleArray ( double [ ] array , Double compareTest ) { double test = compareTest . doubleValue ( ) ; for ( double d : array ) if ( d == test ) return true ; return false ; } \n', 0.3602336326876485)

('private static boolean containsCheckOnShortArray ( short [ ] array , Short compareTest ) { short test = compareTest . shortValue ( ) ; for ( short s : array ) if ( s == test ) return true ; return false ; } \n', 0.34824413533627085)

('private static boolean containsCheckOnFloatArray ( float [ ] array , Float compareTest ) { float test = compareTest . floatValue ( ) ; for ( float f : array ) if ( f == test ) return true ; return false ; } \n', 0.3390590700170038)

('private static boolean containsCheckOnLongArray ( long [ ] array , Long compareTest ) { long test = compareTest . longValue ( ) ; for ( long l : array ) if ( l == test ) return true ; return false ; } \n', 0.3370525576539741)

('public void verifyValues ( ) { List known = new ArrayList ( confirmed . values ( ) ) ; List test = new ArrayList ( values ) ; int size = confirmed . size ( ) ; boolean empty = confirmed . isEmpty ( ) ; assertEquals ( "values-should-be-same-size-as-HashMap\'s" + "-Test:-" + test + "-Real:-" + known , size , values . size ( ) ) ; assertEquals ( "values-should-be-empty-if-HashMap-is" + "-Test:-" + test + "-Real:-" + known , empty , values . isEmpty ( ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , test . containsAll ( known ) ) ; assertTrue ( "values-should-contain-all-HashMap\'s-elements" + "-Test:-" + test + "-Real:-" + known , known . containsAll ( test ) ) ; for ( Iterator it = known . iterator ( ) ; it . hasNext ( ) ; ) { boolean removed = test . remove ( it . next ( ) ) ; assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , removed ) ; } assertTrue ( "Map\'s-values-should-still-equal-HashMap\'s" , test . isEmpty ( ) ) ; } \n', 0.3342096505976902)

('private static boolean containsCheckOnIntArray ( int [ ] array , Integer compareTest ) { int test = compareTest . intValue ( ) ; for ( int i : array ) if ( i == test ) return true ; return false ; } \n', 0.3298072455044525)

('private static boolean containsCheckOnBooleanArray ( boolean [ ] array , Boolean compareTest ) { boolean test = compareTest . booleanValue ( ) ; for ( boolean b : array ) if ( b == test ) return true ; return false ; } \n', 0.3021065535564248)

('public static void assertContains ( String [ ] stringSet , String ... values ) { Set < String > set = new HashSet < String > ( Arrays . asList ( stringSet ) ) ; for ( String value : values ) { ScopeTestHelper . assertTrue ( set . contains ( value ) ) ; } } \n', 0.29607026461450126)

('public void testSortByValues ( ) { Map < String , Integer > map = new HashMap < String , Integer > ( ) ; map . put ( "b" , 2000 ) ; map . put ( "a" , 1000 ) ; map . put ( "c" , 4000 ) ; map . put ( "d" , 3000 ) ; Map < String , Integer > sorted = CollectionUtil . sortByValues ( map ) ; assertNotNull ( sorted ) ; assertEquals ( map . size ( ) , sorted . size ( ) ) ; assert ( map . keySet ( ) . containsAll ( sorted . keySet ( ) ) ) ; assert ( map . values ( ) . containsAll ( sorted . values ( ) ) ) ; List < String > list = new ArrayList < String > ( sorted . keySet ( ) ) ; assertEquals ( "a" , list . get ( 0 ) ) ; Collections . reverse ( list ) ; assertEquals ( "c" , list . get ( 0 ) ) ; } \n', 0.2949996348742437)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 8 #################################
('public String lookupEnumString ( int e ) { String result = map . get ( e ) ; return ( result == null ) ? "Unknown-enum-value=" + e : result ; } \n', 0.4212740360120386)

('public static < T extends Enum < T >> T getEnumFromStringCaseSensitive ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.39054080139591285)

('public static AccountAcTypeEnum lookupEnum ( String value ) { return AccountAcTypeEnum . valueMap . get ( value ) ; } \n', 0.3833591515632784)

('private static < T extends Enum < T >> T getEnumFromValue ( Class < T > enumType , int value ) { int ordinal ; int [ ] registeredValues = sEnumValues . get ( enumType ) ; if ( registeredValues != null ) { ordinal = - 1 ; for ( int i = 0 ; i < registeredValues . length ; ++ i ) { if ( registeredValues [ i ] == value ) { ordinal = i ; break ; } } } else { ordinal = value ; } T [ ] values = enumType . getEnumConstants ( ) ; if ( ordinal < 0 || ordinal >= values . length ) { throw new IllegalArgumentException ( String . format ( "Argument-\'value\'-(%d)-was-not-a-valid-enum-value-for-type-%s-" + "(registered?-%b)" , value , enumType , ( registeredValues != null ) ) ) ; } return values [ ordinal ] ; } \n', 0.3812954251206542)

('public static < T extends Enum < T >> T getEnumFromString ( Class < T > c , String string ) { if ( c != null && string != null ) { try { return Enum . valueOf ( c , string . trim ( ) . toUpperCase ( ) ) ; } catch ( IllegalArgumentException ex ) { } } return null ; } \n', 0.38014169306173196)

('protected Enumerated resolveEnum ( final Object value ) throws InvalidEnumerationException { return toState11 ( ( String ) value ) ; } \n', 0.3782833591892833)

('public static Enum getEnumFromString ( Class enumClass , String code ) { ClassHelper . initializeCheck ( enumClass ) ; Iterator iter = enums . values ( enumClass ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Enum myEnum = ( Enum ) iter . next ( ) ; if ( code . equals ( myEnum . getCode ( ) . toString ( ) ) ) { return myEnum ; } } DebugHome . getDebugLog ( ) . warn ( "Unknown-enum,-class-=-" + enumClass . getName ( ) + ",-code-=-" + code ) ; return null ; } \n', 0.3692864157425656)

('public static < E extends Enum < E >> EnumSet < E > getEnumSetFromString ( Class < E > enumType , String enumString ) { EnumSet < E > es = EnumSet . noneOf ( enumType ) ; if ( ! Strings . isNullOrEmpty ( enumString ) ) { String [ ] split = enumString . split ( "," ) ; for ( String s : split ) { es . add ( Enum . valueOf ( enumType , s ) ) ; } } return es ; } \n', 0.36732509354335485)

('public static < T extends Enum < ? >> T lookupEnum ( String name , Class < T > vocab ) { if ( Strings . isNullOrEmpty ( name ) ) { return null ; } final String normedType = name . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; T [ ] values = vocab . getEnumConstants ( ) ; if ( values != null ) { for ( T val : values ) { final String normedVal = val . name ( ) . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; if ( normedType . equals ( normedVal ) ) { return val ; } } } throw new IllegalArgumentException ( "Cannot-parse-" + name + "-into-a-known-" + vocab . getSimpleName ( ) ) ; } \n', 0.36052107724200017)

('protected E stringToEnum ( final String string ) { final E value = _stringToEnum . get ( string ) ; if ( value == null ) { throw new OpenGammaRuntimeException ( "unexpected-value:-" + string ) ; } return value ; } \n', 0.3565804403862347)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 9 #################################
('protected void recursiveNestedJoin ( EventBean lookupEvent , int nestingOrderIndex , EventBean [ ] currentPath , Collection < EventBean [ ] > result , ExprEvaluatorContext exprEvaluatorContext ) { List < EventBean [ ] > nestedResult = new LinkedList < EventBean [ ] > ( ) ; ExecNode nestedExecNode = childNodes . get ( nestingOrderIndex ) ; nestedExecNode . process ( lookupEvent , currentPath , nestedResult , exprEvaluatorContext ) ; boolean isLastStream = ( nestingOrderIndex == nestingOrderLength - 1 ) ; if ( ! isLastStream ) { for ( EventBean [ ] row : nestedResult ) { EventBean lookup = row [ nestedStreams [ nestingOrderIndex ] ] ; recursiveNestedJoin ( lookup , nestingOrderIndex + 1 , row , result , exprEvaluatorContext ) ; } return ; } for ( EventBean [ ] row : nestedResult ) { result . add ( row ) ; } } \n', 0.3494762225854692)

('public void visitForeachLoop ( JCEnhancedForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStat ( tree . var , loopEnv ) ; Type exprType = types . upperBound ( attribExpr ( tree . expr , loopEnv ) ) ; chk . checkNonVoid ( tree . pos ( ) , exprType ) ; Type elemtype = types . elemtype ( exprType ) ; if ( elemtype == null ) { Type base = types . asSuper ( exprType , syms . iterableType . tsym ) ; if ( base == null ) { log . error ( tree . expr . pos ( ) , "foreach.not.applicable.to.type" , exprType , diags . fragment ( "type.req.array.or.iterable" ) ) ; elemtype = types . createErrorType ( exprType ) ; } else { List < Type > iterableParams = base . allparams ( ) ; elemtype = iterableParams . isEmpty ( ) ? syms . objectType : types . upperBound ( iterableParams . head ) ; } } chk . checkType ( tree . expr . pos ( ) , elemtype , tree . var . sym . type ) ; loopEnv . tree = tree ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.31910015986070384)

('private NestedLoops ( final Vector2D [ ] loop ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; surrounded = new ArrayList < NestedLoops > ( ) ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( previous ) . getX ( ) , line . toSubSpace ( current ) . getX ( ) ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.3025557593544445)

('@ SuppressWarnings ( "serial" ) public void testNestedRuntimeExceptionWithRootCause ( ) { String myMessage = "mesg-for-this-exception" ; String rootCauseMesg = "this-is-the-obscure-message-of-the-root-cause" ; Exception rootCause = new Exception ( rootCauseMesg ) ; NestedRuntimeException nex = new NestedRuntimeException ( myMessage , rootCause ) { } ; assertEquals ( nex . getCause ( ) , rootCause ) ; assertTrue ( nex . getMessage ( ) . indexOf ( myMessage ) != - 1 ) ; assertTrue ( nex . getMessage ( ) . indexOf ( rootCauseMesg ) != - 1 ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintWriter pw = new PrintWriter ( baos ) ; nex . printStackTrace ( pw ) ; pw . flush ( ) ; String stackTrace = new String ( baos . toByteArray ( ) ) ; assertFalse ( stackTrace . indexOf ( rootCause . getClass ( ) . getName ( ) ) == - 1 ) ; assertFalse ( stackTrace . indexOf ( rootCauseMesg ) == - 1 ) ; } \n', 0.30085220317759176)

('public void visitWhileLoop ( JCWhileLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || ! tree . cond . type . isTrue ( ) ; } \n', 0.2993289713789184)

('public void visitForLoop ( JCForLoop tree ) { Env < AttrContext > loopEnv = env . dup ( env . tree , env . info . dup ( env . info . scope . dup ( ) ) ) ; attribStats ( tree . init , loopEnv ) ; if ( tree . cond != null ) attribExpr ( tree . cond , loopEnv , syms . booleanType ) ; loopEnv . tree = tree ; attribStats ( tree . step , loopEnv ) ; attribStat ( tree . body , loopEnv ) ; loopEnv . info . scope . leave ( ) ; result = null ; } \n', 0.2981734140170164)

('protected final int readUntilNestedIgnoreCase ( String endString ) { int index = Util . indexOfNestedIgnoreCase ( fStringSource , endString , fCurrentPosition ) ; if ( index != ( - 1 ) ) { fCurrentPosition = index + 2 + endString . length ( ) ; return 2 + endString . length ( ) ; } fCurrentPosition = fStringSource . length ( ) ; return 0 ; } \n', 0.2973384710464471)

('public void addNestedPos ( ExtractionPos loop ) { nested_loops . add ( loop ) ; } \n', 0.2955534288106427)

('private void removeLoopWithExitNode ( Map < CfgBlock , Set < CfgBlock >> loops , CfgBlock header , Set < CfgBlock > body , CfgBlock headerExitBlock ) { CfgBlock headerClone = null ; for ( CfgBlock b : new HashSet < CfgBlock > ( body ) ) { if ( method . containsEdge ( b , header ) ) { method . removeEdge ( method . getEdge ( b , header ) ) ; if ( headerClone == null ) { headerClone = header . deepCopy ( ) ; addBlockToLoops ( header , headerClone , loops ) ; method . addEdge ( headerClone , headerExitBlock ) ; } method . addEdge ( b , headerClone ) ; } } } \n', 0.29077522927152594)

('protected int incrementLoopExitRepeatition ( Stmt stmt ) { int value = this . getLoopExitRepeatition ( stmt ) ; this . loopExitToRepeatitionMap . put ( stmt , ++ value ) ; return value ; } \n', 0.2897714675806873)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 10 #################################
('public void createSumArrayPut ( long term , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( term ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.27748677358546037)

('public static Bodies [ ] createArrays ( Vector allBodies ) { Bodies [ ] array = new Bodies [ allBodies . size ( ) ] ; allBodies . copyInto ( array ) ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] . createArrays ( ) ; return array ; } \n', 0.26676445164995854)

('public void createSumArrayPut ( long word , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( word ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.262212797449038)

('public static ArrayList < AVector > createSparseArray ( Iterator < AVector > vecIterator ) { AVector v0 = vecIterator . next ( ) ; int len = v0 . length ( ) ; ArrayList < AVector > vecList = new ArrayList < AVector > ( ) ; vecList . add ( v0 ) ; while ( vecIterator . hasNext ( ) ) { AVector v = vecIterator . next ( ) ; if ( ( v == null ) || ( v . isZero ( ) ) ) v = Vectorz . createZeroVector ( len ) ; else v = v . sparseClone ( ) ; vecList . add ( v . sparseClone ( ) ) ; } return vecList ; } \n', 0.2534039371513054)

('public IArray createArrayNoCopy ( final Object javaArray ) { int rank = 0 ; Class < ? > componentType = javaArray . getClass ( ) ; while ( componentType . isArray ( ) ) { rank ++ ; componentType = componentType . getComponentType ( ) ; } int count = 0 ; int [ ] shape = new int [ rank ] ; Object jArray = javaArray ; Class < ? > cType = jArray . getClass ( ) ; while ( cType . isArray ( ) ) { shape [ count ++ ] = java . lang . reflect . Array . getLength ( jArray ) ; jArray = java . lang . reflect . Array . get ( jArray , 0 ) ; cType = jArray . getClass ( ) ; } return createArray ( componentType , shape , javaArray ) ; } \n', 0.24542351040092777)

('public static IArray createArrayNoCopy ( Object javaArray ) { int rank = 0 ; Class < ? > componentType = javaArray . getClass ( ) ; while ( componentType . isArray ( ) ) { rank ++ ; componentType = componentType . getComponentType ( ) ; } int count = 0 ; int [ ] shape = new int [ rank ] ; Object jArray = javaArray ; Class < ? > cType = jArray . getClass ( ) ; while ( cType . isArray ( ) ) { shape [ count ++ ] = java . lang . reflect . Array . getLength ( jArray ) ; jArray = java . lang . reflect . Array . get ( jArray , 0 ) ; cType = jArray . getClass ( ) ; } return createArray ( componentType , shape , javaArray ) ; } \n', 0.24432627512638572)

('private static Object createArrayAndFill ( Class < ? > type , final List < String > stringValues ) throws ConfException { assert ( type != null ) ; assert ( stringValues != null ) ; Object array = Array . newInstance ( type , stringValues . size ( ) ) ; int index = 0 ; for ( String argument : stringValues ) { Object value = valueFromString ( type , argument ) ; Array . set ( array , index ++ , value ) ; } return array ; } \n', 0.24040525593701143)

('public static ArrayList < Integer > initializeAArrayWithValue ( Integer numberToInitialize ) { ArrayList < Integer > arrToIntialize = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= numberToInitialize ; i ++ ) { arrToIntialize . add ( i ) ; } return arrToIntialize ; } \n', 0.23256766087467656)

('private void initObjectsFromArray ( ) { List < EngineObject > newObjects = new ArrayList < EngineObject > ( ) ; for ( int i = 0 ; i < this . objects . length ; i ++ ) { EngineObject obj = objects [ i ] ; if ( obj . placementMask == null ) { initObject ( obj , EngineObject . Placement . CENTER ) ; newObjects . add ( obj ) ; } else { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( obj . placementMask . get ( j ) ) { EngineObject clone = new EngineObject ( obj ) ; initObject ( clone , j ) ; newObjects . add ( clone ) ; } } } } this . originalObjects = new ArrayList < EngineObject > ( Arrays . asList ( objects ) ) ; this . objects = ( EngineObject [ ] ) newObjects . toArray ( new EngineObject [ newObjects . size ( ) ] ) ; } \n', 0.23205519869884597)

('public static Animal [ ] createAnimalArray ( int animalCount , int animalMaxAge ) throws IllegalArgumentException { if ( animalMaxAge <= 0 ) throw new IllegalArgumentException ( "animalMaxAge-must-be-positive" ) ; List < Animal > animalList = new ArrayList < Animal > ( ) ; Random randomGenerator = new Random ( ) ; for ( int i = 0 ; i < animalCount ; i ++ ) { int age = randomGenerator . nextInt ( animalMaxAge ) ; animalList . add ( new Animal ( age ) ) ; } return animalList . toArray ( new Animal [ animalList . size ( ) ] ) ; } \n', 0.2272103294270792)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 11 #################################
('synchronized static private String getRandomString ( ) { long randomLong = randomGenerator . nextLong ( ) ; if ( randomLong < 0 ) randomLong = - randomLong ; return "" + randomLong ; } \n', 0.4308093671305626)

('public String generateRandomString ( int stringLength ) { String stringToReturn = "" ; for ( int index = 0 ; index < stringLength ; index ++ ) { int randomInt = random . nextInt ( alphabet . length ) ; stringToReturn += String . valueOf ( alphabet [ randomInt ] ) ; } return stringToReturn ; } \n', 0.4305107124559666)

('public static String getRandomString ( int length ) { Random generator = new Random ( ) ; char str [ ] = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { str [ i ] = CHARACTERS [ generator . nextInt ( CHARACTERS . length ) ] ; } return new String ( str ) ; } \n', 0.42875250635126405)

('public static String generateRandomString ( ) { String allowedChars = "0123456789abcdefghijklmnopqrstuvwxyz" ; Random random = new Random ( ) ; return generateRandomString ( allowedChars , random ) ; } \n', 0.42864136447512524)

('protected String generateRandomString ( int length ) { Random random = new Random ( ) ; StringBuilder randomStringBuilder = new StringBuilder ( ) ; for ( int i = 0 ; i < length ; i ++ ) { randomStringBuilder . append ( Integer . toHexString ( random . nextInt ( 0x10 ) ) ) ; } return randomStringBuilder . toString ( ) ; } \n', 0.42714600374995665)

('public String getRandomSpecialString ( int length ) { int len = specialCharacters . length ; String str = "" ; Random randomGenerator = new Random ( ) ; int index ; for ( int i = 0 ; i < length ; i ++ ) { index = randomGenerator . nextInt ( len - 1 ) ; str = str + specialCharacters [ index ] ; } return str ; } \n', 0.42568820355287834)

("public static String generateRandomString ( int length ) { char [ ] characters = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char start , end ; switch ( random . nextInt ( 4 ) ) { case 0 : start = 'A' ; end = 'Z' ; case 1 : start = '0' ; end = '9' ; default : start = 'a' ; end = 'z' ; } characters [ i ] = ( char ) ( start + random . nextInt ( end - start ) ) ; } return new String ( characters ) ; } \n", 0.4237233491623514)

('public String generateRandomString ( final int length , final String notThis ) { final int maxTry = 777 ; int numOfTry = 0 ; String randomString = notThis ; while ( notThis . startsWith ( randomString ) && numOfTry < maxTry ) { randomString = generateRandomString ( length ) ; numOfTry ++ ; } if ( numOfTry >= maxTry ) { Assert . fail ( "Could-not-generate-" + length + "-length-random-string-that-differs-from-\'" + notThis + "\'-within-" + numOfTry + "trials.-Go-and-buy-a-lottery!" ) ; } return randomString ; } \n', 0.4230566730728814)

('private static String generateRandomString ( int length ) { String allowedChars = "0123456789abcdefghijklmnopqrstuvwxyz" ; Random random = new Random ( ) ; int max = allowedChars . length ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int value = random . nextInt ( max ) ; buffer . append ( allowedChars . charAt ( value ) ) ; } return buffer . toString ( ) ; } \n', 0.42044615701631194)

('public static String generateRandomString ( ) { Random rnd = new Random ( ) ; int noOfCAPSAlpha = 2 ; int noOfDigits = 2 ; int noOfSplChars = 2 ; char [ ] pswd = new char [ Constant . LOGIN_PASSWORD_LENGTH ] ; int index = 0 , i ; for ( i = 0 ; i < noOfCAPSAlpha ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = ALPHA_CAPS . charAt ( rnd . nextInt ( ALPHA_CAPS . length ( ) ) ) ; } for ( i = 0 ; i < noOfDigits ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = NUM . charAt ( rnd . nextInt ( NUM . length ( ) ) ) ; } for ( i = 0 ; i < noOfSplChars ; i ++ ) { index = getNextIndex ( rnd , Constant . LOGIN_PASSWORD_LENGTH , pswd ) ; pswd [ index ] = SPL_CHARS . charAt ( rnd . nextInt ( SPL_CHARS . length ( ) ) ) ; } for ( i = 0 ; i < Constant . LOGIN_PASSWORD_LENGTH ; i ++ ) { if ( pswd [ i ] == 0 ) { pswd [ i ] = ALPHA . charAt ( rnd . nextInt ( ALPHA . length ( ) ) ) ; } } return String . valueOf ( pswd ) ; } \n', 0.42042499784998816)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 12 #################################
('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.27878423967888266)

('public String printTestConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionTestConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionTestConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printTestConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.27063673120795056)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.26823839885477097)

('public static int [ ] convertStringListToIntArray ( List < String > list , String [ ] convertFrom , int [ ] convertTo ) { if ( list == null ) { return null ; } List < Integer > convertedList = convertStringListToIntList ( list , convertFrom , convertTo ) ; int [ ] returnArray = new int [ convertedList . size ( ) ] ; for ( int i = 0 ; i < returnArray . length ; ++ i ) { returnArray [ i ] = convertedList . get ( i ) ; } return returnArray ; } \n', 0.2524737779041121)

('static void printStringArray ( PrintWriter out , Array ma , Indent indent , ucar . nc2 . util . CancelTask ct ) { if ( ct != null && ct . isCancel ( ) ) return ; int rank = ma . getRank ( ) ; Index ima = ma . getIndex ( ) ; if ( rank == 0 ) { out . print ( "-"" + ma . getObject ( ima ) + """ ) ; return ; } if ( rank == 1 ) { boolean first = true ; for ( int i = 0 ; i < ma . getSize ( ) ; i ++ ) { if ( ! first ) out . print ( ",-" ) ; out . print ( "-"" + ma . getObject ( ima . set ( i ) ) + """ ) ; first = false ; } return ; } int [ ] dims = ma . getShape ( ) ; int last = dims [ 0 ] ; out . print ( "-" + indent + "{" ) ; indent . incr ( ) ; for ( int ii = 0 ; ii < last ; ii ++ ) { ArrayObject slice = ( ArrayObject ) ma . slice ( 0 , ii ) ; printStringArray ( out , slice , indent , ct ) ; if ( ii != last - 1 ) out . print ( "," ) ; } indent . decr ( ) ; out . print ( "-" + indent + "}" ) ; } \n', 0.24576884015836892)

('public void printJavaTypeToObject ( String value , Class javaType ) throws IOException { if ( Object . class . isAssignableFrom ( javaType ) ) print ( value ) ; else if ( javaType . equals ( boolean . class ) ) print ( "new-Boolean(" + value + ")" ) ; else if ( javaType . equals ( byte . class ) ) print ( "new-Byte(" + value + ")" ) ; else if ( javaType . equals ( short . class ) ) print ( "new-Short(" + value + ")" ) ; else if ( javaType . equals ( int . class ) ) print ( "new-Integer(" + value + ")" ) ; else if ( javaType . equals ( long . class ) ) print ( "new-Long(" + value + ")" ) ; else if ( javaType . equals ( char . class ) ) print ( "String.valueOf(" + value + ")" ) ; else if ( javaType . equals ( float . class ) ) print ( "new-Float(" + value + ")" ) ; else if ( javaType . equals ( double . class ) ) print ( "new-Double(" + value + ")" ) ; else print ( value ) ; } \n', 0.24392062746481943)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.23770199203393952)

('@ SuppressWarnings ( "unchecked" ) public static < S > void assertToCollection ( String label , S source ) throws Exception { Converter < S , ? extends Collection > toList = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , List . class ) ; Collection < S > listResult = toList . convert ( source ) ; assertEquals ( label + "-converted-to-List" , source , listResult . toArray ( ) [ 0 ] ) ; Converter < S , ? extends Collection > toSet = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , Set . class ) ; Collection < S > setResult = toSet . convert ( source ) ; assertEquals ( label + "-converted-to-Set" , source , setResult . toArray ( ) [ 0 ] ) ; } \n', 0.23643542698169223)

('@ Override public void print ( ChronoDisplay formattable , Appendable buffer , AttributeQuery attributes , Set < ElementPosition > positions , FormatStep step ) throws IOException { int year = formattable . get ( this . element ) . intValue ( ) ; if ( year < 0 ) { throw new IllegalArgumentException ( "Negative-year-cannot-be-printed-as-two-digit-year:-" + year ) ; } int yy = MathUtils . floorModulo ( year , 100 ) ; String digits = Integer . toString ( yy ) ; char zeroDigit = step . getAttribute ( Attributes . ZERO_DIGIT , attributes , Character . valueOf ( \'0\' ) ) . charValue ( ) ; if ( zeroDigit != \'0\' ) { int diff = zeroDigit - \'0\' ; char [ ] characters = digits . toCharArray ( ) ; for ( int i = 0 ; i < characters . length ; i ++ ) { characters [ i ] = ( char ) ( characters [ i ] + diff ) ; } digits = new String ( characters ) ; } int start = - 1 ; int printed = 0 ; if ( buffer instanceof CharSequence ) { start = ( ( CharSequence ) buffer ) . length ( ) ; } if ( yy < 10 ) { buffer . append ( zeroDigit ) ; printed ++ ; } buffer . append ( digits ) ; printed += digits . length ( ) ; if ( ( start != - 1 ) && ( printed > 0 ) && ( positions != null ) ) { positions . add ( new ElementPosition ( this . element , start , start + printed ) ) ; } } \n', 0.2349581937624394)

('public static byte [ ] convertStringsToByteArray ( final String ... values ) throws IOException { final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; try { for ( String value : values ) { final byte [ ] valueAsBytes = value . getBytes ( Charset . forName ( "UTF-8" ) ) ; stream . write ( ByteBuffer . allocate ( 4 ) . putInt ( valueAsBytes . length ) . array ( ) ) ; stream . write ( valueAsBytes ) ; } return stream . toByteArray ( ) ; } finally { stream . close ( ) ; } } \n', 0.23125734440780435)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 13 #################################
('public static < K , V extends Comparable < V >> Map < K , V > sortMapByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.47019823717805165)

('private static Map sortMapByValues ( Map map ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( ( Map . Entry ) ( o2 ) ) . getValue ( ) == ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ? ( ( Comparable ) ( ( Map . Entry ) ( o1 ) ) . getKey ( ) ) . compareTo ( ( ( Map . Entry ) ( o2 ) ) . getKey ( ) ) : ( ( Comparable ) ( ( Map . Entry ) ( o2 ) ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ; } } ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46917912357463765)

('public static Map < Long , Float > sortMapByValue ( Map < Long , Float > map ) { List < Map . Entry < Long , Float >> list = new LinkedList < Entry < Long , Float >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Long , Float >> ( ) { @ Override public int compare ( Map . Entry < Long , Float > o1 , Map . Entry < Long , Float > o2 ) { if ( o1 . getValue ( ) <= o2 . getValue ( ) ) { return 1 ; } else { return - 1 ; } } } ) ; Map < Long , Float > result = new LinkedHashMap < Long , Float > ( ) ; for ( Iterator < Entry < Long , Float >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Long , Float > entry = it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } \n', 0.4682754856723419)

('public static < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k1 ) . compareTo ( map . get ( k2 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return new LinkedHashMap < K , V > ( sortedByValues ) ; } \n', 0.46806062228012674)

('public static HashMap sortMapByValues ( HashMap map ) { List < Map . Entry > list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new MapValueSorter ( ) ) ; HashMap sortedHashMap = new LinkedHashMap ( ) ; for ( Map . Entry e : list ) { sortedHashMap . put ( e . getKey ( ) , e . getValue ( ) ) ; } return sortedHashMap ; } \n', 0.46781194072755194)

('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46680150576087603)

('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

('static public < K , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public < K extends Comparable < K > , V extends Comparable < V >> Map < K , V > sortByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) { return k1 . compareTo ( k2 ) ; } else { return compare ; } } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.4659323568655886)

('public static < K , V extends Comparable < V >> TreeMap < K , V > sortByValues ( final TreeMap < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; TreeMap < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.46532808992763286)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 14 #################################
("public long getConvertedSpace ( String spaceStr ) { try { double multiplier = 1.0 ; char c ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < spaceStr . length ( ) ; i ++ ) { c = spaceStr . charAt ( i ) ; if ( ! Character . isDigit ( c ) && c != '.' ) { if ( c == 'm' || c == 'M' ) { multiplier = 1024.0 ; } else if ( c == 'g' || c == 'G' ) { multiplier = 1024.0 * 1024.0 ; } break ; } sb . append ( spaceStr . charAt ( i ) ) ; } return ( long ) Math . ceil ( Double . valueOf ( sb . toString ( ) ) * multiplier ) ; } catch ( Exception e ) { return - 1 ; } } \n", 0.20885357042379463)

("protected long getConvertedSpace ( String spaceStr ) { try { double multiplier = 1.0 ; char c ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < spaceStr . length ( ) ; i ++ ) { c = spaceStr . charAt ( i ) ; if ( ! Character . isDigit ( c ) && c != '.' ) { if ( c == 'm' || c == 'M' ) { multiplier = 1024.0 ; } else if ( c == 'g' || c == 'G' ) { multiplier = 1024.0 * 1024.0 ; } break ; } sb . append ( spaceStr . charAt ( i ) ) ; } return ( long ) Math . ceil ( Double . valueOf ( sb . toString ( ) ) * multiplier ) ; } catch ( Exception e ) { return - 1 ; } } \n", 0.20439603473036055)

('protected InetAddress convertIntegerToInternetAddress ( Long l ) throws KettleValueException { if ( l == null ) { return null ; } byte [ ] addr ; if ( l >= Math . pow ( 256 , 4 ) ) { addr = new byte [ 16 ] ; } else { addr = new byte [ 4 ] ; } for ( int i = 0 ; i < addr . length ; i ++ ) { long mask = 0xFF << ( i * 8 ) ; addr [ addr . length - 1 - i ] = ( byte ) ( ( l & mask ) >> ( 8 * i ) ) ; } try { return InetAddress . getByAddress ( addr ) ; } catch ( Exception e ) { throw new KettleValueException ( "Unable-to-convert-an-Integer-to-an-internet-address" , e ) ; } } \n', 0.17450462577807607)

('private TreeSet assembleEdges ( Map nodeNameToInt ) { TreeSet edges = new TreeSet ( ) ; String [ ] nodeNames = new String [ nodeNameToInt . size ( ) ] ; nodeNames = ( String [ ] ) nodeNameToInt . keySet ( ) . toArray ( nodeNames ) ; for ( int i = 0 ; i < nodeNames . length ; i ++ ) { String nodeName = nodeNames [ i ] ; List converterList = ( List ) this . inDataToConverters . get ( nodeName ) ; if ( converterList != null ) { Converter [ ] convs = new Converter [ converterList . size ( ) ] ; convs = ( Converter [ ] ) converterList . toArray ( convs ) ; for ( int j = 0 ; j < convs . length ; j ++ ) { Converter c = convs [ j ] ; String convName = c . getShortName ( ) ; String convsOutputFormatName = c . getOutData ( ) ; String nodeNumber = nodeNameToInt . get ( nodeName ) . toString ( ) ; String convNumber = nodeNameToInt . get ( convName ) . toString ( ) ; String convsOutputNodeNumber = nodeNameToInt . get ( convsOutputFormatName ) . toString ( ) ; String edge1 = nodeNumber + "-" + convNumber ; edges . add ( edge1 ) ; String edge2 = convNumber + "-" + convsOutputNodeNumber ; edges . add ( edge2 ) ; } } } return edges ; } \n', 0.16223351110980566)

('public static long freePhysicalMemoryOnWindowsInBytes ( ) throws IOException { if ( ! isWindows ( ) ) { throw new IllegalStateException ( "Method-freePhysicalMemoryOnWindowsInBytes()-should-" + "be-called-only-on-windows.-Use-Jvm.isWindows()-to-check-the-OS." ) ; } Process pr = Runtime . getRuntime ( ) . exec ( "wmic-OS-get-FreePhysicalMemory-/Value" ) ; try { int result = pr . waitFor ( ) ; String output = convertStreamToString ( pr . getInputStream ( ) ) ; if ( result != 0 ) { String errorOutput = convertStreamToString ( pr . getErrorStream ( ) ) ; throw new IOException ( "Couldn\'t-get-free-physical-memory-on-windows.-" + "Command-"wmic-OS-get-FreePhysicalMemory-/Value"-exited-with-" + result + "-code,-output:-"" + output + "",-error-output:-"" + errorOutput + """ ) ; } String [ ] parts = output . trim ( ) . split ( "=" ) ; if ( parts . length != 2 ) { throw new IOException ( "Couldn\'t-get-free-physical-memory-on-windows.-" + "Command-"wmic-OS-get-FreePhysicalMemory-/Value"-output-has-unexpected-" + "format:-"" + output + """ ) ; } try { return MemoryUnit . KILOBYTES . toBytes ( Long . parseLong ( parts [ 1 ] ) ) ; } catch ( NumberFormatException e ) { throw new IOException ( "Couldn\'t-get-free-physical-memory-on-windows.-" + "Command-"wmic-OS-get-FreePhysicalMemory-/Value"-output-has-unexpected-" + "format:-"" + output + """ , e ) ; } } catch ( InterruptedException e ) { throw new IOException ( e ) ; } } \n', 0.16150347127957662)

('@ Override protected Text convertVertexToLine ( Vertex < I , V , E , ? > vertex ) throws IOException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; DataOutput output = new DataOutputStream ( outputStream ) ; JSONObject vertexObject = new JSONObject ( ) ; vertex . getId ( ) . write ( output ) ; try { vertexObject . put ( JsonBase64VertexFormat . VERTEX_ID_KEY , Base64 . encodeBytes ( outputStream . toByteArray ( ) ) ) ; } catch ( JSONException e ) { throw new IllegalStateException ( "writerVertex:-Failed-to-insert-vertex-id" , e ) ; } outputStream . reset ( ) ; vertex . getValue ( ) . write ( output ) ; try { vertexObject . put ( JsonBase64VertexFormat . VERTEX_VALUE_KEY , Base64 . encodeBytes ( outputStream . toByteArray ( ) ) ) ; } catch ( JSONException e ) { throw new IllegalStateException ( "writerVertex:-Failed-to-insert-vertex-value" , e ) ; } JSONArray edgeArray = new JSONArray ( ) ; for ( Edge < I , E > edge : vertex . getEdges ( ) ) { outputStream . reset ( ) ; edge . getTargetVertexId ( ) . write ( output ) ; edge . getValue ( ) . write ( output ) ; edgeArray . put ( Base64 . encodeBytes ( outputStream . toByteArray ( ) ) ) ; } try { vertexObject . put ( JsonBase64VertexFormat . EDGE_ARRAY_KEY , edgeArray ) ; } catch ( JSONException e ) { throw new IllegalStateException ( "writerVertex:-Failed-to-insert-edge-array" , e ) ; } return new Text ( vertexObject . toString ( ) ) ; } \n', 0.15844124866399034)

('public static int convertToColorInt ( String argb ) throws NumberFormatException { if ( argb . startsWith ( "#" ) ) { argb = argb . replace ( "#" , "" ) ; } int alpha = - 1 , red = - 1 , green = - 1 , blue = - 1 ; if ( argb . length ( ) == 8 ) { alpha = Integer . parseInt ( argb . substring ( 0 , 2 ) , 16 ) ; red = Integer . parseInt ( argb . substring ( 2 , 4 ) , 16 ) ; green = Integer . parseInt ( argb . substring ( 4 , 6 ) , 16 ) ; blue = Integer . parseInt ( argb . substring ( 6 , 8 ) , 16 ) ; } else if ( argb . length ( ) == 6 ) { alpha = 255 ; red = Integer . parseInt ( argb . substring ( 0 , 2 ) , 16 ) ; green = Integer . parseInt ( argb . substring ( 2 , 4 ) , 16 ) ; blue = Integer . parseInt ( argb . substring ( 4 , 6 ) , 16 ) ; } else throw new NumberFormatException ( "string-" + argb + "did-not-meet-length-requirements" ) ; return Color . argb ( alpha , red , green , blue ) ; } \n', 0.14682480739824263)

('public static String padOrConvertIfRequired ( Object ob ) { if ( ob instanceof Integer || ob instanceof Long ) { return AmazonSimpleDBUtil . encodeRealNumberRange ( new BigDecimal ( ob . toString ( ) ) , AmazonSimpleDBUtil . LONG_DIGITS , OFFSET_VALUE ) ; } else if ( ( ob instanceof Double && ! ( ( Double ) ob ) . isInfinite ( ) && ! ( ( Double ) ob ) . isNaN ( ) ) || ( ob instanceof Float && ! ( ( Float ) ob ) . isInfinite ( ) && ! ( ( Float ) ob ) . isNaN ( ) ) ) { return AmazonSimpleDBUtil . encodeRealNumberRange ( new BigDecimal ( ob . toString ( ) ) , AmazonSimpleDBUtil . LONG_DIGITS , AmazonSimpleDBUtil . LONG_DIGITS , OFFSET_VALUE ) ; } else if ( ob instanceof BigDecimal ) { return AmazonSimpleDBUtil . encodeRealNumberRange ( ( BigDecimal ) ob , AmazonSimpleDBUtil . LONG_DIGITS , AmazonSimpleDBUtil . LONG_DIGITS , OFFSET_VALUE ) ; } else if ( ob instanceof Date ) { Date d = ( Date ) ob ; return AmazonSimpleDBUtil . encodeDate ( d ) ; } else if ( ob instanceof byte [ ] ) { return AmazonSimpleDBUtil . encodeByteArray ( ( byte [ ] ) ob ) ; } return ob . toString ( ) ; } \n', 0.1353128654724871)

("float convertToTwips ( String foValue ) throws FOPException { foValue = foValue . trim ( ) ; final StringBuffer number = new StringBuffer ( ) ; final StringBuffer units = new StringBuffer ( ) ; for ( int i = 0 ; i < foValue . length ( ) ; i ++ ) { final char c = foValue . charAt ( i ) ; if ( Character . isDigit ( c ) || c == '.' ) { number . append ( c ) ; } else { units . append ( foValue . substring ( i ) . trim ( ) ) ; break ; } } return numberToTwips ( number . toString ( ) , units . toString ( ) ) ; } \n", 0.11945819291967566)

('private int convertToColorInt ( String argb ) throws NumberFormatException { int alpha = - 1 , red = - 1 , green = - 1 , blue = - 1 ; if ( argb . length ( ) == 8 ) { alpha = Integer . parseInt ( argb . substring ( 0 , 2 ) , 16 ) ; red = Integer . parseInt ( argb . substring ( 2 , 4 ) , 16 ) ; green = Integer . parseInt ( argb . substring ( 4 , 6 ) , 16 ) ; blue = Integer . parseInt ( argb . substring ( 6 , 8 ) , 16 ) ; } else if ( argb . length ( ) == 6 ) { alpha = 255 ; red = Integer . parseInt ( argb . substring ( 0 , 2 ) , 16 ) ; green = Integer . parseInt ( argb . substring ( 2 , 4 ) , 16 ) ; blue = Integer . parseInt ( argb . substring ( 4 , 6 ) , 16 ) ; } return Color . argb ( alpha , red , green , blue ) ; } \n', 0.119448977125797)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 15 #################################
('public byte [ ] concatenateTwoByteArrays ( byte [ ] a , byte [ ] b ) { byte [ ] c = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } \n', 0.34917792092265965)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , final Object [ ] three , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 3 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; matrix [ 2 ] = three ; return concatArrays ( matrix ) ; } \n', 0.34365154097903006)

('public static Object concatArrays ( final Object [ ] one , final Object [ ] two , Class componentType ) { Object [ ] [ ] matrix = ( Object [ ] [ ] ) Array . newInstance ( componentType , new int [ ] { 2 , 0 } ) ; matrix [ 0 ] = one ; matrix [ 1 ] = two ; return concatArrays ( matrix ) ; } \n', 0.32860896141681817)

('public static < A extends Comparable < A > , B > void sortTwoArrays ( A [ ] firstArray , B [ ] secondArray ) { if ( firstArray . length != secondArray . length ) { throw new RuntimeException ( "Both-arrays-must-be-of-the-same-length" ) ; } class element { public A first ; public B second ; } element [ ] elements = new element [ firstArray . length ] ; Arrays . sort ( elements , new Comparator < element > ( ) { public int compare ( element a , element b ) { return a . first . compareTo ( b . first ) ; } } ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { firstArray [ i ] = elements [ i ] . first ; secondArray [ i ] = elements [ i ] . second ; } } \n', 0.3259440797441201)

('private String [ ] concatenateArraysForInput ( String [ ] param , String [ ] value ) { String [ ] array = ( String [ ] ) Array . newInstance ( param [ 0 ] . getClass ( ) , param . length + value . length ) ; int j = 0 ; if ( param . length == value . length ) { for ( int i = 0 ; i < param . length ; i ++ ) { if ( i == 0 ) j = j + i ; else j = j + 1 ; array [ j ] = param [ i ] ; j = j + 1 ; array [ j ] = value [ i ] ; } } else { logger . warn ( "WARNING:-Check-your-array-size" ) ; } return array ; } \n', 0.3249121396561949)

('public static void sortBubbleTwo ( int [ ] array ) { try { for ( int end = 0 ; end < array . length - 1 ; end ++ ) { for ( int index = 0 ; index < array . length - end - 1 ; index ++ ) { if ( array [ index ] > array [ index + 1 ] ) { int temp = array [ index ] ; array [ index ] = array [ index + 1 ] ; array [ index + 1 ] = temp ; System . out . println ( Arrays . toString ( array ) ) ; } } } } catch ( NullPointerException e ) { System . out . println ( "Array-is-empty!" ) ; } System . out . println ( ) ; } \n', 0.3212984501886853)

('public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( Objects . isEmpty ( array1 ) ) { return array2 ; } if ( Objects . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArr , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArr , array1 . length , array2 . length ) ; return newArr ; } \n', 0.31814045405613983)

('public static < T > T [ ] concatenateArrays ( T [ ] first , T [ ] ... rest ) { int totalLength = first . length ; for ( T [ ] array : rest ) { totalLength += array . length ; } T [ ] result = Arrays . copyOf ( first , totalLength ) ; int offset = first . length ; for ( T [ ] array : rest ) { System . arraycopy ( array , 0 , result , offset , array . length ) ; offset += array . length ; } return result ; } \n', 0.31546183172548464)

('private static < T > void concatenateArrays ( Iterable < T [ ] > arraysToConcatenate , T [ ] destination ) { int nextStartIndexToUse = 0 ; for ( T [ ] array : arraysToConcatenate ) { System . arraycopy ( array , 0 , destination , nextStartIndexToUse , array . length ) ; nextStartIndexToUse += array . length ; } } \n', 0.31076428099890496)

('public static java . lang . Object concatenateArrays ( Class < ? > resultClass , java . lang . Object arr1 , java . lang . Object arr2 ) throws ArrayStoreException { if ( arr1 == null ) { return arr2 ; } else if ( arr2 == null ) { return arr1 ; } java . lang . Object newArray = Array . newInstance ( resultClass , Array . getLength ( arr1 ) + Array . getLength ( arr2 ) ) ; System . arraycopy ( arr1 , 0 , newArray , 0 , Array . getLength ( arr1 ) ) ; System . arraycopy ( arr2 , 0 , newArray , Array . getLength ( arr1 ) , Array . getLength ( arr2 ) ) ; return newArray ; } \n', 0.30608763426169416)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 16 #################################
('public File createFileFromURL ( URL resource ) { LOGGER . info ( "Resource-is-{}." , resource . getPath ( ) ) ; String [ ] arr = resource . getPath ( ) . split ( "/" ) ; String filenameWithoutPath = arr [ arr . length - 1 ] ; File configFile = null ; try { String fileContent = Resources . toString ( resource , Charset . defaultCharset ( ) ) ; configFile = createFileFromString ( fileContent , filenameWithoutPath ) ; } catch ( IOException e ) { LOGGER . error ( "Error-reading-resource-{}." , resource . getPath ( ) , e ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.37207679938316557)

('public File createFileFromString ( EDataType eDataType , String initialValue ) { return ( File ) super . createFromString ( eDataType , initialValue ) ; } \n', 0.3547786782348934)

('public static boolean createFromHFileLink ( final Configuration conf , final FileSystem fs , final Path dstFamilyPath , final String hfileLinkName ) throws IOException { Matcher m = LINK_NAME_PATTERN . matcher ( hfileLinkName ) ; if ( ! m . matches ( ) ) { throw new IllegalArgumentException ( hfileLinkName + "-is-not-a-valid-HFileLink-name!" ) ; } return create ( conf , fs , dstFamilyPath , m . group ( 1 ) , m . group ( 2 ) , m . group ( 3 ) ) ; } \n', 0.3376042573568567)

('private File createFileFromString ( String fileContent , String filenameWithoutPath ) { File configFile = null ; createWorkingDirectory ( ) ; LOGGER . info ( "Copy-resource-to-folder-{}." , workingDirectory . getAbsolutePath ( ) ) ; LOGGER . info ( "Targetname-is-{}." , filenameWithoutPath ) ; try { workingDirectory . mkdirs ( ) ; LOGGER . info ( "Create-file-from-Resource-String:-{}," , fileContent ) ; configFile = new File ( workingDirectory , filenameWithoutPath ) ; LOGGER . info ( "Write-file-{}." , configFile . getAbsolutePath ( ) ) ; Files . write ( fileContent , configFile , Charset . defaultCharset ( ) ) ; } catch ( IOException e ) { LOGGER . error ( "Could-not-create-File-from-resource-String:-{}" , fileContent ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.3354318964415436)

('public static String createStringArrayListFromFile ( Context context , VG . TYPE_STORAGE typeStorage , String stringFile , boolean isUtf8 ) { String res = "" ; if ( context != null && stringFile != null && ! "" . equals ( stringFile ) && typeStorage != null ) { int cptMaxLineToRead = 5000 ; try { InputStream is = null ; if ( VG . TYPE_STORAGE . ASSETS . equals ( typeStorage ) ) { is = context . getResources ( ) . getAssets ( ) . open ( stringFile ) ; } else if ( VG . TYPE_STORAGE . INTERNAL . equals ( typeStorage ) ) { String path = context . getApplicationContext ( ) . getFilesDir ( ) + "/" + stringFile ; File file = new File ( path ) ; is = new BufferedInputStream ( new FileInputStream ( file ) ) ; } InputStreamReader isr = null ; if ( isUtf8 ) { isr = new InputStreamReader ( is , "UTF-8" ) ; } else { isr = new InputStreamReader ( is ) ; } BufferedReader in = new BufferedReader ( isr ) ; String line ; int i = 0 ; while ( ( line = in . readLine ( ) ) != null && ( i < cptMaxLineToRead ) ) { res += line ; i ++ ; } in . close ( ) ; } catch ( MalformedURLException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; res = null ; } } return res ; } \n', 0.32862637192325767)

('public static ArrayTable < String > createArrayTableFromCSV ( java . io . File csv ) throws FileNotFoundException { java . util . Scanner s = new java . util . Scanner ( csv ) ; String ret = "" ; for ( int i = 0 ; s . hasNextLine ( ) ; i ++ ) { ret += s . nextLine ( ) + "-" ; } return createArrayTableFromCSV ( ret . substring ( 0 , ret . length ( ) - 1 ) ) ; } \n', 0.3281936188665582)

('public static IFile createFile ( IFile file , String contents ) throws CoreException { if ( contents == null ) { contents = "" ; } InputStream inputStream = new ByteArrayInputStream ( contents . getBytes ( ) ) ; file . create ( inputStream , true , NULL_MONITOR ) ; resourcesCreated . add ( file ) ; return file ; } \n', 0.3275443751617292)

('public void createDefaultDescriptor ( String templateString , String version ) { String content = MessageFormat . format ( templateString , version , version . replace ( \'.\' , \'_\' ) ) ; try { this . file . create ( new ByteArrayInputStream ( content . getBytes ( "UTF-8" ) ) , IResource . FORCE , null ) ; } catch ( Exception e ) { LiferayCore . logError ( e ) ; } } \n', 0.325752171618943)

('public static void createFileFromResource ( String path , Resource bin ) throws IOException { InputStream is = null ; OutputStream os = null ; if ( bin . exists ( ) ) return ; try { Util . copy ( is = new VideoInputImpl ( null ) . getClass ( ) . getResourceAsStream ( path ) , os = bin . getOutputStream ( ) ) ; } finally { Util . closeEL ( is ) ; Util . closeEL ( os ) ; } } \n', 0.32515733453474194)

("static File createTempFileWithContent ( @ NotNull String namePrefix , @ NotNull String nameSuffix , @ NotNull String content ) throws IOException { namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '|' ) + 1 ) ; namePrefix = namePrefix . substring ( namePrefix . lastIndexOf ( '/' ) + 1 ) ; namePrefix = namePrefix . replace ( '.' , '_' ) ; File tempFile = File . createTempFile ( namePrefix , nameSuffix ) ; tempFile . deleteOnExit ( ) ; final BufferedOutputStream stream = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; stream . write ( content . getBytes ( ) ) ; stream . close ( ) ; return tempFile ; } \n", 0.32362114274295406)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 17 #################################
('@ NotNull public static String convertExceptionStackToString ( @ NotNull final Throwable ex ) { final StringBuilder sb = new StringBuilder ( ) ; for ( @ NotNull final StackTraceElement element : ex . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } if ( ex instanceof UmbrellaException ) { sb . append ( "Unwrapping-UmbrellaException-" ) ; final UmbrellaException umbrellaException = ( UmbrellaException ) ex ; for ( @ NotNull final Throwable throwable : umbrellaException . getCauses ( ) ) { for ( @ NotNull final StackTraceElement element : throwable . getStackTrace ( ) ) { sb . append ( element . toString ( ) ) ; sb . append ( "-" ) ; } } } return sb . toString ( ) ; } \n', 0.44490724544019167)

('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

('private static String toStackTraceString ( Throwable t ) { if ( t == null ) { return "" ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; t . printStackTrace ( ps ) ; ps . close ( ) ; return baos . toString ( ) ; } \n', 0.41839505334547444)

('public static String toStackTraceString ( Throwable t ) { StringWriter writer = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( writer ) ; t . printStackTrace ( pw ) ; return writer . toString ( ) ; } \n', 0.41489082562066665)

('private String stackTraceToString ( StackTraceElement [ ] stackTraceElements ) { StringBuffer sb = new StringBuffer ( ) ; if ( stackTraceElements != null ) { for ( StackTraceElement element : stackTraceElements ) { if ( element != null ) { sb . append ( element . toString ( ) ) . append ( "-" ) ; } } } return sb . toString ( ) ; } \n', 0.406955988784114)

('private String throwableStackTraceToString ( Throwable throwable ) { StringWriter sw = new StringWriter ( ) ; try ( PrintWriter pw = new PrintWriter ( sw ) ) { throwable . printStackTrace ( pw ) ; } return sw . toString ( ) ; } \n', 0.40656642088845)

('private String stackTraceString ( ) { CPStringBuilder sb = new CPStringBuilder ( ) ; StackTraceElement [ ] stack = getStackTrace ( ) ; stackTraceStringBuffer ( sb , this . toString ( ) , stack , 0 ) ; Throwable cause = getCause ( ) ; while ( cause != null ) { sb . append ( "Caused-by:-" ) ; StackTraceElement [ ] parentStack = stack ; stack = cause . getStackTrace ( ) ; if ( parentStack == null || parentStack . length == 0 ) stackTraceStringBuffer ( sb , cause . toString ( ) , stack , 0 ) ; else { int equal = 0 ; int frame = stack . length - 1 ; int parentFrame = parentStack . length - 1 ; while ( frame > 0 && parentFrame > 0 ) { if ( stack [ frame ] . equals ( parentStack [ parentFrame ] ) ) { equal ++ ; frame -- ; parentFrame -- ; } else break ; } stackTraceStringBuffer ( sb , cause . toString ( ) , stack , equal ) ; } cause = cause . getCause ( ) ; } return sb . toString ( ) ; } \n', 0.4051720505139402)

("private String stackTraceToString ( StackTraceElement [ ] stackTrace ) { StringBuilder sb = new StringBuilder ( ) ; for ( StackTraceElement stackTraceElement : stackTrace ) { sb . append ( stackTraceElement . toString ( ) ) ; sb . append ( '|n' ) ; } return sb . toString ( ) ; } \n", 0.40459056724394765)

('private static String stackTraceString ( Throwable thrown ) { StringWriter converted = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( converted ) ; thrown . printStackTrace ( printWriter ) ; return converted . toString ( ) ; } \n', 0.4039332393953453)

('private String stackTraceToString ( Throwable throwable ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw ) ; throwable . printStackTrace ( pw ) ; return sw . getBuffer ( ) . toString ( ) ; } \n', 0.4036039972168458)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 18 #################################
('public boolean compareString ( final Object comp1 , final String comp2 ) throws WmiException { if ( comp1 instanceof String ) { try { final DateFormat fmt2 = new SimpleDateFormat ( "MM/dd/yyyy-HH:mm:ss" ) ; final Date date1 = WmiClient . convertWmiDate ( ( String ) comp1 ) ; final Date date2 = fmt2 . parse ( comp2 ) ; return compareToDate ( date1 , date2 ) ; } catch ( ParseException e ) { } return compareToString ( ( String ) comp1 , comp2 ) ; } else if ( comp1 instanceof Integer ) { final Integer compInt1 = ( Integer ) comp1 ; final Integer compInt2 = Integer . parseInt ( comp2 ) ; return compareToInteger ( compInt1 , compInt2 ) ; } else if ( comp1 instanceof Boolean ) { final Boolean bool1 = ( Boolean ) comp1 ; final Boolean bool2 = Boolean . parseBoolean ( comp2 ) ; return compareToBoolean ( bool1 , bool2 ) ; } else if ( comp1 instanceof Float ) { final Float fl1 = ( Float ) comp1 ; final Float fl2 = Float . parseFloat ( comp2 ) ; return compareToFloat ( fl1 , fl2 ) ; } else if ( comp1 instanceof Date ) { final DateFormat fmt = new SimpleDateFormat ( "MM/dd/yyyy-HH:mm:ss" ) ; final Date date1 = ( Date ) comp1 ; Date date2 ; try { date2 = fmt . parse ( comp2 ) ; } catch ( ParseException e ) { throw new WmiException ( "Parsing-date-\'" + comp2 + "\'-failed:-" + e . getMessage ( ) , e ) ; } return compareToDate ( date1 , date2 ) ; } return false ; } \n', 0.2890534018079492)

('protected long compareValues ( Class type , Object value1 , Object value2 ) { long result = NOT_COMPARABLE ; if ( value1 == null || value2 == null ) { result = value1 == value2 ? 0 : NOT_COMPARABLE ; } else { if ( value2 . getClass ( ) != type ) { value2 = convertValue ( type , value2 . toString ( ) ) ; } if ( value2 instanceof String && type != String . class ) { value1 = value1 . toString ( ) ; } if ( ! ( value1 instanceof Comparable && value2 instanceof Comparable ) ) { value1 = value1 . toString ( ) ; value2 = value2 . toString ( ) ; } result = ( ( Comparable ) value1 ) . compareTo ( value2 ) ; } return result ; } \n', 0.27782189909978927)

('@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) public static int typeCoerceCompare ( TypeConverter converter , Object leftValue , Object rightValue ) { Long leftNum = converter . tryConvertTo ( Long . class , leftValue ) ; Long rightNum = converter . tryConvertTo ( Long . class , rightValue ) ; if ( leftNum != null && rightNum != null ) { return leftNum . compareTo ( rightNum ) ; } Double leftDouble = converter . tryConvertTo ( Double . class , leftValue ) ; Double rightDouble = converter . tryConvertTo ( Double . class , rightValue ) ; if ( leftDouble != null && rightDouble != null ) { return leftDouble . compareTo ( rightDouble ) ; } if ( rightValue instanceof String && ( ! ( leftValue instanceof String ) ) ) { return typeCoerceCompare ( converter , rightValue , leftValue ) * - 1 ; } if ( rightValue instanceof Comparable ) { Object value = converter . tryConvertTo ( rightValue . getClass ( ) , leftValue ) ; if ( value != null ) { return ( ( Comparable ) rightValue ) . compareTo ( value ) * - 1 ; } } if ( leftValue instanceof Comparable ) { Object value = converter . tryConvertTo ( leftValue . getClass ( ) , rightValue ) ; if ( value != null ) { return ( ( Comparable ) leftValue ) . compareTo ( value ) ; } } return compare ( leftValue , rightValue ) ; } \n', 0.266792803044012)

('@ Override public boolean doCompare ( Object lValue , Object rValue , Class < ? > type , Locale locale , TimeZone timeZone , String format ) throws Exception { Object convertedLvalue = MiniLangUtil . convertType ( lValue , type , locale , timeZone , format ) ; Object convertedRvalue = MiniLangUtil . convertType ( rValue , type , locale , timeZone , format ) ; if ( convertedLvalue == null ) { return convertedRvalue != null ; } if ( convertedRvalue == null ) { return true ; } if ( convertedLvalue instanceof BigDecimal && convertedRvalue instanceof BigDecimal ) { BigDecimal lBigDecimal = ( BigDecimal ) convertedLvalue ; BigDecimal rBigDecimal = ( BigDecimal ) convertedRvalue ; return compareBigDecimals ( lBigDecimal , rBigDecimal ) != 0 ; } if ( convertedLvalue instanceof Comparable && convertedRvalue instanceof Comparable ) { Comparable < Object > comparable = UtilGenerics . cast ( convertedLvalue ) ; return comparable . compareTo ( convertedRvalue ) != 0 ; } return ! convertedLvalue . equals ( convertedRvalue ) ; } \n', 0.24848070007099746)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.22518081116080835)

('static int compareToTypeRange ( Object o , int targettype ) { if ( ! ( o instanceof Number ) ) { return 0 ; } if ( o instanceof Integer || o instanceof Long ) { long temp = ( ( Number ) o ) . longValue ( ) ; int min ; int max ; switch ( targettype ) { case Types . TINYINT : min = Byte . MIN_VALUE ; max = Byte . MAX_VALUE ; break ; case Types . SMALLINT : min = Short . MIN_VALUE ; max = Short . MAX_VALUE ; break ; case Types . INTEGER : min = Integer . MIN_VALUE ; max = Integer . MAX_VALUE ; break ; case Types . BIGINT : case Types . DECIMAL : case Types . NUMERIC : default : return 0 ; } if ( max < temp ) { return 1 ; } if ( temp < min ) { return - 1 ; } return 0 ; } else { try { o = convertToLong ( o ) ; return compareToTypeRange ( o , targettype ) ; } catch ( HsqlException e ) { if ( e . getErrorCode ( ) == - Trace . NUMERIC_VALUE_OUT_OF_RANGE ) { if ( o instanceof BigDecimal ) { return ( ( BigDecimal ) o ) . signum ( ) ; } else if ( o instanceof Double ) { return ( ( Double ) o ) . doubleValue ( ) > 0 ? 1 : - 1 ; } } } } return 0 ; } \n', 0.22449171583602467)

('@ SuppressWarnings ( "unchecked" ) public static < S > void assertToCollection ( String label , S source ) throws Exception { Converter < S , ? extends Collection > toList = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , List . class ) ; Collection < S > listResult = toList . convert ( source ) ; assertEquals ( label + "-converted-to-List" , source , listResult . toArray ( ) [ 0 ] ) ; Converter < S , ? extends Collection > toSet = ( Converter < S , ? extends Collection > ) Converters . getConverter ( source . getClass ( ) , Set . class ) ; Collection < S > setResult = toSet . convert ( source ) ; assertEquals ( label + "-converted-to-Set" , source , setResult . toArray ( ) [ 0 ] ) ; } \n', 0.21955993155415693)

('public void testUpperCaseStringConvertsToTrue ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) trueValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertTrue ( result . booleanValue ( ) ) ; } \n', 0.21326202436121683)

('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.211558746402099)

('public void testUpperCaseStringConvertsToFalse ( ) throws Exception { Boolean result = ( Boolean ) converter . convert ( ( ( String ) falseValues . get ( 0 ) ) . toUpperCase ( ) ) ; assertFalse ( result . booleanValue ( ) ) ; } \n', 0.21129496578034498)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 19 #################################
('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.3421195191429003)

('public static byte [ ] [ ] splitAndGetPathComponents ( String str ) { try { final int len ; if ( str == null || ( ( len = str . length ( ) ) == 0 ) || str . charAt ( 0 ) != Path . SEPARATOR_CHAR ) { return null ; } char [ ] charArray = UTF8 . getCharArray ( len ) ; str . getChars ( 0 , len , charArray , 0 ) ; List < byte [ ] > componentByteList = new ArrayList < byte [ ] > ( 20 ) ; boolean canFastConvert = true ; int startIndex = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( charArray [ i ] == Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , i , charArray , canFastConvert ) ) ; startIndex = i + 1 ; canFastConvert = true ; } else if ( charArray [ i ] > UTF8 . MAX_ASCII_CODE ) { canFastConvert = false ; } } if ( charArray [ len - 1 ] != Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , len , charArray , canFastConvert ) ) ; } int last = componentByteList . size ( ) ; while ( -- last >= 1 && componentByteList . get ( last ) . length == 0 ) { componentByteList . remove ( last ) ; } return componentByteList . toArray ( new byte [ last + 1 ] [ ] ) ; } catch ( UnsupportedEncodingException e ) { return null ; } } \n', 0.33598383900340983)

('protected String [ ] getFormatStrings ( ) { try { return getResourceString ( KEY_FORMAT_STRINGS ) . split ( ",-*" ) ; } catch ( MissingResourceException mre ) { int [ ] dateFormats = { DateFormat . SHORT , DateFormat . MEDIUM , DateFormat . LONG } ; String [ ] formatStrings = new String [ dateFormats . length + DateTypeConverter . formatStrings . length ] ; for ( int i = 0 ; i < dateFormats . length ; i ++ ) { SimpleDateFormat dateFormat = ( SimpleDateFormat ) DateFormat . getDateInstance ( dateFormats [ i ] , locale ) ; formatStrings [ i ] = preProcessInput ( dateFormat . toPattern ( ) ) ; } System . arraycopy ( DateTypeConverter . formatStrings , 0 , formatStrings , dateFormats . length , DateTypeConverter . formatStrings . length ) ; return formatStrings ; } } \n', 0.28533570856632595)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.27872790039693895)

('public static void convertSearchStringToSearchWords ( String searchString , Set < String > searchWords , Set < UUID > movieIds ) { if ( searchString != null ) { String [ ] splitAroundTags = searchString . split ( "movie:" ) ; for ( String token : splitAroundTags ) { if ( token . length ( ) != 0 ) { if ( token . startsWith ( "\'" ) ) { String [ ] splitAroundQuotes = token . split ( "\'" ) ; movieIds . add ( UUID . fromString ( splitAroundQuotes [ 1 ] ) ) ; if ( splitAroundQuotes . length > 2 ) { for ( int i = 2 ; i < splitAroundQuotes . length ; i ++ ) { for ( String searchWord : splitAroundQuotes [ i ] . split ( "-" ) ) { searchWords . add ( searchWord . toLowerCase ( ) ) ; } } } } else { for ( String searchWord : token . split ( "-" ) ) { searchWords . add ( searchWord . toLowerCase ( ) ) ; } } } } } } \n', 0.26199985308995133)

('public static List < String > convertStringToListOfLines ( String string ) throws IOException { final List < String > lines = new ArrayList < String > ( ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new StringReader ( string ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { lines . add ( line ) ; } } finally { IOUtils . closeQuietly ( reader ) ; } return lines ; } \n', 0.25974566799681276)

('public static String convertCSStringToListOfStrings ( String cSValues ) { List < String > listOfStrings = new ArrayList < String > ( ) ; ; if ( StringUtils . isNotNullOrNotEmpty ( cSValues ) ) { StringTokenizer st = new StringTokenizer ( cSValues , "," ) ; while ( st . hasMoreTokens ( ) ) { listOfStrings . add ( "\'" + st . nextToken ( ) + "\'" ) ; } } return convertListToCSString ( listOfStrings ) ; } \n', 0.2563278214342257)

('public static String convertDecimalNumbersToString ( String decimalString ) throws NumberFormatException { StringBuilder builder = new StringBuilder ( "" ) ; List < Integer > list = new ArrayList < Integer > ( ) ; String string = decimalString . substring ( 1 ) ; for ( String s : string . split ( ",-" ) ) { list . add ( Integer . parseInt ( s ) ) ; } for ( Integer i : list ) { String aChar = Character . valueOf ( ( char ) ( int ) i ) . toString ( ) ; aChar = aChar . trim ( ) ; builder . append ( aChar ) ; } return builder . toString ( ) ; } \n', 0.25009190760180433)

('private static String convertToCamelCaseNameString ( String nameString ) { String [ ] tokens = nameString . split ( "-" ) ; String result = "" ; for ( String token : tokens ) { if ( result . length ( ) > MAX_LENGTH ) { break ; } result += convertTokenToCamelCase ( token ) ; } return result ; } \n', 0.2460709720338464)

('public static String convertLowerCaseStringToTitleCase ( String value ) { String convertedValue = "" ; boolean loopedOnce = false ; for ( String word : value . split ( "-" ) ) { if ( loopedOnce ) { switch ( word ) { case "a" : case "an" : case "and" : case "in" : case "it" : case "for" : case "of" : case "on" : case "the" : case "to" : case "vs" : convertedValue += \'-\' + word ; break ; default : convertedValue += \'-\' + word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } } else { convertedValue += word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } loopedOnce = true ; } return convertedValue ; } \n', 0.24513751722186938)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 20 #################################
('public File createFileWithContents ( String name , byte [ ] contents ) throws IOException { File tempFile = java . io . File . createTempFile ( name , null ) ; tempFile . deleteOnExit ( ) ; FileOutputStream os = new FileOutputStream ( tempFile ) ; os . write ( contents ) ; os . close ( ) ; return tempFile ; } \n', 0.3438969042436998)

('public static File createFileFromByteArray ( byte [ ] bytes , String pathAndFileName ) throws IOException { File outputFile = new File ( pathAndFileName ) ; FileOutputStream outputStream = null ; try { outputStream = new FileOutputStream ( outputFile ) ; outputStream . write ( bytes ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } finally { if ( outputStream != null ) { outputStream . close ( ) ; } } return outputFile ; } \n', 0.3435716880140346)

('public static void createFileFromByteArray ( byte [ ] fileBytes , String path , String name , String extension , boolean isImageFile ) throws Exception { if ( COMPILE_FOR_JAVA ) { String filename ; BufferedImage bufferedImage = null ; if ( fileBytes != null ) { try { if ( isImageFile ) { ByteArrayInputStream inputImage = new ByteArrayInputStream ( fileBytes ) ; bufferedImage = ImageIO . read ( inputImage ) ; filename = path + File . separatorChar + name + "." + ImageType . JPG . getType ( ) ; } else filename = path + File . separatorChar + name + "." + extension ; System . out . println ( "Creating-the-file:-" + filename ) ; FileOutputStream out = new FileOutputStream ( filename ) ; if ( isImageFile ) ImageIO . write ( bufferedImage , ImageType . JPG . getType ( ) , out ) ; else out . write ( fileBytes ) ; out . close ( ) ; } catch ( IOException ioE ) { System . err . println ( "-Received-an-unknown-object-type" ) ; } } else System . err . println ( "-Received-a-null-object-type-for-image" ) ; } else System . err . println ( ERROR_MESSAGE ) ; } \n', 0.339912530582718)

('private static File writeToDisk ( Context context , String content ) throws IOException { File outputDir = context . getExternalFilesDir ( null ) ; File outputFile = File . createTempFile ( "andFHEM-" , ".log" , outputDir ) ; outputFile . setReadable ( true , true ) ; outputFile . deleteOnExit ( ) ; Files . write ( content , outputFile , Charsets . UTF_8 ) ; return outputFile ; } \n', 0.33301200314494783)

('public static File createFileFromString ( String name , String suffix , String contents ) { File temp = null ; try { temp = File . createTempFile ( name , suffix ) ; temp . deleteOnExit ( ) ; BufferedWriter out = new BufferedWriter ( new FileWriter ( temp ) ) ; out . write ( contents ) ; out . close ( ) ; } catch ( IOException e ) { } return temp ; } \n', 0.33032764416609356)

('public boolean createStoredFile ( Context context , byte [ ] content , String mimeType ) { ByteArrayInputStream is = null ; try { is = new ByteArrayInputStream ( content ) ; return createStoredFile ( context , is , mimeType ) ; } catch ( FileNotFoundException e ) { Log . e ( "File-not-found-while-storing-file." , e ) ; } catch ( IOException e ) { Log . a ( "Error-storing-file." , e ) ; } finally { Util . ensureClosed ( is ) ; } return false ; } \n', 0.32684391014767666)

('private File createTempFile ( ) throws Exception { String tempFile = selectedProject . getLocation ( ) . append ( _TEMPFOLDER ) . append ( System . currentTimeMillis ( ) + _XLP ) . toOSString ( ) ; FileOutputStream output = new FileOutputStream ( tempFile ) ; StringBuffer dataSB = new StringBuffer ( ) ; dataSB . append ( "<?xml-version="1.0"-encoding="UTF-8"?>-" ) ; dataSB . append ( "<mergerFiles>-" ) ; for ( IFile iFile : selectIFiles ) { dataSB . append ( MessageFormat . format ( "-<mergerFile-filePath="{0}"/>-" , TextUtil . cleanSpecialString ( iFile . getLocation ( ) . toOSString ( ) ) ) ) ; } dataSB . append ( "</mergerFiles>-" ) ; output . write ( dataSB . toString ( ) . getBytes ( "UTF-8" ) ) ; output . close ( ) ; File file = new File ( tempFile ) ; return file ; } \n', 0.32031896394553555)

('public static void writeToCache ( long crc64 , Bitmap bitmap , int maxResolution ) throws IOException { String file = createFilePathFromCrc64 ( crc64 , maxResolution ) ; if ( bitmap != null && file != null && crc64 != 0 ) { try { File fileC = new File ( file ) ; fileC . createNewFile ( ) ; final FileOutputStream fos = new FileOutputStream ( fileC ) ; final BufferedOutputStream bos = new BufferedOutputStream ( fos , 16384 ) ; bitmap . compress ( Bitmap . CompressFormat . JPEG , 80 , bos ) ; bos . flush ( ) ; bos . close ( ) ; fos . close ( ) ; } catch ( IOException e ) { throw e ; } catch ( Exception e ) { } } } \n', 0.31844845261110566)

('private static void createFile ( String contents , String filePath ) throws Exception { IPath path = new Path ( filePath ) ; FileWriter writer = new FileWriter ( path . toFile ( ) ) ; writer . write ( contents ) ; writer . close ( ) ; } \n', 0.3178327101856496)

('private File createFileFromString ( String fileContent , String filenameWithoutPath ) { File configFile = null ; createWorkingDirectory ( ) ; LOGGER . info ( "Copy-resource-to-folder-{}." , workingDirectory . getAbsolutePath ( ) ) ; LOGGER . info ( "Targetname-is-{}." , filenameWithoutPath ) ; try { workingDirectory . mkdirs ( ) ; LOGGER . info ( "Create-file-from-Resource-String:-{}," , fileContent ) ; configFile = new File ( workingDirectory , filenameWithoutPath ) ; LOGGER . info ( "Write-file-{}." , configFile . getAbsolutePath ( ) ) ; Files . write ( fileContent , configFile , Charset . defaultCharset ( ) ) ; } catch ( IOException e ) { LOGGER . error ( "Could-not-create-File-from-resource-String:-{}" , fileContent ) ; throw new RuntimeException ( e ) ; } return configFile ; } \n', 0.31708850882211087)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 21 #################################
('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

('protected void initialise ( Connection connection ) { if ( ! initialised ) { synchronized ( this ) { if ( ! initialised ) { Set accessorsToRemove = new HashSet ( ) ; Iterator i = accessorMutatorMap . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Method accessor = ( Method ) i . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; Object value = null ; try { value = accessor . invoke ( connection , null ) ; if ( value != null ) { defaultValues . put ( mutator , value ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Remembering-default-value:-" + accessor . getName ( ) + "()-=-" + value ) ; } } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + accessor . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } try { Object [ ] args = { value } ; mutator . invoke ( connection , args ) ; } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + mutator . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } } Iterator j = accessorsToRemove . iterator ( ) ; while ( j . hasNext ( ) ) { Method accessor = ( Method ) j . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; accessorMutatorMap . remove ( accessor ) ; defaultValues . remove ( mutator ) ; } initialised = true ; } } } } \n', 0.3899768502441775)

('public static Context initialise ( final Map environment ) throws NamingException { Context context ; if ( environment != null && environment . size ( ) > 0 ) { context = new InitialContext ( new Hashtable ( environment ) ) ; } else { context = new InitialContext ( ) ; } return context ; } \n', 0.38813912680444246)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.3795221908993608)

('private static void initialise ( ) { exitCodes = new HashSet < ExitCode > ( ) ; Map < String , String > resources = Resources . get ( ExitStatus . class ) ; for ( String key : resources . keySet ( ) ) { String mnemonic = key . substring ( 0 , key . indexOf ( ( int ) FULL_STOP ) ) ; String numericForm = key . substring ( key . indexOf ( ( int ) FULL_STOP ) + 1 ) ; String description = resources . get ( key ) ; int number = Integer . parseInt ( numericForm ) ; exitCodes . add ( new ExitCode ( number , mnemonic , description ) ) ; } } \n', 0.3787476293033488)

('protected void initialiseCommonFeatures ( Map < Integer , FeatureData > initialMap ) { super . initialiseFeatureMap ( initialMap ) ; commonFeaturesMap . putAll ( initialMap ) ; } \n', 0.3759403677907467)

('@ Override protected void doInitialise ( ) throws InitialisationException { authentications = new ConcurrentHashMap < String , Authentication > ( ) ; } \n', 0.37380482700435735)

('private void initialiseMetricMap ( ) { metricMap = new HashMap < EMethodMetricName , Integer > ( 50 ) ; EMethodMetricName [ ] metrics = EMethodMetricName . values ( ) ; for ( EMethodMetricName metric : metrics ) metricMap . put ( metric , 0 ) ; } \n', 0.3681996314523418)

('protected void initialiseFeatureMap ( Map < Integer , FeatureData > initialMap ) { featureMap . putAll ( initialMap ) ; } \n', 0.3664933131352133)

('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.36489232472833166)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 22 #################################
('@ Override protected final void insideLoop ( ) { try { doProcessing ( ) ; } catch ( Throwable e ) { Log . error ( "Event-processing-error!" , e ) ; } try { selector . select ( 50 ) ; } catch ( IOException e ) { Log . error ( "Select-failed!" , e ) ; } try { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; synchronized ( selectedKeys ) { Iterator < ? > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) iter . next ( ) ; iter . remove ( ) ; processKey ( key ) ; } } } catch ( ClosedSelectorException e ) { } } \n', 0.3672683587663921)

('@ Override protected final void insideLoop ( ) { try { doProcessing ( ) ; } catch ( Throwable e ) { Log . error ( "Event-processing-error!" , e ) ; } try { selector . select ( getSelectorTimeout ( ) ) ; } catch ( IOException e ) { Log . error ( "Select-failed!" , e ) ; } try { Set < SelectionKey > selectedKeys = selector . selectedKeys ( ) ; synchronized ( selectedKeys ) { if ( ! selectedKeys . isEmpty ( ) ) { Iterator < ? > iter = selectedKeys . iterator ( ) ; while ( iter . hasNext ( ) ) { SelectionKey key = ( SelectionKey ) iter . next ( ) ; iter . remove ( ) ; processKey ( key ) ; } } } } catch ( ClosedSelectorException e ) { } } \n', 0.35396138124898646)

('public void processRemovedTasks ( Enumeration removedTasks ) { boolean anyRemoved = false ; Set toSubtract = new HashSet ( ) ; while ( removedTasks . hasMoreElements ( ) ) { anyRemoved = true ; Task task = ( Task ) removedTasks . nextElement ( ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer:-Got-a-removed-task---" + task + "-from-" + task . getSource ( ) ) ; } REMOVE_TASKS ++ ; REMOVE_TONS += task . getPreferredValue ( AspectType . QUANTITY ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer---number-of-removed-SUPPLY-tasks:-" + REMOVE_TASKS + ",-aggregated-quantity-from-removed-SUPPLY-tasks:-" + REMOVE_TONS + "-tons." ) ; } } Set unplannedInternal = new HashSet ( ) ; for ( Iterator iter = allInternalTasks . getCollection ( ) . iterator ( ) ; iter . hasNext ( ) ; ) { Task internalTask = ( Task ) iter . next ( ) ; if ( internalTask . getPlanElement ( ) == null ) { unplannedInternal . add ( internalTask ) ; } } toSubtract = new HashSet ( allInternalTasks . getRemovedCollection ( ) ) ; unplannedInternal . removeAll ( toSubtract ) ; handleUnplanned ( unplannedInternal ) ; toSubtract . addAll ( unplannedInternal ) ; if ( getLoggingService ( ) . isInfoEnabled ( ) ) { getLoggingService ( ) . info ( "Packer---subtracting-" + toSubtract . size ( ) + "-tasks." ) ; } for ( Iterator iter = toSubtract . iterator ( ) ; iter . hasNext ( ) ; ) { subtractTaskFromReceiver ( ( Task ) iter . next ( ) ) ; } } \n', 0.33926747348422165)

('public void endAvoidNotify ( ) { avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.33474174737464607)

('public void endAvoidNotify ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.3324344539289146)

('public void flushWaiter ( Locker locker , MemoryBudget mb , int lockTableIndex ) { if ( ( firstWaiter != null ) && ( firstWaiter . getLocker ( ) == locker ) ) { firstWaiter = null ; mb . updateLockMemoryUsage ( REMOVE_LOCKINFO_OVERHEAD , lockTableIndex ) ; } else if ( waiterList != null ) { Iterator < LockInfo > iter = waiterList . iterator ( ) ; while ( iter . hasNext ( ) ) { LockInfo info = iter . next ( ) ; if ( info . getLocker ( ) == locker ) { iter . remove ( ) ; mb . updateLockMemoryUsage ( REMOVE_LOCKINFO_OVERHEAD , lockTableIndex ) ; return ; } } } } \n', 0.33087252849689)

('protected static void processHopcountRemovalLists ( String outputName , IRepositoryConnector connector , IRepositoryConnection connection , IJobManager jobManager , List < QueuedDocument > hopcountremoveList , IIncrementalIngester ingester , Long jobID , String [ ] legalLinkTypes , OutputActivity ingestLogger , int hopcountMethod , IReprioritizationTracker rt , long currentTime ) throws ManifoldCFException { hopcountremoveList = removeFromIndex ( outputName , connection . getName ( ) , jobManager , hopcountremoveList , ingester , ingestLogger ) ; processJobQueueHopcountRemovals ( hopcountremoveList , connector , connection , jobManager , jobID , legalLinkTypes , hopcountMethod , rt , currentTime ) ; } \n', 0.33015115291897673)

('void flushWaiter ( Locker locker , MemoryBudget mb , int lockTableIndex ) { if ( ( firstWaiter != null ) && ( firstWaiter . getLocker ( ) == locker ) ) { firstWaiter = null ; mb . updateLockMemoryUsage ( REMOVE_LOCKINFO_OVERHEAD , lockTableIndex ) ; } else if ( waiterList != null ) { Iterator iter = waiterList . iterator ( ) ; while ( iter . hasNext ( ) ) { LockInfo info = ( LockInfo ) iter . next ( ) ; if ( info . getLocker ( ) == locker ) { iter . remove ( ) ; mb . updateLockMemoryUsage ( REMOVE_LOCKINFO_OVERHEAD , lockTableIndex ) ; return ; } } } } \n', 0.32576883447161475)

('private BundleDescription [ ] internalGetRemovalPending ( ) { synchronized ( this . monitor ) { Iterator < BundleDescription > removed = removalPendings . iterator ( ) ; BundleDescription [ ] result = new BundleDescription [ removalPendings . size ( ) ] ; int i = 0 ; while ( removed . hasNext ( ) ) result [ i ++ ] = getBundle ( removed . next ( ) . getBundleId ( ) ) ; return result ; } } \n', 0.3254276323203818)

('protected static void processHopcountRemovalLists ( IPipelineConnections pipelineConnections , IRepositoryConnector connector , IRepositoryConnection connection , IJobManager jobManager , List < QueuedDocument > hopcountremoveList , IIncrementalIngester ingester , Long jobID , String [ ] legalLinkTypes , OutputActivity ingestLogger , int hopcountMethod , IReprioritizationTracker rt , long currentTime ) throws ManifoldCFException { hopcountremoveList = removeFromIndex ( pipelineConnections , connection . getName ( ) , jobManager , hopcountremoveList , ingester , ingestLogger ) ; processJobQueueHopcountRemovals ( hopcountremoveList , connector , connection , jobManager , jobID , legalLinkTypes , hopcountMethod , rt , currentTime ) ; } \n', 0.3244858569208755)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 23 #################################
('private String generateMd5 ( String message ) { String digest = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] hash = md . digest ( message . getBytes ( "UTF-8" ) ) ; StringBuilder sb = new StringBuilder ( 2 * hash . length ) ; for ( byte b : hash ) { sb . append ( String . format ( "%02x" , b & 0xff ) ) ; } digest = sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( "Error-generating-unique-packet-ID" ) ; logger . error ( e ) ; } return digest ; } \n', 0.41984533143908476)

('protected String generateMd5 ( String string ) { try { MessageDigest messageDigest = MessageDigest . getInstance ( "MD5" ) ; byte [ ] bytes = toBytes ( string ) ; StringBuilder result = new StringBuilder ( ) ; for ( byte b : messageDigest . digest ( bytes ) ) { result . append ( Integer . toHexString ( ( b & 0xf0 ) >>> 4 ) ) ; result . append ( Integer . toHexString ( b & 0x0f ) ) ; } return result . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( "MD5-isn\'t-available-on-this-JVM" , e ) ; } } \n', 0.4159086484322854)

('public static String md5Hash ( String string ) { MessageDigest md5 = null ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { } md5 . update ( string . getBytes ( ) ) ; BigInteger hash = new BigInteger ( 1 , md5 . digest ( ) ) ; return hash . toString ( 16 ) ; } \n', 0.4051177419959471)

('private String generateClientSecret ( ) { return RandomGenerator . generateRandomString ( ) ; } \n', 0.4048129259483478)

('private static String generateMd5 ( String value ) { String encryptedString = null ; byte [ ] bytesToBeEncrypted ; try { bytesToBeEncrypted = value . getBytes ( "UTF-8" ) ; MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; byte [ ] theDigest = md . digest ( bytesToBeEncrypted ) ; Formatter formatter = new Formatter ( ) ; for ( byte b : theDigest ) { formatter . format ( "%02x" , b ) ; } encryptedString = formatter . toString ( ) . toLowerCase ( ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return encryptedString ; } \n', 0.40476996436160567)

('public static String getSaltedMd5Hash ( String payload ) throws UnsupportedEncodingException , NoSuchAlgorithmException { final char [ ] saltRange = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" . toCharArray ( ) ; final StringBuilder sb = new StringBuilder ( ) ; final Random random = new Random ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { char c = saltRange [ random . nextInt ( saltRange . length ) ] ; sb . append ( c ) ; } final String salt = sb . toString ( ) ; return getMd5Hash ( salt + payload ) + ":" + salt ; } \n', 0.40422199249057467)

('public static int generateProof ( byte [ ] bytes , int target ) throws InterruptedException { try { logger . fine ( "Generating-Hash-..." ) ; SecureRandom rnd = SecureRandom . getInstance ( "SHA1PRNG" ) ; MessageDigest md = MessageDigest . getInstance ( "SHA-256" ) ; BigInteger digest = Block . getTarget ( Block . MAXIMUM_TARGET ) ; int nonce = rnd . nextInt ( ) ; long time = System . currentTimeMillis ( ) ; BigInteger tar = Block . getTarget ( target ) ; while ( ! validateHash ( digest , tar ) ) { if ( Thread . currentThread ( ) . isInterrupted ( ) ) { throw new InterruptedException ( ) ; } nonce ++ ; md . reset ( ) ; md . update ( bytes ) ; md . update ( ByteUtil . intToBytes ( nonce ) ) ; byte [ ] digestBytes = md . digest ( ) ; md . reset ( ) ; md . update ( digestBytes ) ; digest = new BigInteger ( 1 , md . digest ( ) ) ; } logger . fine ( "Proof-generated-in-" + ( ( System . currentTimeMillis ( ) - time ) / 1000 ) + "-seconds." ) ; logger . fine ( "Nonce:-" + nonce ) ; logger . fine ( generateLeadingZeros ( digest . toString ( 16 ) ) ) ; return nonce ; } catch ( NoSuchAlgorithmException e ) { logger . log ( Level . SEVERE , "generateProof" , e ) ; } return 0 ; } \n', 0.4026679427387414)

('private String generateRandomToken ( ) { Md5PasswordEncoder enconde = new Md5PasswordEncoder ( ) ; enconde . setEncodeHashAsBase64 ( true ) ; Long rawPass = new Date ( ) . getTime ( ) * new Random ( ) . nextLong ( ) ; return enconde . encodePassword ( rawPass . toString ( ) , null ) ; } \n', 0.3955433609408866)

('public String nextSecureHexString ( int len ) throws NotStrictlyPositiveException { if ( len <= 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . LENGTH , len ) ; } final RandomGenerator secRan = getSecRan ( ) ; MessageDigest alg = null ; try { alg = MessageDigest . getInstance ( "SHA-1" ) ; } catch ( NoSuchAlgorithmException ex ) { throw new MathInternalError ( ex ) ; } alg . reset ( ) ; int numIter = ( len / 40 ) + 1 ; StringBuilder outBuffer = new StringBuilder ( ) ; for ( int iter = 1 ; iter < numIter + 1 ; iter ++ ) { byte [ ] randomBytes = new byte [ 40 ] ; secRan . nextBytes ( randomBytes ) ; alg . update ( randomBytes ) ; byte [ ] hash = alg . digest ( ) ; for ( int i = 0 ; i < hash . length ; i ++ ) { Integer c = Integer . valueOf ( hash [ i ] ) ; String hex = Integer . toHexString ( c . intValue ( ) + 128 ) ; if ( hex . length ( ) == 1 ) { hex = "0" + hex ; } outBuffer . append ( hex ) ; } } return outBuffer . toString ( ) . substring ( 0 , len ) ; } \n', 0.3942631609315612)

('private static String generateMd5 ( final String value ) throws Exception { final byte [ ] digest = MESSAGE_DIGEST . get ( ) . digest ( value . getBytes ( UTF_8 ) ) ; Formatter formatter = null ; try { formatter = new Formatter ( ) ; for ( byte b : digest ) { formatter . format ( "%02x" , b ) ; } return formatter . toString ( ) . toLowerCase ( ) ; } finally { if ( formatter != null ) { formatter . close ( ) ; } } } \n', 0.39339220364584215)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 24 #################################
('private static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4429996253804881)

('public static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] ; } \n', 0.4429996253804881)

('private static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getCallerStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4417238391581071)

('public static StackTraceElement getMyStackTraceElement ( ) { StackTraceElement myStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 2 ) { myStackTraceElement = stackTraceElements [ 2 ] ; } } return myStackTraceElement ; } \n', 0.43606062303011456)

('public int getPrunedStackTrace ( int par1 ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - par1 ] ; System . arraycopy ( var2 , 3 + par1 , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42871933313644817)

('public StackTraceElement getLastStackTrace ( ) { final StackTraceElement [ ] stes = Thread . currentThread ( ) . getStackTrace ( ) ; int i = stes . length - 1 ; for ( ; i >= 0 ; -- i ) { StackTraceElement ste = stes [ i ] ; String className = ste . getClassName ( ) ; if ( className . equals ( StaticConsoleLogger . class . getCanonicalName ( ) ) || className . equals ( Logger . class . getCanonicalName ( ) ) ) { break ; } } return stes [ i + 1 ] ; } \n', 0.4284278536130619)

('public static StackTraceElement getCallerStackTraceElement ( ) { StackTraceElement callerStackTraceElement = null ; StackTraceElement [ ] stackTraceElements = Thread . currentThread ( ) . getStackTrace ( ) ; if ( stackTraceElements != null ) { if ( stackTraceElements . length > 3 ) { callerStackTraceElement = stackTraceElements [ 3 ] ; } } return callerStackTraceElement ; } \n', 0.4282413662067419)

('public int getPrunedStackTrace ( int p_85073_1_ ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - p_85073_1_ ] ; System . arraycopy ( var2 , 3 + p_85073_1_ , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42809281907080465)

('public int getPrunedStackTrace ( int size ) { StackTraceElement [ ] var2 = Thread . currentThread ( ) . getStackTrace ( ) ; if ( var2 . length <= 0 ) { return 0 ; } else { this . stackTrace = new StackTraceElement [ var2 . length - 3 - size ] ; System . arraycopy ( var2 , 3 + size , this . stackTrace , 0 , this . stackTrace . length ) ; return this . stackTrace . length ; } } \n', 0.42681183584127413)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 25 #################################
('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

('void sortProperties ( ) { if ( properties . size ( ) > 1 ) { List < Entry < String , PropertyDescriptor >> entries = new ArrayList < Entry < String , PropertyDescriptor >> ( properties . entrySet ( ) ) ; Collections . sort ( entries , PropertyComparator . comparator ) ; Map < String , PropertyDescriptor > orderedProperties = new LinkedHashMap < String , PropertyDescriptor > ( ( int ) ( entries . size ( ) / 0.75 ) ) ; Map < String , PropertyDescriptor > orderedDeclared = new LinkedHashMap < String , PropertyDescriptor > ( ( int ) ( declaredProperties . size ( ) / 0.75 ) ) ; for ( Entry < String , PropertyDescriptor > e : entries ) { orderedProperties . put ( e . getKey ( ) , e . getValue ( ) ) ; if ( declaredProperties . containsKey ( e . getKey ( ) ) ) { orderedDeclared . put ( e . getKey ( ) , e . getValue ( ) ) ; } } this . properties = orderedProperties ; this . declaredProperties = orderedDeclared ; } } \n', 0.408443290910788)

('@ Override public void setSortProperties ( Container . Sortable container , Object [ ] propertyId , boolean [ ] ascending ) { this . container = container ; final List < Object > ids = new ArrayList < Object > ( ) ; final List < Boolean > orders = new ArrayList < Boolean > ( ) ; final Collection < ? > sortable = container . getSortableContainerPropertyIds ( ) ; for ( int i = 0 ; i < propertyId . length ; i ++ ) { if ( sortable . contains ( propertyId [ i ] ) ) { ids . add ( propertyId [ i ] ) ; orders . add ( Boolean . valueOf ( i < ascending . length ? ascending [ i ] : true ) ) ; } } sortPropertyIds = ids . toArray ( ) ; sortDirections = new boolean [ orders . size ( ) ] ; for ( int i = 0 ; i < sortDirections . length ; i ++ ) { sortDirections [ i ] = ( orders . get ( i ) ) . booleanValue ( ) ; } } \n', 0.3939231167346853)

('public static PropertyListComparator propertyListComparatorWithGuideArray ( Object [ ] guideArray ) { if ( guideArray != null && guideArray . length > 0 ) { Object [ ] sortedArray = guideArray . clone ( ) ; Arrays . sort ( sortedArray , AscendingInsensitivePropertyListComparator ) ; if ( ! Arrays . equals ( guideArray , sortedArray ) ) { PropertyListComparator result = new PropertyListComparator ( true ) ; int size = guideArray . length ; if ( size > 0 ) { result . guideMap = new HashMap ( size ) ; for ( int i = 0 ; i < size ; ++ i ) { Object origEntry = guideArray [ i ] ; Object oneEntry = origEntry ; if ( origEntry instanceof Map ) { Object name = ( ( Map ) origEntry ) . get ( "name" ) ; if ( name == null ) { name = ( ( Map ) origEntry ) . get ( "prototypeName" ) ; } if ( name != null ) { oneEntry = name ; } } if ( oneEntry != null ) { result . guideMap . put ( oneEntry , Integer . valueOf ( i ) ) ; } } } return result ; } } return AscendingInsensitivePropertyListComparator ; } \n', 0.37947371287242776)

('public void sort ( ) { String property = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getRequestParameterMap ( ) . get ( SORT_PROPERTY_PARAMETER ) ; if ( property != null ) { SortOrder currentPropertySortOrder = sortsOrders . get ( property ) ; if ( multipleSorting ) { if ( ! sortPriorities . contains ( property ) ) { sortPriorities . add ( property ) ; } } else { sortsOrders . clear ( ) ; } if ( currentPropertySortOrder == null || currentPropertySortOrder . equals ( SortOrder . descending ) ) { sortsOrders . put ( property , SortOrder . ascending ) ; } else { sortsOrders . put ( property , SortOrder . descending ) ; } } } \n', 0.36445560103268604)

('public List < RelationMember > sortMembers ( List < RelationMember > relationMembers ) { List < RelationMember > newMembers = new ArrayList < > ( ) ; List < RelationMember > defaultMembers = new ArrayList < > ( relationMembers . size ( ) ) ; Map < AdditionalSorter , List < RelationMember >> customMap = new LinkedHashMap < > ( ) ; for ( RelationMember m : relationMembers ) { boolean wasAdded = false ; for ( AdditionalSorter sorter : additionalSorters ) { if ( sorter . acceptsMember ( m ) ) { List < RelationMember > list ; list = customMap . get ( sorter ) ; if ( list == null ) { customMap . put ( sorter , list = new LinkedList < > ( ) ) ; } list . add ( m ) ; wasAdded = true ; break ; } } if ( ! wasAdded ) { defaultMembers . add ( m ) ; } } for ( Entry < AdditionalSorter , List < RelationMember >> entry : customMap . entrySet ( ) ) { newMembers . addAll ( entry . getKey ( ) . sortMembers ( entry . getValue ( ) ) ) ; } newMembers . addAll ( sortMembersByConnectivity ( defaultMembers ) ) ; return newMembers ; } \n', 0.36215416399160527)

('public void sortPropertiesByLowestPrice ( ) { Collections . sort ( this . properties , new Comparator < Property > ( ) { @ Override public int compare ( Property p1 , Property p2 ) { return Double . valueOf ( p1 . getPayAmount ( ) ) . compareTo ( Double . valueOf ( p2 . getPayAmount ( ) ) ) ; } } ) ; } \n', 0.3493189823453705)

('public static ArrayList < Customer > sortCustomers ( HashMap < Integer , Customer > hm ) { Collection < Customer > c = hm . values ( ) ; ArrayList < Customer > a = new ArrayList < Customer > ( c ) ; Collections . sort ( a ) ; return a ; } \n', 0.3464072751275238)

('public static Map sortMapByValue ( Map map , Boolean desc ) { List < Map . Entry > list = new LinkedList < Map . Entry > ( map . entrySet ( ) ) ; boolean asc = ( desc == null || ! desc ) ; Collections . sort ( list , new PropertyComparator ( "value" , true , asc ) ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : list ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.3457964438296415)

('private Element sortEntityTypeProperties ( Element el ) throws JDOMException { XPath xp = XPath . newInstance ( "//x:EntityType" ) ; xp . addNamespace ( "x" , "http://schemas.microsoft.com/ado/2006/04/edm" ) ; for ( Object pNode : xp . selectNodes ( el ) ) { Element node = ( Element ) pNode ; final List < Element > props = new ArrayList < Element > ( ) ; for ( Object pChild : new ArrayList < Object > ( node . getChildren ( ) ) ) { Element child = ( Element ) pChild ; if ( child . getName ( ) . equals ( "Property" ) ) { props . add ( ( Element ) child . clone ( ) ) ; child . detach ( ) ; } } Collections . sort ( props , new Comparator < Element > ( ) { public int compare ( Element o1 , Element o2 ) { return o1 . getAttributeValue ( "Name" ) . compareTo ( o2 . getAttributeValue ( "Name" ) ) ; } } ) ; for ( Element prop : props ) { node . addContent ( ( Content ) prop ) ; } } return el ; } \n', 0.3451312545675277)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 26 #################################
('public static double roundToDecimalPlaces ( final double val , final int decimalPlaces ) { String zeros = "1" ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { zeros += "0" ; } int decimal = Integer . valueOf ( zeros ) . intValue ( ) ; if ( ! isNullOrZero ( val ) ) { return ( double ) Math . round ( val * decimal ) / decimal ; } return val ; } \n', 0.47474848012569243)

('public static Double roundToDecimalPlaces ( final Double val , final int decimalPlaces ) { if ( ! isNullOrZero ( val ) ) { return Double . valueOf ( roundToDecimalPlaces ( val . doubleValue ( ) , decimalPlaces ) ) ; } return val ; } \n', 0.4708190755488689)

('public static Double roundToNDecimalPlaces ( Double toBeFormatted , int nDecimalPlaces ) { double decPlacesFact = Math . pow ( 10 , nDecimalPlaces ) ; return ( double ) Math . round ( toBeFormatted * decPlacesFact ) / decPlacesFact ; } \n', 0.46764733215472787)

('public static float roundFloat ( float number , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( String . valueOf ( number ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } catch ( Exception e ) { logger . error ( e ) ; return number ; } } \n', 0.46368390074375193)

('protected double roundToDecimalPlaces ( double number , int decimalPlace , boolean place ) { int temp = 1 ; for ( int i = 0 ; i < decimalPlace ; i ++ ) { temp = temp * 10 ; } if ( place ) { number = number / temp ; number = Math . round ( number ) ; number = number * temp ; } else { number = number * temp ; number = Math . round ( number ) ; number = number / temp ; } return number ; } \n', 0.462814356628056)

('public static double roundDouble ( double number , int decimalPlace ) { double numberRound ; if ( ! Double . isInfinite ( number ) && ( ! Double . isNaN ( number ) ) ) { BigDecimal bd = new BigDecimal ( number ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_UP ) ; numberRound = bd . doubleValue ( ) ; return numberRound ; } else return number ; } \n', 0.4559023944253502)

('public static float round ( float d , int decimalPlace ) { BigDecimal bd = new BigDecimal ( Float . toString ( d ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } \n', 0.4536031667009631)

('public static float roundToDecimalPlace ( float number , int decimal ) { return ( float ) ( ( Math . round ( ( number * Math . pow ( 10 , decimal ) ) ) ) / Math . pow ( 10 , decimal ) ) ; } \n', 0.45272977337826237)

('public static float round ( float number , int numDecimalPlaces ) { if ( numDecimalPlaces < 1 ) { return Math . round ( number ) ; } float decimal = numDecimalPlaces * 10 ; return Math . round ( number * decimal ) / decimal ; } \n', 0.4517466597772535)

('public double round ( double d , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( Double . toString ( d ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . doubleValue ( ) ; } catch ( Throwable t ) { int i = ( int ) d ; return i ; } } \n', 0.44967533179412505)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 27 #################################
('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

('@ NonNull public static String leftPadWithZeros ( @ Nullable final String toPad , final int finalSize ) { final StringBuilder temp = new StringBuilder ( ) ; if ( CoreLibConstants . IS_PARAMETER_CHECKING_ENABLED ) { if ( finalSize < 0 ) { throw new IllegalArgumentException ( "finalSize-cannot-be-negative" ) ; } } if ( null != toPad ) { temp . append ( toPad ) ; } if ( temp . length ( ) < finalSize ) { do { temp . insert ( 0 , \'0\' ) ; } while ( finalSize != temp . length ( ) ) ; } return temp . toString ( ) ; } \n', 0.4060354117236279)

('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40178837872132317)

('public static String leftPad ( final String str , final int size , final char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > StringUtils . PAD_LIMIT ) { return StringUtils . leftPad ( str , size , String . valueOf ( padChar ) ) ; } return StringUtils . padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40175002810435456)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( new Integer ( size ) , substring ) ; } \n', 0.3974942111254081)

('public static final byte [ ] leftPad ( byte [ ] value , int length , int padByte ) { byte [ ] left = new byte [ length ] ; Arrays . fill ( left , ( byte ) padByte ) ; System . arraycopy ( value , 0 , left , length - value . length , value . length ) ; return left ; } \n', 0.39301718397741947)

('public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isNullOrEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.3913625230645047)

("public static String leftPad ( String str , int length ) { return ( leftPad ( str , length , '-' ) ) ; } \n", 0.39082311992471847)

('public Expression leftPad ( int size , Object substring ) { return leftPad ( Integer . valueOf ( size ) , substring ) ; } \n', 0.3873597474059222)

('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return repeat ( padChar , pads ) . concat ( str ) ; } \n', 0.3855200469850956)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 28 #################################
('private static Class < ? > createArrayClass ( GenericArrayType atp ) { Type tp = atp . getGenericComponentType ( ) ; Class < ? > rawClass = null ; if ( tp instanceof Class ) { rawClass = ( Class < ? > ) tp ; } else if ( tp instanceof GenericArrayType ) { rawClass = createArrayClass ( ( GenericArrayType ) tp ) ; } else if ( tp instanceof ParameterizedType ) { rawClass = ( Class < ? > ) ( ( ParameterizedType ) tp ) . getRawType ( ) ; if ( List . class . isAssignableFrom ( rawClass ) ) { rawClass = getClass ( tp ) ; rawClass = Array . newInstance ( rawClass , 0 ) . getClass ( ) ; } } return Array . newInstance ( rawClass , 0 ) . getClass ( ) ; } \n', 0.3720405282797228)

('@ Override public Array createArrayOf ( int type , Object [ ] elements , Connection connection ) throws SQLException { if ( elements == null || elements . length == 0 ) { return null ; } String typeName ; switch ( type ) { case Types . VARCHAR : typeName = "NX_STRING_TABLE" ; break ; case Types . OTHER : switch ( idType ) { case VARCHAR : typeName = "NX_STRING_TABLE" ; break ; case SEQUENCE : typeName = "NX_INT_TABLE" ; break ; default : throw new AssertionError ( "Unknown-id-type:-" + idType ) ; } break ; default : throw new AssertionError ( "Unknown-type:-" + type ) ; } connection = ConnectionHelper . unwrap ( connection ) ; try { Object arrayDescriptor = arrayDescriptorConstructor . newInstance ( typeName , connection ) ; return ( Array ) arrayConstructor . newInstance ( arrayDescriptor , connection , elements ) ; } catch ( ReflectiveOperationException e ) { throw new SQLException ( e ) ; } } \n', 0.36024518663168237)

('public Object [ ] createEStringArrayFromString ( EDataType eDataType , String initialValue ) { return ( Object [ ] ) super . createFromString ( initialValue ) ; } \n', 0.3494492968831504)

('public Array createArrayOf ( String typeName , Object [ ] elements ) throws SQLException { throw helper . unsupported ( ) ; } \n', 0.3409983787400057)

('static Object createObjectArray ( final Class < ? > type , int dim ) { final VmType < ? > vmClass = AccessController . doPrivileged ( new PrivilegedAction < VmType < ? >> ( ) { public VmType < ? > run ( ) { return VmType . fromClass ( type ) ; } } ) ; final String arrClsName = vmClass . getArrayClassName ( ) ; final VmType < ? > arrCls ; try { final VmClassLoader curLoader = vmClass . getLoader ( ) ; arrCls = curLoader . loadClass ( arrClsName , true ) ; if ( arrCls == null ) { throw new NoClassDefFoundError ( arrClsName ) ; } } catch ( ClassNotFoundException ex ) { throw new NoClassDefFoundError ( arrClsName ) ; } return VmUtils . getVm ( ) . getHeapManager ( ) . newArray ( ( VmArrayClass < ? > ) arrCls , dim ) ; } \n', 0.33850990871160613)

('@ Override public Array createArrayOf ( String typeName , Object [ ] elements ) throws SQLException { return con . createArrayOf ( typeName , elements ) ; } \n', 0.3236385520395131)

('private Type createArrayTypeFromString ( String string ) { return new ArrayType ( string , getTypeCreateIfNeeded ( string . substring ( 0 , string . length ( ) - ArrayType . ARRAY_SUFFIX . length ( ) ) ) , entityType ) ; } \n', 0.32293766977244326)

('@ Override public Array createArrayOf ( int type , Object [ ] elements , Connection connection ) throws SQLException { if ( elements == null || elements . length == 0 ) { return null ; } String typeName ; switch ( type ) { case Types . VARCHAR : typeName = "varchar" ; break ; case Types . CLOB : typeName = "text" ; break ; case Types . BIT : typeName = "bool" ; break ; case Types . BIGINT : typeName = "int8" ; break ; case Types . DOUBLE : typeName = "float8" ; break ; case Types . TIMESTAMP : typeName = "timestamp" ; break ; case Types . SMALLINT : typeName = "int2" ; break ; case Types . INTEGER : typeName = "int4" ; break ; case Types . OTHER : switch ( idType ) { case VARCHAR : typeName = "varchar" ; break ; case UUID : typeName = "uuid" ; break ; case SEQUENCE : typeName = "int8" ; break ; default : throw new AssertionError ( "Unknown-id-type:-" + idType ) ; } break ; default : throw new AssertionError ( "Unknown-type:-" + type ) ; } return connection . createArrayOf ( typeName , elements ) ; } \n', 0.3217554370947186)

('public Array createArrayOf ( String typeName , Object [ ] elements ) throws SQLException { return delegate . createArrayOf ( typeName , elements ) ; } \n', 0.3206063375306049)

('private static ArrayType < String > createStringArrayType ( ) { try { return new ArrayType < String > ( STRING , false ) ; } catch ( OpenDataException e ) { throw new IllegalStateException ( e ) ; } } \n', 0.3140958475785687)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 29 #################################
('public static int [ ] readIntsFromTextFile ( String file ) { String [ ] strings = readTextFile ( file ) ; if ( strings == null ) return null ; int [ ] ints = new int [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) ints [ i ] = Integer . parseInt ( strings [ i ] ) ; return ints ; } \n', 0.41965661505699475)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.41573641785888943)

('private static List < String > readTextFile ( final URL fileURL , final boolean skipEmptyLines ) throws IOException { final List < String > content = new ArrayList < String > ( ) ; BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader ( new InputStreamReader ( fileURL . openStream ( ) ) ) ; String line ; StringBuffer entry = new StringBuffer ( ) ; boolean readMore = false ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( ( ! skipEmptyLines || line . trim ( ) . length ( ) > 0 ) && line . charAt ( 0 ) != LINE_COMMENT_PREFIX ) { if ( line . endsWith ( LINE_CONTINUE_CHAR ) ) { entry . append ( line . substring ( 0 , line . length ( ) - 1 ) ) ; continue ; } else { entry . append ( line ) ; content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; continue ; } } if ( line . trim ( ) . length ( ) == 0 && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; } } if ( entry != null && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; } } finally { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } return content ; } \n', 0.41037649869810844)

('public static PrefixEncodedLexicographicallySortedDictionary loadFromPlainTextFile ( Path path , FileSystem fs , int window ) throws IOException { LOG . info ( "Reading-from-" + path ) ; LineReader reader = new LineReader ( fs . open ( path ) ) ; PrefixEncodedLexicographicallySortedDictionary terms = new PrefixEncodedLexicographicallySortedDictionary ( window ) ; int cnt = 0 ; Text t = new Text ( ) ; while ( reader . readLine ( t ) > 0 ) { String term = t . toString ( ) ; if ( term . contains ( "-" ) ) { term = term . split ( "|t" ) [ 0 ] ; } terms . add ( term ) ; cnt ++ ; if ( cnt % 1000000 == 0 ) { LOG . info ( "read-" + cnt + "-lines" ) ; } } LOG . info ( "Finished-reading-from-" + path ) ; LOG . info ( "compression-ratio:-" + terms . getCompresssionRatio ( ) ) ; return terms ; } \n', 0.40723575545112345)

('private String loadStringFromFile ( String fileName ) throws Exception { InputStream inputStream = null ; BufferedInputStream bufferedInputStream = null ; ByteArrayOutputStream byteOutputStream = null ; try { inputStream = new FileInputStream ( fileName ) ; bufferedInputStream = new BufferedInputStream ( inputStream ) ; byteOutputStream = new ByteArrayOutputStream ( ) ; int ch ; while ( ( ch = bufferedInputStream . read ( ) ) != - 1 ) { byteOutputStream . write ( ch ) ; } byte [ ] messageBytes = byteOutputStream . toByteArray ( ) ; String fileContents = new String ( messageBytes , "UTF-8" ) ; return fileContents ; } catch ( Exception e ) { SystemLogger . error ( this , "Error-in-loadStringFromFile:-" + e ) ; throw e ; } finally { try { inputStream . close ( ) ; bufferedInputStream . close ( ) ; byteOutputStream . close ( ) ; } catch ( IOException ie ) { } } } \n', 0.3976214698339576)

('public static String ReadStringFromFile ( String sFileName ) { if ( TextUtils . isEmpty ( sFileName ) ) return null ; String sDest = null ; File f = new File ( sFileName ) ; if ( ! f . exists ( ) ) { return null ; } try { FileInputStream is = new FileInputStream ( f ) ; ByteArrayOutputStream bais = new ByteArrayOutputStream ( ) ; try { byte [ ] buffer = new byte [ 1 ] ; while ( is . read ( buffer ) != - 1 ) { bais . write ( buffer ) ; } sDest = bais . toString ( ) . trim ( ) ; } catch ( IOException ioex ) { LogUtil . e ( "Excetion-:-ioexception-at-read-string-from-file!-" ) ; } finally { is . close ( ) ; bais . close ( ) ; } } catch ( Exception ex ) { LogUtil . e ( "Exception-:-read-string-from-file!" + ex . getMessage ( ) ) ; } return sDest ; } \n', 0.39225626808136804)

('public static String readTextFile ( File file ) { InputStreamReader reader ; BufferedReader in ; StringBuffer text = new StringBuffer ( ) ; int c ; try { reader = new InputStreamReader ( new FileInputStream ( file ) , detectCharSet ( file . getAbsolutePath ( ) ) ) ; in = new BufferedReader ( reader ) ; do { c = in . read ( ) ; if ( c != - 1 ) { text . append ( ( char ) c ) ; } } while ( c != - 1 ) ; in . close ( ) ; } catch ( IOException e ) { Log . w ( TAG , "Can\'t-read-file-" + file . getName ( ) , e ) ; return null ; } catch ( OutOfMemoryError e ) { Log . w ( TAG , "File-is-to-big-to-read" , e ) ; return null ; } String content = text . toString ( ) ; int windows = content . indexOf ( "-" ) ; int macos = content . indexOf ( "-" ) ; if ( windows != - 1 ) { Settings . END_OF_LINE = EOL_WINDOWS ; content = content . replaceAll ( "-" , "-" ) ; } else { if ( macos != - 1 ) { Settings . END_OF_LINE = EOL_MAC ; content = content . replaceAll ( "-" , "-" ) ; } else { Settings . END_OF_LINE = EOL_LINUX ; } } if ( BuildConfig . DEBUG ) { Log . d ( TAG , "Using-End-of-Line-:-" + Settings . END_OF_LINE ) ; } return content ; } \n', 0.391892630310015)

('private List < String > readStatementsFromTextFile ( String filename ) throws Throwable { List < String > statements = new ArrayList < String > ( ) ; Scanner scanner = new Scanner ( new FileInputStream ( filename ) ) ; scanner . useDelimiter ( ";" ) ; try { while ( scanner . hasNext ( ) ) { statements . add ( scanner . next ( ) ) ; } } finally { scanner . close ( ) ; } return statements ; } \n', 0.39163487410554043)

('public static String loadTextFromFile ( File file ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( "Unable-to-find-file:-" + file . getAbsolutePath ( ) ) ; } return new String ( Files . readAllBytes ( file . toPath ( ) ) ) ; } \n', 0.3903906803293821)

('String getFileContentsFromJar ( JarFile jarFile , JarEntry jarEntry ) throws IOException { StringBuffer fileContent = new StringBuffer ( ) ; InputStream is = jarFile . getInputStream ( jarEntry ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; int length = 500 ; byte buf [ ] = new byte [ length ] ; int count = 0 ; while ( ( count = bis . read ( buf , 0 , length ) ) != - 1 ) { fileContent . append ( new String ( buf , 0 , count ) ) ; buf = new byte [ length ] ; } bis . close ( ) ; is . close ( ) ; return fileContent . toString ( ) ; } \n', 0.38759600247433235)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 30 #################################
('protected boolean _acceptJsonFormatVisitorForEnum ( JsonFormatVisitorWrapper visitor , JavaType typeHint , Class < ? > enumType ) throws JsonMappingException { JsonStringFormatVisitor stringVisitor = visitor . expectStringFormat ( typeHint ) ; if ( stringVisitor != null ) { Set < String > enums = new LinkedHashSet < String > ( ) ; for ( Object en : enumType . getEnumConstants ( ) ) { try { enums . add ( String . valueOf ( _accessorMethod . invoke ( en ) ) ) ; } catch ( Exception e ) { Throwable t = e ; while ( t instanceof InvocationTargetException && t . getCause ( ) != null ) { t = t . getCause ( ) ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw JsonMappingException . wrapWithPath ( t , en , _accessorMethod . getName ( ) + "()" ) ; } } stringVisitor . enumTypes ( enums ) ; } return true ; } \n', 0.32518664141223563)

('private List < String > getEnumNames ( Class < T > optionsEnumClass ) { return FluentIterable . from ( Arrays . asList ( optionsEnumClass . getEnumConstants ( ) ) ) . transform ( Enums . stringConverter ( optionsEnumClass ) . reverse ( ) ) . toList ( ) ; } \n', 0.31719139408488584)

('final Object toNonNullOpenValue ( MXBeanLookup lookup , Object value ) throws OpenDataException { final Collection valueCollection = ( Collection ) value ; if ( valueCollection instanceof SortedSet ) { Comparator comparator = ( ( SortedSet ) valueCollection ) . comparator ( ) ; if ( comparator != null ) { final String msg = "Cannot-convert-SortedSet-with-non-null-comparator:-" + comparator ; throw new OpenDataException ( msg ) ; } } final Object [ ] openArray = ( Object [ ] ) Array . newInstance ( getOpenClass ( ) . getComponentType ( ) , valueCollection . size ( ) ) ; int i = 0 ; for ( Object o : valueCollection ) openArray [ i ++ ] = elementConverter . toOpenValue ( lookup , o ) ; return openArray ; } \n', 0.3105862779620868)

('public static LoopInfo [ ] collectPossibleLoopsInfoForWhile ( Statement bodyStatement , Statement elseStatement , int label ) { List < LoopInfo > list ; LoopInfo loopInfo ; if ( ( list = StatementUtil . collectPossibleLoopsInfo ( bodyStatement ) ) != null ) { for ( Iterator < LoopInfo > it = list . iterator ( ) ; it . hasNext ( ) ; ) { loopInfo = it . next ( ) ; if ( loopInfo . matchLabel ( label ) && ( loopInfo . type == LoopInfo . BREAK || loopInfo . type == LoopInfo . CONTINUE ) ) { it . remove ( ) ; } } list = list . isEmpty ( ) ? null : list ; } if ( elseStatement != null ) { List < LoopInfo > list2 = StatementUtil . collectPossibleLoopsInfo ( elseStatement ) ; if ( list == null ) { list = list2 ; } else if ( list2 != null ) { list . addAll ( list2 ) ; } } return list == null || list . isEmpty ( ) ? null : list . toArray ( new LoopInfo [ list . size ( ) ] ) ; } \n', 0.2978760892198848)

('public String convertChoreographyLoopTypeToString ( EDataType eDataType , Object instanceValue ) { return instanceValue == null ? null : instanceValue . toString ( ) ; } \n', 0.29495635333775366)

('protected void convertAll ( ) { if ( converted ) return ; super . clear ( ) ; for ( Object o : underlying ) { if ( o instanceof Number ) o = enumClass . getEnumConstants ( ) [ ( ( Number ) o ) . intValue ( ) ] ; else o = Enum . valueOf ( enumClass , o . toString ( ) ) ; super . add ( ( TYPE ) o ) ; } converted = true ; } \n', 0.29485070599257657)

('@ Benchmark public void iterableViaForLoopConsumption ( Input input ) throws InterruptedException { for ( int i : input . iterable ) { input . observer . onNext ( i ) ; } } \n', 0.2926599514151904)

('private void findLoopBody ( Map < Object , Object > backEdges , DirectedGraph g ) { Set maps = backEdges . entrySet ( ) ; for ( Iterator iter = maps . iterator ( ) ; iter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; Object tail = entry . getKey ( ) ; Object head = entry . getValue ( ) ; Set < Object > loopBody = finder ( tail , head , g ) ; loops . add ( loopBody ) ; } } \n', 0.29111766048295085)

('public static < T > T [ ] convertStringsToEnumArray ( String [ ] value , Class < T > enumType ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( value == null ) return null ; Object retvalue = Array . newInstance ( enumType , value . length ) ; int i = 0 ; Method valueof = enumType . getMethod ( "valueOf" , String . class ) ; for ( String v : value ) { Array . set ( retvalue , i , valueof . invoke ( null , value [ i ] ) ) ; i ++ ; } return ( T [ ] ) retvalue ; } \n', 0.29002931867872517)

('public void getEnumeratedValuesForSimpleType ( XSDTypeDefinition type , List result ) { List enumerationFacets = ( ( XSDSimpleTypeDefinition ) type ) . getEnumerationFacets ( ) ; for ( Iterator i = enumerationFacets . iterator ( ) ; i . hasNext ( ) ; ) { XSDEnumerationFacet enumFacet = ( XSDEnumerationFacet ) i . next ( ) ; List values = enumFacet . getValue ( ) ; for ( Iterator j = values . iterator ( ) ; j . hasNext ( ) ; ) { Object o = j . next ( ) ; if ( o != null ) { if ( ! result . contains ( o ) ) { result . add ( o . toString ( ) ) ; } } } } } \n', 0.2863345140939182)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 31 #################################
('static void checkMalformed ( String csn ) throws Exception { boolean failed = false ; System . out . printf ( "-Check-malformed-<%s>...%n" , csn ) ; for ( boolean direct : new boolean [ ] { false , true } ) { for ( byte [ ] bins : malformed ) { int mlen = bins [ 0 ] ; byte [ ] bin = Arrays . copyOfRange ( bins , 1 , bins . length ) ; CoderResult cr = decodeCR ( bin , csn , direct ) ; String ashex = "" ; for ( int i = 0 ; i < bin . length ; i ++ ) { if ( i > 0 ) ashex += "-" ; ashex += Integer . toBinaryString ( ( int ) bin [ i ] & 0xff ) ; } if ( ! cr . isMalformed ( ) ) { System . out . printf ( "-FAIL(direct=%b):-[%s]-not-malformed.-" , direct , ashex ) ; failed = true ; } else if ( cr . length ( ) != mlen ) { System . out . printf ( "-FAIL(direct=%b):-[%s]-malformed[len=%d].-" , direct , ashex , cr . length ( ) ) ; failed = true ; } } } if ( failed ) throw new RuntimeException ( "Check-malformed-failed-" + csn ) ; } \n', 0.3578099332819398)

('private boolean checkPossessionOfTwoOfClubs ( ) { if ( robotsCards . contains ( Object ) ) { possessionOfTwoOfClubs = true ; } else { possessionOfTwoOfClubs = false ; } return possessionOfTwoOfClubs ; } \n', 0.3535034633387055)

('public static void checkLoaded ( ) { if ( LOAD_ERROR != null ) { throw LOAD_ERROR ; } BigInteger two = BigInteger . valueOf ( 2 ) ; BigInteger three = BigInteger . valueOf ( 3 ) ; BigInteger five = BigInteger . valueOf ( 5 ) ; BigInteger answer ; answer = modPowInsecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowInsecure-returned-the-wrong-answer" ) ; } answer = modPowSecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowSecure-returned-the-wrong-answer" ) ; } } \n', 0.3468051299255108)

('protected boolean determineShouldBeAtLeastGrayChecked ( Object treeElement ) { List checked = ( List ) checkedStateStore . get ( treeElement ) ; if ( checked != null && ( ! checked . isEmpty ( ) ) ) { return true ; } Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } return false ; } \n', 0.3412439028260299)

('public static boolean arePercentagesHeavy ( int [ ] weekOne , int [ ] weekTwo , int [ ] weekThree , int [ ] weekFour ) { return Arrays . equals ( weekOne , WendlerConstants . HEAVY_PERCENTAGES_W_1 ) && Arrays . equals ( weekTwo , WendlerConstants . HEAVY_PERCENTAGES_W_2 ) && Arrays . equals ( weekThree , WendlerConstants . HEAVY_PERCENTAGES_W_3 ) && Arrays . equals ( weekFour , WendlerConstants . HEAVY_PERCENTAGES_W_4 ) ; } \n', 0.3403453909461178)

('public < E > void assertHasAtLeastOneElementOfType ( AssertionInfo info , E [ ] actual , Class < ? > type ) { Objects . instance ( ) . assertNotNull ( info , actual ) ; boolean found = false ; for ( Object o : actual ) { if ( ! type . isInstance ( o ) ) continue ; found = true ; break ; } if ( ! found ) throw failures . failure ( info , shouldHaveAtLeastOneElementOfType ( actual , type ) ) ; } \n', 0.337571886370023)

('protected boolean determineShouldBeAtLeastGrayChecked ( final Object treeElement ) { final List < Object > checked = checkedStateStore . get ( treeElement ) ; if ( checked != null && ! checked . isEmpty ( ) ) { return true ; } if ( expandedTreeNodes . contains ( treeElement ) ) { final Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } } return false ; } \n', 0.3365821331317027)

('private boolean determineShouldBeAtLeastGrayChecked ( Object treeElement ) { List checked = ( List ) checkedStateStore . get ( treeElement ) ; if ( checked != null && ( ! checked . isEmpty ( ) ) ) { return true ; } if ( expandedTreeNodes . contains ( treeElement ) ) { Object [ ] children = treeContentProvider . getChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( checkedStateStore . containsKey ( children [ i ] ) ) { return true ; } } } return false ; } \n', 0.33530429924291366)

('@ SuppressWarnings ( "nls" ) private boolean checkSimilar ( char last , char check ) { String iSimilar = "ijl1!" ; String oSimilar = "oO0" ; String puncSimilar = ".," ; boolean match = ( iSimilar . indexOf ( last ) > 0 && iSimilar . indexOf ( check ) > 0 ) || ( oSimilar . indexOf ( last ) > 0 && oSimilar . indexOf ( check ) > 0 ) || ( puncSimilar . indexOf ( last ) > 0 && puncSimilar . indexOf ( check ) > 0 ) ; if ( match ) return false ; return true ; } \n', 0.33382362269589283)

('void assertContainsSequence ( Description description , Object array , Object sequence ) { checkIsNotNullAndNotEmpty ( sequence ) ; assertNotNull ( description , array ) ; int sizeOfActual = sizeOf ( array ) ; int sizeOfSequence = sizeOf ( sequence ) ; boolean firstFound = false ; int index = 0 ; if ( sizeOfActual < sizeOfSequence ) { String format = "The-size-of-sequence-is-greater-than-the-size-of-array" ; throw failures . failure ( description , new BasicErrorMessageFactory ( format , array , sequence ) ) ; } for ( int i = 0 ; i < sizeOfActual && index < sizeOfSequence ; i ++ ) { if ( areEqual ( Array . get ( array , i ) , Array . get ( sequence , index ) ) ) { firstFound = true ; index ++ ; if ( i >= sizeOfActual - 1 && index < sizeOfSequence ) { throw arrayDoesNotContainSequence ( description , array , sequence ) ; } continue ; } if ( ! firstFound ) { if ( i >= sizeOfActual - 1 && index < sizeOfSequence ) { throw arrayDoesNotContainSequence ( description , array , sequence ) ; } continue ; } else { throw arrayDoesNotContainSequence ( description , array , sequence ) ; } } } \n', 0.33195626582539217)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 32 #################################
('public static int convertToInt ( String str ) throws NumberFormatException { int s , e ; for ( s = 0 ; s < str . length ( ) ; s ++ ) if ( Character . isDigit ( str . charAt ( s ) ) ) break ; for ( e = str . length ( ) ; e > 0 ; e -- ) if ( Character . isDigit ( str . charAt ( e - 1 ) ) ) break ; if ( e > s ) { try { return Integer . parseInt ( str . substring ( s , e ) ) ; } catch ( NumberFormatException ex ) { Log . e ( "convertToInt" , ex ) ; throw new NumberFormatException ( ) ; } } else { throw new NumberFormatException ( ) ; } } \n', 0.3897049253959102)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.38881819720642374)

('protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( "" ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < 8 ) { byte [ ] newByteString = new byte [ 8 ] ; for ( int i = 0 ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = 0 ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; } \n', 0.3853495140118308)

('private static int [ ] convertStringArrayToIntArray ( String [ ] arr ) { try { if ( arr == null ) return null ; int [ ] intArr = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { intArr [ i ] = Integer . parseInt ( arr [ i ] ) ; } return intArr ; } catch ( Exception e ) { return null ; } } \n', 0.38355787460310664)

('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.37822569717556054)

('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.37820241142063793)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.3781016161063178)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.3772291174528063)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.3752796206086033)

('public static int convertToInteger ( String rawValue ) throws XMPException { try { if ( rawValue == null || rawValue . length ( ) == 0 ) { throw new XMPException ( "Empty-convert-string" , XMPError . BADVALUE ) ; } if ( rawValue . startsWith ( "0x" ) ) { return Integer . parseInt ( rawValue . substring ( 2 ) , 16 ) ; } else { return Integer . parseInt ( rawValue ) ; } } catch ( NumberFormatException e ) { throw new XMPException ( "Invalid-integer-string" , XMPError . BADVALUE ) ; } } \n', 0.37437199593690673)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 33 #################################
('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

('public static String convertToStringUTF8 ( byte [ ] byteArray ) throws UnsupportedEncodingException { return new String ( byteArray , UTF8_CHARSET ) ; } \n', 0.35874313678012715)

('@ NotNull public static CharSequence convertToBytesIfAsciiString ( @ NotNull CharSequence name ) { int length = name . length ( ) ; if ( length == 0 ) return "" ; byte [ ] bytes = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { char c = name . charAt ( i ) ; if ( c >= 128 ) { return new String ( name . toString ( ) ) ; } bytes [ i ] = ( byte ) c ; } return new ByteArrayCharSequence ( bytes ) ; } \n', 0.35798380207931746)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.34732607717293607)

('public static String convertByteArrayToStringWithoutEscape ( byte [ ] data , int offset , int length ) { StringBuilder sb = new StringBuilder ( length ) ; for ( int i = offset ; i < length && i < data . length ; i ++ ) { sb . append ( ( char ) data [ i ] ) ; } return sb . toString ( ) ; } \n', 0.34483506461771884)

('public static String convertToUTF8 ( String s ) { String converted = null ; if ( s != null ) { byte [ ] bytes = new byte [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { bytes [ i ] = ( byte ) s . charAt ( i ) ; } try { converted = new String ( bytes , "UTF-8" ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( "Converted-\'" + s + "\'-to-UTF-8-\'" + converted + "\'." ) ; } } catch ( UnsupportedEncodingException ue ) { log . error ( "Unable-to-set-UTF-8-character-encoding-for-string-\'" + s + "\'!" , ue ) ; } } return converted ; } \n', 0.3422764898672679)

('public static String [ ] convertToStringArray ( CharSequence [ ] charSequences ) { if ( charSequences == null ) { return null ; } if ( charSequences instanceof String [ ] ) { return ( String [ ] ) charSequences ; } String [ ] strings = new String [ charSequences . length ] ; for ( int index = 0 ; index < charSequences . length ; index ++ ) { strings [ index ] = charSequences [ index ] . toString ( ) ; } return strings ; } \n', 0.3399451024756752)

('public static byte [ ] convertToByteArray ( String s ) { try { return s . getBytes ( "UTF8" ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; throw new Error ( "Platform-doesn\'t-support-UTF8-encoding" ) ; } } \n', 0.3313940648771572)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.330947907033479)

('@ Override protected Byte convertObjectToByte ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToByte ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToByte ( sourceObject ) ; } \n', 0.3291214073557483)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 34 #################################
('private void writeToExistFiles ( String rstring , int from , int to ) { for ( int i = from ; i <= to ; i ++ ) { String filePrefix = String . format ( "%04d" , i ) ; if ( files . contains ( filePrefix ) ) { handler . writeOut ( rstring , filePrefix ) ; } } } \n', 0.32261723007058074)

('private void checkFileExist ( File file ) { if ( file . exists ( ) ) { readFileContentIntoStorageArray ( file ) ; } else { createNewFile ( file ) ; isMissing = true ; } } \n', 0.3113425714440073)

('static void testTempFile ( String prefix , String suffix , Path dir ) throws IOException { Path file = ( dir == null ) ? Files . createTempFile ( prefix , suffix ) : Files . createTempFile ( dir , prefix , suffix ) ; try { String name = file . getFileName ( ) . toString ( ) ; if ( prefix != null && ! name . startsWith ( prefix ) ) throw new RuntimeException ( "Should-start-with-" + prefix ) ; if ( suffix == null && ! name . endsWith ( ".tmp" ) ) throw new RuntimeException ( "Should-end-with-.tmp" ) ; if ( suffix != null && ! name . endsWith ( suffix ) ) throw new RuntimeException ( "Should-end-with-" + suffix ) ; checkInDirectory ( file , dir ) ; Files . newByteChannel ( file , READ ) . close ( ) ; Files . newByteChannel ( file , WRITE ) . close ( ) ; Files . newByteChannel ( file , READ , WRITE ) . close ( ) ; if ( Files . getFileStore ( file ) . supportsFileAttributeView ( "posix" ) ) { Set < PosixFilePermission > perms = Files . getPosixFilePermissions ( file ) ; perms . remove ( PosixFilePermission . OWNER_READ ) ; perms . remove ( PosixFilePermission . OWNER_WRITE ) ; if ( ! perms . isEmpty ( ) ) throw new RuntimeException ( "Temporary-file-is-not-secure" ) ; } } finally { Files . delete ( file ) ; } } \n', 0.30989765725222806)

('private boolean ensureFileExists ( Uri uri , String path ) { File file = new File ( path ) ; if ( file . exists ( ) ) { return true ; } else { try { checkAccess ( uri , file , ParcelFileDescriptor . MODE_READ_WRITE | ParcelFileDescriptor . MODE_CREATE ) ; } catch ( FileNotFoundException e ) { return false ; } int secondSlash = path . indexOf ( \'/\' , 1 ) ; if ( secondSlash < 1 ) return false ; String directoryPath = path . substring ( 0 , secondSlash ) ; File directory = new File ( directoryPath ) ; if ( ! directory . exists ( ) ) return false ; file . getParentFile ( ) . mkdirs ( ) ; try { return file . createNewFile ( ) ; } catch ( IOException ioe ) { Log . e ( TAG , "File-creation-failed" , ioe ) ; } return false ; } } \n', 0.3078485682502542)

('private void checkFile ( boolean createParent , boolean create , boolean canRead , boolean canWrite ) throws PageException { if ( file == null ) throw new ApplicationException ( "attribute-file-is-not-defined-for-tag-file" ) ; securityManager . checkFileLocation ( pageContext . getConfig ( ) , file , serverPassword ) ; if ( ! file . exists ( ) ) { if ( create ) { Resource parent = file . getParentResource ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( createParent ) parent . mkdirs ( ) ; else throw new ApplicationException ( "parent-directory-for-[" + file + "]-doesn\'t-exist" ) ; } try { file . createFile ( false ) ; } catch ( IOException e ) { throw new ApplicationException ( "invalid-file-[" + file + "]" , e . getMessage ( ) ) ; } } else if ( ! file . isFile ( ) ) throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-is-not-a-file" ) ; else throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-doesn\'t-exist" ) ; } else if ( ! file . isFile ( ) ) throw new ApplicationException ( "source-file-[" + file . toString ( ) + "]-is-not-a-file" ) ; else if ( canRead && ! file . canRead ( ) ) throw new ApplicationException ( "no-read-access-to-source-file-[" + file . toString ( ) + "]" ) ; else if ( canWrite && ! file . canWrite ( ) ) throw new ApplicationException ( "no-write-access-to-source-file-[" + file . toString ( ) + "]" ) ; } \n', 0.3007664293847666)

('public boolean checkIfFileExistsAndCreateIfNot ( String filePrefix , String pageContents , Parser p ) throws IOException { String fileContents ; String fileName = filePrefix + "_" + p . convertUrlToFileNameWithExtension ( browser . getCurrentPagePath ( ) ) ; if ( ! p . isFileAlreadyExists ( fileName ) ) { p . writeToFile ( fileName , pageContents ) ; fail ( "The-file-for-storing-the-" + filePrefix + "-of-this-page-(" + fileName + ")-did-not-exist-previously,-creating-it-on-this-run-to-serve-as-a-template-to-test-against-on-future-runs." ) ; } fileContents = removeCarriageReturns ( p . getFileContents ( fileName ) ) ; return fileContents . equals ( pageContents ) ; } \n', 0.29847383581428233)

('private void checkSumClassContentsAndWrite ( String classContents , File targetPath , String sourceFileName ) { long checksumValue = GsCollectionsCodeGenerator . calculateChecksum ( classContents ) ; File outputFile = new File ( targetPath , sourceFileName + ".java" ) ; Path outputChecksumPath = Paths . get ( targetPath . getAbsolutePath ( ) , sourceFileName + ".java.crc" ) ; if ( ! outputChecksumPath . toFile ( ) . exists ( ) ) { this . writeFileAndChecksum ( outputFile , classContents , checksumValue , outputChecksumPath , false ) ; return ; } String existingChecksum = FileUtils . readFile ( outputChecksumPath ) ; if ( existingChecksum . equals ( String . valueOf ( checksumValue ) ) ) { return ; } this . writeFileAndChecksum ( outputFile , classContents , checksumValue , outputChecksumPath , true ) ; } \n', 0.29784319315868113)

('public void testLoadingFromInvalidCacheFile ( ) { File directory = targetContex . getDir ( targetContex . getPackageName ( ) , Context . MODE_PRIVATE ) ; File mock = new File ( directory , FILE_DEFAULT_NAME ) ; try { mock . createNewFile ( ) ; FileOutputStream outputStream = new FileOutputStream ( mock ) ; ObjectOutputStream objectStream = new ObjectOutputStream ( outputStream ) ; objectStream . writeObject ( new TokenCacheItem ( ) ) ; objectStream . flush ( ) ; objectStream . close ( ) ; outputStream . close ( ) ; } catch ( Exception e ) { fail ( "Error-in-mocking-file" ) ; } CustomLogger logger = new CustomLogger ( ) ; Logger . getInstance ( ) . setExternalLogger ( logger ) ; ITokenCacheStore store = new FileTokenCacheStore ( targetContex , FILE_DEFAULT_NAME ) ; String msgToCheck = "Existing-cache-format-is-wrong-ver:" + AuthenticationContext . getVersionName ( ) ; assertTrue ( "Verify-message-" , logger . logMessage . contains ( msgToCheck ) ) ; } \n', 0.29618997498908195)

('private Optional < String > readFileIfItExists ( Path fileToRead , String pathRelativeToProjectRoot ) { if ( Files . isRegularFile ( fileToRead ) ) { String contents ; try { contents = new String ( Files . readAllBytes ( fileToRead ) , Charsets . UTF_8 ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error-reading-" + pathRelativeToProjectRoot , e ) ; } return Optional . of ( contents ) ; } else { return Optional . absent ( ) ; } } \n', 0.28432306473839164)

('static void testTempFile ( String prefix , String suffix , Path dir ) throws IOException { Path file = ( dir == null ) ? Files . createTempFile ( prefix , suffix ) : Files . createTempFile ( dir , prefix , suffix ) ; try { String name = file . getFileName ( ) . toString ( ) ; if ( prefix != null && ! name . startsWith ( prefix ) ) throw new RuntimeException ( "Should-start-with-" + prefix ) ; if ( suffix == null && ! name . endsWith ( ".tmp" ) ) throw new RuntimeException ( "Should-end-with-.tmp" ) ; if ( suffix != null && ! name . endsWith ( suffix ) ) throw new RuntimeException ( "Should-end-with-" + suffix ) ; checkInDirectory ( file , dir ) ; Files . newByteChannel ( file , READ ) . close ( ) ; Files . newByteChannel ( file , WRITE ) . close ( ) ; Files . newByteChannel ( file , READ , WRITE ) . close ( ) ; if ( Files . getFileStore ( file ) . supportsFileAttributeView ( "posix" ) ) { Set < PosixFilePermission > perms = Files . getPosixFilePermissions ( file ) ; perms . remove ( PosixFilePermission . OWNER_READ ) ; perms . remove ( PosixFilePermission . OWNER_WRITE ) ; if ( ! perms . isEmpty ( ) ) throw new RuntimeException ( "Temporary-file-is-not-secure" ) ; } } finally { Files . delete ( file ) ; } } \n', 0.2837007260726866)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 35 #################################
('public static String convertLongToDateString ( long toConvert ) { Date d = new Date ( toConvert ) ; return d . toString ( ) ; } \n', 0.4158088170839229)

('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.41281115376975164)

('public static Date convertStringToDateInPostList ( String dateString ) throws ParseException { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy/M/d-H:mm:ss" , Locale . ENGLISH ) ; return sdf1 . parse ( dateString ) ; } \n', 0.4122611692448791)

('public static Date convertStringToDateInQueryResult ( String dateString ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( "yyyy/M/d-HH:mm" , Locale . ENGLISH ) ; return sdf . parse ( dateString ) ; } \n', 0.41130191593095433)

('public static Date convertStringToDate ( String date ) throws ParseException { SimpleDateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; Date convertedDate = new Date ( ) ; convertedDate = dateFormat . parse ( date ) ; return convertedDate ; } \n', 0.4084653057179023)

('public static String convertDateToString ( Date date ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( ALLOWED_DATE_FORMAT ) ; return sdf . format ( date ) ; } \n', 0.4074081851786442)

('private static String convertTwitterDateToISO8601 ( String oldDate ) throws ParseException { TimeZone timeZone = TimeZone . getTimeZone ( "Europe/Dublin" ) ; SimpleDateFormat twitterFormat ; twitterFormat = new SimpleDateFormat ( "EEE-MMM-dd-HH:mm:ss-ZZZZZ-yyyy" , Locale . ENGLISH ) ; Date date = twitterFormat . parse ( oldDate . substring ( 0 , 30 ) ) ; return DateUtils . dateTimeToString ( date . getTime ( ) ) ; } \n', 0.4071918924510295)

('public static Date convertStringToDateInPostContent ( String dateString ) throws ParseException { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy/M/d-H:mm:ss" , Locale . ENGLISH ) ; return sdf1 . parse ( dateString ) ; } \n', 0.4052837539743037)

('public static Calendar convertStringToCalendar ( String str ) throws ParseException { Date date = DateConverter . dateFormatter . parse ( str ) ; Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return calendar ; } \n', 0.40214454863739385)

('public static String convertStringToStringDate ( String date , Context context ) throws ParseException { SimpleDateFormat fromApi = new SimpleDateFormat ( context . getString ( R . string . date_format_from_api ) ) ; SimpleDateFormat newFormat = new SimpleDateFormat ( context . getString ( R . string . date_format_local ) ) ; return fromApi == newFormat ? date : newFormat . format ( fromApi . parse ( date ) ) ; } \n', 0.40058656827310263)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 36 #################################
('@ Converter public static byte [ ] convertToByteArray ( StreamCache cache , Exchange exchange ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; cache . writeTo ( os ) ; return os . toByteArray ( ) ; } \n', 0.39872405219597484)

('public byte [ ] convertClassToByteArray ( Object obj ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( obj ) ; oos . flush ( ) ; oos . close ( ) ; bos . close ( ) ; byte [ ] thisConvertedByteArray = bos . toByteArray ( ) ; return thisConvertedByteArray ; } \n', 0.37822805007335913)

('public static byte [ ] convertToByteArray ( String s ) { try { return s . getBytes ( "UTF8" ) ; } catch ( java . io . UnsupportedEncodingException uee ) { uee . printStackTrace ( ) ; throw new Error ( "Platform-doesn\'t-support-UTF8-encoding" ) ; } } \n', 0.36438375589623284)

('public static int [ ] convertBytesToInts ( byte [ ] bytes ) { try { int nInts = bytes . length / ( Integer . SIZE / 8 ) ; int [ ] ints = new int [ nInts ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nInts ; i ++ ) { if ( dis . available ( ) >= ( Integer . SIZE / 8 ) ) { ints [ i ] = dis . readInt ( ) ; } } dis . close ( ) ; return ints ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.36362471116465367)

('public static byte [ ] convertStringsToByteArray ( final String ... values ) throws IOException { final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; try { for ( String value : values ) { final byte [ ] valueAsBytes = value . getBytes ( Charset . forName ( "UTF-8" ) ) ; stream . write ( ByteBuffer . allocate ( 4 ) . putInt ( valueAsBytes . length ) . array ( ) ) ; stream . write ( valueAsBytes ) ; } return stream . toByteArray ( ) ; } finally { stream . close ( ) ; } } \n', 0.36095374919080353)

('public static long [ ] convertBytesToLongs ( byte [ ] bytes ) { try { int nLongs = bytes . length / ( Long . SIZE / 8 ) ; long [ ] longs = new long [ nLongs ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nLongs ; i ++ ) { if ( dis . available ( ) >= ( Long . SIZE / 8 ) ) { longs [ i ] = dis . readLong ( ) ; } } dis . close ( ) ; return longs ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.3605742858137523)

('protected byte [ ] convertObjectToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof byte [ ] ) { return ( byte [ ] ) sourceObject ; } else if ( sourceObject instanceof Byte [ ] ) { Byte [ ] objectBytes = ( Byte [ ] ) sourceObject ; byte [ ] bytes = new byte [ objectBytes . length ] ; for ( int index = 0 ; index < objectBytes . length ; index ++ ) { bytes [ index ] = objectBytes [ index ] . byteValue ( ) ; } return bytes ; } else if ( sourceObject instanceof String ) { return Helper . buildBytesFromHexString ( ( String ) sourceObject ) ; } else if ( sourceObject instanceof Blob ) { Blob blob = ( Blob ) sourceObject ; try { return blob . getBytes ( 1L , ( int ) blob . length ( ) ) ; } catch ( SQLException exception ) { throw DatabaseException . sqlException ( exception ) ; } } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . APBYTE ) ; } \n', 0.3588265906290626)

('private byte [ ] convertIntoTempByteArray ( byte [ ] input ) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( input ) ; Reader reader = new InputStreamReader ( bais ) ; BufferedReader breader = new BufferedReader ( reader ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; while ( true ) { String line = breader . readLine ( ) ; if ( line != null ) { String [ ] replacement = lineConverter . getReplacement ( line ) ; writeReplacement ( baos , replacement ) ; } else { break ; } } return baos . toByteArray ( ) ; } \n', 0.35572394153126585)

('public static String convertBytesToString ( byte [ ] array ) throws IOException { ByteArrayOutputStream result = new ByteArrayOutputStream ( array . length ) ; result . write ( array ) ; return result . toString ( ) ; } \n', 0.3549608043154385)

('public byte [ ] convertToBytes ( DataHandler dh ) throws IOException { InputStream is = dh . getInputStream ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try { int read = 0 ; byte [ ] bytes = new byte [ 1024 ] ; while ( ( read = is . read ( bytes ) ) != - 1 ) { baos . write ( bytes , 0 , read ) ; } } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Exception e ) { LOG . error ( "Could-not-close-input-stream-:-" + e . getMessage ( ) ) ; } } } return baos . toByteArray ( ) ; } \n', 0.35141268588424246)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 37 #################################
('public static Converter < Integer > getIntegerConverter ( ) { if ( integerConverter == null ) { integerConverter = new Converter < Integer > ( ) { public Integer convert ( Object o ) { return ( o != null ) ? Integer . valueOf ( o . toString ( ) ) : 0 ; } public String serialize ( Object o ) { return ( o != null ) ? o . toString ( ) : "" ; } } ; } return integerConverter ; } \n', 0.26555668849497804)

('public static Boolean convertStringToBoolean ( String s ) { if ( s == null ) { String message = Logging . getMessage ( "nullValue.StringIsNull" ) ; Logging . logger ( ) . severe ( message ) ; throw new IllegalArgumentException ( message ) ; } try { s = s . trim ( ) ; if ( s . length ( ) == 0 ) return null ; if ( s . length ( ) == 1 ) return convertNumericStringToBoolean ( s ) ; return Boolean . valueOf ( s ) ; } catch ( NumberFormatException e ) { String message = Logging . getMessage ( "generic.ConversionError" , s ) ; Logging . logger ( ) . log ( java . util . logging . Level . SEVERE , message , e ) ; return null ; } } \n', 0.2594232119317943)

('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.2417559716453611)

('public static String getBigDecimalString ( CallableStatement cs , int parameterIndex , int parameterType ) throws SQLException { String bigDecimalString = null ; switch ( representation ) { case BIGDECIMAL_REPRESENTATION : if ( cs . getBigDecimal ( parameterIndex ) != null ) bigDecimalString = cs . getBigDecimal ( parameterIndex ) . toString ( ) ; break ; case STRING_REPRESENTATION : bigDecimalString = cs . getString ( parameterIndex ) ; if ( ( bigDecimalString != null ) && ! canConvertToDecimal ( parameterType ) ) throw new SQLException ( "Invalid-data-conversion.-Method-not-called." ) ; break ; default : new Exception ( "Failed:-Invalid-Big-Decimal-representation" ) . printStackTrace ( ) ; } return bigDecimalString ; } \n', 0.23136123797721925)

("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.230853652563891)

('@ Override protected BigInteger convertObjectToBigInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return null ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToBigInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToBigInteger ( sourceObject ) ; } \n', 0.22597026876512916)

('protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( "" ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < 8 ) { byte [ ] newByteString = new byte [ 8 ] ; for ( int i = 0 ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = 0 ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; } \n', 0.22173219723269194)

('private static Object coerce ( CommandSession session , Class < ? > type , Object arg , int [ ] convert ) { if ( arg == null ) { return null ; } if ( type . isAssignableFrom ( arg . getClass ( ) ) ) { return arg ; } if ( type . isArray ( ) ) { return NO_MATCH ; } if ( type . isPrimitive ( ) && arg instanceof Long ) { Number num = ( Number ) arg ; if ( type == short . class ) { return num . shortValue ( ) ; } if ( type == int . class ) { return num . intValue ( ) ; } if ( type == long . class ) { return num . longValue ( ) ; } } convert [ 0 ] += 2 ; Object converted = session . convert ( type , arg ) ; if ( converted != null ) { return converted ; } String string = arg . toString ( ) ; if ( type . isAssignableFrom ( String . class ) ) { return string ; } if ( type . isPrimitive ( ) ) { type = primitiveToObject ( type ) ; } try { return type . getConstructor ( String . class ) . newInstance ( string ) ; } catch ( Exception e ) { } if ( type == Character . class && string . length ( ) == 1 ) { return string . charAt ( 0 ) ; } return NO_MATCH ; } \n', 0.21639947378992894)

('@ Override protected Integer convertObjectToInteger ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToInteger ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToInteger ( sourceObject ) ; } \n', 0.21174524932748867)

('@ Override protected Short convertObjectToShort ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { String sourceString = ( String ) sourceObject ; if ( sourceString . length ( ) == 0 ) { return 0 ; } else if ( sourceString . charAt ( 0 ) == PLUS ) { return super . convertObjectToShort ( sourceString . substring ( 1 ) ) ; } } return super . convertObjectToShort ( sourceObject ) ; } \n', 0.2106037041658359)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 38 #################################
('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

('private Serializable copyObject ( Serializable o ) throws RemoteException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; byte [ ] ba = bos . toByteArray ( ) ; Method m = IxcRegistryImpl . getIxcClassLoader ( importer ) . getDeserializeMethod ( ) ; return ( Serializable ) m . invoke ( null , new Object [ ] { ba } ) ; } catch ( RemoteException ex ) { throw ex ; } catch ( Exception ex ) { throw new RemoteException ( "Cannot-copy-object" , ex ) ; } } \n', 0.40537060398417707)

('@ XmlElementDecl ( namespace = AMZN_NS , name = "CopyObject" ) public JAXBElement < CopyObject > createCopyObject ( CopyObject r ) { return Util . createGeneric ( r , CopyObject . class ) ; } \n', 0.40423278690176023)

('@ SuppressWarnings ( "unchecked" ) public static < T > T copyInstance ( T src ) { if ( src == null ) { throw new NullPointerException ( "src-cannot-be-null" ) ; } T copyInstance = null ; Class < T > srcClass = ( Class < T > ) src . getClass ( ) ; PropertyDescriptor [ ] props = retrievePropertyDescriptors ( srcClass ) ; try { copyInstance = ( T ) srcClass . newInstance ( ) ; for ( PropertyDescriptor pd : props ) { Method rm = pd . getReadMethod ( ) ; Method wm = pd . getWriteMethod ( ) ; if ( wm != null && rm != null ) { wm . invoke ( copyInstance , rm . invoke ( src ) ) ; } } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } return copyInstance ; } \n', 0.39487107591654114)

('public static < T > T copyObject ( final Class < T > clazz , final T sourceObject ) { try { final byte [ ] byteArray = toByteArray ( sourceObject ) ; return fromByteArray ( clazz , byteArray ) ; } catch ( final Exception e ) { throw new IllegalStateException ( "Can-not-copy-" , e ) ; } } \n', 0.3917783189621187)

('public static Object deepCopy ( Object src ) throws InstantiationException , IllegalAccessException { Class < ? > clazz = src . getClass ( ) ; if ( Modifier . isFinal ( clazz . getModifiers ( ) ) ) { return src ; } Object dst = clazz . newInstance ( ) ; if ( src instanceof Calendar ) { ( ( Calendar ) dst ) . setTimeInMillis ( ( ( Calendar ) src ) . getTimeInMillis ( ) ) ; return dst ; } Field [ ] fields = clazz . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Object fObj = fields [ i ] . get ( src ) ; if ( fObj == null ) { continue ; } Class < ? > fRealType = fObj . getClass ( ) ; if ( ( ! fRealType . isPrimitive ( ) ) || ( ! fRealType . isEnum ( ) ) || fRealType . getPackage ( ) != JAVA_LANG_PKG ) { if ( fRealType . isArray ( ) ) { Object [ ] items = ( Object [ ] ) fObj ; fObj = Array . newInstance ( fRealType . getComponentType ( ) , items . length ) ; for ( int j = 0 ; j < items . length ; j ++ ) { Array . set ( fObj , j , deepCopy ( items [ j ] ) ) ; } } else { fObj = deepCopy ( fObj ) ; } } fields [ i ] . set ( dst , fObj ) ; } return dst ; } \n', 0.3884000434864907)

('public Object copyToNDJavaArray ( ) { Object javaArray ; try { javaArray = java . lang . reflect . Array . newInstance ( getElementType ( ) , getShape ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } IndexIterator iter = getIndexIterator ( ) ; reflectArrayCopyOut ( javaArray , this , iter ) ; return javaArray ; } \n', 0.3871508605741164)

('public static Object copyOf ( Object src ) { int srcLength = Array . getLength ( src ) ; Class < ? > srcComponentType = src . getClass ( ) . getComponentType ( ) ; Object dest = Array . newInstance ( srcComponentType , srcLength ) ; if ( srcComponentType . isArray ( ) ) { for ( int i = 0 ; i < Array . getLength ( src ) ; i ++ ) { Array . set ( dest , i , copyOf ( Array . get ( src , i ) ) ) ; } } else { System . arraycopy ( src , 0 , dest , 0 , srcLength ) ; } return dest ; } \n', 0.3835520166607283)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 39 #################################
('public long getExecutionTimeMillis ( ) { return result . getExecutionTimeMillis ( ) ; } \n', 0.3491162998252478)

('public long scheduledExecutionTime ( ) { synchronized ( lock ) { switch ( executionType ) { case FIXED_RATE : return System . currentTimeMillis ( ) + rate ; case FIXED_DELAY : return nextExecutionTime + rate ; case FIXED_DELAY_POST_EXECUTION : return nextExecutionTime + rate ; } return ( rate < 0 ? nextExecutionTime + rate : nextExecutionTime - rate ) ; } } \n', 0.3455840684646044)

('public long getExecutionTime ( TimeUnit unit ) { return unit . convert ( executionNanos , TimeUnit . NANOSECONDS ) ; } \n', 0.3386946954794139)

('public String getExecutionTime ( ) { return result . getExecutionTime ( ) ; } \n', 0.33792865755999557)

('private static void saveLastExecutionTime ( Task task ) { TaskDefinition taskDefinition = null ; try { if ( task . getTaskDefinition ( ) != null ) { SchedulerService schedulerService = Context . getSchedulerService ( ) ; taskDefinition = task . getTaskDefinition ( ) ; taskDefinition . setLastExecutionTime ( new Date ( ) ) ; schedulerService . saveTask ( taskDefinition ) ; } else { log . warn ( "Unable-to-save-the-last-execution-time-for-task.-Task.taskDefinition-is-null-in-" + task . getClass ( ) ) ; } } catch ( Exception e ) { log . warn ( "Unable-to-save-the-last-execution-time-for-task-" , e ) ; } } \n', 0.3312954449737842)

('public static long measureExecutionTime ( Runnable r ) { long before = System . currentTimeMillis ( ) ; r . run ( ) ; long after = System . currentTimeMillis ( ) ; return ( after - before ) ; } \n', 0.3292402524514107)

('public long getExecutionTime ( TimeUnit unit ) { return unit . convert ( executionMillis , TimeUnit . MILLISECONDS ) ; } \n', 0.3260543365791999)

('public static long time ( Runnable runnable , int n ) { long before = System . nanoTime ( ) ; for ( int i = 0 ; i < n ; i ++ ) { runnable . run ( ) ; } return ( System . nanoTime ( ) - before ) / n ; } \n', 0.32535553820872576)

('public long getExecutionTime ( ) { if ( _executeMultiple . get ( ) == false ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

('public long getExecutionTime ( ) { if ( ! _executeMultiple . get ( ) ) { return - 1 ; } return _executionTime ; } \n', 0.3244611616861993)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 40 #################################
('public static List < String > readFileByLineAsStringList ( File source , int numOfIngnoredLine ) { List < String > list = new ArrayList < String > ( ) ; if ( source == null || ! source . exists ( ) ) return list ; FileReader fr = null ; BufferedReader br = null ; try { fr = new FileReader ( source ) ; br = new BufferedReader ( fr ) ; String data = "" ; int cnt = numOfIngnoredLine ; while ( ( data = br . readLine ( ) ) != null ) { if ( cnt < 1 ) { list . add ( data ) ; } else { cnt -- ; } } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { try { if ( fr != null ) fr . close ( ) ; if ( br != null ) br . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return list ; } \n', 0.4252874498575152)

('public static String getLineOfTextFromFile ( ) throws IOException { return reader . readLine ( ) ; } \n', 0.4138493485793753)

('private HashMap < String , String > readFormatterFile ( String lfFileName ) { HashMap < String , String > formatters = new HashMap < String , String > ( ) ; File formatterFile = new File ( lfFileName + ".formatters" ) ; if ( formatterFile . exists ( ) ) { Reader in = null ; try { in = new FileReader ( formatterFile ) ; if ( in != null ) { StringBuilder sb = new StringBuilder ( ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) { sb . append ( ( char ) c ) ; } String [ ] lines = sb . toString ( ) . split ( "-" ) ; for ( int i = 0 ; i < lines . length ; i ++ ) { String line = lines [ i ] . trim ( ) ; if ( line . length ( ) == 0 ) continue ; int index = line . indexOf ( ":" ) ; if ( ( index > 0 ) && ( index + 1 < line . length ( ) ) ) { String formatterName = line . substring ( 0 , index ) ; String contents = line . substring ( index + 1 ) ; formatters . put ( formatterName , contents ) ; } } } } catch ( IOException ex ) { ex . printStackTrace ( ) ; } finally { if ( in != null ) try { in . close ( ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } } } return formatters ; } \n', 0.39838148239304905)

('public static String [ ] readFileLineByLine ( File file , boolean readComments , Context context ) { BufferedReader br = null ; String [ ] ret = null ; if ( file != null && isExternalStorageMounted ( ) && file . exists ( ) ) { try { br = new BufferedReader ( new FileReader ( file ) ) ; String line ; ArrayList < String > linesArray = new ArrayList < String > ( ) ; while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . equals ( "" ) && ( readComments || ! line . startsWith ( "#" ) ) ) { try { linesArray . add ( line ) ; } catch ( OutOfMemoryError e ) { Toast . makeText ( context , R . string . info_file_to_big , Toast . LENGTH_LONG ) . show ( ) ; return null ; } } } if ( linesArray . size ( ) > 0 ) { ret = linesArray . toArray ( new String [ linesArray . size ( ) ] ) ; } else { ret = new String [ ] { "" } ; } } catch ( Exception e ) { Log . e ( LOG_TAG , "Error-while-reading-from-file-" + file . getPath ( ) + "." , e ) ; ret = null ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException e ) { Log . e ( LOG_TAG , "Error-while-closing-file." , e ) ; ret = null ; } } } } return ret ; } \n', 0.3980338237412293)

('private static List < String > readTextFile ( final URL fileURL , final boolean skipEmptyLines ) throws IOException { final List < String > content = new ArrayList < String > ( ) ; BufferedReader bufferedReader = null ; try { bufferedReader = new BufferedReader ( new InputStreamReader ( fileURL . openStream ( ) ) ) ; String line ; StringBuffer entry = new StringBuffer ( ) ; boolean readMore = false ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { if ( ( ! skipEmptyLines || line . trim ( ) . length ( ) > 0 ) && line . charAt ( 0 ) != LINE_COMMENT_PREFIX ) { if ( line . endsWith ( LINE_CONTINUE_CHAR ) ) { entry . append ( line . substring ( 0 , line . length ( ) - 1 ) ) ; continue ; } else { entry . append ( line ) ; content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; continue ; } } if ( line . trim ( ) . length ( ) == 0 && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; entry . delete ( 0 , entry . length ( ) ) ; } } if ( entry != null && entry . length ( ) > 0 ) { content . add ( entry . toString ( ) . trim ( ) ) ; } } finally { if ( bufferedReader != null ) { bufferedReader . close ( ) ; } } return content ; } \n', 0.3859143098030262)

('public int readCSVLine ( final Text input ) throws IOException { Preconditions . checkNotNull ( input , "inputText-may-not-be-null" ) ; inputText = new Text ( input ) ; long totalBytesConsumed = 0 ; if ( endOfFile ) { return 0 ; } if ( inMultiLine ) { throw new RuntimeException ( "Cannot-begin-reading-a-CSV-record-while-inside-of-a-multi-line-CSV-record." ) ; } final StringBuilder stringBuilder = new StringBuilder ( ) ; do { inputText . clear ( ) ; totalBytesConsumed += readFileLine ( inputText ) ; stringBuilder . append ( inputText . toString ( ) ) ; if ( currentlyInQuotes && ! endOfFile ) { stringBuilder . append ( \'|n\' ) ; if ( totalBytesConsumed > maximumRecordSize || totalBytesConsumed > Integer . MAX_VALUE ) { final String record = stringBuilder . toString ( ) ; LOGGER . error ( "Possibly-malformed-file-encountered.-First-line-of-record:-" + record . substring ( 0 , record . indexOf ( \'|n\' ) ) ) ; throw new IOException ( "Possibly-malformed-file-encountered.-Check-log-statements-for-more-information" ) ; } } } while ( currentlyInQuotes && ! endOfFile ) ; input . set ( stringBuilder . toString ( ) ) ; return ( int ) totalBytesConsumed ; } \n', 0.38364577136689815)

('public static String [ ] loadTextFileFromFileSystem ( File file ) throws IOException { if ( file == null ) throw new NullPointerException ( "file-is-null" ) ; if ( ! file . exists ( ) ) throw new IOException ( "Text-resource-does-not-exist!" ) ; FileReader fr = new FileReader ( file ) ; BufferedReader br = new BufferedReader ( fr ) ; ArrayList < String > strings = new ArrayList < String > ( ) ; String s ; try { while ( ( s = br . readLine ( ) ) != null ) { strings . add ( s ) ; } } finally { br . close ( ) ; fr . close ( ) ; } return strings . toArray ( new String [ 0 ] ) ; } \n', 0.37919295296501615)

('public static String [ ] readLinesFromFile ( File file ) { if ( file == null ) { return null ; } if ( ! file . exists ( ) ) { return null ; } List < String > lines = new ArrayList < String > ( ) ; BufferedReader bufferedReader = null ; try { FileReader fileReader = new FileReader ( file ) ; bufferedReader = new BufferedReader ( fileReader ) ; String line ; while ( ( line = bufferedReader . readLine ( ) ) != null ) { lines . add ( line ) ; } } catch ( Exception e ) { LiferayCore . logError ( "Could-not-read-file:-" + file . getPath ( ) ) ; } finally { if ( bufferedReader != null ) { try { bufferedReader . close ( ) ; } catch ( Exception e ) { } } } return lines . toArray ( new String [ lines . size ( ) ] ) ; } \n', 0.37831297424665483)

('private void loadFromTextFile ( File file , StringBuilder sb ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; for ( ; ; ) { String line = reader . readLine ( ) ; boolean done = line == null ; if ( done ) { break ; } loadOneLine ( line , sb ) ; } } \n', 0.3775250317184947)

('public static String [ ] readTextFile ( InputStream in , String encoding ) throws IOException { ArrayList < String > lines = new ArrayList < String > ( ) ; BufferedReader bufferedIn ; if ( encoding != null ) { bufferedIn = new BufferedReader ( new InputStreamReader ( in , encoding ) ) ; } else { bufferedIn = new BufferedReader ( new InputStreamReader ( in ) ) ; } String line ; while ( ( line = bufferedIn . readLine ( ) ) != null ) { lines . add ( line ) ; } bufferedIn . close ( ) ; in . close ( ) ; return ( String [ ] ) lines . toArray ( new String [ lines . size ( ) ] ) ; } \n', 0.37738270031708865)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 41 #################################
('static < T > List < T > makeAbstractColumnList ( T [ ] array ) { List < T > result = Lists . newArrayListWithExpectedSize ( array . length ) ; result . addAll ( Arrays . asList ( array ) ) ; return result ; } \n', 0.3689043307455845)

('public static List < CMLChemFile > wrapAtomContainerListInChemModelList ( List < IAtomContainer > atomContainers ) { List < CMLChemFile > cmlChemfileList = new ArrayList < CMLChemFile > ( ) ; for ( int i = 0 ; i < atomContainers . size ( ) ; i ++ ) { cmlChemfileList . add ( wrapAtomContainerInChemModel ( atomContainers . get ( i ) ) ) ; } return cmlChemfileList ; } \n', 0.33560044361775043)

('@ SuppressWarnings ( "unchecked" ) public < Q , T extends Collection < Q >> T javaListFromPList ( T theCollectionToFillOrNull , Class < Q > theElementRequiredClass ) { return javaListFromPList ( theCollectionToFillOrNull , theElementRequiredClass , false ) ; } \n', 0.3253128079398513)

('public static List resourceListAsLabelValueBeanList ( List resourceList ) { List l = new ArrayList ( ) ; Resource r ; for ( Iterator i = resourceList . iterator ( ) ; i . hasNext ( ) ; ) { r = ( Resource ) i . next ( ) ; l . add ( new LabelValueBean ( r . getResourceName ( ) , String . valueOf ( r . getResourceId ( ) ) ) ) ; } return l ; } \n', 0.3222140465532856)

('protected static List < LinkedList < Relationship >> constructAllPathsToNodeAsRelationshipLinkedLists ( Node node , Map < Node , List < Relationship >> predecessors , boolean backwards ) { List < LinkedList < Relationship >> paths = new LinkedList < LinkedList < Relationship >> ( ) ; List < Relationship > current = predecessors . get ( node ) ; if ( current != null ) { for ( Relationship r : current ) { Node n = r . getOtherNode ( node ) ; List < LinkedList < Relationship >> newPaths = constructAllPathsToNodeAsRelationshipLinkedLists ( n , predecessors , backwards ) ; paths . addAll ( newPaths ) ; for ( LinkedList < Relationship > path : newPaths ) { if ( backwards ) { path . addFirst ( r ) ; } else { path . addLast ( r ) ; } } } } if ( paths . isEmpty ( ) ) { paths . add ( new LinkedList < Relationship > ( ) ) ; } return paths ; } \n', 0.3186910264168714)

('protected static List < LinkedList < Node >> constructAllPathsToNodeAsNodeLinkedLists ( Node node , Map < Node , List < Relationship >> predecessors , boolean includeNode , boolean backwards ) { List < LinkedList < Node >> paths = new LinkedList < LinkedList < Node >> ( ) ; List < Relationship > current = predecessors . get ( node ) ; if ( current != null ) { for ( Relationship r : current ) { Node n = r . getOtherNode ( node ) ; paths . addAll ( constructAllPathsToNodeAsNodeLinkedLists ( n , predecessors , true , backwards ) ) ; } } if ( paths . isEmpty ( ) ) { paths . add ( new LinkedList < Node > ( ) ) ; } if ( includeNode ) { for ( LinkedList < Node > path : paths ) { if ( backwards ) { path . addFirst ( node ) ; } else { path . addLast ( node ) ; } } } return paths ; } \n', 0.3152086967438753)

('public static ArrayList < String > CreateStringListFromIntegerList ( ArrayList < Integer > values ) { ArrayList < String > stringList = new ArrayList < String > ( ) ; for ( Integer value : values ) if ( value . equals ( Integer . MIN_VALUE ) ) stringList . add ( "NA" ) ; else stringList . add ( String . valueOf ( value ) ) ; return stringList ; } \n', 0.3086479046587048)

('public static < T extends Comparable < T >> List < T > mergeListsToUniqueList ( Collection < ? extends Collection < T >> inputLists ) { List < T > resultList = new ArrayList < T > ( ) ; HashSet < T > hs = new HashSet < T > ( ) ; for ( Collection < T > selectionList : inputLists ) { hs . addAll ( selectionList ) ; } resultList . addAll ( hs ) ; Collections . sort ( resultList , Collections . reverseOrder ( ) ) ; return resultList ; } \n', 0.30862933159155026)

('public static List < String > stringListFromPreferenceList ( List < ParticipantId > preferenceList ) { if ( preferenceList == null ) { return Collections . emptyList ( ) ; } return Lists . transform ( new ArrayList < ParticipantId > ( preferenceList ) , new Function < ParticipantId , String > ( ) { @ Override public String apply ( ParticipantId participantId ) { return participantId . stringify ( ) ; } } ) ; } \n', 0.3050333982372091)

('public CancelReservedInstancesListingResult withReservedInstancesListings ( java . util . Collection < ReservedInstancesListing > reservedInstancesListings ) { if ( reservedInstancesListings == null ) { this . reservedInstancesListings = null ; } else { java . util . List < ReservedInstancesListing > reservedInstancesListingsCopy = new java . util . ArrayList < ReservedInstancesListing > ( reservedInstancesListings . size ( ) ) ; reservedInstancesListingsCopy . addAll ( reservedInstancesListings ) ; this . reservedInstancesListings = reservedInstancesListingsCopy ; } return this ; } \n', 0.3045483181142228)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 42 #################################
('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.22827352679027355)

('public static Element convertToNewFormat ( Element profileFile , InspectionProfile profile ) { Element rootElement = new Element ( INSPECTIONS_TAG ) ; rootElement . setAttribute ( NAME_ATT , profile . getName ( ) ) ; final InspectionToolWrapper [ ] tools = profile . getInspectionTools ( null ) ; for ( final Object o : profileFile . getChildren ( INSP_TOOL_TAG ) ) { Element toolElement = ( ( Element ) o ) . clone ( ) ; String toolClassName = toolElement . getAttributeValue ( CLASS_ATT ) ; final String shortName = convertToShortName ( toolClassName , tools ) ; if ( shortName == null ) { continue ; } toolElement . setAttribute ( CLASS_ATT , shortName ) ; rootElement . addContent ( toolElement ) ; } return rootElement ; } \n', 0.21752330557728616)

('public static void convertFileFromUtf16ToUtf8 ( File inputFile , File outputFile ) throws IOException { String charset ; if ( inputFile == null || ! inputFile . canRead ( ) ) { throw new FileNotFoundException ( "Can\'t-read-inputFile." ) ; } try { charset = getFileCharset ( inputFile ) ; } catch ( IOException ex ) { logger . debug ( "Exception-during-charset-detection." , ex ) ; throw new IllegalArgumentException ( "Can\'t-confirm-inputFile-is-UTF-16." ) ; } if ( isCharsetUTF16 ( charset ) ) { if ( ! outputFile . exists ( ) ) { BufferedReader reader = null ; try { if ( equalsIgnoreCase ( charset , CHARSET_UTF_16LE ) ) { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16" ) ) ; } else { reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( inputFile ) , "UTF-16BE" ) ) ; } } catch ( UnsupportedEncodingException ex ) { logger . warn ( "Unsupported-exception." , ex ) ; throw ex ; } BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( outputFile ) , "UTF-8" ) ) ; int c ; while ( ( c = reader . read ( ) ) != - 1 ) { writer . write ( c ) ; } writer . close ( ) ; reader . close ( ) ; } } else { throw new IllegalArgumentException ( "File-is-not-UTF-16" ) ; } } \n', 0.21648424852644635)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.2140206174415257)

('private BidiStringConverter buildRecentFilesSizeConverter ( ) { return new BidiStringConverter ( ) { public String convertToString ( Object o ) { return ( o == null ) ? null : ( ( Integer ) o ) . toString ( ) ; } public Object convertToObject ( String s ) { if ( s == null ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } Integer i = new Integer ( s ) ; if ( i . intValue ( ) < 0 || i . intValue ( ) > RecentFilesManager . MAX_MAX_SIZE ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } return i ; } public String toString ( ) { return "RecentFilesManager-IntegerStringConverter" ; } } ; } \n', 0.20967616735656736)

('protected ByteArrayOutputStream convertFileListToBytes ( ArrayList < String > fileList ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; if ( fileList . isEmpty ( ) ) { bos . write ( UNICODE_NULL_TERMINATOR ) ; } else { for ( int i = 0 ; i < fileList . size ( ) ; i ++ ) { byte [ ] bytes = fileList . get ( i ) . getBytes ( getDefaultUnicodeEncoding ( ) ) ; bos . write ( bytes , 0 , bytes . length ) ; bos . write ( UNICODE_NULL_TERMINATOR ) ; } } bos . write ( UNICODE_NULL_TERMINATOR ) ; return bos ; } \n', 0.20499135768048482)

('private void convert ( File from , File to ) throws IOException { try ( BufferedReader in = new BufferedReader ( new InputStreamReader ( new FileInputStream ( from ) , SOURCE_ENCODING ) ) ) { try ( PrintWriter out = new PrintWriter ( new OutputStreamWriter ( new FileOutputStream ( to ) , "UTF-8" ) ) ) { out . print ( "<!DOCTYPE-html><html><head><meta-charset="UTF-8"-/>" + "<title>Source-Code</title></head><body><pre>" ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { StringBuilder result = new StringBuilder ( ) ; int len = line . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = line . charAt ( i ) ; switch ( c ) { case \'&\' : result . append ( "&amp;" ) ; break ; case \'<\' : result . append ( "&lt;" ) ; break ; default : result . append ( c ) ; } } out . print ( result . toString ( ) + LINE_SEPARATOR ) ; } out . print ( "</pre></body></html>" ) ; } } } \n', 0.20084557950184653)

('private static File convertGLFile ( File originalFile ) throws IOException { File resultFile = new File ( new File ( System . getProperty ( "java.io.tmpdir" ) ) , "ratings.txt" ) ; if ( resultFile . exists ( ) ) { resultFile . delete ( ) ; } Writer writer = null ; try { writer = new OutputStreamWriter ( new FileOutputStream ( resultFile ) , Charsets . UTF_8 ) ; for ( String line : new FileLineIterable ( originalFile , false ) ) { int lastDelimiterStart = line . lastIndexOf ( COLON_DELIMTER ) ; if ( lastDelimiterStart < 0 ) { throw new IOException ( "Unexpected-input-format-on-line:-" + line ) ; } String subLine = line . substring ( 0 , lastDelimiterStart ) ; String convertedLine = COLON_DELIMITER_PATTERN . matcher ( subLine ) . replaceAll ( "," ) ; writer . write ( convertedLine ) ; writer . write ( \'|n\' ) ; } } catch ( IOException ioe ) { resultFile . delete ( ) ; throw ioe ; } finally { Closeables . closeQuietly ( writer ) ; } return resultFile ; } \n', 0.19354689312340562)

('public String printTestConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionTestConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionTestConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printTestConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.190893398983095)

('public void write ( T object , OutputStream outputStream ) throws IOException { StringBuilder buffer = new StringBuilder ( ) ; for ( String property : converters . keySet ( ) ) { PropertyConverter < T > converter = converters . get ( property ) ; Object value = converter . convert ( object , property ) ; if ( value == null ) { buffer . append ( DELIMITER ) ; } else { buffer . append ( ReportFormatHelper . quoteIfInvalidCharacters ( value . toString ( ) ) ) . append ( DELIMITER ) ; } } buffer . delete ( buffer . length ( ) - 1 , buffer . length ( ) ) . append ( "-" ) ; outputStream . write ( buffer . toString ( ) . getBytes ( ) ) ; } \n', 0.1870794139591739)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 43 #################################
('protected Date convertStringToDate ( String s ) { try { return dateFormat . parse ( s ) ; } catch ( ParseException e ) { throw new DataImportHandlerException ( SEVERE , "Value-for-" + LAST_INDEX_KEY + "-is-invalid-for-date-format-" + dateFormat . toLocalizedPattern ( ) + "-:-" + s ) ; } } \n', 0.42394657253575907)

('public static String convertDateToXSDString ( Date date ) { if ( date == null ) { return null ; } StringBuilder lexicalForm ; String dateTime = convertDateToString ( date , true ) ; int len = dateTime . length ( ) - 1 ; if ( dateTime . indexOf ( \'.\' , len - 4 ) != - 1 ) { while ( dateTime . charAt ( len - 1 ) == \'0\' ) { len -- ; } if ( dateTime . charAt ( len - 1 ) == \'.\' ) { len -- ; } lexicalForm = new StringBuilder ( dateTime . substring ( 0 , len ) ) ; lexicalForm . append ( \'Z\' ) ; } else { lexicalForm = new StringBuilder ( dateTime ) ; } if ( date . before ( ONE_CE ) ) { DateFormat df = new SimpleDateFormat ( "yyyy" ) ; df . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; StringBuilder year = new StringBuilder ( String . valueOf ( Integer . parseInt ( df . format ( date ) ) - 1 ) ) ; while ( year . length ( ) < 4 ) { year . insert ( 0 , \'0\' ) ; } lexicalForm . replace ( 0 , lexicalForm . indexOf ( "-" , 4 ) , year . toString ( ) ) ; if ( date . before ( ONE_BCE ) ) { lexicalForm . insert ( 0 , "-" ) ; } } return lexicalForm . toString ( ) ; } \n', 0.41733908011452703)

('public static final long convertUTCStringToTimestamp ( final String aTimeString ) throws ParseException { return UTCSimpleDateFormat . parse ( aTimeString ) . getTime ( ) ; } \n', 0.4147141825887174)

('public static Date convertStringToDateInPostList ( String dateString ) throws ParseException { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy/M/d-H:mm:ss" , Locale . ENGLISH ) ; return sdf1 . parse ( dateString ) ; } \n', 0.4108061237132392)

('public static Date convertStringToDateInQueryResult ( String dateString ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( "yyyy/M/d-HH:mm" , Locale . ENGLISH ) ; return sdf . parse ( dateString ) ; } \n', 0.4071363206578549)

('public Date convertStringToDate ( String dateString ) throws ParseException { return dateFormat . get ( ) . parse ( dateString ) ; } \n', 0.4055583636644695)

('public static String convertDateToString ( Date date ) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat ( ALLOWED_DATE_FORMAT ) ; return sdf . format ( date ) ; } \n', 0.4025924942192908)

('public static Date convertStringToDateInPostContent ( String dateString ) throws ParseException { SimpleDateFormat sdf1 = new SimpleDateFormat ( "yyyy/M/d-H:mm:ss" , Locale . ENGLISH ) ; return sdf1 . parse ( dateString ) ; } \n', 0.4006823936680498)

('private String convertToFullDateString ( String rawDate ) { if ( rawDate . equals ( "" ) || rawDate . isEmpty ( ) ) { return "" ; } SimpleDateFormat oldFormat = new SimpleDateFormat ( Constants . DATETIME_FORMAT_STORAGE_2 ) ; SimpleDateFormat newWithYearFormat = new SimpleDateFormat ( Constants . DATETIME_FORMAT_FULL_SHORT ) ; SimpleDateFormat newWithoutYearFormat2 = new SimpleDateFormat ( Constants . DATETIME_FORMAT_FULL_SHORT_WITHOUT_YEAR ) ; int rawYear = convertStringToInteger ( rawDate . split ( "/" ) [ 2 ] ) ; int nowYear = Calendar . getInstance ( ) . get ( Calendar . YEAR ) ; String newDate = "" ; try { if ( rawYear == nowYear ) { newDate = newWithoutYearFormat2 . format ( oldFormat . parse ( rawDate ) ) ; } else { newDate = newWithYearFormat . format ( oldFormat . parse ( rawDate ) ) ; } return newDate ; } catch ( ParseException e ) { e . printStackTrace ( ) ; return "-" ; } } \n', 0.3880701346815787)

('public static long convertToMillis ( String valueToConvert ) throws NumberFormatException { valueToConvert = valueToConvert . trim ( ) ; String timeVal = valueToConvert . toLowerCase ( ) ; int index = 0 ; float factor = 1.0f ; if ( timeVal . endsWith ( "us" ) ) { factor = 0.001f ; index = timeVal . indexOf ( "us" ) ; } else if ( timeVal . endsWith ( "ms" ) ) { factor = 1.0f ; index = timeVal . indexOf ( "ms" ) ; } else if ( timeVal . endsWith ( "s" ) ) { factor = 1000.0f ; index = timeVal . indexOf ( \'s\' ) ; } else if ( timeVal . endsWith ( "m" ) ) { factor = 1000.0f * 60.0f ; index = timeVal . indexOf ( \'m\' ) ; } else if ( timeVal . endsWith ( "h" ) ) { factor = 1000.0f * 60.0f * 60.0f ; index = timeVal . indexOf ( \'h\' ) ; } else if ( timeVal . endsWith ( "d" ) ) { factor = 1000.0f * 60.0f * 60.0f * 24.0f ; index = timeVal . indexOf ( \'d\' ) ; } if ( index == 0 ) { index = timeVal . length ( ) ; } Float fVal = new Float ( timeVal . substring ( 0 , index ) ) ; return ( ( long ) ( fVal . floatValue ( ) * factor ) ) ; } \n', 0.3722630477804959)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 44 #################################
('private Converter [ ] filterConverters ( Converter [ ] allConverters ) { Map < String , Converter > lastInDataToConverter = new HashMap < String , Converter > ( ) ; for ( int ii = 0 ; ii < allConverters . length ; ii ++ ) { Converter converter = allConverters [ ii ] ; String lastInputData = getLastConverterInData ( converter ) ; if ( lastInDataToConverter . containsKey ( lastInputData ) ) { Converter alreadyStoredConverter = lastInDataToConverter . get ( lastInputData ) ; Converter chosenConverter = returnPreferredConverter ( converter , alreadyStoredConverter ) ; lastInDataToConverter . put ( lastInputData , chosenConverter ) ; } else { lastInDataToConverter . put ( lastInputData , converter ) ; } } return ( Converter [ ] ) lastInDataToConverter . values ( ) . toArray ( new Converter [ 0 ] ) ; } \n', 0.223793056750968)

('private List < byte [ ] > parseColNamePostfix ( String columnName , Row row ) { String columnNameWithPrefix = columnName + "Id" ; byte [ ] namePrefix = StandardConverters . convertToBytes ( columnNameWithPrefix ) ; Collection < Column > columns = row . columnByPrefix ( namePrefix ) ; List < byte [ ] > entities = new ArrayList < byte [ ] > ( ) ; for ( Column col : columns ) { byte [ ] rowkeyFullName = col . getName ( ) ; int rkLen = rowkeyFullName . length - namePrefix . length ; byte [ ] rk = new byte [ rkLen ] ; for ( int i = namePrefix . length ; i < rowkeyFullName . length ; i ++ ) { rk [ i - namePrefix . length ] = rowkeyFullName [ i ] ; } entities . add ( rk ) ; } return entities ; } \n', 0.2153085655301638)

('public void getNumOfMonitorList ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @ Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; if ( source != null ) { Iterable numEnumerable = ( Iterable ) source ; Iterator numIterator = numEnumerable . iterator ( ) ; while ( numIterator . hasNext ( ) ) { nums . add ( Integer . parseInt ( numIterator . next ( ) . toString ( ) ) ) ; } } return nums ; } } ; getConfigFromCache ( new GetConfigurationValueParameters ( ConfigurationValues . ValidNumOfMonitors , getDefaultConfigurationVersion ( ) ) , aQuery ) ; } \n', 0.20949725553573828)

('public String printComparisonConverterPaths ( ) { StringBuffer sb = new StringBuffer ( ) ; String [ ] keySet = new String [ this . fileExtensionCompareConverters . keySet ( ) . size ( ) ] ; keySet = ( String [ ] ) this . fileExtensionCompareConverters . keySet ( ) . toArray ( keySet ) ; for ( int i = 0 ; i < keySet . length ; i ++ ) { String s = keySet [ i ] ; sb . append ( printComparisonConverterPath ( s ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.20538705531595902)

('public static List < SQLParams > convertBeansToSqlParams ( List beans , SQLInfo sql , String dbname , int action , Connection con ) throws SQLException { if ( beans == null ) return null ; List < SQLParams > batchparams = new ArrayList < SQLParams > ( beans . size ( ) ) ; for ( Object bean : beans ) { SQLParams params = convertBeanToSqlParams ( bean , sql , dbname , action , con ) ; batchparams . add ( params ) ; } return batchparams ; } \n', 0.19523641439957498)

('public static Pattern convertPerlRegexToPattern ( @ Nonnull final String regex , @ Nonnull final boolean faultTolerant ) { Check . notNull ( regex , "regex" ) ; String pattern = regex . trim ( ) ; final Matcher matcher = faultTolerant ? PERL_STYLE_TOLERANT . matcher ( pattern ) : PERL_STYLE . matcher ( pattern ) ; if ( ! matcher . matches ( ) ) { throw new IllegalArgumentException ( "The-given-regular-expression-\'" + pattern + "\'-seems-to-be-not-in-PERL-style-or-has-unsupported-modifiers." ) ; } pattern = pattern . substring ( 1 ) ; final int lastIndex = pattern . lastIndexOf ( \'/\' ) ; pattern = pattern . substring ( 0 , lastIndex ) ; final int flags = Flag . convertToBitmask ( Flag . parse ( matcher . group ( 1 ) ) ) ; return Pattern . compile ( pattern , flags ) ; } \n', 0.19504627117742485)

('public String printTestConverterPath ( String s ) { StringBuffer sb = new StringBuffer ( ) ; List al = ( List ) this . fileExtensionTestConverters . get ( s ) ; for ( int i = 0 ; i < al . size ( ) ; i ++ ) { ConverterPath cp = ( ConverterPath ) al . get ( i ) ; sb . append ( cp . toString ( ) ) ; } sb . trimToSize ( ) ; return sb . toString ( ) ; } \n', 0.19127479531152472)

('public static List < Tuple > getTuplesFromConstantTupleStringAsByteArray ( String [ ] tupleConstants ) throws ParserException , ExecException { List < Tuple > tuples = getTuplesFromConstantTupleStrings ( tupleConstants ) ; for ( Tuple t : tuples ) { convertStringToDataByteArray ( t ) ; } return tuples ; } \n', 0.18214400017728882)

('@ SuppressWarnings ( "unchecked" ) private List < Converter > buildConverterList ( List < Map < String , Object >> converters ) { if ( converters == null || converters . isEmpty ( ) ) { return Collections . emptyList ( ) ; } final List < Converter > cl = Lists . newArrayListWithCapacity ( converters . size ( ) ) ; for ( Map < String , Object > converterSummary : converters ) { cl . add ( new Converter ( Converter . Type . fromString ( converterSummary . get ( "type" ) . toString ( ) ) , ( Map < String , Object > ) converterSummary . get ( "config" ) ) ) ; } return cl ; } \n', 0.17278399917578385)

('public Template convert ( DRS drs , List < Slot > ls ) { Set < SPARQL_Prefix > prefixes = new HashSet < SPARQL_Prefix > ( ) ; prefixes . add ( new SPARQL_Prefix ( "rdf" , "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ) ) ; prefixes . add ( new SPARQL_Prefix ( "rdfs" , "http://www.w3.org/2000/01/rdf-schema#" ) ) ; logger . trace ( "Converting-DRS{" + drs . toString ( ) + "}..." ) ; template = new Template ( new Query ( ) ) ; slots = ls ; Query q = convert ( drs , new Query ( ) , false ) ; if ( q == null ) return null ; q . setPrefixes ( prefixes ) ; template . setQuery ( q ) ; logger . trace ( "...-done" ) ; usedInts = new ArrayList < Integer > ( ) ; return template ; } \n', 0.16925511687384157)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 45 #################################
('public String ucWords ( String wordsToConvert ) { wordsToConvert = wordsToConvert . toLowerCase ( ) ; Boolean ucChar = false ; String convertedString = "" ; for ( int i = 0 ; i < wordsToConvert . length ( ) ; i ++ ) { if ( i == 0 | ucChar ) { convertedString += Character . toUpperCase ( wordsToConvert . charAt ( i ) ) ; } else { convertedString += Character . toString ( wordsToConvert . charAt ( i ) ) ; } if ( Character . isWhitespace ( wordsToConvert . charAt ( i ) ) ) { ucChar = true ; } else { ucChar = false ; } } return convertedString ; } \n', 0.25097136223043237)

('@ Override public Character fromString ( String input ) throws IllegalArgumentException { if ( input == null ) { throw new NullPointerException ( "input-must-not-be-null" ) ; } if ( input . length ( ) != 1 ) { throw new IllegalArgumentException ( "The-input-string-"" + input + ""-cannot-be-converted-to-a-" + "character.-The-input\'s-length-must-be-1" ) ; } return input . toCharArray ( ) [ 0 ] ; } \n', 0.2227385445715608)

('@ Override public byte [ ] convertSchemaBase64ToByteArray ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof String ) { StringTokenizer tokenizer = new StringTokenizer ( ( String ) sourceObject ) ; StringBuilder builder = new StringBuilder ( ) ; while ( tokenizer . hasMoreTokens ( ) ) { builder . append ( tokenizer . nextToken ( ) ) ; } byte [ ] bytes = Base64 . base64Decode ( builder . toString ( ) . getBytes ( ) ) ; return bytes ; } return convertObjectToByteArray ( sourceObject ) ; } \n', 0.22156284143057722)

('private String convertTabsToSpaces ( IDocument document , String text , int offset , String indentString ) throws BadLocationException { if ( text . indexOf ( "-" ) != - 1 ) { if ( text . equals ( "-" ) ) { deleteWhitespaceAfter ( document , offset ) ; text = indentString ; } else { char [ ] chars = text . toCharArray ( ) ; FastStringBuffer newText = new FastStringBuffer ( ) ; for ( int count = 0 ; count < chars . length ; count ++ ) { if ( chars [ count ] == \'|t\' ) { newText . append ( indentString ) ; } else { newText . append ( chars [ count ] ) ; } } text = newText . toString ( ) ; } } return text ; } \n', 0.20037882476411673)

('@ Override public String buildBase64StringFromBytes ( byte [ ] bytes ) { byte [ ] convertedBytes = Base64 . base64Encode ( bytes ) ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = 0 ; i < convertedBytes . length ; i ++ ) { buffer . append ( ( char ) convertedBytes [ i ] ) ; } return buffer . toString ( ) ; } \n', 0.1920857275199649)

('@ Override public Object convertTestString ( String typeStr , String testStr ) { Matcher matcher = TYPE_PATTERN . matcher ( typeStr ) ; if ( ! matcher . matches ( ) ) { return new TestInfo ( preProcessPattern ( testStr ) , false , false , false , 0 ) ; } int maxOffset = 0 ; String lengthStr = matcher . group ( 1 ) ; if ( lengthStr != null && lengthStr . length ( ) > 1 ) { try { maxOffset = Integer . decode ( lengthStr . substring ( 1 ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( "Invalid-format-for-search-length:-" + testStr ) ; } } boolean compactWhiteSpace = false ; boolean optionalWhiteSpace = false ; boolean caseInsensitive = false ; String flagsStr = matcher . group ( 2 ) ; if ( flagsStr != null ) { for ( char ch : flagsStr . toCharArray ( ) ) { switch ( ch ) { case \'B\' : compactWhiteSpace = true ; break ; case \'b\' : optionalWhiteSpace = true ; break ; case \'c\' : caseInsensitive = true ; break ; case \'t\' : case \'w\' : case \'W\' : break ; } } } String processedPattern = preProcessPattern ( testStr ) ; return new TestInfo ( processedPattern , compactWhiteSpace , optionalWhiteSpace , caseInsensitive , maxOffset ) ; } \n', 0.17174053615596996)

('private Throwable convertString ( final ListIterator < String > lines , final boolean removeCausedBy ) { String firstLine = lines . next ( ) ; if ( removeCausedBy ) { firstLine = firstLine . substring ( CAUSED_BY_STRING_LENGTH ) ; } final int colon = firstLine . indexOf ( ":" ) ; String throwableClassName ; String message = null ; if ( colon > 1 ) { throwableClassName = firstLine . substring ( 0 , colon ) ; if ( firstLine . length ( ) > colon + 1 ) { message = firstLine . substring ( colon + 1 ) . trim ( ) ; } } else { throwableClassName = firstLine ; } final List < StackTraceElement > stackTrace = new ArrayList < > ( ) ; Throwable cause = null ; while ( lines . hasNext ( ) ) { final String line = lines . next ( ) ; if ( line . startsWith ( "Caused-by-" ) ) { lines . previous ( ) ; cause = convertString ( lines , true ) ; break ; } stackTrace . add ( StackTraceElementAttributeConverter . convertString ( line . trim ( ) . substring ( 3 ) . trim ( ) ) ) ; } return this . getThrowable ( throwableClassName , message , cause , stackTrace . toArray ( new StackTraceElement [ stackTrace . size ( ) ] ) ) ; } \n', 0.1701845045281182)

('public ISpecialStr convertStringToSpecialStr ( Object o ) throws ParseException { if ( o instanceof ISpecialStr ) { return ( ISpecialStr ) o ; } else { if ( o instanceof Token ) { return ( ( Token ) o ) . asSpecialStr ( ) ; } return createSpecialStr ( ( ( String ) o ) . trim ( ) , AbstractPythonGrammar . DEFAULT_SEARCH_ON_LAST , false ) ; } } \n', 0.16922399742372796)

('public static String convertToPinyinFirstCharString ( String text , String separator , boolean remainNone ) { List < Pinyin > pinyinList = PinyinDictionary . convertToPinyin ( text , remainNone ) ; int length = pinyinList . size ( ) ; StringBuilder sb = new StringBuilder ( length * ( 1 + separator . length ( ) ) ) ; int i = 1 ; for ( Pinyin pinyin : pinyinList ) { sb . append ( pinyin . getFirstChar ( ) ) ; if ( i < length ) { sb . append ( separator ) ; } ++ i ; } return sb . toString ( ) ; } \n', 0.16236733170475404)

('public static String convertStringToCString ( String str ) throws StringUtilException { if ( str == null ) throw new StringUtilException ( "input-is-null" ) ; StringBuffer stringBuffer = new StringBuffer ( ) ; for ( int index = 0 ; index < str . length ( ) ; ++ index ) { char currentChar = str . charAt ( index ) ; String escapeSequenceRepresentation = getStringOfEscapeSequenceChar ( currentChar ) ; if ( escapeSequenceRepresentation == null ) stringBuffer . append ( currentChar ) ; else stringBuffer . append ( escapeSequenceRepresentation ) ; } return stringBuffer . toString ( ) ; } \n', 0.15821071661827435)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 46 #################################
('public String ucWords ( String wordsToConvert ) { wordsToConvert = wordsToConvert . toLowerCase ( ) ; Boolean ucChar = false ; String convertedString = "" ; for ( int i = 0 ; i < wordsToConvert . length ( ) ; i ++ ) { if ( i == 0 | ucChar ) { convertedString += Character . toUpperCase ( wordsToConvert . charAt ( i ) ) ; } else { convertedString += Character . toString ( wordsToConvert . charAt ( i ) ) ; } if ( Character . isWhitespace ( wordsToConvert . charAt ( i ) ) ) { ucChar = true ; } else { ucChar = false ; } } return convertedString ; } \n', 0.2975540550551912)

('public static String preprocessMultiLineStrings ( String code ) throws Exception { StringBuilder result = new StringBuilder ( code . length ( ) + 1000 ) ; String delimiter = """"" ; int lastStop = 0 ; while ( true ) { int start = code . indexOf ( delimiter , lastStop ) ; if ( - 1 == start ) { result . append ( code . substring ( lastStop , code . length ( ) ) ) ; break ; } int stop = code . indexOf ( delimiter , start + delimiter . length ( ) ) ; if ( - 1 == stop ) { throw new Exception ( "Multiline-string-not-terminated" ) ; } result . append ( code . substring ( lastStop , start ) ) ; lastStop = stop + delimiter . length ( ) ; result . append ( convertMultiLineStringToJavaScript ( code . substring ( start + delimiter . length ( ) , stop ) ) ) ; } return result . toString ( ) ; } \n', 0.2712617916979018)

('public static byte [ ] [ ] splitAndGetPathComponents ( String str ) { try { final int len ; if ( str == null || ( ( len = str . length ( ) ) == 0 ) || str . charAt ( 0 ) != Path . SEPARATOR_CHAR ) { return null ; } char [ ] charArray = UTF8 . getCharArray ( len ) ; str . getChars ( 0 , len , charArray , 0 ) ; List < byte [ ] > componentByteList = new ArrayList < byte [ ] > ( 20 ) ; boolean canFastConvert = true ; int startIndex = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( charArray [ i ] == Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , i , charArray , canFastConvert ) ) ; startIndex = i + 1 ; canFastConvert = true ; } else if ( charArray [ i ] > UTF8 . MAX_ASCII_CODE ) { canFastConvert = false ; } } if ( charArray [ len - 1 ] != Path . SEPARATOR_CHAR ) { componentByteList . add ( extractBytes ( str , startIndex , len , charArray , canFastConvert ) ) ; } int last = componentByteList . size ( ) ; while ( -- last >= 1 && componentByteList . get ( last ) . length == 0 ) { componentByteList . remove ( last ) ; } return componentByteList . toArray ( new byte [ last + 1 ] [ ] ) ; } catch ( UnsupportedEncodingException e ) { return null ; } } \n', 0.2494414971206559)

('public static int [ ] splitAndConvertIntegers ( String expressionString , final String clause , int numOfFields ) throws TermEvaulatorException { final String [ ] sA = clause . split ( "|." , numOfFields ) ; if ( sA . length < numOfFields ) { StringBuilder sB = new StringBuilder ( ) ; sB . append ( "Invalid-string-" ) ; sB . append ( clause ) ; sB . append ( "-following-" ) ; sB . append ( expressionString ) ; sB . append ( "-should-be-" ) ; sB . append ( numOfFields ) ; sB . append ( "-integers-separated-by-dots" ) ; throw new TermEvaulatorException ( sB . toString ( ) ) ; } int [ ] fields = new int [ numOfFields ] ; int index = 0 ; for ( String field : clause . split ( "|." , numOfFields ) ) { fields [ index ++ ] = Integer . parseInt ( field ) ; } return fields ; } \n', 0.2493496268573035)

('protected String convertDelimiters ( String text , boolean stripEol ) { String result = super . convertDelimiters ( text ) ; int len ; if ( stripEol && text != null && ( len = text . length ( ) ) > 0 ) { for ( int i = len - 1 ; i >= 0 ; i -- ) { char c = text . charAt ( i ) ; if ( c == SWT . CR ) { continue ; } else if ( c == SWT . LF ) { continue ; } if ( i + 1 != len ) { result = text . substring ( 0 , i + 1 ) ; } break ; } } return result ; } \n', 0.24066434008629412)

('public static String convertToPinyinFirstCharString ( String text , String separator , boolean remainNone ) { List < Pinyin > pinyinList = PinyinDictionary . convertToPinyin ( text , remainNone ) ; int length = pinyinList . size ( ) ; StringBuilder sb = new StringBuilder ( length * ( 1 + separator . length ( ) ) ) ; int i = 1 ; for ( Pinyin pinyin : pinyinList ) { sb . append ( pinyin . getFirstChar ( ) ) ; if ( i < length ) { sb . append ( separator ) ; } ++ i ; } return sb . toString ( ) ; } \n', 0.23809108374773014)

('private String convertTabsToSpaces ( IDocument document , String text , int offset , String indentString ) throws BadLocationException { if ( text . indexOf ( "-" ) != - 1 ) { if ( text . equals ( "-" ) ) { deleteWhitespaceAfter ( document , offset ) ; text = indentString ; } else { char [ ] chars = text . toCharArray ( ) ; FastStringBuffer newText = new FastStringBuffer ( ) ; for ( int count = 0 ; count < chars . length ; count ++ ) { if ( chars [ count ] == \'|t\' ) { newText . append ( indentString ) ; } else { newText . append ( chars [ count ] ) ; } } text = newText . toString ( ) ; } } return text ; } \n', 0.22684537331024895)

('public static String [ ] convertBytesToStrings ( byte [ ] bytes , int nChars ) { try { int nStrings = ( int ) ( bytes . length / ( nChars * ( Character . SIZE / 8 ) ) ) ; String [ ] strings = new String [ nStrings ] ; byte [ ] stringBytes = new byte [ nChars * ( Character . SIZE / 8 ) ] ; DataInputStream dis = new DataInputStream ( new ByteArrayInputStream ( bytes ) ) ; for ( int i = 0 ; i < nStrings ; i ++ ) { if ( dis . available ( ) >= ( nChars * ( Character . SIZE / 8 ) ) ) { dis . read ( stringBytes ) ; strings [ i ] = new String ( stringBytes , "UTF-16BE" ) . trim ( ) ; } } return strings ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; throw new RuntimeException ( ex ) ; } } \n', 0.22507001136228255)

('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.22244121888560128)

('public static String convertLowerCaseStringToTitleCase ( String value ) { String convertedValue = "" ; boolean loopedOnce = false ; for ( String word : value . split ( "-" ) ) { if ( loopedOnce ) { switch ( word ) { case "a" : case "an" : case "and" : case "in" : case "it" : case "for" : case "of" : case "on" : case "the" : case "to" : case "vs" : convertedValue += \'-\' + word ; break ; default : convertedValue += \'-\' + word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } } else { convertedValue += word . substring ( 0 , 1 ) . toUpperCase ( ) + word . substring ( 1 ) ; } loopedOnce = true ; } return convertedValue ; } \n', 0.2181279414764394)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 47 #################################
('private BidiStringConverter buildRecentFilesSizeConverter ( ) { return new BidiStringConverter ( ) { public String convertToString ( Object o ) { return ( o == null ) ? null : ( ( Integer ) o ) . toString ( ) ; } public Object convertToObject ( String s ) { if ( s == null ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } Integer i = new Integer ( s ) ; if ( i . intValue ( ) < 0 || i . intValue ( ) > RecentFilesManager . MAX_MAX_SIZE ) { return new Integer ( RecentFilesManager . DEFAULT_MAX_SIZE ) ; } return i ; } public String toString ( ) { return "RecentFilesManager-IntegerStringConverter" ; } } ; } \n', 0.24714493843839652)

('public void getNumOfMonitorList ( AsyncQuery aQuery ) { aQuery . converterCallback = new IAsyncConverter ( ) { @ Override public Object Convert ( Object source , AsyncQuery _asyncQuery ) { ArrayList < Integer > nums = new ArrayList < Integer > ( ) ; if ( source != null ) { Iterable numEnumerable = ( Iterable ) source ; Iterator numIterator = numEnumerable . iterator ( ) ; while ( numIterator . hasNext ( ) ) { nums . add ( Integer . parseInt ( numIterator . next ( ) . toString ( ) ) ) ; } } return nums ; } } ; getConfigFromCache ( new GetConfigurationValueParameters ( ConfigurationValues . ValidNumOfMonitors , getDefaultConfigurationVersion ( ) ) , aQuery ) ; } \n', 0.23206273364270463)

('public static Converter < Integer > getIntegerConverter ( ) { if ( integerConverter == null ) { integerConverter = new Converter < Integer > ( ) { public Integer convert ( Object o ) { return ( o != null ) ? Integer . valueOf ( o . toString ( ) ) : 0 ; } public String serialize ( Object o ) { return ( o != null ) ? o . toString ( ) : "" ; } } ; } return integerConverter ; } \n', 0.21366026515877742)

('public static List < Tuple > getTuplesFromConstantTupleStringAsByteArray ( String [ ] tupleConstants ) throws ParserException , ExecException { List < Tuple > tuples = getTuplesFromConstantTupleStrings ( tupleConstants ) ; for ( Tuple t : tuples ) { convertStringToDataByteArray ( t ) ; } return tuples ; } \n', 0.20962817789550275)

('@ Override public Long getCardinality ( String sobject ) throws ResourceException { InputStream is = null ; try { is = doRestHttpGet ( new URL ( restEndpoint + "/query/?explain=select+id+from+" + URLEncoder . encode ( sobject , "UTF-8" ) ) ) ; String s = ObjectConverterUtil . convertToString ( new InputStreamReader ( is , Charset . forName ( "UTF-8" ) ) ) ; int index = s . indexOf ( "cardinality" ) ; if ( index < 0 ) { return null ; } index = s . indexOf ( ":" , index ) ; if ( index < 0 ) { return null ; } int end = s . indexOf ( "," , index ) ; if ( end < 0 ) { end = s . indexOf ( "}" , index ) ; } if ( end < 0 ) { return null ; } s = s . substring ( index + 1 , end ) ; return Long . valueOf ( s ) ; } catch ( NumberFormatException e ) { throw new ResourceException ( e ) ; } catch ( MalformedURLException e ) { throw new ResourceException ( e ) ; } catch ( UnsupportedEncodingException e ) { throw new ResourceException ( e ) ; } catch ( IOException e ) { throw new ResourceException ( e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } } } \n', 0.18949831419023547)

('public static byte [ ] convertToDecimalBytes ( Object obj ) { Object value = obj ; Class clazz = obj . getClass ( ) ; if ( Byte . class . equals ( clazz ) || Short . class . equals ( clazz ) || Integer . class . equals ( clazz ) || Long . class . equals ( clazz ) ) { clazz = Double . class ; Double d = translate ( obj ) ; value = d ; } BaseConverter converter = stdConverters . get ( clazz ) ; if ( converter == null ) throw new IllegalArgumentException ( "Type-not-supported-at-this-time=" + obj . getClass ( ) ) ; return converter . convertToNoSql ( value ) ; } \n', 0.18334698177685804)

('protected BigDecimal convertObjectToNumber ( Object sourceObject ) throws ConversionException { try { if ( sourceObject instanceof String ) { return new BigDecimal ( ( String ) sourceObject ) ; } if ( sourceObject instanceof Number ) { return new BigDecimal ( ( ( Number ) sourceObject ) . doubleValue ( ) ) ; } if ( sourceObject instanceof Boolean ) { if ( ( ( Boolean ) sourceObject ) . booleanValue ( ) ) { return BigDecimal . valueOf ( 1 ) ; } else { return BigDecimal . valueOf ( 0 ) ; } } } catch ( NumberFormatException exception ) { throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . NUMBER , exception ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , ClassConstants . NUMBER ) ; } \n', 0.18214891770087893)

('private static void addNumberToShortConverters ( Map map , NumberFormat numberFormat , Class [ ] fromTypes ) { for ( int i = 0 ; i < fromTypes . length ; i ++ ) { Class fromType = fromTypes [ i ] ; if ( ! fromType . equals ( Short . class ) && ! fromType . equals ( short . class ) ) { String fromName = ( fromType . isPrimitive ( ) ) ? getKeyForClass ( fromType , null ) : fromType . getName ( ) ; map . put ( new Pair ( fromName , SHORT_CLASS ) , new NumberToShortConverter ( numberFormat , fromType , true ) ) ; map . put ( new Pair ( fromName , Short . class . getName ( ) ) , new NumberToShortConverter ( numberFormat , fromType , false ) ) ; } } } \n', 0.17821090343751697)

('private static void addNumberToIntegerConverters ( Map map , NumberFormat numberFormat , Class [ ] fromTypes ) { for ( int i = 0 ; i < fromTypes . length ; i ++ ) { Class fromType = fromTypes [ i ] ; if ( ! fromType . equals ( Integer . class ) && ! fromType . equals ( int . class ) ) { String fromName = ( fromType . isPrimitive ( ) ) ? getKeyForClass ( fromType , null ) : fromType . getName ( ) ; map . put ( new Pair ( fromName , INTEGER_CLASS ) , new NumberToIntegerConverter ( numberFormat , fromType , true ) ) ; map . put ( new Pair ( fromName , Integer . class . getName ( ) ) , new NumberToIntegerConverter ( numberFormat , fromType , false ) ) ; } } } \n', 0.1771390695727295)

('private String convertFromEditableLength ( String string ) throws NumberFormatException { if ( string . length ( ) == 0 ) return string ; for ( int i = 1 ; i < lengthPrefixes . length ; i ++ ) { if ( string . endsWith ( lengthPrefixes [ i ] ) ) { long value = Long . parseLong ( string . substring ( 0 , string . length ( ) - 1 ) ) ; value *= Math . pow ( 1024 , i ) ; return Long . toString ( value ) ; } } return Long . toString ( Long . parseLong ( string ) ) ; } \n', 0.1710906815379612)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 48 #################################
('protected static String convertToMethodSignature ( String methodName , String descriptor , boolean full ) { if ( descriptor . charAt ( 0 ) != \'(\' ) { throw new IllegalArgumentException ( "Can\'t-convert-" + descriptor ) ; } int p = descriptor . lastIndexOf ( \')\' ) ; String params = descriptor . substring ( 1 , p ) ; StringTokenizer tokenizer = new StringTokenizer ( params , ";" ) ; StringBuilder sb = new StringBuilder ( ) ; if ( full ) { String retParam = descriptor . substring ( p + 1 ) ; if ( retParam . endsWith ( ";" ) ) { retParam = retParam . substring ( 0 , retParam . length ( ) - 1 ) ; } String ret = convertParam ( retParam ) ; int r = ret . lastIndexOf ( "." ) ; if ( r > 0 ) { ret = ret . substring ( r + 1 ) ; } sb . append ( ret ) . append ( "-" ) ; } sb . append ( methodName ) . append ( "(" ) ; while ( tokenizer . hasMoreTokens ( ) ) { String param = tokenizer . nextToken ( ) ; sb . append ( convertParam ( param ) ) ; if ( tokenizer . hasMoreTokens ( ) ) { sb . append ( ",-" ) ; } } sb . append ( ")" ) ; return sb . toString ( ) ; } \n', 0.2755374560733284)

('public static < T > T convert ( String from , Class < T > to ) { Class < T > toAsNonPrimitiveType ; if ( from == null ) { return null ; } T t = null ; toAsNonPrimitiveType = Primitives . wrap ( to ) ; if ( toAsNonPrimitiveType . isAssignableFrom ( from . getClass ( ) ) ) { return toAsNonPrimitiveType . cast ( from ) ; } Method converter = CONVERTERS . get ( toAsNonPrimitiveType . getName ( ) ) ; if ( converter == null ) { logger . error ( "No-converter-found-to-convert-{}.-" + "Returning-null.-" + "You-may-want-to-extend-the-class." , toAsNonPrimitiveType ) ; } else { try { t = toAsNonPrimitiveType . cast ( converter . invoke ( toAsNonPrimitiveType , from ) ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException ex ) { logger . error ( "Cannot-convert-from-" + from . getClass ( ) . getName ( ) + "-to-" + toAsNonPrimitiveType . getName ( ) + ".-Conversion-failed-with-" + ex . getMessage ( ) , ex ) ; } } return t ; } \n', 0.2719487610262711)

('public static String convertToGetMethod ( String name ) throws IllegalArgumentException { if ( name == null || name . isEmpty ( ) ) { throw new IllegalArgumentException ( "Name-cannot-be-null-or-empty" ) ; } return "get" + Character . toUpperCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; } \n', 0.26641890802102175)

('public org . omg . CosNaming . NameComponent [ ] convertToNameComponent ( String theStringifiedName ) throws org . omg . CosNaming . NamingContextPackage . InvalidName { String [ ] theStringifiedNameComponents = breakStringToNameComponents ( theStringifiedName ) ; if ( ( theStringifiedNameComponents == null ) || ( theStringifiedNameComponents . length == 0 ) ) { return null ; } NameComponent [ ] theNameComponents = new NameComponent [ theStringifiedNameComponents . length ] ; for ( int i = 0 ; i < theStringifiedNameComponents . length ; i ++ ) { theNameComponents [ i ] = createNameComponentFromString ( theStringifiedNameComponents [ i ] ) ; } return theNameComponents ; } \n', 0.2566612755444992)

('public static < T > T convert ( String from , Class < T > to ) { Class < T > toAsNonPrimitiveType ; if ( from == null ) { return null ; } T t = null ; toAsNonPrimitiveType = Primitives . wrap ( to ) ; if ( toAsNonPrimitiveType . isAssignableFrom ( from . getClass ( ) ) ) { return toAsNonPrimitiveType . cast ( from ) ; } Method converter = CONVERTERS . get ( toAsNonPrimitiveType . getName ( ) ) ; if ( converter == null ) { logger . error ( "No-converter-found-to-convert-{}.-" + "Returning-null.-" + "You-may-want-to-extend-the-class." , toAsNonPrimitiveType ) ; } else { try { t = toAsNonPrimitiveType . cast ( converter . invoke ( toAsNonPrimitiveType , from ) ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException ex ) { logger . error ( "Cannot-convert-from-" + from . getClass ( ) . getName ( ) + "-to-" + toAsNonPrimitiveType . getName ( ) + ".-Conversion-failed-with-" + ex . getMessage ( ) , ex ) ; } } return t ; } \n', 0.25613485124820357)

('public static String convertToSearchMethod ( String name ) throws IllegalArgumentException { if ( name == null || name . isEmpty ( ) ) { throw new IllegalArgumentException ( "Name-cannot-be-null-or-empty" ) ; } return "search" + Character . toUpperCase ( name . charAt ( 0 ) ) + name . substring ( 1 ) ; } \n', 0.2560208155946334)

('public static Object getCharToByteConverter ( String encoding ) { Class charToByteConverterClass = null ; java . lang . reflect . Method getConverterMethod = null ; try { charToByteConverterClass = Class . forName ( "sun.io.CharToByteConverter" ) ; Class argTypes [ ] = new Class [ 1 ] ; argTypes [ 0 ] = String . class ; getConverterMethod = charToByteConverterClass . getMethod ( "getConverter" , argTypes ) ; } catch ( Exception e ) { System . err . println ( "Warning:-Could-not-get-charToByteConverterClass!" ) ; return null ; } Object args [ ] = new Object [ 1 ] ; for ( int i = 0 ; i < _encodings . length ; ++ i ) { if ( _encodings [ i ] . name . equalsIgnoreCase ( encoding ) ) { try { args [ 0 ] = _encodings [ i ] . javaName ; Object converter = getConverterMethod . invoke ( null , args ) ; if ( null != converter ) return converter ; } catch ( Exception iae ) { } } } return null ; } \n', 0.2506318378826762)

('protected QName convertObjectToQName ( Object sourceObject ) throws ConversionException { if ( sourceObject instanceof QName ) { return ( QName ) sourceObject ; } if ( sourceObject instanceof String ) { return qnameFromString ( ( String ) sourceObject ) ; } throw ConversionException . couldNotBeConverted ( sourceObject , Constants . QNAME_CLASS ) ; } \n', 0.24367863769607823)

('private Object attemptToConvertStringToEnum ( Class < ? > requiredType , String trimmedValue , Object currentConvertedValue ) { Object convertedValue = currentConvertedValue ; if ( Enum . class == requiredType ) { int index = trimmedValue . lastIndexOf ( "." ) ; if ( index > - 1 ) { String enumType = trimmedValue . substring ( 0 , index ) ; String fieldName = trimmedValue . substring ( index + 1 ) ; ClassLoader cl = this . targetObject . getClass ( ) . getClassLoader ( ) ; try { Class < ? > enumValueType = ClassUtils . forName ( enumType , cl ) ; Field enumField = enumValueType . getField ( fieldName ) ; convertedValue = enumField . get ( null ) ; } catch ( ClassNotFoundException ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Enum-class-[" + enumType + "]-cannot-be-loaded" , ex ) ; } } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + fieldName + "]-isn\'t-an-enum-value-for-type-[" + enumType + "]" , ex ) ; } } } } if ( convertedValue == currentConvertedValue ) { try { Field enumField = requiredType . getField ( trimmedValue ) ; convertedValue = enumField . get ( null ) ; } catch ( Throwable ex ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( "Field-[" + convertedValue + "]-isn\'t-an-enum-value" , ex ) ; } } } return convertedValue ; } \n', 0.2433637957845509)

('private String convertMethodKeyObject ( final KeyGenerator methodGenerator , final Object keyValue ) { String res = "" ; if ( keyValue instanceof String ) { res = ( String ) keyValue ; } else { try { final List < Method > converterList = ClassUtility . retrieveMethodList ( keyValue . getClass ( ) , methodGenerator . value ( ) ) ; Method converter = null ; for ( final Method m : converterList ) { if ( m . getParameterTypes ( ) . length == 0 ) { converter = m ; } } if ( converter == null ) { LOGGER . log ( METHOD_NOT_FOUND , methodGenerator . value ( ) , keyValue . getClass ( ) . getSimpleName ( ) ) ; } else { final Object localKey = converter . invoke ( keyValue ) ; if ( localKey == null ) { LOGGER . log ( NULL_METHOD_KEY_STRING , converter . getName ( ) , keyValue . getClass ( ) . getSimpleName ( ) ) ; } else { res = localKey . toString ( ) ; } } } catch ( final SecurityException e ) { LOGGER . log ( NO_TOSTRING_KEY_METHOD , methodGenerator . value ( ) , keyValue . getClass ( ) . getSimpleName ( ) , e ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { LOGGER . log ( METHOD_KEY_TOSTRING_FAILURE , methodGenerator . value ( ) , keyValue . getClass ( ) . getSimpleName ( ) , e ) ; } } return res + "|" ; } \n', 0.24289550265638588)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 49 #################################
('private char getPlusOneCharacter ( ) throws LinePositionPointerOutOfBoundaryException { if ( hasNextCharacter ( ) ) { return lineCharacters [ linePosition + 1 ] ; } else throw ( new LinePositionPointerOutOfBoundaryException ( ) ) ; } \n', 0.27647886228430896)

('private ApexCodeLocation getLocationFromStackLine ( String name , String stackTrace ) { if ( Utils . isEmpty ( name ) || Utils . isEmpty ( stackTrace ) ) return null ; String line = null ; String column = null ; try { String [ ] temp = stackTrace . split ( "line" ) ; line = temp [ 1 ] . split ( "," ) [ 0 ] . trim ( ) ; String c = temp [ 1 ] . trim ( ) ; column = c . split ( "column" ) [ 1 ] . trim ( ) ; if ( Utils . isNotEmpty ( column ) && column . contains ( "-" ) ) { column = column . substring ( 0 , column . indexOf ( "-" ) ) ; } } catch ( Exception e ) { } return new ApexCodeLocation ( name , line , column ) ; } \n', 0.26672943681896677)

('public void testGetLinesAndCornersWithSomeRadiusNoMarginAndWidthOfOne ( ) throws Exception { style . setBorderWidth ( "1" ) ; style . setMargin ( "0" ) ; style . setRoundedCornerRadius ( "10" ) ; border = new Border ( style , insideMargin ) ; verifyLine ( border . getTopLine ( ) , 10 , 0 , 89 , 0 ) ; verifyLine ( border . getRightLine ( ) , 99 , 10 , 99 , 189 ) ; verifyLine ( border . getBottomLine ( ) , 89 , 199 , 10 , 199 ) ; verifyLine ( border . getLeftLine ( ) , 0 , 189 , 0 , 10 ) ; verifyArc ( border . getTopRightArc ( ) , 90 , - 90 , 79 , 0 , 20 , 20 ) ; verifyArc ( border . getBottomRightArc ( ) , 0 , - 90 , 79 , 179 , 20 , 20 ) ; verifyArc ( border . getBottomLeftArc ( ) , 270 , - 90 , 0 , 179 , 20 , 20 ) ; verifyArc ( border . getTopLeftArc ( ) , 180 , - 90 , 0 , 0 , 20 , 20 ) ; } \n', 0.2659365218506423)

('private static ApexCodeLocation getLocationFromStackLine ( String name , String stackTrace ) { if ( Utils . isEmpty ( name ) || Utils . isEmpty ( stackTrace ) ) { logger . warn ( "Unable-to-get-location-from-stacktrace---name-and/or-stacktrace-is-null" ) ; return null ; } String line = null ; String column = null ; try { String [ ] temp = stackTrace . split ( "line" ) ; line = temp [ 1 ] . split ( "," ) [ 0 ] . trim ( ) ; String c = temp [ 1 ] . trim ( ) ; column = c . split ( "column" ) [ 1 ] . trim ( ) ; if ( Utils . isNotEmpty ( column ) && column . contains ( "-" ) ) { column = column . substring ( 0 , column . indexOf ( "-" ) ) ; } } catch ( Exception e ) { logger . warn ( "Unable-to-get-location-from-stacktrace" , e ) ; } return new ApexCodeLocation ( name , line , column ) ; } \n', 0.26526074679397)

('public File findPlatformFile ( ) { try { if ( platformFile == null ) { BufferedReader br = new BufferedReader ( new FileReader ( seriesMatrixFile ) ) ; String currentLine ; String platformName = "" ; while ( ( currentLine = br . readLine ( ) ) != null ) { if ( currentLine . contains ( "!Series_platform_id" ) ) { platformName = currentLine . substring ( currentLine . indexOf ( "G" ) , currentLine . lastIndexOf ( """ ) ) ; break ; } } platformFile = new File ( directory , platformName ) ; } if ( ! platformFile . exists ( ) ) { String URLname = "http://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?targ=self&" + "form=text&view=data&acc=" + platformFile . getName ( ) ; Download . downlaodTextFile ( URLname , platformFile . getAbsolutePath ( ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; MessageDialog . openWarning ( main . getShell ( ) , "Download-failed!" , "ChiBE-could-not-download-the-file.-Check-your-parameters." ) ; } return platformFile ; } \n', 0.260307658412106)

('public static void getCurrentLine ( ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; new Throwable ( ) . printStackTrace ( printWriter ) ; String fullInfo = new String ( stringWriter . toString ( ) ) ; String lineNumber = null ; if ( fullInfo . length ( ) == 0 ) { lineNumber = "NA" ; } if ( lineNumber == null ) { int iend = fullInfo . lastIndexOf ( \')\' ) ; int ibegin = fullInfo . lastIndexOf ( \':\' , iend - 1 ) ; if ( ibegin == - 1 ) { lineNumber = "-1" ; } else { lineNumber = fullInfo . substring ( ibegin + 1 , iend ) ; } } System . out . println ( lineNumber ) ; } \n', 0.2434003867020477)

('public static String getStackTraceOnly ( Throwable throwable ) { String stackTrace = getStackTrace ( throwable ) ; int firstLine = stackTrace . indexOf ( STACK_LINE_PREFIX ) ; return ( firstLine == - 1 ) ? "" : stackTrace . substring ( firstLine ) ; } \n', 0.23791197345182072)

('private boolean isStackTraceLineFiltred ( boolean isFirstLine , String line ) { if ( ! isFirstLine && stackTraceFilterAction . isChecked ( ) ) { for ( String pattern : STACK_TRACE_FILTER_PATTERNS ) { if ( pattern . charAt ( pattern . length ( ) - 1 ) == \'*\' ) { pattern = pattern . substring ( 0 , pattern . length ( ) - 1 ) ; } else if ( Character . isUpperCase ( pattern . charAt ( 0 ) ) ) { pattern = "at-" + pattern + \'.\' ; } else { int lastDotIndex = pattern . lastIndexOf ( \'.\' ) ; if ( ( lastDotIndex != - 1 ) && ( lastDotIndex != pattern . length ( ) - 1 ) && Character . isUpperCase ( pattern . charAt ( lastDotIndex + 1 ) ) ) { pattern += \'.\' ; } } if ( line . indexOf ( pattern ) > 0 ) { return true ; } } } return false ; } \n', 0.2351593979412823)

('public String getScriptStackTrace ( FilenameFilter filter ) { List interpreterStack ; Evaluator interpreter = Context . createInterpreter ( ) ; if ( interpreter != null ) interpreterStack = interpreter . getScriptStack ( this ) ; else interpreterStack = new ArrayList ( ) ; int interpreterStackIndex = 0 ; StringBuffer buffer = new StringBuffer ( ) ; String lineSeparator = SecurityUtilities . getSystemProperty ( "line.separator" ) ; StackTraceElement [ ] stack = getStackTrace ( ) ; for ( int i = 0 ; i < stack . length ; i ++ ) { StackTraceElement e = stack [ i ] ; String name = e . getFileName ( ) ; if ( e . getLineNumber ( ) > - 1 && name != null && filter . accept ( null , name ) ) { buffer . append ( "-at-" ) ; buffer . append ( e . getFileName ( ) ) ; buffer . append ( \':\' ) ; buffer . append ( e . getLineNumber ( ) ) ; buffer . append ( lineSeparator ) ; } else if ( interpreterStack != null && "org.mozilla.javascript.Interpreter" . equals ( e . getClassName ( ) ) && "interpretLoop" . equals ( e . getMethodName ( ) ) ) { buffer . append ( interpreterStack . get ( interpreterStackIndex ++ ) ) ; } } return buffer . toString ( ) ; } \n', 0.21862398961078233)

('public String getScriptStackTrace ( FilenameFilter filter ) { List < String > interpreterStack ; Evaluator interpreter = Context . createInterpreter ( ) ; if ( interpreter != null ) interpreterStack = interpreter . getScriptStack ( this ) ; else interpreterStack = new ArrayList < String > ( ) ; int interpreterStackIndex = 0 ; StringBuffer buffer = new StringBuffer ( ) ; String lineSeparator = SecurityUtilities . getSystemProperty ( "line.separator" ) ; StackTraceElement [ ] stack = getStackTrace ( ) ; for ( int i = 0 ; i < stack . length ; i ++ ) { StackTraceElement e = stack [ i ] ; String name = e . getFileName ( ) ; if ( e . getLineNumber ( ) > - 1 && name != null && filter . accept ( null , name ) ) { buffer . append ( "-at-" ) ; buffer . append ( e . getFileName ( ) ) ; buffer . append ( \':\' ) ; buffer . append ( e . getLineNumber ( ) ) ; buffer . append ( lineSeparator ) ; } else if ( interpreterStack != null && "org.mozilla.nb.javascript.Interpreter" . equals ( e . getClassName ( ) ) && "interpretLoop" . equals ( e . getMethodName ( ) ) ) { buffer . append ( interpreterStack . get ( interpreterStackIndex ++ ) ) ; } } return buffer . toString ( ) ; } \n', 0.21848578325355728)

FRank:   | P@1:   | P@5:   | P@10: 

########################## 50 #################################
('public static Map < String , Map < String , String >> convertTripleListToMaps ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , Map < String , String >> results = new HashMap < String , Map < String , String >> ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 3 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 3 ) { String role = list . get ( count ) ; String key = list . get ( count + 1 ) ; String val = list . get ( count + 2 ) ; Map < String , String > roleMap = results . get ( role ) ; if ( roleMap == null ) { roleMap = new HashMap < String , String > ( ) ; results . put ( role , roleMap ) ; } if ( roleMap . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-for-key-" + key + "-under-" + role ) ; } roleMap . put ( key , val ) ; } } return results ; } \n', 0.3923345746619985)

('public static Map < String , String > convertTupleListToMap ( String description , List < String > list ) throws BadCommandArgumentsException { Map < String , String > results = new HashMap < String , String > ( ) ; if ( list != null && ! list . isEmpty ( ) ) { int size = list . size ( ) ; if ( size % 2 != 0 ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_PARSE_FAILURE + description ) ; } for ( int count = 0 ; count < size ; count += 2 ) { String key = list . get ( count ) ; String val = list . get ( count + 1 ) ; if ( results . get ( key ) != null ) { throw new BadCommandArgumentsException ( ErrorStrings . ERROR_DUPLICATE_ENTRY + description + ":-" + key ) ; } results . put ( key , val ) ; } } return results ; } \n', 0.3858308548055216)

('private static List < Object > convertToBytesRefListIfStringList ( Iterable < ? > objs ) { if ( objs == null ) { return null ; } List < Object > newObjs = new ArrayList < > ( ) ; for ( Object obj : objs ) { newObjs . add ( convertToBytesRefIfString ( obj ) ) ; } return newObjs ; } \n', 0.37104133910321274)

('public static List < String > convertToStringList ( ConfigurationSection cs , String key ) { List < String > args = new ArrayList < String > ( ) ; args . add ( key ) ; args . addAll ( convertToStringList ( cs . getString ( key ) ) ) ; return args ; } \n', 0.36839571406356497)

('private static Collection < String > convertJSONArrayToList ( JSONArray jsonArray ) throws JSONException { List < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < jsonArray . length ( ) ; i ++ ) { list . add ( ( String ) jsonArray . get ( i ) ) ; } return list ; } \n', 0.35892636936653144)

('public static List < SQLParams > convertBeansToSqlParams ( List beans , SQLInfo sql , String dbname , int action , Connection con ) throws SQLException { if ( beans == null ) return null ; List < SQLParams > batchparams = new ArrayList < SQLParams > ( beans . size ( ) ) ; for ( Object bean : beans ) { SQLParams params = convertBeanToSqlParams ( bean , sql , dbname , action , con ) ; batchparams . add ( params ) ; } return batchparams ; } \n', 0.35303300137018223)

('private static String convertFromList ( String name , List < ? > list , boolean isProperty ) { String json = null ; if ( list != null && ! list . isEmpty ( ) ) { String format = "[%s]" ; StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( sb . length ( ) > 0 ) { sb . append ( "," ) ; } json = JsonConverter . convertFromKeyValue ( null , list . get ( i ) ) ; if ( json != null ) { sb . append ( json ) ; } } if ( isProperty ) { format = ""%s":[%s]" ; if ( name == null || "" . equals ( name ) ) { name = "list" ; } json = String . format ( format , name , sb . toString ( ) ) ; } else { if ( name != null && ! "" . equals ( name ) ) { format = ""%s":[%s]" ; json = String . format ( format , name , sb . toString ( ) ) ; } else { json = String . format ( format , sb . toString ( ) ) ; } } } return json ; } \n', 0.34975239935852054)

('public static List < Integer > convertStringListToIntList ( List < String > list , String [ ] convertFrom , int [ ] convertTo ) { if ( list == null ) { return null ; } List < Integer > convertedList = new ArrayList < > ( list . size ( ) ) ; for ( String str : list ) { int strIndex = getArrayIndex ( convertFrom , str ) ; if ( strIndex < 0 ) { Log . w ( TAG , "Ignoring-invalid-value-" + str ) ; continue ; } if ( strIndex < convertTo . length ) { convertedList . add ( convertTo [ strIndex ] ) ; } } return convertedList ; } \n', 0.34572162970026465)

('static void convertToMapOfElementProperties ( Map < String , String > map , Map < QName , ElementProperty > elementsMap ) { if ( map != null ) { for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { String key = entry . getKey ( ) ; String value = entry . getValue ( ) ; String text = null ; boolean child = false ; int d = value . indexOf ( \'}\' ) ; d = value . indexOf ( \'=\' , d < 0 ? 0 : d ) ; if ( d > 0 ) { text = value . substring ( d + 1 ) ; value = value . substring ( 0 , d ) ; } if ( key . endsWith ( "/" ) ) { key = key . substring ( 0 , key . length ( ) - 1 ) ; child = true ; } QName lname = DOMUtils . convertStringToQName ( key ) ; QName rname = DOMUtils . convertStringToQName ( value ) ; ElementProperty desc = new ElementProperty ( rname , text , child ) ; elementsMap . put ( lname , desc ) ; } } } \n', 0.34104201134908385)

('private static List < Object > convertToStringListIfBytesRefList ( Iterable < ? > objs ) { if ( objs == null ) { return null ; } List < Object > newObjs = new ArrayList < > ( ) ; for ( Object obj : objs ) { newObjs . add ( convertToStringIfBytesRef ( obj ) ) ; } return newObjs ; } \n', 0.34092621063301676)

FRank:   | P@1:   | P@5:   | P@10: 

Mean sims: 0.3327