########################## 1 #################################
+('public static String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 2048 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , ENCODING ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } String text = writer . toString ( ) ; return text ; } \n', 0.4173901049663673)

+('public static String convertStreamToString ( InputStream is ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( is , Charset . forName ( "UTF-8" ) ) ) ; StringBuilder sb = new StringBuilder ( ) ; int cp ; try { while ( ( cp = reader . read ( ) ) != - 1 ) { sb . append ( ( char ) cp ) ; } } catch ( IOException e ) { debug ( e ) ; } finally { try { is . close ( ) ; } catch ( IOException e ) { debug ( e ) ; } } return sb . toString ( ) ; } \n', 0.4119601648721223)

+('private static String convertFileToString ( InputStream in ) { InputStreamReader input = new InputStreamReader ( in , IoUtils . UTF8_CHARSET ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; OutputStreamWriter output = new OutputStreamWriter ( baos , IoUtils . UTF8_CHARSET ) ; char [ ] buffer = new char [ 4096 ] ; int n = 0 ; try { while ( - 1 != ( n = input . read ( buffer ) ) ) { output . write ( buffer , 0 , n ) ; } output . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return new String ( baos . toByteArray ( ) , IoUtils . UTF8_CHARSET ) ; } \n', 0.41014937054393663)

+('public String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4086881582715446)

+('private static String convertReaderToString ( Reader reader ) throws IOException { if ( reader != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { reader . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.40778385592006827)

+('private String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

+('private String convertStreamToString ( InputStream is ) throws IOException { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

+('public String convertStreamToString ( InputStream is ) { try { if ( is != null ) { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } catch ( IOException e ) { throw new RuntimeException ( "Did-not-expect-this-one..." , e ) ; } } \n', 0.4074249952540185)

+('public String convertStreamToString ( InputStream is ) throws IOException { Writer writer = new StringWriter ( ) ; char [ ] buffer = new char [ 1024 ] ; try { Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } \n', 0.4074249952540185)

+('private static String convertStreamToString ( final InputStream is ) throws IOException { if ( is != null ) { final Writer writer = new StringWriter ( ) ; final char [ ] buffer = new char [ 1024 ] ; try { final Reader reader = new BufferedReader ( new InputStreamReader ( is , "UTF-8" ) ) ; int n ; while ( ( n = reader . read ( buffer ) ) != - 1 ) { writer . write ( buffer , 0 , n ) ; } } finally { is . close ( ) ; } return writer . toString ( ) ; } else { return "" ; } } \n', 0.4074249952540185)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 2 #################################
+('public static < T > List < T > fromArray ( Class < T > clazz , Array array ) throws SQLException { List < T > values = null ; if ( array != null ) { values = new LinkedList < T > ( ) ; ResultSet rs = array . getResultSet ( ) ; while ( rs . next ( ) ) { values . add ( Row . convert ( rs . getObject ( 2 ) , clazz ) ) ; } } return values ; } \n', 0.33456901532235694)

-('private List constructResponseListForDefinedArray ( List definedArrayRequestMapList , String updateValue ) { final List responseList = new ArrayList ( ) ; DefinedArrayRequestBean definedArrayRequestBean = new DefinedArrayRequestBean ( ) ; final Iterator definedArrayRequestMapListItr = definedArrayRequestMapList . iterator ( ) ; int i = 0 ; while ( definedArrayRequestMapListItr . hasNext ( ) ) { final Map defineArrayMap = ( Map ) definedArrayRequestMapListItr . next ( ) ; final Set defineArraySet = defineArrayMap . keySet ( ) ; final Iterator defineArraySetItr = defineArraySet . iterator ( ) ; definedArrayRequestBean = ( DefinedArrayRequestBean ) defineArraySetItr . next ( ) ; final List arrayStatusCollec = definedArrayRequestBean . getArrayStatusList ( ) ; final List newStatusList = this . constructNewStatusList ( arrayStatusCollec ) ; if ( newStatusList . contains ( updateValue ) ) { newStatusList . remove ( updateValue ) ; newStatusList . add ( 0 , updateValue ) ; responseList . add ( i , newStatusList ) ; } else { responseList . add ( i , newStatusList ) ; } i ++ ; } return responseList ; } \n', 0.3302248193584658)

-('public ArrayList < ArrayList < Double >> createTestList ( int num_points , boolean integers , boolean negative ) { ArrayList < ArrayList < Double >> test_list = new ArrayList ( ) ; for ( int i = 0 ; i < num_points ; i ++ ) { ArrayList < Double > temp_arraylist = new ArrayList ( ) ; double temp_val1 = Math . random ( ) * scale_x ; double temp_val2 = Math . random ( ) * scale_y ; if ( integers ) { temp_val1 = Math . floor ( temp_val1 ) ; temp_val2 = Math . floor ( temp_val2 ) ; } if ( negative ) { temp_val1 = temp_val1 * 2 - scale_x ; temp_val2 = temp_val2 * 2 - scale_y ; } temp_arraylist . add ( temp_val1 ) ; temp_arraylist . add ( temp_val2 ) ; test_list . add ( temp_arraylist ) ; } return test_list ; } \n', 0.32433913586832874)

-('private ArrayList < SmsMessage > createMessageListFromRawRecords ( List < SmsRawData > records ) { ArrayList < SmsMessage > messages = new ArrayList < SmsMessage > ( ) ; if ( records != null ) { int count = records . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SmsRawData data = records . get ( i ) ; if ( data != null ) { SmsMessage sms = SmsMessage . createFromEfRecord ( i + 1 , data . getBytes ( ) ) ; if ( sms != null ) { messages . add ( sms ) ; } } } } return messages ; } \n', 0.3216897311826858)

-('private static ArrayList < SmsMessage > createMessageListFromRawRecords ( List < SmsRawData > records ) { ArrayList < SmsMessage > messages = new ArrayList < SmsMessage > ( ) ; if ( records != null ) { int count = records . size ( ) ; for ( int i = 0 ; i < count ; i ++ ) { SmsRawData data = records . get ( i ) ; if ( data != null ) { SmsMessage sms = SmsMessage . createFromEfRecord ( i + 1 , data . getBytes ( ) ) ; if ( sms != null ) { messages . add ( sms ) ; } } } } return messages ; } \n', 0.3216897311826858)

+('public static < T > Iterable < T > fromArray ( T [ ] array ) { return Arrays . asList ( array ) ; } \n', 0.3168052896664495)

+('public static < T > List < T > fromArray ( Class < T > type , T [ ] source ) { return Arrays . asList ( Optional . ofNullable ( source ) . orElse ( ( T [ ] ) Array . newInstance ( type , 0 ) ) ) ; } \n', 0.3154031792211479)

-('public List createIntegerListFromString ( EDataType eDataType , String initialValue ) { if ( initialValue == null ) return null ; List result = new ArrayList ( ) ; for ( StringTokenizer stringTokenizer = new StringTokenizer ( initialValue ) ; stringTokenizer . hasMoreTokens ( ) ; ) { String item = stringTokenizer . nextToken ( ) ; result . add ( ( BigInteger ) XMLTypeFactory . eINSTANCE . createFromString ( XMLTypePackage . Literals . INTEGER , item ) ) ; } return result ; } \n', 0.31496377986000623)

+('private ArrayList < String > arrayToArrayList ( String [ ] array ) { ArrayList < String > arraylist = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { arraylist . add ( array [ i ] ) ; } return arraylist ; } \n', 0.31113449677079336)

-('protected List < MusicIndex > createIndexesFromExpression ( String expr ) { List < MusicIndex > result = new ArrayList < MusicIndex > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( expr , "-" ) ; while ( tokenizer . hasMoreTokens ( ) ) { MusicIndex index = createIndexFromExpression ( tokenizer . nextToken ( ) ) ; result . add ( index ) ; } return result ; } \n', 0.30760946234670805)

FRank: 1  | P@1: 1  | P@5: 1  | P@10: 4

########################## 3 #################################
-('public Iterator entryIterator ( ) { final Iterator iter = keyIterator ( ) ; return new Iterator ( ) { public boolean hasNext ( ) { return iter . hasNext ( ) ; } public Object next ( ) { Object key = iter . next ( ) ; Object value = get ( key ) ; return new Entry ( BeanMap . this , key , value ) ; } public void remove ( ) { throw new UnsupportedOperationException ( "remove()-not-supported-for-BeanMap" ) ; } } ; } \n', 0.372495960953197)

-('public static < K , V > Map < K , V > zipMap ( Iterable < K > keys , Iterable < V > values ) { Map < K , V > retVal = new LinkedHashMap < > ( ) ; Iterator < K > keysIter = keys . iterator ( ) ; Iterator < V > valsIter = values . iterator ( ) ; while ( keysIter . hasNext ( ) ) { final K key = keysIter . next ( ) ; Preconditions . checkArgument ( valsIter . hasNext ( ) , "number-of-values[%s]-less-than-number-of-keys,-broke-on-key[%s]" , retVal . size ( ) , key ) ; retVal . put ( key , valsIter . next ( ) ) ; } Preconditions . checkArgument ( ! valsIter . hasNext ( ) , "number-of-values[%s]-exceeds-number-of-keys[%s]" , retVal . size ( ) + Iterators . size ( valsIter ) , retVal . size ( ) ) ; return retVal ; } \n', 0.3637310354426888)

-('public < Iterators extends Iterator < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , Iterators ... iterators ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList < Map . Entry < Key , Value >> ( ) ; for ( Iterators iterator : iterators ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterator ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3588090109696799)

+('public Iterator < Map . Entry < Object , Object >> entryIterator ( ) { final Iterator < String > iter = keyIterator ( ) ; return new Iterator < Map . Entry < Object , Object >> ( ) { public boolean hasNext ( ) { return iter . hasNext ( ) ; } public Map . Entry < Object , Object > next ( ) { final Object key = iter . next ( ) ; final Object value = get ( key ) ; @ SuppressWarnings ( "unchecked" ) final Map . Entry < Object , Object > tmpEntry = new Entry ( BeanMap . this , key , value ) ; return tmpEntry ; } public void remove ( ) { throw new UnsupportedOperationException ( "remove()-not-supported-for-BeanMap" ) ; } } ; } \n', 0.35830793513541914)

+('public Iterator < Map . Entry < String , Object >> entryIterator ( ) { final Iterator < String > iter = keyIterator ( ) ; return new Iterator < Map . Entry < String , Object >> ( ) { public boolean hasNext ( ) { return iter . hasNext ( ) ; } public Map . Entry < String , Object > next ( ) { String key = iter . next ( ) ; Object value = get ( key ) ; return new Entry ( BeanMap . this , key , value ) ; } public void remove ( ) { throw new UnsupportedOperationException ( "remove()-not-supported-for-BeanMap" ) ; } } ; } \n', 0.3574331347621835)

+('public Iterable < QueryAndLimit > queriesIterable ( ) { return new Iterable < QueryAndLimit > ( ) { @ Override public Iterator < QueryAndLimit > iterator ( ) { return new Iterator < QueryAndLimit > ( ) { private final Iterator < Map . Entry < Query , Integer >> iter = queries . entrySet ( ) . iterator ( ) ; @ Override public boolean hasNext ( ) { return iter . hasNext ( ) ; } @ Override public QueryAndLimit next ( ) { final Map . Entry < Query , Integer > ent = iter . next ( ) ; return new QueryAndLimit ( ent . getKey ( ) , ent . getValue ( ) ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; } \n', 0.35601576975228727)

+('@ SmallTest public void testEntryIterator ( ) throws Exception { HashMap map = new HashMap ( ) ; boolean [ ] slots = new boolean [ 4 ] ; addItems ( map ) ; Iterator iter = map . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { int slot = 0 ; Object entry = iter . next ( ) ; if ( entry . toString ( ) . equals ( "one=1" ) ) slot = 0 ; else if ( entry . toString ( ) . equals ( "two=2" ) ) slot = 1 ; else if ( entry . toString ( ) . equals ( "three=3" ) ) slot = 2 ; else if ( entry . toString ( ) . equals ( "four=4" ) ) slot = 3 ; else fail ( "Unkown-entry-in-hashmap" ) ; if ( slots [ slot ] ) fail ( "entry-returned-more-than-once" ) ; else slots [ slot ] = true ; } assertTrue ( slots [ 0 ] ) ; assertTrue ( slots [ 1 ] ) ; assertTrue ( slots [ 2 ] ) ; assertTrue ( slots [ 3 ] ) ; } \n', 0.3538180547473711)

-('Iter ( ) { m_iterators = new ArrayList < Iterator < T >> ( m_iterables . size ( ) ) ; m_heap = new HeapList < Entry > ( m_iterables . size ( ) - 1 ) ; for ( int i = 0 ; i < m_iterables . size ( ) ; i ++ ) { Iterator < T > iterator = m_iterables . get ( i ) . iterator ( ) ; m_iterators . add ( iterator ) ; m_current = new Entry ( i ) ; moveNext ( ) ; } } \n', 0.35048269068305005)

+('public < T extends Iterable < ? extends Map . Entry < Key , Value >>> MapIntersectionIterator ( Aggregator < Map . Entry < Key , Value > , Result > aggregator , T ... iterables ) { this . aggregator = aggregator ; this . comparator = null ; list = new ArrayList ( iterables . length ) ; for ( T iterable : iterables ) { final MapIntersectionIterator . Entry < Key , Value > entry = new MapIntersectionIterator . Entry < Key , Value > ( size ++ , comparator , iterable . iterator ( ) ) ; if ( entry . current != null ) heap . add ( entry ) ; list . add ( null ) ; } } \n', 0.3500509165733183)

-('private StatusIterator ( Iterator < Snapshot > i ) { m_snapshots = new LinkedList < Pair < Snapshot , Table >> ( ) ; while ( i . hasNext ( ) ) { final Snapshot s = i . next ( ) ; s . iterateTables ( new Snapshot . TableIterator ( ) { @ Override public void next ( Table t ) { m_snapshots . add ( Pair . of ( s , t ) ) ; } } ) ; } m_iter = m_snapshots . iterator ( ) ; } \n', 0.3484864165571492)

FRank: 4  | P@1: 0  | P@5: 2  | P@10: 5

########################## 4 #################################
-('public double randomInRange ( double min , double max ) { double range = max - min ; double scaled = randomNumGenerator_ . nextDouble ( ) * range ; double shifted = scaled + min ; return shifted ; } \n', 0.4206617243953209)

+('public static int randomIntegerInRange ( final int min , final int max ) { return Utils . getRandomGenerator ( ) . nextInt ( max - min + 1 ) + min ; } \n', 0.3934022469170664)

+('public static ArrayList < Integer > generateRandomIntegerList ( int size , int maxValue ) { ArrayList < Integer > randomNumbers = new ArrayList < > ( ) ; SecureRandom numberGenerator = new SecureRandom ( ) ; int currentIndex = 0 ; while ( currentIndex < size ) { randomNumbers . add ( numberGenerator . nextInt ( maxValue ) ) ; currentIndex ++ ; } return randomNumbers ; } \n', 0.38002307367065613)

+('public Position generateRandomMove ( Position initPos ) { List < Position > positions = field . getPossibleSteps ( initPos ) ; int ind = randomGenerator . nextInt ( positions . size ( ) ) ; return positions . get ( ind ) ; } \n', 0.3758404920419783)

+('private DataBag generateRandomSortedSamples ( int numSamples , int max ) throws Exception { Random rand = new Random ( 1000 ) ; List < Tuple > samples = new ArrayList < Tuple > ( ) ; for ( int i = 0 ; i < numSamples ; i ++ ) { Tuple t = tFact . newTuple ( 1 ) ; t . set ( 0 , rand . nextInt ( max ) ) ; samples . add ( t ) ; } Collections . sort ( samples ) ; return new NonSpillableDataBag ( samples ) ; } \n', 0.37559212601017566)

-('private Vector < WeightedPoint > generateRandomWeightedPoints ( int n , Rectangle boundary , Range weightRange , boolean isInteger , boolean isDistinct ) { Vector < WeightedPoint > points = new Vector < WeightedPoint > ( ) ; HashSet < Long > hash = new HashSet < Long > ( ) ; int num = 0 ; while ( true ) { Point point = UniformGenerator . randomPoint ( boundary , isInteger ) ; String keyString = Utils . createKeyString ( point ) ; long hashedKey = MurmurHash . hash64 ( keyString ) ; if ( ! hash . contains ( hashedKey ) || ! isDistinct ) { hash . add ( hashedKey ) ; double weight = 0.0 ; weight = UniformGenerator . randomValue ( weightRange , true ) ; points . add ( new WeightedPoint ( point . getX ( ) , point . getY ( ) , weight ) ) ; num ++ ; if ( num > n ) return points ; } } } \n', 0.37442965257470096)

+('public static short generateFloor ( ArrayList < Short > probabilities ) { Random random = new Random ( ) ; short generatedFloor = - 1 ; short floorProb = ( short ) random . nextInt ( 100 ) ; short lowerBoundOfRange = 0 ; short higherBoundOfRange = 0 ; for ( short i = 0 ; i < numOfFloors ; i ++ ) { higherBoundOfRange = probabilities . get ( i ) ; if ( lowerBoundOfRange <= floorProb && floorProb < higherBoundOfRange ) { generatedFloor = i ; break ; } lowerBoundOfRange = higherBoundOfRange ; } if ( generatedFloor == - 1 ) { System . err . println ( "Starting-floor-not-found." ) ; return - 1 ; } return generatedFloor ; } \n', 0.3726048247500972)

+('public static int [ ] generateRandomArray ( int size , int lowerBound , int upperBound ) { Random generator = new Random ( ) ; int [ ] result = new int [ size ] ; int range ; if ( upperBound - lowerBound > Integer . MAX_VALUE ) { System . err . println ( "Range-of-values-too-large!" ) ; return null ; } else { range = upperBound - lowerBound ; } for ( int i = 0 ; i < size ; i ++ ) { int randVal = generator . nextInt ( range + 1 ) ; randVal += lowerBound ; result [ i ] = randVal ; } return result ; } \n', 0.36892469422286944)

+('public Datum generateRandom ( ) { if ( this . size ( ) == 0 ) return null ; int index = ( new Random ( ) ) . nextInt ( this . size ( ) ) ; Range randomRange = null ; Iterator < Range > iter = this . iterator ( ) ; for ( int i = 0 ; i < index ; i ++ ) iter . next ( ) ; randomRange = iter . next ( ) ; return randomRange . generateRandom ( ) ; } \n', 0.36859561162018445)

+('public Element [ ] generateRandomElements ( int numberOfElements , int range ) { Element [ ] elements = new Element [ numberOfElements ] ; Random random = new Random ( ) ; int max = range , min = 0 ; for ( int i = 0 ; i < numberOfElements ; i ++ ) { int rand = random . nextInt ( max - min + 1 ) + min ; elements [ i ] = new Element ( BigInteger . valueOf ( rand ) , null , null , false ) ; } return elements ; } \n', 0.3669564258859066)

FRank: 2  | P@1: 0  | P@5: 4  | P@10: 8

########################## 5 #################################
-('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.42556612403100647)

+("public static String convertDecimalStringToHexString ( String in ) { int integer = Integer . parseInt ( in ) ; String hexString = Integer . toHexString ( integer ) ; if ( hexString . length ( ) == 1 ) { hexString = '0' + hexString ; } return hexString ; } \n", 0.42457246965468176)

+('private static Object convertStringToPrimitive ( String value , final Class < ? > expectedClz ) throws VoltTypeException { value = value . trim ( ) ; if ( value . equals ( Constants . CSV_NULL ) ) return nullValueForType ( expectedClz ) ; value = value . replaceAll ( "|," , "" ) ; try { if ( expectedClz == long . class ) { return Long . parseLong ( value ) ; } if ( expectedClz == int . class ) { return Integer . parseInt ( value ) ; } if ( expectedClz == short . class ) { return Short . parseShort ( value ) ; } if ( expectedClz == byte . class ) { return Byte . parseByte ( value ) ; } if ( expectedClz == double . class ) { return Double . parseDouble ( value ) ; } } catch ( NumberFormatException nfe ) { } throw new VoltTypeException ( "tryToMakeCompatible:-Unable-to-convert-string-" + value + "-to-" + expectedClz . getName ( ) + "-value-for-target-parameter." ) ; } \n', 0.40751204187907863)

-('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.40614039395713675)

+('private static int [ ] convertStringArrayToIntArray ( String [ ] stringArray ) throws NumberFormatException { if ( stringArray != null ) { int intArray [ ] = new int [ stringArray . length ] ; for ( int i = 0 ; i < stringArray . length ; i ++ ) { intArray [ i ] = Integer . parseInt ( stringArray [ i ] ) ; } return intArray ; } return null ; } \n', 0.4042160832634376)

+('public static int [ ] [ ] stringToInt ( String s ) { int [ ] [ ] temp1 = new int [ s . length ( ) ] [ ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { byte [ ] temp2 = s . getBytes ( ) ; String temp3 = Integer . toBinaryString ( temp2 [ i ] ) ; int [ ] temp4 = new int [ temp3 . length ( ) ] ; for ( int j = 0 ; j < temp4 . length ; j ++ ) { temp4 [ j ] = new Integer ( Character . toString ( temp3 . charAt ( j ) ) ) ; } temp1 [ i ] = temp4 ; } return temp1 ; } \n', 0.4021500358151584)

+('public static int convertToInt ( String str ) throws NumberFormatException { int s , e ; for ( s = 0 ; s < str . length ( ) ; s ++ ) if ( Character . isDigit ( str . charAt ( s ) ) ) break ; for ( e = str . length ( ) ; e > 0 ; e -- ) if ( Character . isDigit ( str . charAt ( e - 1 ) ) ) break ; if ( e > s ) { try { return Integer . parseInt ( str . substring ( s , e ) ) ; } catch ( NumberFormatException ex ) { Log . e ( "convertToInt" , ex ) ; throw new NumberFormatException ( ) ; } } else { throw new NumberFormatException ( ) ; } } \n', 0.3963696699535767)

+('@ Deprecated public static int intFromParseableIntegerString ( String s ) { try { int x = Integer . parseInt ( s ) ; return x ; } catch ( NumberFormatException e ) { return 0 ; } } \n', 0.3934253905027531)

+('public static Integer [ ] convertFromHexStringToInts ( String s ) { int numOfHexStrings = s . length ( ) / 8 + ( s . length ( ) % 8 != 0 ? 1 : 0 ) ; String [ ] strings = new String [ numOfHexStrings ] ; int j = 0 ; System . out . println ( "String-is-" + s ) ; for ( int i = 0 ; i < numOfHexStrings ; i ++ ) { strings [ i ] = s . substring ( j , j + ( s . length ( ) - j < 8 ? s . length ( ) - j : 8 ) ) ; if ( strings [ i ] . length ( ) < 8 ) { String str = "" ; for ( int k = 0 ; k < ( 8 - strings [ i ] . length ( ) ) ; k ++ ) { str += "0" ; } strings [ i ] = str + strings [ i ] ; } System . out . println ( "Made:-" + strings [ i ] ) ; j += 8 ; } Integer [ ] ints = new Integer [ numOfHexStrings ] ; for ( int i = 0 ; i < strings . length ; i ++ ) { BigInteger uncipheredInt = new BigInteger ( strings [ i ] , 16 ) ; ints [ i ] = uncipheredInt . intValue ( ) ; System . out . println ( "::" + Integer . toHexString ( ints [ i ] ) ) ; } return ints ; } \n', 0.3921775618436244)

+('public static int [ ] parseJSONAsIntArray ( String value ) { String [ ] intStrings = value . substring ( 1 , value . length ( ) - 1 ) . split ( "," ) ; int [ ] ints = new int [ intStrings . length ] ; for ( int f = 0 ; f < intStrings . length ; f ++ ) { ints [ f ] = Integer . parseInt ( intStrings [ f ] ) ; } return ints ; } \n', 0.38799050822225345)

FRank: 2  | P@1: 0  | P@5: 3  | P@10: 8

########################## 6 #################################
+('protected static Map < String , String [ ] > readAndInitializeFromInput ( String filePath ) { List < String > discMarkLines = new ArrayList < String > ( ) ; Map < String , String [ ] > discourseMarkers = new HashMap < String , String [ ] > ( ) ; try { discMarkLines = FileUtils . readLines ( new File ( filePath ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( String inputLine : discMarkLines ) { String [ ] markers = inputLine . split ( "||-" ) ; String key = markers [ 0 ] ; String [ ] values = markers [ 1 ] . split ( "-" ) ; discourseMarkers . put ( key , values ) ; System . out . println ( "" ) ; } return discourseMarkers ; } \n', 0.3439359290483235)

+('private void initializeStrings ( ) throws Exception { File stringFile = new File ( "data/strings.dat" ) ; if ( ! stringFile . exists ( ) ) throw new Exception ( "string.dat-was-not-found,-can-not-continue." ) ; FileInputStream inStream = new FileInputStream ( stringFile ) ; ObjectInputStream objStream = new ObjectInputStream ( inStream ) ; grassString = ( String [ ] ) objStream . readObject ( ) ; woodsString = ( String [ ] ) objStream . readObject ( ) ; waterString = ( String [ ] ) objStream . readObject ( ) ; pondString = ( String ) objStream . readObject ( ) ; pondWoodString = ( String ) objStream . readObject ( ) ; exitString = ( String ) objStream . readObject ( ) ; mercDesc = ( String [ ] ) objStream . readObject ( ) ; broadcastString = ( String [ ] ) objStream . readObject ( ) ; objStream . close ( ) ; inStream . close ( ) ; } \n', 0.32748205806251174)

+('public static Map < String , String [ ] > readAndInitializePdtbDimlexFromInput ( String pdtbDimlexinputfilepath ) { List < String > discMarkLines = new ArrayList < String > ( ) ; Map < String , String [ ] > discourseMarkers = new HashMap < String , String [ ] > ( ) ; try { discMarkLines = FileUtils . readLines ( new File ( pdtbDimlexinputfilepath ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } for ( String inputLine : discMarkLines ) { String [ ] markers = inputLine . split ( "||-" ) ; String key = markers [ 0 ] ; String [ ] values = new String [ 2 ] ; values = markers [ 1 ] . split ( "-" , 2 ) ; discourseMarkers . put ( key , values ) ; System . out . println ( "" ) ; } return discourseMarkers ; } \n', 0.3131572023389875)

-('public LinesPanel ( ) throws Exception { Scanner file = new Scanner ( new File ( "input.txt" ) ) ; while ( file . hasNext ( ) ) { Scanner line = new Scanner ( file . nextLine ( ) ) ; Integer [ ] arr = new Integer [ 7 ] ; while ( line . hasNext ( ) ) { for ( int i = 0 ; i < 7 ; i ++ ) { arr [ i ] = line . nextInt ( ) ; } } linesArrayList . add ( arr ) ; } file . close ( ) ; } \n', 0.3001092323576109)

-('public static double [ ] loadMatrix ( File file , String separator ) throws IOException { BufferedReader in = null ; try { in = new BufferedReader ( new FileReader ( file ) ) ; String line ; List < String [ ] > lines = new ArrayList < > ( ) ; while ( ( line = in . readLine ( ) ) != null ) { lines . add ( line . split ( separator ) ) ; if ( lines . get ( lines . size ( ) - 1 ) . length != lines . get ( 0 ) . length ) { throw new IOException ( "Invalid-matrix!" ) ; } } double [ ] result = new double [ lines . size ( ) * lines . get ( 0 ) . length ] ; int k = 0 ; for ( String [ ] row : lines ) { for ( int j = 0 ; j < row . length ; j ++ ) { result [ k ++ ] = Double . valueOf ( row [ j ] . trim ( ) ) ; } } return result ; } finally { if ( in != null ) { in . close ( ) ; } } } \n', 0.2995084045709868)

+('private void importConfig ( ) throws Exception { final BufferedReader read = new BufferedReader ( new FileReader ( this . config ) ) ; String line ; final List < String [ ] > lines = new ArrayList < String [ ] > ( ) ; while ( ( line = read . readLine ( ) ) != null ) { lines . add ( line . split ( Pattern . quote ( "-" ) ) ) ; } read . close ( ) ; for ( int i = 0 ; i < lines . size ( ) ; i ++ ) { if ( lines . get ( i ) . length == 1 ) { if ( lines . get ( i ) [ 0 ] . isEmpty ( ) ) { continue ; } else { final List < String [ ] > dataContent = new ArrayList < String [ ] > ( ) ; int j = i ; j ++ ; while ( ! lines . get ( j ) [ 0 ] . isEmpty ( ) ) { j ++ ; if ( lines . size ( ) <= j ) { break ; } if ( lines . get ( j ) != null ) { dataContent . add ( lines . get ( j ) ) ; } if ( lines . size ( ) <= j + 1 || lines . get ( j + 1 ) . length == 0 ) { j ++ ; break ; } } this . data . put ( lines . get ( i ) [ 0 ] , dataContent ) ; i = j ; } } else { throw new IllegalArgumentException ( "Fehlerhafte-Konfigurationsdatei." ) ; } } } \n', 0.2981311463555627)

-("protected boolean parseGlobalOptionsLine ( final ParserData parserData , final String line , int lineNumber ) throws ParsingException { final HashMap < ParserType , String [ ] > variableMap = getLineVariables ( parserData , line , lineNumber , '[' , ']' , ',' , false ) ; if ( ( variableMap . size ( ) > 1 && variableMap . containsKey ( ParserType . NONE ) ) || ( variableMap . size ( ) > 0 && ! variableMap . containsKey ( ParserType . NONE ) ) ) { throw new ParsingException ( format ( ProcessorConstants . ERROR_RELATIONSHIP_BASE_LEVEL_MSG , lineNumber , line ) ) ; } String [ ] variables = variableMap . get ( ParserType . NONE ) ; if ( variables . length > 0 ) { addOptions ( parserData , parserData . getCurrentLevel ( ) , variables , 0 , line , lineNumber ) ; } else { log . warn ( format ( ProcessorConstants . WARN_EMPTY_BRACKETS_MSG , lineNumber ) ) ; } return true ; } \n", 0.2942491769693404)

+('public static void initialize ( String aFileName , boolean aAppend , String [ ] aSourceNames , String [ ] aActionCodeNames ) throws IOException { ServerConfigurationManager theSCM = ServerConfigurationManager . getInstance ( ) ; enabled = theSCM . getProperty ( ServerConfigurationManager . MAUI_PROFILE_ENABLE ) . equals ( "true" ) ; if ( enabled ) { logStream = new PrintStream ( new FileOutputStream ( aFileName , aAppend ) ) ; sourceNames = ( String [ ] ) aSourceNames . clone ( ) ; actionCodeNames = ( String [ ] ) aActionCodeNames . clone ( ) ; runtime = Runtime . getRuntime ( ) ; for ( int i = 0 ; i < profileEntries . length ; i ++ ) { profileEntries [ i ] = new ProfileEntry ( ) ; } logStream . println ( "Sequence,Source,Action,Millis,Mem-Change,In-Use,-Comment" ) ; } } \n', 0.29046512165467275)

+('public void setMultiLines ( int [ ] aList ) { if ( ( aList == null ) || ( aList . length == 0 ) ) { mMultiLines = EMPTY_INT_ARRAY ; return ; } mMultiLines = new int [ aList . length ] ; System . arraycopy ( aList , 0 , mMultiLines , 0 , aList . length ) ; Arrays . sort ( mMultiLines ) ; } \n', 0.2867949884307634)

-('void importContents ( Object contents ) { Object [ ] array = ( Object [ ] ) contents ; this . name = ( String ) array [ 0 ] ; this . output . clear ( ) ; Object [ ] output = ( Object [ ] ) array [ 1 ] ; for ( int i = 0 ; i < output . length ; i += 2 ) { Output o = new Output ( ( String ) output [ i ] ) ; String [ ] props = ( String [ ] ) output [ i + 1 ] ; for ( int p = 0 ; p < props . length ; p += 2 ) { o . setProperty ( props [ p ] , props [ p + 1 ] ) ; } this . output . add ( o ) ; } String [ ] properties = ( String [ ] ) array [ 2 ] ; for ( int i = 0 ; i < properties . length ; i += 2 ) this . properties . put ( properties [ i ] , properties [ i + 1 ] ) ; Object [ ] inputRef = ( Object [ ] ) array [ 3 ] ; if ( inputRef [ 0 ] != null ) { input = new Input ( ( Integer ) inputRef [ 0 ] ) ; String [ ] props = ( String [ ] ) output [ 1 ] ; for ( int p = 0 ; p < props . length ; p += 2 ) { input . setProperty ( props [ p ] , props [ p + 1 ] ) ; } } } \n', 0.2839789567087452)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 6

########################## 7 #################################
+('public static final < X > boolean doesArrayContainValue ( X [ ] array , X valueToTest ) { return Arrays . asList ( array ) . contains ( valueToTest ) ; } \n', 0.37850046472556786)

+('public static boolean arrContains ( String [ ] strArray , String value ) { if ( ( strArray != null ) && ( value != null ) ) return Arrays . asList ( strArray ) . contains ( value ) ; return false ; } \n', 0.35241011243361187)

+('public static boolean arrayContains ( Object [ ] array , Object el ) { return Arrays . asList ( array ) . contains ( el ) ; } \n', 0.29510533632084557)

-('private int strictlyContainsHelper ( Sequence sequence2 , int index , int index2 , long previousTimeStamp , long previousTimeStamp2 ) { if ( index == size ( ) ) { return 0 ; } if ( size ( ) - index < sequence2 . size ( ) - index2 ) { return 0 ; } int returnValue = 0 ; for ( int i = index ; i < size ( ) ; i ++ ) { long interval1 = get ( i ) . getTimestamp ( ) - previousTimeStamp ; long interval2 = sequence2 . get ( index2 ) . getTimestamp ( ) - previousTimeStamp2 ; if ( get ( i ) . getItems ( ) . containsAll ( sequence2 . get ( index2 ) . getItems ( ) ) && interval1 == interval2 ) { boolean sameSize = get ( i ) . getItems ( ) . size ( ) == sequence2 . get ( index2 ) . size ( ) ; if ( sequence2 . size ( ) - 1 == index2 ) { if ( sameSize ) { return 2 ; } returnValue = 1 ; } else { int resultat = strictlyContainsHelper ( sequence2 , i + 1 , index2 + 1 , get ( i ) . getTimestamp ( ) , sequence2 . get ( index2 ) . getTimestamp ( ) ) ; if ( resultat == 2 && sameSize ) { return 2 ; } else if ( resultat != 0 ) { returnValue = 1 ; } } } } return returnValue ; } \n', 0.29455696242498286)

-('@ SafeVarargs static < T > T [ ] checkArrayForNullsAndCopy ( String parameterName , T ... a ) { return checkArrayForNulls ( parameterName , Arrays . copyOf ( a , a . length ) ) ; } \n', 0.2916791091474027)

+('public static < T > boolean arrayContains ( T [ ] array , T item ) { return Arrays . asList ( array ) . contains ( item ) ; } \n', 0.2898006583058562)

-('public void testSetNullValueArray ( ) throws Exception { testNode . setProperty ( propertyName2 , vArrayNull ) ; superuser . save ( ) ; assertEquals ( "Node.setProperty(String,-nullValueArray[])-did-not-set-the-property-to-an-empty-Value[]" , Arrays . asList ( new Value [ 0 ] ) , Arrays . asList ( testNode . getProperty ( propertyName2 ) . getValues ( ) ) ) ; } \n', 0.2872064758154088)

-('protected Object [ ] getTestValues ( final Class < ? > valueType ) { final Object [ ] values = CLASS_TO_VALUES . get ( valueType ) ; if ( values == null ) { if ( valueType . isEnum ( ) ) { final Object [ ] enumConsts = valueType . getEnumConstants ( ) ; final List < Object > consts = new ArrayList < Object > ( enumConsts . length + 1 ) ; consts . addAll ( Arrays . asList ( enumConsts ) ) ; consts . add ( null ) ; return consts . toArray ( ) ; } return EMPTY_ARRAY ; } return values ; } \n', 0.284871646419247)

+('public static boolean contains ( Object arrOrColl , Object value ) { if ( arrOrColl instanceof Object [ ] ) { Object [ ] arr = ( Object [ ] ) arrOrColl ; return Arr . indexOf ( arr , value ) >= 0 ; } else if ( arrOrColl instanceof Collection < ? > ) { Collection < ? > coll = ( Collection < ? > ) arrOrColl ; return coll . contains ( value ) ; } else { throw U . illegalArg ( "Expected-array-or-collection,-but-found:-%s" , U . readable ( arrOrColl ) ) ; } } \n', 0.28250143260802285)

-('public void testSetNullValueArrayWithPropertyType ( ) throws Exception { testNode . setProperty ( propertyName2 , vArrayNull , PropertyType . STRING ) ; superuser . save ( ) ; assertEquals ( "Node.setProperty(String,-nullValueArray[],-int)-did-not-set-the-property-to-an-empty-Value[]" , Arrays . asList ( new Value [ 0 ] ) , Arrays . asList ( testNode . getProperty ( propertyName2 ) . getValues ( ) ) ) ; } \n', 0.2824749806918566)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 5

########################## 8 #################################
-('public String lookupEnumString ( int e ) { String result = map . get ( e ) ; return ( result == null ) ? "Unknown-enum-value=" + e : result ; } \n', 0.4212740360120386)

+('public static AccountAcTypeEnum lookupEnum ( String value ) { return AccountAcTypeEnum . valueMap . get ( value ) ; } \n', 0.3833591515632784)

+('public EnumDeclaration lookupEnum ( String name ) { return enums . get ( name ) ; } \n', 0.38039641014024483)

+('public EnumDeclaration lookupEnum ( String name ) { return fEnums . get ( name ) ; } \n', 0.3652057133615579)

+('public EnumDeclaration lookupEnum ( String name ) { return enums . get ( name ) ; } \n', 0.3652057133615579)

+('public static < T extends Enum < ? >> T lookupEnum ( String name , Class < T > vocab ) { if ( Strings . isNullOrEmpty ( name ) ) { return null ; } final String normedType = name . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; T [ ] values = vocab . getEnumConstants ( ) ; if ( values != null ) { for ( T val : values ) { final String normedVal = val . name ( ) . toUpperCase ( ) . replaceAll ( "[.-_-]" , "" ) ; if ( normedType . equals ( normedVal ) ) { return val ; } } } throw new IllegalArgumentException ( "Cannot-parse-" + name + "-into-a-known-" + vocab . getSimpleName ( ) ) ; } \n', 0.36052107724200017)

+('public static CustomerTransactionDrcrEnum lookupEnum ( String value ) { return CustomerTransactionDrcrEnum . valueMap . get ( value ) ; } \n', 0.35365953040330067)

+('public < T extends Enum < T >> T lookupEnum ( Class < T > type , String name ) { if ( type == null ) { throw new IllegalArgumentException ( "type-must-not-be-null" ) ; } if ( name == null ) { throw new IllegalArgumentException ( "name-must-not-be-null" ) ; } Map < String , Enum < ? >> map = getEnumRenames ( type ) ; Enum < ? > value = map . get ( name ) ; if ( value != null ) { return type . cast ( value ) ; } return Enum . valueOf ( type , name ) ; } \n', 0.3420321486222323)

+('public static < E extends Enum < E >> E lookup ( Class < E > clazz , String name , E defaultValue ) { try { return Enum . valueOf ( clazz , name ) ; } catch ( IllegalArgumentException e ) { return defaultValue ; } } \n', 0.33707134385058696)

-('public static Object lookupDeepAttributeProperty ( Object value , String propertyPath ) { if ( value == null ) return null ; String [ ] ps = propertyPath . split ( "|." , 2 ) ; String searchProperty = ps [ 0 ] ; if ( value instanceof CompositeData ) { CompositeData compositeData = ( ( CompositeData ) value ) ; if ( compositeData . containsKey ( searchProperty ) ) { value = compositeData . get ( searchProperty ) ; } else { LOG . debug ( "Unable-to-read-attribute-property-[" + propertyPath + "]-from-composite-data-value" ) ; } } else { try { PropertyDescriptor [ ] pds = Introspector . getBeanInfo ( value . getClass ( ) ) . getPropertyDescriptors ( ) ; for ( PropertyDescriptor pd : pds ) { if ( pd . getName ( ) . equals ( searchProperty ) ) { value = pd . getReadMethod ( ) . invoke ( value ) ; } } } catch ( Exception e ) { LOG . debug ( "Unable-to-read-property-from-measurement-attribute-[" + searchProperty + "]-not-found-on-[" + ( ( value != null ) ? value . getClass ( ) . getSimpleName ( ) : "null" ) + "]" ) ; } } if ( ps . length > 1 ) { value = lookupDeepAttributeProperty ( value , ps [ 1 ] ) ; } return value ; } \n', 0.3353788305956961)

FRank: 2  | P@1: 0  | P@5: 4  | P@10: 8

########################## 9 #################################
-('public synchronized Map < URI , Set < URI >> getReachableLeaves ( ) { if ( cache . reachableLeaves . isEmpty ( ) ) { Map < URI , Set < URI >> leaves = descGetter . getTerminalVertices ( ) ; for ( URI c : classes ) { if ( ! leaves . containsKey ( c ) ) { Set < URI > s = new HashSet < URI > ( ) ; s . add ( c ) ; leaves . put ( c , s ) ; } } cache . reachableLeaves = leaves ; } return Collections . unmodifiableMap ( cache . reachableLeaves ) ; } \n', 0.3120309986436244)

-('public static String [ ] explodeIntoTerminatedSentences ( String s ) { ArrayList < String > list = new ArrayList < String > ( ) ; int termination = getTerminatedIndex ( s ) ; while ( termination != - 1 ) { list . add ( s . substring ( 0 , termination ) ) ; s = s . substring ( termination ) ; termination = getTerminatedIndex ( s ) ; } if ( ! s . equals ( "" ) ) list . add ( s ) ; return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; } \n', 0.3033854746206164)

-('private NestedLoops ( final Vector2D [ ] loop ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; surrounded = new ArrayList < NestedLoops > ( ) ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( previous ) . getX ( ) , line . toSubSpace ( current ) . getX ( ) ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.3025557593544445)

-('public void visitWhileLoop ( JCWhileLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || ! tree . cond . type . isTrue ( ) ; } \n', 0.29932897137891834)

-('private void removeLoopWithExitNode ( Map < CfgBlock , Set < CfgBlock >> loops , CfgBlock header , Set < CfgBlock > body , CfgBlock headerExitBlock ) { CfgBlock headerClone = null ; for ( CfgBlock b : new HashSet < CfgBlock > ( body ) ) { if ( method . containsEdge ( b , header ) ) { method . removeEdge ( method . getEdge ( b , header ) ) ; if ( headerClone == null ) { headerClone = header . deepCopy ( ) ; addBlockToLoops ( header , headerClone , loops ) ; method . addEdge ( headerClone , headerExitBlock ) ; } method . addEdge ( b , headerClone ) ; } } } \n', 0.29077522927152594)

-('protected int incrementLoopExitRepeatition ( Stmt stmt ) { int value = this . getLoopExitRepeatition ( stmt ) ; this . loopExitToRepeatitionMap . put ( stmt , ++ value ) ; return value ; } \n', 0.2897714675806873)

-('public void visitForLoop ( JCForLoop tree ) { ListBuffer < PendingExit > prevPendingExits = pendingExits ; boolean prevLoopPassTwo = loopPassTwo ; int nextadrPrev = nextadr ; scanStats ( tree . init ) ; Bits initsCond ; Bits uninitsCond ; pendingExits = new ListBuffer < PendingExit > ( ) ; int prevErrors = log . nerrors ; do { Bits uninitsEntry = uninits . dup ( ) ; uninitsEntry . excludeFrom ( nextadr ) ; if ( tree . cond != null ) { scanCond ( tree . cond ) ; initsCond = initsWhenFalse ; uninitsCond = uninitsWhenFalse ; inits = initsWhenTrue ; uninits = uninitsWhenTrue ; alive = ! tree . cond . type . isFalse ( ) ; } else { initsCond = inits . dup ( ) ; initsCond . inclRange ( firstadr , nextadr ) ; uninitsCond = uninits . dup ( ) ; uninitsCond . inclRange ( firstadr , nextadr ) ; alive = true ; } scanStat ( tree . body ) ; alive |= resolveContinues ( tree ) ; scan ( tree . step ) ; if ( log . nerrors != prevErrors || loopPassTwo || uninitsEntry . dup ( ) . diffSet ( uninits ) . nextBit ( firstadr ) == - 1 ) break ; uninits = uninitsEntry . andSet ( uninits ) ; loopPassTwo = true ; alive = true ; } while ( true ) ; loopPassTwo = prevLoopPassTwo ; inits = initsCond ; uninits = uninitsCond ; alive = resolveBreaks ( tree , prevPendingExits ) || tree . cond != null && ! tree . cond . type . isTrue ( ) ; nextadr = nextadrPrev ; } \n', 0.2855659496454257)

-('public static String unifyLineBreaksToConfiguredLineBreaks ( String s ) { return LINE_BREAKS . matcher ( s ) . replaceAll ( Globals . NEWLINE ) ; } \n', 0.28545385927318456)

-('private NestedLoops ( final Vector2D [ ] loop , final double tolerance ) throws MathIllegalArgumentException { if ( loop [ 0 ] == null ) { throw new MathIllegalArgumentException ( LocalizedFormats . OUTLINE_BOUNDARY_LOOP_OPEN ) ; } this . loop = loop ; this . surrounded = new ArrayList < NestedLoops > ( ) ; this . tolerance = tolerance ; final ArrayList < SubHyperplane < Euclidean2D >> edges = new ArrayList < SubHyperplane < Euclidean2D >> ( ) ; Vector2D current = loop [ loop . length - 1 ] ; for ( int i = 0 ; i < loop . length ; ++ i ) { final Vector2D previous = current ; current = loop [ i ] ; final Line line = new Line ( previous , current , tolerance ) ; final IntervalsSet region = new IntervalsSet ( line . toSubSpace ( ( Point < Euclidean2D > ) previous ) . getX ( ) , line . toSubSpace ( ( Point < Euclidean2D > ) current ) . getX ( ) , tolerance ) ; edges . add ( new SubLine ( line , region ) ) ; } polygon = new PolygonsSet ( edges , tolerance ) ; if ( Double . isInfinite ( polygon . getSize ( ) ) ) { polygon = new RegionFactory < Euclidean2D > ( ) . getComplement ( polygon ) ; originalIsClockwise = false ; } else { originalIsClockwise = true ; } } \n', 0.28483742870821604)

-('public Collection < Stmt > targetsOfLoopExit ( Stmt loopExit ) { assert getLoopExits ( ) . contains ( loopExit ) ; List < Unit > succs = g . getSuccsOf ( loopExit ) ; Collection < Stmt > res = new HashSet < Stmt > ( ) ; for ( Unit u : succs ) { Stmt s = ( Stmt ) u ; res . add ( s ) ; } res . removeAll ( loopStatements ) ; return res ; } \n', 0.2844463027336429)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 10 #################################
+('public void createSumArrayPut ( long term , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( term ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.27748677358546037)

+('public static Bodies [ ] createArrays ( Vector allBodies ) { Bodies [ ] array = new Bodies [ allBodies . size ( ) ] ; allBodies . copyInto ( array ) ; for ( int i = 0 ; i < array . length ; i ++ ) array [ i ] . createArrays ( ) ; return array ; } \n', 0.26676445164995854)

+('public void createSumArrayPut ( long word , float [ ] sumArray ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( sumArray . length * 4 ) ; for ( float f : sumArray ) { buffer . putFloat ( f ) ; } buffer . flip ( ) ; byte [ ] rowkey = Bytes . toBytes ( word ) ; Put p = new Put ( rowkey ) ; p . add ( SUMARRAYS , SUMARRAYS , buffer . array ( ) ) ; puts . add ( p ) ; } \n', 0.262212797449038)

-('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final int initialCapacity ) { return Util . makeArrayList ( initialCapacity ) ; } \n', 0.25944119104017654)

+('public static Value [ ] makeSerialValueArray ( Value [ ] values ) throws RepositoryException { List < Value > serials = new ArrayList < Value > ( ) ; if ( values != null ) { for ( Value value : values ) { if ( value != null ) { serials . add ( makeSerialValue ( value ) ) ; } } } return serials . toArray ( new Value [ serials . size ( ) ] ) ; } \n', 0.24640378375203076)

+('protected void enlargeArrays ( ) { if ( keyStart == null ) { int initialSize = 2 ; keyStart = new int [ initialSize ] ; keyEnd = new int [ initialSize ] ; valueLength = new int [ initialSize ] ; keyObjects = new LazyPrimitive < ? , ? > [ initialSize ] ; valueObjects = new LazyObject [ initialSize ] ; keyInited = new boolean [ initialSize ] ; valueInited = new boolean [ initialSize ] ; } else { keyStart = Arrays . copyOf ( keyStart , keyStart . length * 2 ) ; keyEnd = Arrays . copyOf ( keyEnd , keyEnd . length * 2 ) ; valueLength = Arrays . copyOf ( valueLength , valueLength . length * 2 ) ; keyObjects = Arrays . copyOf ( keyObjects , keyObjects . length * 2 ) ; valueObjects = Arrays . copyOf ( valueObjects , valueObjects . length * 2 ) ; keyInited = Arrays . copyOf ( keyInited , keyInited . length * 2 ) ; valueInited = Arrays . copyOf ( valueInited , valueInited . length * 2 ) ; } } \n', 0.24355217246651892)

+('public static Value [ ] makeSerialValueArray ( String [ ] values ) { List < Value > serials = new ArrayList < Value > ( ) ; if ( values != null ) { for ( String value : values ) { if ( value != null ) { serials . add ( INSTANCE . createValue ( value ) ) ; } } } return serials . toArray ( new Value [ serials . size ( ) ] ) ; } \n', 0.24135246763680945)

-('public static < T > T [ ] createArray ( int size , T initialValue , T [ ] dummyArray ) { return ( Collections . nCopies ( size , initialValue ) ) . toArray ( dummyArray ) ; } \n', 0.22347223210421047)

-('static public Array makeArray ( DataType dtype , String [ ] stringValues ) throws NumberFormatException { return makeArray ( dtype , Arrays . asList ( stringValues ) ) ; } \n', 0.2231692498110817)

+('public static Object createArray ( Class < ? > clazz , JsonValue jsonArray ) throws JsonException { Object array = null ; if ( jsonArray != null && ! jsonArray . isNull ( ) ) { Class < ? > componentType = clazz . getComponentType ( ) ; array = Array . newInstance ( componentType , jsonArray . size ( ) ) ; Iterator < JsonValue > values = jsonArray . getElements ( ) ; int i = 0 ; if ( componentType . isArray ( ) ) { if ( JsonUtils . isKnownType ( componentType ) ) { while ( values . hasNext ( ) ) { JsonValue v = values . next ( ) ; Array . set ( array , i ++ , createObjectKnownTypes ( componentType , v ) ) ; } } else { while ( values . hasNext ( ) ) { JsonValue v = values . next ( ) ; Array . set ( array , i ++ , createArray ( componentType , v ) ) ; } } } else { if ( JsonUtils . isKnownType ( componentType ) ) { while ( values . hasNext ( ) ) { JsonValue v = values . next ( ) ; Array . set ( array , i ++ , createObjectKnownTypes ( componentType , v ) ) ; } } else { while ( values . hasNext ( ) ) { JsonValue v = values . next ( ) ; Array . set ( array , i ++ , createObject ( componentType , v ) ) ; } } } } return array ; } \n', 0.22288449577657993)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 7

########################## 11 #################################
+('public static String getRandomAlphanumericString ( int length ) { StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( randomAlphaNumericCharacters [ random . nextInt ( randomAlphaNumericCharacters . length ) ] ) ; } return sb . toString ( ) ; } \n', 0.43253386353057166)

+('public static String randomAlphanumeric ( final int count ) { final StringBuilder strBuilder = new StringBuilder ( count ) ; final int anLen = ALPHA_NUMERIC . length ( ) ; synchronized ( RANDOM ) { for ( int i = 0 ; i < count ; i ++ ) { strBuilder . append ( ALPHA_NUMERIC . charAt ( RANDOM . nextInt ( anLen ) ) ) ; } } return strBuilder . toString ( ) ; } \n', 0.41674771402906596)

+('public static String generateRandomNumericString ( String prefix , int min , int max ) { StringBuilder sb = new StringBuilder ( ) ; if ( prefix != null ) sb . append ( prefix ) ; int len = min + sRandom . nextInt ( max - min + 1 ) ; for ( int i = 0 ; i < len ; i ++ ) sb . append ( sRandom . nextInt ( 10 ) ) ; return sb . toString ( ) ; } \n', 0.41424250381613736)

+('public String getNumericRandomString ( final int stringLength ) throws NoSuchAlgorithmException , NoSuchProviderException , IllegalArgumentException { final StringBuffer numericRandom = new StringBuffer ( ) ; if ( stringLength < 1 ) throw new IllegalArgumentException ( "stringLength-should-be-a-positive-integer" ) ; final SecureRandom randomGenerator = this . getRandomGenerator ( ) ; for ( int i = 0 ; i < stringLength ; i ++ ) numericRandom . append ( String . valueOf ( randomGenerator . nextInt ( PSEUDO_RANDOM_MAX ) ) ) ; return numericRandom . toString ( ) ; } \n', 0.4138117141657082)

+('public static String getRandomAlphaNumericalString ( final int length , final String additionalCharacters ) { String characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" + additionalCharacters ; Random random = new Random ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { int nextInt = random . nextInt ( characters . length ( ) ) ; char nextChar = characters . charAt ( nextInt ) ; sb . append ( nextChar ) ; } return sb . toString ( ) ; } \n', 0.41099424917786326)

+('public static String randomNumeric ( int length ) { StringBuilder sb = new StringBuilder ( ) ; Random random = new Random ( ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( allNumericChars . charAt ( random . nextInt ( allNumericChars . length ( ) ) ) ) ; } return sb . toString ( ) ; } \n', 0.4094911305866397)

+('public static String generateRandomAlphabetsString ( int length ) { Random rd = new Random ( ) ; String aphaNumericString = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( aphaNumericString . charAt ( rd . nextInt ( aphaNumericString . length ( ) ) ) ) ; } return sb . toString ( ) ; } \n', 0.4086226119352353)

+('public static String generateRandomAlphaNumericString ( int length ) { Random rd = new Random ( ) ; String aphaNumericString = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { sb . append ( aphaNumericString . charAt ( rd . nextInt ( aphaNumericString . length ( ) ) ) ) ; } return sb . toString ( ) ; } \n', 0.39558038867971834)

+('public static String generateRandomString ( short type , int length , boolean initialCaps ) { int min = type == TYPE_LOWER_ONLY ? 26 : 0 ; int max = type == TYPE_UPPER_ONLY ? 26 : alphas . length ; String generated = "" ; for ( int i = 0 ; i < length ; i ++ ) { int random = rnd . nextInt ( max - min ) + min ; generated += alphas [ random ] ; } generated = initialCaps ? ( "" + generated . charAt ( 0 ) ) . toUpperCase ( ) + generated . substring ( 1 ) : generated ; return generated ; } \n', 0.39295379022846666)

+('public static String generateRandomNumericString ( int len , boolean unique ) { int maxLen = Math . min ( len , 1000 ) ; StringBuffer sb = null ; if ( unique ) { do { sb = new StringBuffer ( maxLen ) ; for ( int i = 0 ; i < maxLen ; i ++ ) { sb . append ( generator . nextInt ( 10 ) ) ; } } while ( set . contains ( sb . toString ( ) ) ) ; set . add ( sb . toString ( ) ) ; } else { sb = new StringBuffer ( maxLen ) ; for ( int i = 0 ; i < maxLen ; i ++ ) { sb . append ( generator . nextInt ( 10 ) ) ; } } return sb . toString ( ) ; } \n', 0.3903572547515909)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 12 #################################
-('public static String printArray ( byte [ ] array ) { return printArray ( array , false ) ; } \n', 0.34633338623158627)

+('public void printBitArrays ( ) { for ( ArrayList < Integer > bitArray : bitArrays ) { for ( Integer bit : bitArray ) { System . out . print ( bit . intValue ( ) ) ; } System . out . println ( ) ; } } \n', 0.33993759585503436)

-('public static final String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

-('public static String printArray ( Object [ ] obj , boolean braces ) { return printArray ( obj , braces , false ) ; } \n', 0.3343599429169632)

-('public static final String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

-('public static String printArray ( Object [ ] obj ) { return printArray ( obj , true ) ; } \n', 0.3265409947067068)

-('private void printArrayProperty ( final StringBuffer sb , final String prefix , final Object array ) { final int length = Array . getLength ( array ) ; for ( int i = 0 ; i < length ; i ++ ) { final Object obj = Array . get ( array , i ) ; printProperty ( sb , String . format ( "%s[%s]" , prefix , i ) , obj ) ; } } \n', 0.3253721760862642)

+('protected void printObjectArrayContents ( Object objectArrayToPrint ) { Object [ ] arrayToPrint = ( Object [ ] ) objectArrayToPrint ; System . out . print ( "-RESULT:-" ) ; for ( int i = 0 ; i < arrayToPrint . length ; i ++ ) { if ( i > 0 ) { System . out . print ( ",-" ) ; } System . out . print ( arrayToPrint [ i ] ) ; } System . out . println ( "-" ) ; } \n', 0.3253158161385643)

+('public void printIntArray ( int [ ] someArray ) { for ( int i = 0 ; i < someArray . length ; i ++ ) { System . out . print ( String . valueOf ( someArray [ i ] ) + "-" ) ; } System . out . println ( ) ; } \n', 0.31951465703922155)

-('public static void printArray ( int [ ] a ) { printArray ( null , a ) ; } \n', 0.31926721743453024)

FRank: 2  | P@1: 0  | P@5: 1  | P@10: 3

########################## 13 #################################
+('public static < K , V extends Comparable < V >> Map < K , V > sortMapByValues ( final Map < K , V > map ) { Comparator < K > valueComparator = new Comparator < K > ( ) { public int compare ( K k1 , K k2 ) { int compare = map . get ( k2 ) . compareTo ( map . get ( k1 ) ) ; if ( compare == 0 ) return 1 ; else return compare ; } } ; Map < K , V > sortedByValues = new TreeMap < K , V > ( valueComparator ) ; sortedByValues . putAll ( map ) ; return sortedByValues ; } \n', 0.47019823717805165)

+('private static Map sortMapByValues ( Map map ) { List list = new LinkedList ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator ( ) { public int compare ( Object o1 , Object o2 ) { return ( ( ( Map . Entry ) ( o2 ) ) . getValue ( ) == ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ? ( ( Comparable ) ( ( Map . Entry ) ( o1 ) ) . getKey ( ) ) . compareTo ( ( ( Map . Entry ) ( o2 ) ) . getKey ( ) ) : ( ( Comparable ) ( ( Map . Entry ) ( o2 ) ) . getValue ( ) ) . compareTo ( ( ( Map . Entry ) ( o1 ) ) . getValue ( ) ) ; } } ) ; Map sortedMap = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46917912357463765)

+('public static Map < Long , Float > sortMapByValue ( Map < Long , Float > map ) { List < Map . Entry < Long , Float >> list = new LinkedList < Entry < Long , Float >> ( map . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Long , Float >> ( ) { @ Override public int compare ( Map . Entry < Long , Float > o1 , Map . Entry < Long , Float > o2 ) { if ( o1 . getValue ( ) <= o2 . getValue ( ) ) { return 1 ; } else { return - 1 ; } } } ) ; Map < Long , Float > result = new LinkedHashMap < Long , Float > ( ) ; for ( Iterator < Entry < Long , Float >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Long , Float > entry = it . next ( ) ; result . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return result ; } \n', 0.4682754856723419)

+('private static ArrayList < Map . Entry < Integer , Value >> sortMapByValue ( HashMap < Integer , Value > map ) { ArrayList < Map . Entry < Integer , Value >> al = new ArrayList < Map . Entry < Integer , Value >> ( map . entrySet ( ) ) ; Collections . sort ( al , new Comparator < Map . Entry < Integer , Value >> ( ) { public int compare ( Entry < Integer , Value > o1 , Entry < Integer , Value > o2 ) { return ( ( Comparable < Integer > ) ( o1 . getValue ( ) . getValue ( ) ) ) . compareTo ( o2 . getValue ( ) . getValue ( ) ) ; } } ) ; return al ; } \n', 0.4663542359745496)

+('private static Map < Integer , Double > sortMapAscendingDouble ( Map < Integer , Double > sort ) { List < Map . Entry < Integer , Double >> list = new LinkedList < Map . Entry < Integer , Double >> ( sort . entrySet ( ) ) ; Collections . sort ( list , new Comparator < Map . Entry < Integer , Double >> ( ) { public int compare ( Map . Entry < Integer , Double > o1 , Map . Entry < Integer , Double > o2 ) { return ( o1 . getValue ( ) ) . compareTo ( o2 . getValue ( ) ) ; } } ) ; Map < Integer , Double > sorted = new LinkedHashMap < Integer , Double > ( ) ; for ( Iterator < Map . Entry < Integer , Double >> it = list . iterator ( ) ; it . hasNext ( ) ; ) { Map . Entry < Integer , Double > entry = it . next ( ) ; sorted . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sorted ; } \n', 0.4625160758613071)

+('public static < K , V > LinkedHashMap < K , V > sortMapByValue ( final Map < K , V > map , final SortingOrder sortingOrder ) { Comparator < Map . Entry < K , V >> comparator = new Comparator < Entry < K , V >> ( ) { public int compare ( Entry < K , V > o1 , Entry < K , V > o2 ) { return comparableCompare ( o1 . getValue ( ) , o2 . getValue ( ) , sortingOrder ) ; } } ; return sortMap ( map , comparator ) ; } \n', 0.4620787561367913)

+('public static < K , V extends Comparable < ? super V >> List < Pair < K , V >> sortMapByValue ( Map < K , V > map ) { List < Pair < K , V >> result = new ArrayList < Pair < K , V >> ( ) ; for ( Map . Entry < K , V > e : map . entrySet ( ) ) result . add ( new Pair < K , V > ( e . getKey ( ) , e . getValue ( ) ) ) ; Util . sortPairsBySecondElement ( result ) ; return result ; } \n', 0.4616939645497932)

+('public static < K , V extends Comparable < ? super V >> Map < K , V > sortMapByValues ( final Map < K , V > mapToSort ) { ArrayList < Map . Entry < K , V >> entries = new ArrayList < Map . Entry < K , V >> ( mapToSort . size ( ) ) ; entries . addAll ( mapToSort . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < K , V >> ( ) { @ Override public int compare ( final Map . Entry < K , V > entry1 , final Map . Entry < K , V > entry2 ) { return entry2 . getValue ( ) . compareTo ( entry1 . getValue ( ) ) ; } } ) ; Map < K , V > sortedMap = new LinkedHashMap < K , V > ( ) ; for ( Map . Entry < K , V > entry : entries ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46044583584318677)

+('public < K , V extends Comparable < ? super V >> Map < K , V > sortMapByValues ( final Map < K , V > mapToSort ) { List < Map . Entry < K , V >> entries = new ArrayList < Map . Entry < K , V >> ( mapToSort . size ( ) ) ; entries . addAll ( mapToSort . entrySet ( ) ) ; Collections . sort ( entries , new Comparator < Map . Entry < K , V >> ( ) { public int compare ( final Map . Entry < K , V > entry1 , final Map . Entry < K , V > entry2 ) { return entry1 . getValue ( ) . compareTo ( entry2 . getValue ( ) ) ; } } ) ; Map < K , V > sortedMap = new LinkedHashMap < K , V > ( ) ; for ( Map . Entry < K , V > entry : entries ) { sortedMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return sortedMap ; } \n', 0.46044583584318677)

-('public static < K , V > LinkedHashMap < K , V > sortMapEntriesByValueAndByKey ( final Map < K , V > map ) { LinkedHashMap < K , V > result = new LinkedHashMap < K , V > ( map . size ( ) ) ; LinkedHashMap < K , V > orderedSubMapWithDifferentValues = sortMapByValue ( getSubMapWithDifferentValues ( map ) , SortingOrder . ASCENDING ) ; List < Map . Entry < K , V >> subSetWithDifferentValues = new LinkedList < Map . Entry < K , V >> ( orderedSubMapWithDifferentValues . entrySet ( ) ) ; for ( Map . Entry < K , V > entry : subSetWithDifferentValues ) { V value = entry . getValue ( ) ; LinkedHashMap < K , V > orderedSubMapWithGivenValue = sortMapByKey ( getSubMapWithGivenValue ( map , value ) , SortingOrder . ASCENDING ) ; List < Map . Entry < K , V >> subSetWithGivenValue = new LinkedList < Map . Entry < K , V >> ( orderedSubMapWithGivenValue . entrySet ( ) ) ; for ( Map . Entry < K , V > orderedEntry : subSetWithGivenValue ) { K orderedEntryKey = orderedEntry . getKey ( ) ; V orderedEntryValue = orderedEntry . getValue ( ) ; result . put ( orderedEntryKey , orderedEntryValue ) ; } } return result ; } \n', 0.46019222423325123)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 9

########################## 14 #################################
-('private void normalizeSpeed ( Command command , double stopTurnThreshold ) { if ( Math . abs ( command . turningSpeed ) > stopTurnThreshold ) { command . drivingSpeed = 0 ; } else { double lossFactor = Math . abs ( command . turningSpeed ) / stopTurnThreshold ; lossFactor *= FORWARD_LOSS_MULTIPLIER ; lossFactor = Utilities . restrictValueToInterval ( lossFactor , 0.0 , 1.0 ) . doubleValue ( ) ; command . drivingSpeed *= 1.0 - lossFactor ; } } \n', 0.2964195346924362)

-('public double getGhostSpeed ( ) { if ( ! mGhostSpeeds . isEmpty ( ) ) { double speed = mGhostSpeeds . get ( 0 ) ; mGhostSpeeds . remove ( 0 ) ; return speed ; } else return 0 ; } \n', 0.28224906124339144)

-('protected double [ ] normalize ( double [ ] speeds , double maxSpeed , boolean scale ) { maxSpeed = maxSpeed > MAX_SPEED ? MAX_SPEED : Math . abs ( maxSpeed ) ; double maxInputSpeed = Double . NEGATIVE_INFINITY ; for ( int i = 0 ; i < numWheels ; i ++ ) maxInputSpeed = Math . max ( Math . abs ( speeds [ i ] ) , maxInputSpeed ) ; if ( scale || maxInputSpeed > maxSpeed ) for ( int i = 0 ; i < numWheels ; i ++ ) speeds [ i ] = ( speeds [ i ] / maxInputSpeed ) * maxSpeed ; return speeds ; } \n', 0.2813723488325828)

-('public String doSquareRootsMath ( ArrayList < String > mathSymbolsToCompute , ArrayList < Double > mathNumbersToCompute , int isThereASquareRoot ) { double myNumberToTakeSquareRootOf = mathNumbersToCompute . get ( isThereASquareRoot ) ; if ( myNumberToTakeSquareRootOf < 0 ) return ( "ERROR" ) ; else { double mySquareRootedNumber = Math . sqrt ( myNumberToTakeSquareRootOf ) ; double myTruncatedSquareRootedNumber = truncateMyDecimal ( mySquareRootedNumber ) ; mathSymbolsToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . remove ( isThereASquareRoot ) ; mathNumbersToCompute . add ( isThereASquareRoot , mySquareRootedNumber ) ; return ( String . valueOf ( myTruncatedSquareRootedNumber ) ) ; } } \n', 0.2772193949730584)

-('public void decreaseAngularSpeed ( ) { m_rotationalSpeed = Math . max ( m_rotationalSpeed - ANGULAR_ACCELERATION , MINIMUM_ANGULAR_SPEED ) ; } \n', 0.2739822938651274)

-('public void removeSpeed ( ) { if ( extraBasic == null ) { return ; } extraBasic . speed = 0.0f ; extraBasic . hasSpeed = false ; checkExtraBasic ( ) ; } \n', 0.2731391244947241)

-('public void removeSensorSpeed ( ) { if ( extraSensor == null ) { return ; } extraSensor . speed = 0.0f ; extraSensor . hasSpeed = false ; checkExtraSensor ( ) ; } \n', 0.2565531254204184)

-('public double speedDifference ( ) { double difference = Math . abs ( m_currentSpeed - m_lastRecordedSpeed ) ; Log . d ( TAG , "Speed-Difference-is:-" + difference ) ; return difference ; } \n', 0.25585771048013517)

-('private boolean validateSpeedGradient ( long ei , TreeMap < Long , List > intervalSpeed , double tolerance ) { List < Double > speedList = intervalSpeed . get ( ei ) ; double gradient = Math . abs ( speedList . get ( speedList . size ( ) - 1 ) - speedList . get ( 0 ) ) ; if ( tolerance >= gradient ) { return true ; } else { return false ; } } \n', 0.252223350366088)

-('protected boolean isRootOK ( double min , double max , Complex z ) { double tolerance = FastMath . max ( relativeAccuracy * z . abs ( ) , absoluteAccuracy ) ; return ( isSequence ( min , z . getReal ( ) , max ) ) && ( FastMath . abs ( z . getImaginary ( ) ) <= tolerance || z . abs ( ) <= functionValueAccuracy ) ; } \n', 0.25046170526347916)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 15 #################################
+('public byte [ ] concatenateTwoByteArrays ( byte [ ] a , byte [ ] b ) { byte [ ] c = new byte [ a . length + b . length ] ; System . arraycopy ( a , 0 , c , 0 , a . length ) ; System . arraycopy ( b , 0 , c , a . length , b . length ) ; return c ; } \n', 0.34917792092265965)

+('private double [ ] concatenateSamples ( final double [ ] x , final double [ ] y ) { final double [ ] z = new double [ x . length + y . length ] ; System . arraycopy ( x , 0 , z , 0 , x . length ) ; System . arraycopy ( y , 0 , z , x . length , y . length ) ; return z ; } \n', 0.34041046675096964)

+('private String [ ] concatenateArraysForInput ( String [ ] param , String [ ] value ) { String [ ] array = ( String [ ] ) Array . newInstance ( param [ 0 ] . getClass ( ) , param . length + value . length ) ; int j = 0 ; if ( param . length == value . length ) { for ( int i = 0 ; i < param . length ; i ++ ) { if ( i == 0 ) j = j + i ; else j = j + 1 ; array [ j ] = param [ i ] ; j = j + 1 ; array [ j ] = value [ i ] ; } } else { logger . warn ( "WARNING:-Check-your-array-size" ) ; } return array ; } \n', 0.3249121396561949)

+('public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( Objects . isEmpty ( array1 ) ) { return array2 ; } if ( Objects . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , 0 , newArr , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , newArr , array1 . length , array2 . length ) ; return newArr ; } \n', 0.31814045405613983)

-('public static String concatenateWithNulls ( Object ... objects ) { StringBuffer string = new StringBuffer ( 50 ) ; for ( int i = 0 ; i < objects . length ; i ++ ) { string . append ( ( objects [ i ] != null ) ? objects [ i ] : "null" ) ; } return string . toString ( ) ; } \n', 0.3169538439348487)

-("public static StringBuffer concatenateWithColon ( final String firstPart , final Object secondPart ) { final StringBuffer ret = new StringBuffer ( firstPart ) ; ret . append ( ':' ) ; ret . append ( secondPart ) ; return ret ; } \n", 0.31608873285865835)

+('public static < T > T [ ] concatenateArrays ( T [ ] first , T [ ] ... rest ) { int totalLength = first . length ; for ( T [ ] array : rest ) { totalLength += array . length ; } T [ ] result = Arrays . copyOf ( first , totalLength ) ; int offset = first . length ; for ( T [ ] array : rest ) { System . arraycopy ( array , 0 , result , offset , array . length ) ; offset += array . length ; } return result ; } \n', 0.31546183172548464)

-("private static String concatenateRange ( String [ ] array , int start , int end ) { StringBuilder builder = new StringBuilder ( 32 ) ; for ( int i = start ; i < end ; ++ i ) { if ( i != start ) { builder . append ( '-' ) ; } builder . append ( array [ i ] ) ; } return builder . toString ( ) ; } \n", 0.3148976302284505)

+('private static < T > void concatenateArrays ( Iterable < T [ ] > arraysToConcatenate , T [ ] destination ) { int nextStartIndexToUse = 0 ; for ( T [ ] array : arraysToConcatenate ) { System . arraycopy ( array , 0 , destination , nextStartIndexToUse , array . length ) ; nextStartIndexToUse += array . length ; } } \n', 0.31076428099890496)

+('public static byte [ ] concatenateArrays ( byte [ ] left , byte [ ] right ) { byte [ ] result = new byte [ left . length + right . length ] ; System . arraycopy ( left , 0 , result , 0 , left . length ) ; System . arraycopy ( right , 0 , result , left . length , right . length ) ; return result ; } \n', 0.30975507420605136)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 7

########################## 16 #################################
-('public static BufferedReader readerFromString ( String textFileOrUrl , String encoding ) throws IOException { InputStream is = getInputStreamFromURLOrClasspathOrFileSystem ( textFileOrUrl ) ; if ( encoding == null ) { return new BufferedReader ( new InputStreamReader ( is ) ) ; } return new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; } \n', 0.3582133127709208)

-('public File createFileFromString ( EDataType eDataType , String initialValue ) { return ( File ) super . createFromString ( eDataType , initialValue ) ; } \n', 0.3547786782348934)

+('String getFileContentsFromJar ( JarFile jarFile , JarEntry jarEntry ) throws IOException { StringBuffer fileContent = new StringBuffer ( ) ; InputStream is = jarFile . getInputStream ( jarEntry ) ; BufferedInputStream bis = new BufferedInputStream ( is ) ; int length = 500 ; byte buf [ ] = new byte [ length ] ; int count = 0 ; while ( ( count = bis . read ( buf , 0 , length ) ) != - 1 ) { fileContent . append ( new String ( buf , 0 , count ) ) ; buf = new byte [ length ] ; } bis . close ( ) ; is . close ( ) ; return fileContent . toString ( ) ; } \n', 0.340092415981402)

-('public static BufferedReader readerFromString ( String textFileOrUrl ) throws IOException { return new BufferedReader ( new InputStreamReader ( getInputStreamFromURLOrClasspathOrFileSystem ( textFileOrUrl ) , "UTF-8" ) ) ; } \n', 0.33814181185671527)

-('public static String stringFromFile ( File file ) throws IOException { return stringFromFile ( file , System . getProperty ( "line.separator" ) ) ; } \n', 0.33409271284715764)

-('@ Override public Object fromString ( String value ) throws InvalidSettingValueException { try { if ( new File ( value ) . isDirectory ( ) ) { return value ; } } catch ( Exception e ) { } throw new InvalidSettingValueException ( ) ; } \n', 0.3312779400499686)

+('public static Attachment fromTextFile ( File file , MediaType mediaType ) throws IOException { return fromText ( Files . toString ( file , mediaType . getCharset ( ) ) , mediaType ) ; } \n', 0.33008032651469965)

-('public static BufferedReader readReaderFromString ( String textFileOrUrl , String encoding ) throws IOException { InputStream is ; if ( textFileOrUrl . matches ( "https?://" ) ) { URL u = new URL ( textFileOrUrl ) ; URLConnection uc = u . openConnection ( ) ; is = uc . getInputStream ( ) ; } else { is = new FileInputStream ( textFileOrUrl ) ; } if ( textFileOrUrl . endsWith ( ".gz" ) ) { is = new GZIPInputStream ( is ) ; } return new BufferedReader ( new InputStreamReader ( is , encoding ) ) ; } \n', 0.3281411127305574)

-('public File fromString ( String value ) throws ConstrettoConversionException { File f = new File ( value ) ; if ( basedir == null ) { return convertToAbsolute ( f ) ; } if ( f . isAbsolute ( ) ) { return f ; } return convertToAbsolute ( new File ( basedir , value ) ) ; } \n', 0.32319267173554)

-('public static ObjectOutputStream writeStreamFromString ( String serializePath ) throws IOException { ObjectOutputStream oos ; if ( serializePath . endsWith ( ".gz" ) ) { oos = new ObjectOutputStream ( new BufferedOutputStream ( new GZIPOutputStream ( new FileOutputStream ( serializePath ) ) ) ) ; } else { oos = new ObjectOutputStream ( new BufferedOutputStream ( new FileOutputStream ( serializePath ) ) ) ; } return oos ; } \n', 0.32017727996670603)

FRank: 3  | P@1: 0  | P@5: 1  | P@10: 2

########################## 17 #################################
+('public static String convertStackTraceToString ( Throwable t ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( stringWriter ) ; t . printStackTrace ( writer ) ; return stringWriter . toString ( ) ; } \n', 0.4380905171992364)

+('static String convertStackTrace ( Throwable t , boolean appendOutputError ) { StackTraceWriter writer = new StackTraceWriter ( appendOutputError ) ; t . printStackTrace ( new PrintWriter ( writer ) ) ; return writer . toString ( ) . replaceAll ( "%" , "%%" ) ; } \n', 0.43406566344828357)

+('public static String writeStackTrace ( Throwable cause ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( cause ) ; sb . append ( "-" ) ; StackTraceElement [ ] trace = cause . getStackTrace ( ) ; for ( int i = 0 ; i < trace . length ; i ++ ) { String traceString = trace [ i ] . toString ( ) ; if ( ! ( traceString . startsWith ( "sun.reflect." ) && i > 1 ) ) { sb . append ( "-at-" ) ; sb . append ( traceString ) ; sb . append ( "-" ) ; } } return sb . toString ( ) ; } \n', 0.43287102920966625)

+('public static String toStackTraceString ( final Throwable throwable ) { final Writer result = new StringWriter ( ) ; final PrintWriter printWriter = new PrintWriter ( result ) ; throwable . printStackTrace ( printWriter ) ; return result . toString ( ) ; } \n', 0.42014845456648114)

+('private static String toStackTraceString ( Throwable t ) { if ( t == null ) { return "" ; } ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; PrintStream ps = new PrintStream ( baos ) ; t . printStackTrace ( ps ) ; ps . close ( ) ; return baos . toString ( ) ; } \n', 0.41839505334547444)

+('private static String getStackTraceStrings ( Throwable ex ) { String logMsg = ex . toString ( ) + "-" ; Throwable cause = ( ex . getCause ( ) != null ) ? ex . getCause ( ) : ex ; StackTraceElement [ ] stacks = cause . getStackTrace ( ) ; for ( int i = 0 ; i < stacks . length ; i ++ ) { logMsg += stacks [ i ] . toString ( ) + "-" ; } return logMsg ; } \n', 0.416862962844021)

+('public static String stackTraceToString ( Throwable t ) { if ( PRINT_STACK_TRACE ) { StringWriter descr = new StringWriter ( ) { boolean writeOK = true ; public void write ( char [ ] cbuf , int off , int len ) { if ( canWrite ( ) ) super . write ( cbuf , off , len ) ; } public void write ( int c ) { if ( canWrite ( ) ) super . write ( c ) ; } public void write ( String str , int off , int len ) { if ( canWrite ( ) ) super . write ( str , off , len ) ; } public void write ( String str ) { if ( canWrite ( ) ) super . write ( str ) ; } private boolean canWrite ( ) { if ( writeOK && this . getBuffer ( ) . length ( ) > MAX_CHARS ) { super . write ( "-...-[-too-long---truncated-]" ) ; writeOK = false ; } return writeOK ; } } ; t . printStackTrace ( new PrintWriter ( descr ) ) ; return descr . toString ( ) ; } else { return null ; } } \n', 0.4160986482708238)

+('public static String getStackTraceAsString ( Exception e ) { StringWriter stackTrace = new StringWriter ( ) ; e . printStackTrace ( new PrintWriter ( stackTrace ) ) ; return stackTrace . toString ( ) ; } \n', 0.41505870674673156)

+('public static String toStackTraceString ( Throwable t ) { StringWriter writer = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( writer ) ; t . printStackTrace ( pw ) ; return writer . toString ( ) ; } \n', 0.41489082562066665)

+('public static String getStackTraceAsString ( Exception exception ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; exception . printStackTrace ( pw ) ; return sw . toString ( ) ; } \n', 0.41487894827449484)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 18 #################################
+('public static int robustStringCompare ( @ CheckForNull final String string1 , @ CheckForNull final String string2 ) { int result = 0 ; if ( ( string1 == null ) && ( string2 == null ) ) { result = 0 ; } else if ( string1 == null ) { result = - 1 ; } else if ( string2 == null ) { result = 1 ; } else { result = string1 . compareTo ( string2 ) ; } return result ; } \n', 0.3493711934452177)

+('private int compareStringOrNull ( final String thisString , final String otherString ) { if ( thisString == null ) { if ( otherString != null ) { return - 1 ; } } else { if ( otherString == null ) { return 1 ; } final int result = thisString . compareTo ( otherString ) ; if ( result != 0 ) { return result ; } } return 0 ; } \n', 0.3462885110388132)

+('public static int StringCompareIgnCase ( String lhs , String rhs ) { return NormalizeString ( lhs ) . compareToIgnoreCase ( NormalizeString ( rhs ) ) ; } \n', 0.34453683534365276)

+('public static int compareString ( String string1 , String string2 ) { return string1 . compareTo ( string2 ) ; } \n', 0.34307234948497034)

+('private static boolean equalsStrings ( String string1 , String string2 ) { return ( ( ( string1 == null ) && ( string2 == null ) ) || string1 . equals ( string2 ) ) ; } \n', 0.34235840277758334)

+('private int compareString ( String s1 , String s2 ) { if ( s1 != null && s1 . equals ( s2 ) ) { return 0 ; } if ( s1 == null ) { return - 1 ; } if ( s2 == null ) { return 1 ; } return String . CASE_INSENSITIVE_ORDER . compare ( s1 , s2 ) ; } \n', 0.34068496127643105)

+('private static int compareStringForChinese ( String s1 , String s2 ) { String m_s1 = null , m_s2 = null ; try { m_s1 = new String ( s1 . getBytes ( "GB2312" ) , "GBK" ) ; m_s2 = new String ( s2 . getBytes ( "GB2312" ) , "GBK" ) ; } catch ( Exception ex ) { LOGGER . error ( "compareStringForChineseError" , ex ) ; return s1 . compareTo ( s2 ) ; } int res = chineseCompareTo ( m_s1 , m_s2 ) ; return res ; } \n', 0.33881479899367073)

+('public static int StringCompare ( String lhs , String rhs ) { return NormalizeString ( lhs ) . compareTo ( NormalizeString ( rhs ) ) ; } \n', 0.3379810324932133)

+('private static int compareStringDate ( final Object o1 , final Object o2 ) { final String value1 = ( String ) o1 ; final String value2 = DatePropertyParser . format ( ( Date ) o2 , DateProperty . DEFAULT_FORMAT ) ; return value1 . compareTo ( value2 ) ; } \n', 0.3355922879995149)

+('private static int compareDateString ( final Object o1 , final Object o2 ) { final String value1 = DatePropertyParser . format ( ( Date ) o1 , DateProperty . DEFAULT_FORMAT ) ; final String value2 = ( String ) o2 ; return value1 . compareTo ( value2 ) ; } \n', 0.3311149040389461)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 19 #################################
+('private static String [ ] splitString ( String str ) { int i = 0 ; if ( str == null ) { return new String [ 0 ] ; } StringTokenizer stringTokenizer = new StringTokenizer ( str , "," ) ; if ( stringTokenizer . countTokens ( ) == 0 ) { return new String [ ] { str } ; } String [ ] strArr = new String [ stringTokenizer . countTokens ( ) ] ; while ( i < strArr . length ) { strArr [ i ] = stringTokenizer . nextToken ( ) . trim ( ) ; i ++ ; } return strArr ; } \n', 0.4010580820487074)

+('private String splitString ( String string ) { StringBuilder buf = new StringBuilder ( ) ; String tempString = string ; if ( string != null ) { while ( tempString . length ( ) > 60 ) { String block = tempString . substring ( 0 , 60 ) ; int index = block . lastIndexOf ( \'-\' ) ; if ( index < 0 ) { index = tempString . indexOf ( \'-\' ) ; } if ( index >= 0 ) { buf . append ( tempString . substring ( 0 , index ) ) . append ( "<BR>" ) ; } tempString = tempString . substring ( index + 1 ) ; } } else { tempString = "-" ; } buf . append ( tempString ) ; return buf . toString ( ) ; } \n', 0.3942953648286438)

+('private static String [ ] splitString ( String instr , String separator ) { if ( instr == null ) { throw new IllegalArgumentException ( "Input-string-must-not-be-null." ) ; } StringTokenizer tokenizer = new StringTokenizer ( instr , separator ) ; int length = tokenizer . countTokens ( ) ; String [ ] str_array = new String [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { str_array [ i ] = tokenizer . nextToken ( ) ; } return str_array ; } \n', 0.39321329471555344)

+("private String [ ] splitString ( String s ) { int i , j , n ; n = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == '.' ) n ++ ; String [ ] arr = new String [ n + 1 ] ; i = 0 ; n = 0 ; j = s . indexOf ( '.' ) ; while ( j != - 1 ) { arr [ n ] = s . substring ( i , j ) ; i = j + 1 ; j = s . indexOf ( '.' , i ) ; n ++ ; } arr [ n ] = s . substring ( s . lastIndexOf ( '.' ) + 1 ) ; return arr ; } \n", 0.392605278035114)

+('public static String [ ] split ( String value , char delimiter ) { char [ ] valueChars = value . toCharArray ( ) ; int lastIndex = 0 ; ArrayList strings = null ; for ( int i = 0 ; i < valueChars . length ; i ++ ) { char c = valueChars [ i ] ; if ( c == delimiter ) { if ( strings == null ) { strings = new ArrayList ( ) ; } strings . add ( new String ( valueChars , lastIndex , i - lastIndex ) ) ; lastIndex = i + 1 ; } } if ( strings == null ) { return new String [ ] { value } ; } strings . add ( new String ( valueChars , lastIndex , valueChars . length - lastIndex ) ) ; return ( String [ ] ) strings . toArray ( new String [ strings . size ( ) ] ) ; } \n', 0.39202786219458763)

+('public static String [ ] splitStringToArray ( final CharSequence s , final char c ) { if ( s == null || s . length ( ) == 0 ) { return Strings . EMPTY_ARRAY ; } int count = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { count ++ ; } } final String [ ] result = new String [ count ] ; final StringBuilder builder = new StringBuilder ( ) ; int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == c ) { if ( builder . length ( ) > 0 ) { result [ res ++ ] = builder . toString ( ) ; builder . setLength ( 0 ) ; } } else { builder . append ( s . charAt ( i ) ) ; } } if ( builder . length ( ) > 0 ) { result [ res ++ ] = builder . toString ( ) ; } if ( res != count ) { String [ ] result1 = new String [ res ] ; System . arraycopy ( result , 0 , result1 , 0 , res ) ; return result1 ; } return result ; } \n', 0.39186095551488026)

+('protected static List < String > splitString ( String string ) { List < String > words = new ArrayList < String > ( ) ; char [ ] letters = string . toCharArray ( ) ; int length = letters . length ; int marker = 0 ; for ( int i = 0 ; i < length ; ++ i ) { char c = letters [ i ] ; if ( "--_.$" . indexOf ( c ) > - 1 ) { words . add ( string . substring ( marker , i ) . toLowerCase ( Locale . ENGLISH ) ) ; for ( ++ i ; i < length && "--_.$" . indexOf ( letters [ i ] ) > - 1 ; ++ i ) { } marker = i ; } else if ( Character . isUpperCase ( c ) && i > 0 && Character . isLowerCase ( letters [ i - 1 ] ) ) { words . add ( string . substring ( marker , i ) . toLowerCase ( Locale . ENGLISH ) ) ; marker = i ; } } if ( marker < length ) { words . add ( string . substring ( marker ) . toLowerCase ( Locale . ENGLISH ) ) ; } return words ; } \n', 0.3917870000528613)

+('private String [ ] splitString ( String str , String delimiter ) { List list = new ArrayList ( ) ; StringTokenizer st = new StringTokenizer ( str , delimiter ) ; while ( st . hasMoreTokens ( ) ) { String t = st . nextToken ( ) ; if ( t . startsWith ( "_" ) ) { break ; } else { list . add ( t . trim ( ) ) ; } } return ( String [ ] ) list . toArray ( new String [ list . size ( ) ] ) ; } \n', 0.3893490509226766)

+('private static List < String > split ( String s , char c ) { List < String > strings = new ArrayList < String > ( ) ; StringTokenizer tok = new StringTokenizer ( s , "" + c ) ; while ( tok . hasMoreTokens ( ) ) { String o = tok . nextToken ( ) ; strings . add ( o ) ; } return strings ; } \n', 0.3869735259988072)

+('private static List < String > splitString ( String theString , char separator , char escape , boolean trimTokens ) { ArrayList < String > v = new ArrayList < String > ( ) ; int start = 0 ; String tmp ; int i = 0 ; if ( theString == null ) { v . add ( null ) ; return v ; } while ( i <= theString . length ( ) ) { if ( ( i == theString . length ( ) ) || ( theString . charAt ( i ) == separator ) ) { if ( ( i == 0 ) || ( i == theString . length ( ) ) || ( theString . charAt ( i - 1 ) != escape ) ) { tmp = theString . substring ( start , i ) ; if ( trimTokens ) { tmp = tmp . trim ( ) ; } if ( tmp . length ( ) > 0 ) { v . add ( tmp ) ; } start = i + 1 ; } else if ( ( theString . charAt ( i ) == separator ) && ( theString . charAt ( i - 1 ) == escape ) ) { theString = theString . substring ( 0 , i - 1 ) + theString . substring ( i ) ; continue ; } } i ++ ; } return v ; } \n', 0.3860161474398943)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 20 #################################
-('public static BufferedWriter openFileToWrite ( String pathToFile , String encoding ) { try { return Files . newBufferedWriter ( new File ( pathToFile ) . toPath ( ) , Charset . forName ( encoding ) ) ; } catch ( IOException e ) { LOG . error ( "-" , e ) ; return null ; } } \n', 0.3561619246806307)

-('public void writeSourceFiles ( String destSrcDir ) throws IOException { Objects . requireNonNull ( destSrcDir ) ; File file = new File ( destSrcDir ) ; cm . build ( file ) ; } \n', 0.3521900127459023)

+('public static StoredFile createLocalStoredFile ( InputStream is , String sourceUrl , String localFilePath , String mimeType ) { if ( is == null ) { return null ; } CountingOutputStream cos = null ; BufferedOutputStream bos = null ; FileOutputStream fos = null ; try { File localFile = new File ( localFilePath ) ; if ( localFile . exists ( ) ) { localFile . delete ( ) ; } fos = new FileOutputStream ( localFile ) ; bos = new BufferedOutputStream ( fos ) ; cos = new CountingOutputStream ( bos ) ; byte [ ] buf = new byte [ 2048 ] ; int count ; while ( ( count = is . read ( buf , 0 , 2048 ) ) != - 1 ) { cos . write ( buf , 0 , count ) ; } Log . d ( "File-saved,-size-=-" + ( cos . getBytesWritten ( ) / 1024 ) + "k" ) ; } catch ( IOException e ) { Log . e ( "Error-creating-local-copy-of-file-attachment." ) ; return null ; } finally { Util . ensureClosed ( cos ) ; Util . ensureClosed ( bos ) ; Util . ensureClosed ( fos ) ; } StoredFile storedFile = new StoredFile ( ) ; storedFile . setSourceUriOrPath ( sourceUrl ) ; storedFile . setLocalFilePath ( localFilePath ) ; storedFile . setMimeType ( mimeType ) ; return storedFile ; } \n', 0.34606335587570214)

+('private Path writeChecksumFile ( FileSystem fs , String name , GenThread [ ] threads ) throws IOException { Path checksumFile = new Path ( rtc . output_dir , name + ".checksum" ) ; SequenceFile . Writer write = null ; write = SequenceFile . createWriter ( fs , fs . getConf ( ) , checksumFile , Text . class , Text . class , CompressionType . NONE ) ; try { for ( GenThread rawThread : threads ) { GenWriterThread thread = ( GenWriterThread ) rawThread ; write . append ( new Text ( thread . outputPath . toString ( ) ) , new Text ( Long . toString ( thread . dc . getDirectoryChecksum ( ) ) ) ) ; } } finally { if ( write != null ) write . close ( ) ; write = null ; } return checksumFile ; } \n', 0.33483508873498274)

-("private void createNewLocalFile ( File newFile ) throws CmsException { if ( newFile . exists ( ) ) { throw new CmsSynchronizeException ( Messages . get ( ) . container ( Messages . ERR_EXISTENT_FILE_1 , newFile . getPath ( ) ) ) ; } FileOutputStream fOut = null ; try { File parentFolder = new File ( newFile . getPath ( ) . replace ( '/' , File . separatorChar ) . substring ( 0 , newFile . getPath ( ) . lastIndexOf ( File . separator ) ) ) ; parentFolder . mkdirs ( ) ; if ( parentFolder . exists ( ) ) { fOut = new FileOutputStream ( newFile ) ; } else { throw new CmsSynchronizeException ( Messages . get ( ) . container ( Messages . ERR_CREATE_DIR_1 , newFile . getPath ( ) ) ) ; } } catch ( IOException e ) { throw new CmsSynchronizeException ( Messages . get ( ) . container ( Messages . ERR_CREATE_FILE_1 , this . getClass ( ) . getName ( ) , newFile . getPath ( ) ) , e ) ; } finally { if ( fOut != null ) { try { fOut . close ( ) ; } catch ( IOException e ) { } } } } \n", 0.3304271980585537)

+('public static File createBackupObjectFile ( BackupObject backupObject , String destinationDir , String fileNameBase ) throws IOException { File backupObjectFile = new File ( destinationDir , createFileName ( fileNameBase , BackupObject . EXTENSION ) ) ; String xml = backupObject . getAsString ( ) ; System . out . println ( "[INFO]-Building-BackupObject-file:-" + backupObjectFile . getAbsolutePath ( ) ) ; Files . write ( xml , backupObjectFile , Charsets . UTF_8 ) ; return backupObjectFile ; } \n', 0.3284162162048652)

+('private MimeBodyPart makeBodyPart ( InputStream is , String fileName , String mimeType ) throws EmailException , MessagingException , IOException { String extension = null ; if ( fileName != null ) extension = FileUtil . getFileNameExtension ( fileName ) ; if ( extension == null ) extension = MIMETypeUtil . fileExtensionForMIMEType ( mimeType ) ; if ( extension == null ) extension = "dat" ; extension = "." + extension ; File tempFile = File . createTempFile ( "mail" , extension ) ; tempFile . deleteOnExit ( ) ; log . debug ( "Created-temporary-file-"" + tempFile . getPath ( ) + """ ) ; temporaryFiles . add ( tempFile ) ; OutputStream os = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; int b ; while ( ( b = is . read ( ) ) != - 1 ) os . write ( b ) ; os . close ( ) ; if ( mimeType == null ) mimeType = "application/octet-stream" ; if ( fileName == null ) fileName = tempFile . getName ( ) ; return makeBodyPart ( tempFile , fileName , mimeType ) ; } \n', 0.32691751358853033)

-('public static void writeFileBufferedFileWriter ( File file , List < String > content ) { BufferedWriter bufferedWriter = null ; try { bufferedWriter = new BufferedWriter ( new FileWriter ( file ) ) ; for ( String line : content ) { bufferedWriter . write ( line ) ; bufferedWriter . newLine ( ) ; } } catch ( IOException e ) { log . error ( "##-[WriteFile]-write-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } finally { try { if ( bufferedWriter != null ) { bufferedWriter . close ( ) ; } } catch ( IOException e ) { log . error ( "##-[WriteFile]-close-file-failed-##" ) ; log . error ( e . getMessage ( ) ) ; } } } \n', 0.32670302460150763)

-('public OutputStream writeFile ( String filename ) throws IOException { return new FileOutputStream ( externalStoragePath + filename + BASIC_FILE_EXTENSION ) ; } \n', 0.3264182573485189)

+('public static void writeFile ( String contentToWrite , String fileName ) { Preconditions . checkNotNull ( contentToWrite ) ; Preconditions . checkNotNull ( fileName ) ; try { Files . write ( contentToWrite , new File ( fileName ) , Charset . defaultCharset ( ) ) ; } catch ( IOException e ) { throw ExceptionsMu . asUnchecked ( e ) ; } } \n', 0.3261508450717904)

FRank: 3  | P@1: 0  | P@5: 2  | P@10: 5

########################## 21 #################################
-('public void initialise ( ) throws InitialisationException { if ( _context == null ) { Hashtable props = new Hashtable ( ) ; if ( initialFactory != null ) { props . put ( Context . INITIAL_CONTEXT_FACTORY , initialFactory ) ; } else if ( properties == null || ! properties . containsKey ( Context . INITIAL_CONTEXT_FACTORY ) ) { throw new InitialisationException ( CoreMessages . objectIsNull ( "jndiInitialFactory" ) , this ) ; } if ( url != null ) { props . put ( Context . PROVIDER_URL , url ) ; } if ( properties != null ) { props . putAll ( properties ) ; } try { _context = new InitialContext ( props ) ; } catch ( NamingException e ) { throw new InitialisationException ( e , this ) ; } } } \n', 0.40575301176190537)

-('private void initMappings ( ) throws Exception { checkClient ( ) ; if ( mappings != null && mappings . length > 0 ) { Map < String , Collection < String >> indexes = new HashMap < > ( ) ; for ( int i = 0 ; i < mappings . length ; i ++ ) { String indexmapping = mappings [ i ] ; String [ ] indexmappingsplitted = indexmapping . split ( "/" ) ; String index = indexmappingsplitted [ 0 ] ; if ( index == null ) throw new Exception ( "Can-not-read-index-in-[" + indexmapping + "].-Check-that-mappings-contains-only-indexname/mappingname-elements." ) ; if ( ! indexes . containsKey ( index ) ) { indexes . put ( index , new ArrayList < String > ( ) ) ; } if ( indexmappingsplitted . length > 1 ) { String mapping = indexmappingsplitted [ 1 ] ; indexes . get ( index ) . add ( mapping ) ; } } for ( String index : indexes . keySet ( ) ) { createIndex ( client , classpathRoot , index ) ; if ( mergeSettings ) { updateSettings ( client , classpathRoot , index ) ; } Collection < String > mappings = indexes . get ( index ) ; for ( Iterator < String > iterator = mappings . iterator ( ) ; iterator . hasNext ( ) ; ) { String type = iterator . next ( ) ; createMapping ( client , classpathRoot , index , type , mergeMapping , forceMapping ) ; } } } } \n', 0.39948416997342673)

-('private void initMappings ( ) throws Exception { if ( mappings != null && mappings . length > 0 ) { Map < String , Collection < String >> indexes = new HashMap < String , Collection < String >> ( ) ; for ( int i = 0 ; i < mappings . length ; i ++ ) { String indexmapping = mappings [ i ] ; String [ ] indexmappingsplitted = indexmapping . split ( "/" ) ; String index = indexmappingsplitted [ 0 ] ; logger . info ( "index:" + index + ",-mapping:" + indexmapping ) ; if ( index == null ) { throw new Exception ( "Can-not-read-index-in-[" + indexmapping + "].-Check-that-mappings-contains-only-indexname/mappingname-elements." ) ; } if ( ! indexes . containsKey ( index ) ) { indexes . put ( index , new ArrayList < String > ( ) ) ; } if ( indexmappingsplitted . length > 1 ) { String mapping = indexmappingsplitted [ 1 ] ; indexes . get ( index ) . add ( mapping ) ; } } for ( String index : indexes . keySet ( ) ) { if ( ! isIndexExist ( index ) ) { createIndex ( index ) ; } else { if ( mergeSettings ) { mergeIndexSettings ( index ) ; } } Collection < String > mappings = indexes . get ( index ) ; for ( Iterator < String > iterator = mappings . iterator ( ) ; iterator . hasNext ( ) ; ) { String type = iterator . next ( ) ; pushMapping ( index , type , rebuildMapping , mergeMapping ) ; logger . info ( "create-mapping-ok.-index=" + index + ",-type=" + type ) ; } } } } \n', 0.399459968429366)

-('private static Map < XClass , Class < ? >> initializeClassMappings ( SearchConfiguration cfg , ReflectionManager reflectionManager ) { Iterator < Class < ? >> iter = cfg . getClassMappings ( ) ; Map < XClass , Class < ? >> map = new HashMap < XClass , Class < ? >> ( ) ; while ( iter . hasNext ( ) ) { Class < ? > mappedClass = iter . next ( ) ; if ( mappedClass == null ) { continue ; } XClass mappedXClass = reflectionManager . toXClass ( mappedClass ) ; if ( mappedXClass == null ) { continue ; } map . put ( mappedXClass , mappedClass ) ; } return map ; } \n', 0.3991137356467231)

-('private static Map < XClass , Class > initializeClassMappings ( SearchConfiguration cfg , ReflectionManager reflectionManager ) { Iterator < Class < ? >> iter = cfg . getClassMappings ( ) ; Map < XClass , Class > map = new HashMap < XClass , Class > ( ) ; while ( iter . hasNext ( ) ) { Class < ? > mappedClass = iter . next ( ) ; if ( mappedClass == null ) { continue ; } @ SuppressWarnings ( "unchecked" ) XClass mappedXClass = reflectionManager . toXClass ( mappedClass ) ; if ( mappedXClass == null ) { continue ; } map . put ( mappedXClass , mappedClass ) ; } return map ; } \n', 0.3983247967783194)

-('protected void initialise ( Connection connection ) { if ( ! initialised ) { synchronized ( this ) { if ( ! initialised ) { Set accessorsToRemove = new HashSet ( ) ; Iterator i = accessorMutatorMap . keySet ( ) . iterator ( ) ; while ( i . hasNext ( ) ) { Method accessor = ( Method ) i . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; Object value = null ; try { value = accessor . invoke ( connection , null ) ; if ( value != null ) { defaultValues . put ( mutator , value ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Remembering-default-value:-" + accessor . getName ( ) + "()-=-" + value ) ; } } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + accessor . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } try { Object [ ] args = { value } ; mutator . invoke ( connection , args ) ; } catch ( Throwable t ) { log . debug ( driverName + "-does-not-support-" + mutator . getName ( ) + ".-Proxool-doesn\'t-mind." ) ; accessorsToRemove . add ( accessor ) ; } } Iterator j = accessorsToRemove . iterator ( ) ; while ( j . hasNext ( ) ) { Method accessor = ( Method ) j . next ( ) ; Method mutator = ( Method ) accessorMutatorMap . get ( accessor ) ; accessorMutatorMap . remove ( accessor ) ; defaultValues . remove ( mutator ) ; } initialised = true ; } } } } \n', 0.3899768502441775)

-('public static Context initialise ( final Map environment ) throws NamingException { Context context ; if ( environment != null && environment . size ( ) > 0 ) { context = new InitialContext ( new Hashtable ( environment ) ) ; } else { context = new InitialContext ( ) ; } return context ; } \n', 0.38813912680444246)

-('protected void initializeMappings ( ) { String viewMappings = webConfig . getOptionValue ( FaceletsViewMappings ) ; if ( ( viewMappings != null ) && ( viewMappings . length ( ) > 0 ) ) { Map < String , Object > appMap = FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getApplicationMap ( ) ; String [ ] mappingsArray = Util . split ( appMap , viewMappings , ";" ) ; List < String > extensionsList = new ArrayList < > ( mappingsArray . length ) ; List < String > prefixesList = new ArrayList < > ( mappingsArray . length ) ; for ( String aMappingsArray : mappingsArray ) { String mapping = aMappingsArray . trim ( ) ; int mappingLength = mapping . length ( ) ; if ( mappingLength <= 1 ) { continue ; } if ( mapping . charAt ( 0 ) == \'*\' ) { extensionsList . add ( mapping . substring ( 1 ) ) ; } else if ( mapping . charAt ( mappingLength - 1 ) == \'*\' ) { prefixesList . add ( mapping . substring ( 0 , mappingLength - 1 ) ) ; } } extensionsArray = new String [ extensionsList . size ( ) ] ; extensionsList . toArray ( extensionsArray ) ; prefixesArray = new String [ prefixesList . size ( ) ] ; prefixesList . toArray ( prefixesArray ) ; } } \n', 0.38688192835410196)

-('private void initMappingMap ( ) { mapping = new HashMap < K , K > ( ) ; mappingReverse = new HashMap < K , HashSet < K >> ( ) ; } \n', 0.38164398924259824)

-('protected void initialiseMapsForFile ( ) { goTermGeneToEvidence = new LinkedHashMap < GoTermToGene , Set < Evidence >> ( ) ; productCollectionsMap = new LinkedHashMap < Integer , List < String >> ( ) ; storedProductIds = new HashMap < String , Integer > ( ) ; } \n', 0.3795221908993608)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 22 ################################# remove
-('public void detectDependencyLoop ( Set nodes ) throws DependencyLoopException { Set availableNodes = new HashSet ( nodes ) ; while ( ! availableNodes . isEmpty ( ) ) { DependentNode leafNode = findLeafNode ( availableNodes ) ; if ( leafNode != null ) { availableNodes . remove ( leafNode ) ; continue ; } throw new DependencyLoopException ( DependencyLoopException . getMessage ( availableNodes ) ) ; } } \n', 0.36402190480027485)

-('private < T > Iterable < T > dropWhile ( final Iterable < T > xs , final Predicate < ? super T > p ) { return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { PeekingIterator < T > xsi = Iterators . peekingIterator ( xs . iterator ( ) ) ; while ( xsi . hasNext ( ) ) { if ( p . apply ( xsi . peek ( ) ) ) { break ; } xsi . next ( ) ; } return xsi ; } } ; } \n', 0.3520155015905121)

-('public static void cleanupLoop ( RouteAdvertisement route , PeerID localPeer ) { Vector hops = route . getVectorHops ( ) ; Vector newHops = new Vector ( hops . size ( ) ) ; Object lastHop = null ; if ( hops . size ( ) > 0 ) { lastHop = hops . elementAt ( hops . size ( ) - 1 ) ; } hops = ( ( RouteAdvertisement ) route . cloneOnlyPIDs ( ) ) . getVectorHops ( ) ; for ( int i = 0 ; i < hops . size ( ) ; i ++ ) { int loopAt = newHops . indexOf ( hops . elementAt ( i ) ) ; if ( loopAt != - 1 ) { for ( int j = newHops . size ( ) ; -- j > loopAt ; ) { newHops . remove ( j ) ; } } else { newHops . add ( hops . elementAt ( i ) ) ; } } if ( localPeer != null ) { for ( int i = newHops . size ( ) ; -- i >= 0 ; ) { if ( localPeer . equals ( ( ( AccessPointAdvertisement ) newHops . elementAt ( i ) ) . getPeerID ( ) ) ) { for ( int j = 0 ; j <= i ; j ++ ) { newHops . remove ( 0 ) ; } break ; } } } if ( lastHop != null && newHops . size ( ) > 0 ) { newHops . setElementAt ( lastHop , newHops . size ( ) - 1 ) ; } route . setHops ( newHops ) ; } \n', 0.350121442776346)

-('private void handleLoopEndCommand ( String line ) throws IllegalSyntaxException { checkCommandPattern ( line , Constant . COMMANDPARSER_COMMAND_LOOPEND_PARAMETER ) ; Loop loop ; try { loop = loopQueue . pop ( ) ; } catch ( EmptyStackException e ) { throw new IllegalSyntaxException ( ErrorMessages . COMMANDPARSER_ILLEGAL_PARAMETER , codeLine ) ; } int lastCommandListIndex = commandList . size ( ) ; for ( int i = 0 ; i < loop . getLoopLength ( ) - 1 ; i ++ ) { for ( int j = loop . getCommandListIndex ( ) ; j < lastCommandListIndex ; j ++ ) { Command command = commandList . get ( j ) . clone ( ) ; commandList . add ( command ) ; } } } \n', 0.34484413444090944)

-('public static void removeLoopTask ( final Runnable r ) { loopTasks . remove ( r ) ; } \n', 0.3416537963391302)

-('public void endAvoidNotify ( ) { avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.33474174737464607)

-('public void endAvoidNotify ( ) { org . simonme . tracer . logger . Tracer . traceMethodInvoke ( ) ; avoidNotify . remove ( Thread . currentThread ( ) ) ; } \n', 0.3324344539289146)

-('public Collection < Stmt > targetsOfLoopExit ( Stmt loopExit ) { assert getLoopExits ( ) . contains ( loopExit ) ; List < Unit > succs = g . getSuccsOf ( loopExit ) ; Collection < Stmt > res = new HashSet < Stmt > ( ) ; for ( Unit u : succs ) { Stmt s = ( Stmt ) u ; res . add ( s ) ; } res . removeAll ( loopStatements ) ; return res ; } \n', 0.3286593377256622)

-('private static void runSelectLoopMode ( ) throws MethodAndArgsCaller { ArrayList < FileDescriptor > fds = new ArrayList ( ) ; ArrayList < ZygoteConnection > peers = new ArrayList ( ) ; FileDescriptor [ ] fdArray = new FileDescriptor [ 4 ] ; fds . add ( sServerSocket . getFileDescriptor ( ) ) ; peers . add ( null ) ; int loopCount = GC_LOOP_COUNT ; while ( true ) { int index ; if ( loopCount <= 0 ) { gc ( ) ; loopCount = GC_LOOP_COUNT ; } else { loopCount -- ; } try { fdArray = fds . toArray ( fdArray ) ; index = selectReadable ( fdArray ) ; } catch ( IOException ex ) { throw new RuntimeException ( "Error-in-select()" , ex ) ; } if ( index < 0 ) { throw new RuntimeException ( "Error-in-select()" ) ; } else if ( index == 0 ) { ZygoteConnection newPeer = acceptCommandPeer ( ) ; peers . add ( newPeer ) ; fds . add ( newPeer . getFileDesciptor ( ) ) ; } else { boolean done ; done = peers . get ( index ) . runOnce ( ) ; if ( done ) { peers . remove ( index ) ; fds . remove ( index ) ; } } } } \n', 0.3262875789653783)

-('private void removeLoop ( Node loopingNode ) { int loopingNodeIndex = loopingNode . getRelativeIndex ( ) ; reindexedNodes = new LinkedHashSet < Node > ( ) ; int smallestReindexedInd = Integer . MAX_VALUE ; int loopsSize = 0 ; for ( Node successor : loopingNode . getSuccessors ( ) ) { int loopingChildIndex = successor . getRelativeIndex ( ) ; if ( loopingChildIndex < loopingNodeIndex ) { if ( loopingChildIndex < smallestReindexedInd ) smallestReindexedInd = loopingChildIndex ; int loopSize = countUniqueControlNodes ( successor ) ; loopsSize += loopSize ; nextIndex = loopingNodeIndex - loopSize + 1 ; reindexLoop ( successor ) ; } } reindexTheRest ( rootNode , smallestReindexedInd , loopingNodeIndex , loopsSize ) ; } \n', 0.3258320513151275)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 23 #################################
+('public static String generateMD5 ( String unhashed ) { String generated_md5 = null ; if ( unhashed == null ) return null ; try { MessageDigest digest = MessageDigest . getInstance ( "MD5" ) ; digest . update ( unhashed . getBytes ( ) , 0 , unhashed . length ( ) ) ; generated_md5 = new BigInteger ( 1 , digest . digest ( ) ) . toString ( 16 ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; } return generated_md5 ; } \n', 0.4331418272446791)

+('private static byte [ ] generateKeyFromPasswordSaltWithMD5 ( byte [ ] password , byte [ ] salt , int keyLen ) throws IOException { if ( salt . length < 8 ) throw new IllegalArgumentException ( "Salt-needs-to-be-at-least-8-bytes-for-key-generation." ) ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( "MD5" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "VM-does-not-support-MD5" , e ) ; } byte [ ] key = new byte [ keyLen ] ; byte [ ] tmp = new byte [ md5 . getDigestLength ( ) ] ; while ( true ) { md5 . update ( password , 0 , password . length ) ; md5 . update ( salt , 0 , 8 ) ; int copy = ( keyLen < tmp . length ) ? keyLen : tmp . length ; try { md5 . digest ( tmp , 0 , tmp . length ) ; } catch ( DigestException e ) { IOException ex = new IOException ( "could-not-digest-password" ) ; ex . initCause ( e ) ; throw ex ; } System . arraycopy ( tmp , 0 , key , key . length - keyLen , copy ) ; keyLen -= copy ; if ( keyLen == 0 ) return key ; md5 . update ( tmp , 0 , tmp . length ) ; } } \n', 0.4277104097002139)

+('public static String generateMD5 ( InputStream md5Stream ) throws SWORDException { String md5 = null ; try { MessageDigest md = MessageDigest . getInstance ( "MD5" ) ; md . reset ( ) ; byte [ ] bytes = new byte [ 1024 ] ; int count = 0 ; try { while ( ( count = md5Stream . read ( bytes ) ) != - 1 ) { md . update ( bytes , 0 , count ) ; } } catch ( IOException e ) { throw new SWORDException ( SWORDException . IO_ERROR , e ) ; } byte [ ] md5Digest = md . digest ( ) ; StringBuffer buffer = new StringBuffer ( ) ; for ( byte b : md5Digest ) { String hex = Integer . toHexString ( b & 0xFF ) ; if ( hex . length ( ) == 1 ) { buffer . append ( "0" ) ; } buffer . append ( hex ) ; } md5 = buffer . toString ( ) ; } catch ( NoSuchAlgorithmException ex ) { log . error ( "MD5-Algorithm-Not-found" ) ; throw new SWORDException ( SWORDException . MD5_MISSING ) ; } finally { if ( md5Stream != null ) { try { md5Stream . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return md5 ; } \n', 0.4236590780045079)

+('public static String generateMD5 ( String ... args ) throws NoSuchAlgorithmException { MessageDigest md ; try { byte [ ] colonBytes = ":" . getBytes ( ) ; md = MessageDigest . getInstance ( "MD5" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { String arg = args [ i ] ; md . update ( arg . getBytes ( ) ) ; if ( i != args . length - 1 ) { md . update ( colonBytes ) ; } } byte byteData [ ] = md . digest ( ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < byteData . length ; i ++ ) { sb . append ( Integer . toString ( ( byteData [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } return sb . toString ( ) ; } catch ( NoSuchAlgorithmException e ) { throw e ; } } \n', 0.4181341694256403)

+('public String generateSHA1checksum ( InputStream inputStream ) { try { if ( inputStream != null ) { MessageDigest md = MessageDigest . getInstance ( "SHA1" ) ; byte [ ] dataBytes = new byte [ 1024 ] ; int byteNumberRead = 0 ; while ( ( byteNumberRead = inputStream . read ( dataBytes ) ) != - 1 ) { md . update ( dataBytes , 0 , byteNumberRead ) ; } byte [ ] mdBytes = md . digest ( ) ; StringBuffer sb = new StringBuffer ( "" ) ; for ( int i = 0 ; i < mdBytes . length ; i ++ ) { sb . append ( Integer . toString ( ( mdBytes [ i ] & 0xff ) + 0x100 , 16 ) . substring ( 1 ) ) ; } inputStream . close ( ) ; return sb . toString ( ) ; } else { LOG . error ( "Input-stream-is-null!" ) ; } } catch ( Exception e ) { LOG . error ( "Could-not-generate-the-checksum." , e ) ; } return null ; } \n', 0.4166514420212687)

+('public void hashPassword ( ) throws SecurityError { if ( password == null || password . length < 4 ) { throw new SecurityError ( "Password-must-be-at-least-4-characters-long" ) ; } Random rand = new SecureRandom ( ) ; salt = new byte [ 20 ] ; rand . nextBytes ( salt ) ; byte [ ] b = concatenate ( password , salt ) ; password = null ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( "SHA-1" ) ; } catch ( NoSuchAlgorithmException e ) { Logger . error ( "Cannot-use-SHA-1" , e ) ; throw new Error ( e ) ; } sha1 = md . digest ( b ) ; } \n', 0.41116374969531605)

+('public void generateChallengeHash ( ) { if ( Constants . CRYPTO_OFF ) { byte [ ] concat = new byte [ R_1_size + R_2_size ] ; System . arraycopy ( R_1 , 0 , concat , 0 , R_1 . length ) ; System . arraycopy ( R_2 , 0 , concat , R_1 . length , R_2 . length ) ; this . challengePayload . challengeHash = concat ; } else { md . reset ( ) ; md . update ( R_1 ) ; md . update ( R_2 ) ; this . challengePayload . challengeHash = md . digest ( ) ; } } \n', 0.4098016663773416)

+('private static String generateCash ( String prefix , int value , MessageDigest md ) throws NoSuchAlgorithmException { SecureRandom rnd = SecureRandom . getInstance ( "SHA1PRNG" ) ; byte [ ] tmpBytes = new byte [ 4 ] ; rnd . nextBytes ( tmpBytes ) ; long random = unsignedIntToLong ( tmpBytes ) ; rnd . nextBytes ( tmpBytes ) ; long counter = unsignedIntToLong ( tmpBytes ) ; prefix = prefix + Long . toString ( random , 32 ) + ":" ; String temp ; int tempValue ; byte [ ] bArray ; do { counter ++ ; temp = prefix + Long . toHexString ( counter ) ; md . reset ( ) ; md . update ( temp . getBytes ( ) ) ; bArray = md . digest ( ) ; tempValue = numberOfLeadingZeros ( bArray ) ; } while ( tempValue < value ) ; return temp ; } \n', 0.4071737090356201)

+('public static byte [ ] generateMD5 ( byte [ ] data ) { try { byte [ ] md5 = MessageDigest . getInstance ( "MD5" ) . digest ( data ) ; String m = "" ; for ( int i = 0 ; i < md5 . length ; i ++ ) { m = m + byteToHexString ( md5 [ i ] ) . toUpperCase ( ) ; } return m . getBytes ( ) ; } catch ( NoSuchAlgorithmException e ) { e . printStackTrace ( ) ; return null ; } } \n', 0.40424129978469797)

-('public static String getSaltedMd5Hash ( String payload ) throws UnsupportedEncodingException , NoSuchAlgorithmException { final char [ ] saltRange = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" . toCharArray ( ) ; final StringBuilder sb = new StringBuilder ( ) ; final Random random = new Random ( ) ; for ( int i = 0 ; i < 2 ; i ++ ) { char c = saltRange [ random . nextInt ( saltRange . length ) ] ; sb . append ( c ) ; } final String salt = sb . toString ( ) ; return getMd5Hash ( salt + payload ) + ":" + salt ; } \n', 0.40422199249057467)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 9

########################## 24 #################################
+('public static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 3 ] ; } \n', 0.4429996253804881)

+('private static StackTraceElement getCurrentStackTraceElement ( ) { return Thread . currentThread ( ) . getStackTrace ( ) [ 4 ] ; } \n', 0.4429996253804881)

-('private StackTraceElement [ ] getInternalStackTrace ( ) { if ( stackTrace == null ) { stackTrace = getStackTraceImpl ( ) ; } return stackTrace ; } \n', 0.4411772637485003)

-('public static final String getBriefStackTrace ( Throwable t ) { return formatStackTrace ( null , t , ">>" , 6 ) . toString ( ) ; } \n', 0.43848245578733636)

-('private StackTrace getStackTraceFromSerial ( int ser ) throws IOException { if ( stackTraces == null ) { return null ; } StackTrace result = stackTraces . get ( new Integer ( ser ) ) ; if ( result == null ) { warn ( "Stack-trace-not-found-for-serial-#-" + ser ) ; } return result ; } \n', 0.43842363447935406)

-('public static String getStackTrace ( Exception exception ) { return getStackTrace ( ( Throwable ) exception ) ; } \n', 0.43762904330370306)

+('protected String getPartialServletStackTrace ( Throwable t ) { StringBuffer trace = new StringBuffer ( ) ; trace . append ( t . toString ( ) ) . append ( \'|n\' ) ; StackTraceElement [ ] elements = t . getStackTrace ( ) ; int pos = elements . length ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core.ApplicationFilterChain" ) ) && ( elements [ i ] . getMethodName ( ) . equals ( "internalDoFilter" ) ) ) { pos = i ; } } for ( int i = 0 ; i < pos ; i ++ ) { if ( ! ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core." ) ) ) { trace . append ( \'|t\' ) . append ( elements [ i ] . toString ( ) ) . append ( \'|n\' ) ; } } return trace . toString ( ) ; } \n', 0.4335079026276265)

+('public String getPartialServletStackTrace ( Throwable t ) { StringBuffer trace = new StringBuffer ( ) ; trace . append ( t . toString ( ) ) . append ( \'|n\' ) ; StackTraceElement [ ] elements = t . getStackTrace ( ) ; int pos = elements . length ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core.ApplicationFilterChain" ) ) && ( elements [ i ] . getMethodName ( ) . equals ( "internalDoFilter" ) ) ) { pos = i ; } } for ( int i = 0 ; i < pos ; i ++ ) { if ( ! ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core." ) ) ) { trace . append ( \'|t\' ) . append ( elements [ i ] . toString ( ) ) . append ( \'|n\' ) ; } } return trace . toString ( ) ; } \n', 0.4335079026276265)

-('public static String getStackTrace ( String title , Exception exception ) { return getStackTrace ( title , ( Throwable ) exception ) ; } \n', 0.4324274639843548)

+('protected String getPartialServletStackTrace ( Throwable t ) { StringBuilder trace = new StringBuilder ( ) ; trace . append ( t . toString ( ) ) . append ( \'|n\' ) ; StackTraceElement [ ] elements = t . getStackTrace ( ) ; int pos = elements . length ; for ( int i = elements . length - 1 ; i >= 0 ; i -- ) { if ( ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core.ApplicationFilterChain" ) ) && ( elements [ i ] . getMethodName ( ) . equals ( "internalDoFilter" ) ) ) { pos = i ; break ; } } for ( int i = 0 ; i < pos ; i ++ ) { if ( ! ( elements [ i ] . getClassName ( ) . startsWith ( "org.apache.catalina.core." ) ) ) { trace . append ( \'|t\' ) . append ( elements [ i ] . toString ( ) ) . append ( \'|n\' ) ; } } return trace . toString ( ) ; } \n', 0.43042476541565006)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 5

########################## 25 #################################
+('public static Collection sortListOfBensByProperty ( List lst , String getProperty , String typeOrder ) throws CompareException { if ( lst == null ) return new ArrayList < > ( ) ; Collections . sort ( lst , new ObjectSimpleComparator ( getProperty , typeOrder ) ) ; return lst ; } \n', 0.43651996656532577)

-('public Collection sort ( Object object , String property ) { List properties = new ArrayList ( 1 ) ; properties . add ( property ) ; if ( object instanceof Collection ) { return sort ( ( Collection ) object , properties ) ; } else if ( object instanceof Object [ ] ) { return sort ( ( Object [ ] ) object , properties ) ; } else if ( object instanceof Map ) { return sort ( ( Map ) object , properties ) ; } return null ; } \n', 0.41263685074800294)

-('private void sortProperties ( Property [ ] properties ) { Arrays . sort ( properties ) ; } \n', 0.4111116867002739)

+('public void sortProperties ( ) { Collections . sort ( properties , new Comparator < EscherProperty > ( ) { public int compare ( EscherProperty p1 , EscherProperty p2 ) { short s1 = p1 . getPropertyNumber ( ) ; short s2 = p2 . getPropertyNumber ( ) ; return s1 < s2 ? - 1 : s1 == s2 ? 0 : 1 ; } } ) ; } \n', 0.40933960607728537)

-('private void sortProperties ( ) { List < String > props = new ArrayList ( ) ; for ( Property pr : properties ) { props . add ( pr . toString ( ) ) ; } Collections . sort ( props ) ; properties . clear ( ) ; for ( String p : props ) { properties . add ( new Property ( p , false ) ) ; } } \n', 0.4080867770781451)

+('private IPropertyDescriptor [ ] sortPropertyDescriptors ( IPropertyDescriptor [ ] theDescriptors ) { List descriptors = Arrays . asList ( theDescriptors ) ; Collections . sort ( descriptors , new DescriptorSorter ( ) ) ; return ( IPropertyDescriptor [ ] ) descriptors . toArray ( new IPropertyDescriptor [ descriptors . size ( ) ] ) ; } \n', 0.3984002850016318)

-('private static Query ensureSortProperties ( Query nativeQuery , SortBy [ ] sortBy ) { LinkedHashSet < PropertyName > sortProperties = new LinkedHashSet < > ( ) ; for ( SortBy sb : sortBy ) { PropertyName pn = sb . getPropertyName ( ) ; if ( pn != null ) { sortProperties . add ( pn ) ; } } List < PropertyName > nativeProperties = nativeQuery . getProperties ( ) ; Query q = new Query ( nativeQuery ) ; if ( nativeProperties == Query . ALL_PROPERTIES ) { q . setProperties ( new ArrayList < > ( sortProperties ) ) ; } else { List < PropertyName > allProperties = new ArrayList < > ( nativeProperties ) ; for ( PropertyName propertyName : sortProperties ) { if ( ! allProperties . contains ( propertyName ) ) { allProperties . add ( propertyName ) ; } } q . setProperties ( allProperties ) ; } return q ; } \n', 0.3849829002405464)

-('public static ArrayList < Feature > sortFeatureListByAttributeBeginWithSmallest ( List < Feature > features , String attributeNameForSorting ) { ArrayList < Feature > sortedFeatureList = new ArrayList < Feature > ( ) ; ArrayList < Double > sortedValueList = new ArrayList < Double > ( ) ; int i = 0 ; boolean first = true ; for ( Iterator iterator = features . iterator ( ) ; iterator . hasNext ( ) ; ) { Feature f = ( Feature ) iterator . next ( ) ; if ( first ) { sortedFeatureList . add ( f . clone ( true ) ) ; double valuef = FeatureCollectionTools . getNumericalAttributeValue ( f , attributeNameForSorting ) ; sortedValueList . add ( valuef ) ; first = false ; } else { double valuef = FeatureCollectionTools . getNumericalAttributeValue ( f , attributeNameForSorting ) ; boolean isLarger = true ; int j = 0 ; while ( isLarger ) { double valueFtemp = sortedValueList . get ( j ) ; if ( valuef >= valueFtemp ) { } else { sortedFeatureList . add ( j , f . clone ( true ) ) ; sortedValueList . add ( j , valuef ) ; isLarger = false ; } if ( j + 1 == sortedFeatureList . size ( ) ) { sortedFeatureList . add ( f . clone ( true ) ) ; sortedValueList . add ( valuef ) ; isLarger = false ; } j ++ ; } } i ++ ; } return sortedFeatureList ; } \n', 0.38436667226063803)

-('private static List < Properties > sortProperties ( List < Properties > allProperties ) { List < Properties > sortedProperties = new ArrayList < Properties > ( ) ; for ( Properties p : allProperties ) { int configOrder = getConfigurationOrdinal ( p ) ; int i ; for ( i = 0 ; i < sortedProperties . size ( ) ; i ++ ) { int listConfigOrder = getConfigurationOrdinal ( sortedProperties . get ( i ) ) ; if ( listConfigOrder > configOrder ) { break ; } } sortedProperties . add ( i , p ) ; } return sortedProperties ; } \n', 0.3840007457616828)

-('public List < Module > sort ( List < Module > loadables ) { List < Module > sortedLoadables = new ArrayList < Module > ( ) ; List < String > names = new ArrayList < String > ( ) ; for ( Loadable t : loadables ) { names . add ( t . getName ( ) ) ; } Collections . sort ( names ) ; for ( String name : names ) { for ( Module t : loadables ) { if ( t . getName ( ) . equals ( name ) ) { sortedLoadables . add ( t ) ; } } } return sortedLoadables ; } \n', 0.372532615699365)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 3

########################## 26 #################################
+('public static double roundToDecimalPlaces ( final double val , final int decimalPlaces ) { String zeros = "1" ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { zeros += "0" ; } int decimal = Integer . valueOf ( zeros ) . intValue ( ) ; if ( ! isNullOrZero ( val ) ) { return ( double ) Math . round ( val * decimal ) / decimal ; } return val ; } \n', 0.47474848012569243)

-('public static Double roundToDecimalPlaces ( final Double val , final int decimalPlaces ) { if ( ! isNullOrZero ( val ) ) { return Double . valueOf ( roundToDecimalPlaces ( val . doubleValue ( ) , decimalPlaces ) ) ; } return val ; } \n', 0.4708190755488689)

+('public static float roundDecimal ( float value , double places ) { double multiplier = Math . pow ( 10 , places ) ; value *= multiplier ; return ( float ) ( Math . round ( value ) / multiplier ) ; } \n', 0.46927089065622263)

+('public static Double roundToNDecimalPlaces ( Double toBeFormatted , int nDecimalPlaces ) { double decPlacesFact = Math . pow ( 10 , nDecimalPlaces ) ; return ( double ) Math . round ( toBeFormatted * decPlacesFact ) / decPlacesFact ; } \n', 0.46764733215472787)

+('public static float roundFloat ( float number , int decimalPlace ) { try { BigDecimal bd = new BigDecimal ( String . valueOf ( number ) ) ; bd = bd . setScale ( decimalPlace , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } catch ( Exception e ) { logger . error ( e ) ; return number ; } } \n', 0.46368390074375193)

+('public double round ( double val , int places ) { return Util . round ( val , places ) ; } \n', 0.4629896911742747)

+('protected double roundToDecimalPlaces ( double number , int decimalPlace , boolean place ) { int temp = 1 ; for ( int i = 0 ; i < decimalPlace ; i ++ ) { temp = temp * 10 ; } if ( place ) { number = number / temp ; number = Math . round ( number ) ; number = number * temp ; } else { number = number * temp ; number = Math . round ( number ) ; number = number / temp ; } return number ; } \n', 0.462814356628056)

+('public static double roundBigDecimalDouble ( double d , int decimalPlaces ) { BigDecimal bd = new BigDecimal ( Double . toString ( d ) ) ; bd = bd . setScale ( decimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . doubleValue ( ) ; } \n', 0.46216983525252214)

+('public static float round ( float num , int decimalPlaces ) { float digit = 1 ; for ( int i = 0 ; i < decimalPlaces ; i ++ ) { digit *= 10 ; } return Math . round ( num * digit ) / digit ; } \n', 0.4608344527940348)

+('public static float round ( float valueToRound , int numDecimalPlaces ) { BigDecimal bd = new BigDecimal ( Float . toString ( valueToRound ) ) ; bd = bd . setScale ( numDecimalPlaces , BigDecimal . ROUND_HALF_UP ) ; return bd . floatValue ( ) ; } \n', 0.4595635904307136)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 9

########################## 27 #################################
+('public static String leftPadWithZeros ( String input , int expectedSize ) { if ( input == null ) { return leftPadWithZeros ( "" , expectedSize ) ; } StringBuilder sb = new StringBuilder ( expectedSize ) ; for ( int i = expectedSize - input . length ( ) ; i > 0 ; i -- ) { sb . append ( ZERO ) ; } sb . append ( input ) ; return sb . toString ( ) ; } \n', 0.40673119992920004)

+('@ NonNull public static String leftPadWithZeros ( @ Nullable final String toPad , final int finalSize ) { final StringBuilder temp = new StringBuilder ( ) ; if ( CoreLibConstants . IS_PARAMETER_CHECKING_ENABLED ) { if ( finalSize < 0 ) { throw new IllegalArgumentException ( "finalSize-cannot-be-negative" ) ; } } if ( null != toPad ) { temp . append ( toPad ) ; } if ( temp . length ( ) < finalSize ) { do { temp . insert ( 0 , \'0\' ) ; } while ( finalSize != temp . length ( ) ) ; } return temp . toString ( ) ; } \n', 0.4060354117236279)

+('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40178837872132317)

+('public static String leftPad ( final String str , final int size , final char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > StringUtils . PAD_LIMIT ) { return StringUtils . leftPad ( str , size , String . valueOf ( padChar ) ) ; } return StringUtils . padding ( pads , padChar ) . concat ( str ) ; } \n', 0.40175002810435456)

-("protected void zeroPadAfterSignWithGroupingFixup ( int groupSize , char comma ) { int firstZero = start + lenSign ; int p = firstZero + lenWhole ; int step = groupSize + 1 ; for ( p = p - step ; p >= firstZero ; p -= step ) { result . setCharAt ( p , comma ) ; } if ( p + step == firstZero ) { result . insert ( firstZero , '0' ) ; lenWhole += 1 ; } } \n", 0.39925411606674444)

+('private static String zeroLeftPad ( int value , int len ) { final String strValue = String . valueOf ( value ) ; if ( strValue . length ( ) >= len ) return strValue ; final StringBuffer sb = new StringBuffer ( len ) ; for ( int i = strValue . length ( ) ; i < len ; i ++ ) { sb . append ( "0" ) ; } return sb . append ( strValue ) . toString ( ) ; } \n', 0.38970889284984866)

+('public static String leftPad ( String str , int size , String padStr ) { if ( str == null ) { return null ; } if ( isNullOrEmpty ( padStr ) ) { padStr = "-" ; } int padLen = padStr . length ( ) ; int strLen = str . length ( ) ; int pads = size - strLen ; if ( pads <= 0 ) { return str ; } if ( pads == padLen ) { return padStr . concat ( str ) ; } else if ( pads < padLen ) { return padStr . substring ( 0 , pads ) . concat ( str ) ; } else { char [ ] padding = new char [ pads ] ; char [ ] padChars = padStr . toCharArray ( ) ; for ( int i = 0 ; i < pads ; i ++ ) { padding [ i ] = padChars [ i % padLen ] ; } return new String ( padding ) . concat ( str ) ; } } \n', 0.38567862025131094)

+('public static String leftPad ( String str , int size , char padChar ) { if ( str == null ) { return null ; } int pads = size - str . length ( ) ; if ( pads <= 0 ) { return str ; } if ( pads > PAD_LIMIT ) { return leftPad ( str , size , String . valueOf ( padChar ) ) ; } return repeat ( padChar , pads ) . concat ( str ) ; } \n', 0.3855200469850956)

+('public static String leftPadZero ( int val , int length ) { if ( val < 0 ) { throw new IllegalArgumentException ( "Cannot-left-pad-a-negative-number-(" + val + ")" ) ; } String valString = Integer . toString ( val ) ; if ( valString . length ( ) > length ) { throw new IllegalArgumentException ( "Cannot-truncate-" + val + "-to-a-length-of-" + length + "-without-data-loss" ) ; } StringBuilder builder = new StringBuilder ( length ) ; int padding = length - valString . length ( ) ; for ( int i = 0 ; i < padding ; i ++ ) { builder . append ( "0" ) ; } builder . append ( valString ) ; return builder . toString ( ) ; } \n', 0.3854418889064096)

+('public static byte [ ] padWithLeadingZeroes ( byte [ ] input , int wantedLength ) { if ( wantedLength < input . length ) { throw new IllegalArgumentException ( "Wanted-length-is-smaller-than-the-input-length" ) ; } byte [ ] zeroes = new byte [ wantedLength - input . length ] ; return Utils . concatByteArrays ( zeroes , input ) ; } \n', 0.38330660619757534)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 9

########################## 28 #################################
-('public static < ArrayType > PermutationGenerator < ArrayType > createOptimizedGenerator ( ArrayType array ) { OptimizedGeneratorCreator creator = _optimizedGeneratorCreators . get ( array . getClass ( ) ) ; if ( creator == null ) { throw new NoSuchOptimizedPermutationGeneratorException ( array . getClass ( ) ) ; } return creator . createOptimizedGenerator ( array ) ; } \n', 0.30212441214158237)

-('public static int [ ] generateDisorderedIntArrayWithExistingArray ( int [ ] array ) { int [ ] indexArray = generateNotDuplicatedIntArray ( array . length ) ; int [ ] resultArray = new int [ array . length ] ; for ( int i = 0 ; i < resultArray . length ; i ++ ) { resultArray [ i ] = array [ indexArray [ i ] - 1 ] ; } return resultArray ; } \n', 0.2730459346730608)

-('@ SafeVarargs public static < T > TestDataGenerator < ArrayList < T >> arrayListGenerator ( final T ... elements ) { return new TestDataGenerator < ArrayList < T >> ( ) { @ Override public ArrayList < T > generate ( ) { return new ArrayList < T > ( Arrays . asList ( elements ) ) ; } } ; } \n', 0.2646186274142995)

+('private BindingStrategy buildAggregateDefaultFactoryBindings ( ) { Collection < Type [ ] > generics = new ArrayList < Type [ ] > ( ) ; if ( aggregateOrVOClasses != null && ! aggregateOrVOClasses . isEmpty ( ) ) { for ( Class < ? > aggregateClass : aggregateOrVOClasses ) { generics . add ( new Type [ ] { aggregateClass } ) ; } } if ( ! generics . isEmpty ( ) ) { return new GenericBindingStrategy < Factory > ( Factory . class , FactoryInternal . class , generics ) ; } return null ; } \n', 0.26102403605791213)

-('public Type [ ] getGenericInterfaces ( ) { Type [ ] result ; synchronized ( Caches . genericInterfaces ) { result = Caches . genericInterfaces . get ( this ) ; if ( result == null ) { String annotationSignature = AnnotationAccess . getSignature ( this ) ; if ( annotationSignature == null ) { result = getInterfaces ( ) ; } else { GenericSignatureParser parser = new GenericSignatureParser ( getClassLoader ( ) ) ; parser . parseForClass ( this , annotationSignature ) ; result = Types . getTypeArray ( parser . interfaceTypes , false ) ; } Caches . genericInterfaces . put ( this , result ) ; } } return ( result . length == 0 ) ? result : result . clone ( ) ; } \n', 0.25291219715394897)

-('public String toGenericString ( ) { StringBuilder sb = new StringBuilder ( 80 ) ; initGenericTypes ( ) ; int modifier = getModifiers ( ) ; if ( modifier != 0 ) { sb . append ( Modifier . toString ( modifier & ~ Modifier . VARARGS ) ) . append ( \'-\' ) ; } if ( formalTypeParameters != null && formalTypeParameters . length > 0 ) { sb . append ( \'<\' ) ; for ( int i = 0 ; i < formalTypeParameters . length ; i ++ ) { appendGenericType ( sb , formalTypeParameters [ i ] ) ; if ( i < formalTypeParameters . length - 1 ) { sb . append ( ",-" ) ; } } sb . append ( ">-" ) ; } appendArrayType ( sb , getDeclaringClass ( ) ) ; sb . append ( \'(\' ) ; appendArrayGenericType ( sb , Types . getClonedTypeArray ( genericParameterTypes ) ) ; sb . append ( \')\' ) ; Type [ ] genericExceptionTypeArray = Types . getClonedTypeArray ( genericExceptionTypes ) ; if ( genericExceptionTypeArray . length > 0 ) { sb . append ( "-throws-" ) ; appendArrayGenericType ( sb , genericExceptionTypeArray ) ; } return sb . toString ( ) ; } \n', 0.23571254121296767)

-('public Type [ ] getGenericExceptionTypes ( ) throws GenericSignatureFormatError , TypeNotPresentException , MalformedParameterizedTypeException { if ( data . genericExceptionTypes == null ) { data . genericExceptionTypes = Parser . getGenericExceptionTypes ( this , VMGenericsAndAnnotations . getSignature ( data . vm_member_id ) ) ; } return ( Type [ ] ) data . genericExceptionTypes . clone ( ) ; } \n', 0.23483418520578248)

-('List < FrameworkMethod > generateExplodedTestMethodsFor ( List < FrameworkMethod > testMethods ) { List < FrameworkMethod > result = new ArrayList < FrameworkMethod > ( ) ; if ( testMethods == null ) { return result ; } for ( FrameworkMethod testMethod : testMethods ) { FrameworkMethod dataProviderMethod = getDataProviderMethod ( testMethod ) ; result . addAll ( testGenerator . generateExplodedTestMethodsFor ( testMethod , dataProviderMethod ) ) ; } return result ; } \n', 0.224132406263398)

-('private List < MethodTree > generateTestMethods ( TypeElement srcClass , CharSequence instanceClsName , List < ExecutableElement > srcMethods , WorkingCopy workingCopy ) { if ( srcMethods . isEmpty ( ) ) { return Collections . < MethodTree > emptyList ( ) ; } List < String > testMethodNames = TestMethodNameGenerator . getTestMethodNames ( srcMethods , null , null , workingCopy ) ; Iterator < ExecutableElement > srcMethodsIt = srcMethods . iterator ( ) ; Iterator < String > tstMethodNamesIt = testMethodNames . iterator ( ) ; List < MethodTree > testMethods = new ArrayList < MethodTree > ( srcMethods . size ( ) ) ; while ( srcMethodsIt . hasNext ( ) ) { assert tstMethodNamesIt . hasNext ( ) ; ExecutableElement srcMethod = srcMethodsIt . next ( ) ; String testMethodName = tstMethodNamesIt . next ( ) ; testMethods . add ( generateTestMethod ( srcClass , srcMethod , testMethodName , instanceClsName , workingCopy ) ) ; } assert ! tstMethodNamesIt . hasNext ( ) ; return testMethods ; } \n', 0.2223495898100731)

-('public static BigInteger [ ] genPrimePair ( final int keysize , final SecureRandom secureRandom ) { final RSAKeyGenParameterSpec spec = new RSAKeyGenParameterSpec ( keysize , internalParameterForRSAKeyPairGeneration ) ; final KeyPairGenerator keyPairGenerator ; try { keyPairGenerator = KeyPairGenerator . getInstance ( internalKeyPairGeneratorAlgorithmName ) ; } catch ( NoSuchAlgorithmException e ) { logger . error ( "caught-exception" , e ) ; throw new InternalError ( "unacceptable-exception-is-occurred" ) ; } logger . trace ( "Selected-key-generation-algorithm-is-"{}"" , keyPairGenerator . getAlgorithm ( ) ) ; logger . trace ( "Its-provider-is-"{}"" , keyPairGenerator . getProvider ( ) ) ; try { keyPairGenerator . initialize ( spec , secureRandom ) ; } catch ( InvalidAlgorithmParameterException e ) { logger . error ( "caught-exception-with-inputs-({},-{})" , keysize , secureRandom ) ; logger . error ( "output-stack-trace" , e ) ; throw new IllegalArgumentException ( e ) ; } final KeyPair pair = keyPairGenerator . generateKeyPair ( ) ; final RSAPrivateCrtKey crtKey = ( RSAPrivateCrtKey ) pair . getPrivate ( ) ; logger . trace ( "Generated-RSA-private-CRT-key-is:%n{}" , crtKey ) ; return new BigInteger [ ] { crtKey . getPrimeP ( ) , crtKey . getPrimeQ ( ) } ; } \n', 0.22174621448631437)

FRank: 4  | P@1: 0  | P@5: 1  | P@10: 1

########################## 29 #################################
+('public static PrefixEncodedLexicographicallySortedDictionary loadFromPlainTextFile ( Path path , FileSystem fs , int window ) throws IOException { LOG . info ( "Reading-from-" + path ) ; LineReader reader = new LineReader ( fs . open ( path ) ) ; PrefixEncodedLexicographicallySortedDictionary terms = new PrefixEncodedLexicographicallySortedDictionary ( window ) ; int cnt = 0 ; Text t = new Text ( ) ; while ( reader . readLine ( t ) > 0 ) { String term = t . toString ( ) ; if ( term . contains ( "-" ) ) { term = term . split ( "|t" ) [ 0 ] ; } terms . add ( term ) ; cnt ++ ; if ( cnt % 1000000 == 0 ) { LOG . info ( "read-" + cnt + "-lines" ) ; } } LOG . info ( "Finished-reading-from-" + path ) ; LOG . info ( "compression-ratio:-" + terms . getCompresssionRatio ( ) ) ; return terms ; } \n', 0.40723575545112345)

+('private void readInFile ( ) { plainText = "" ; String temp = "" ; try { BufferedReader bufferIn = new BufferedReader ( new FileReader ( file ) ) ; while ( ( temp = bufferIn . readLine ( ) ) != null ) { plainText += temp ; } bufferIn . close ( ) ; } catch ( IOException e ) { } wellFormCheck ( ) ; } \n', 0.3851581340756116)

+('protected void process_plainTextFile ( ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( fileName ) ) ; String zeile = reader . readLine ( ) ; StringBuffer buffer = new StringBuffer ( "" ) ; while ( zeile != null ) { buffer . append ( zeile + System . getProperty ( "line.separator" ) ) ; zeile = reader . readLine ( ) ; } fullText = buffer . toString ( ) ; } \n', 0.3816530877984642)

-('public PlainTextGISModelReader ( File f ) throws IOException { if ( f . getName ( ) . endsWith ( ".gz" ) ) { input = new BufferedReader ( new InputStreamReader ( new BufferedInputStream ( new GZIPInputStream ( new BufferedInputStream ( new FileInputStream ( f ) ) ) ) ) ) ; } else { input = new BufferedReader ( new FileReader ( f ) ) ; } } \n', 0.3762148568804501)

-('private ClassListToReportCollector constructPlainTextReader ( ) { BufferedReader br ; try { br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( classListFile ) , Charset . forName ( "UTF-8" ) ) ) ; } catch ( FileNotFoundException e ) { throw new ClassListException ( "Could-not-read-class-names-from-given-file-(" + classListFile . getAbsolutePath ( ) + ")" , e ) ; } return new PlainTextClassListToReportReader ( br ) ; } \n', 0.3749456331349588)

+('public static StringBuffer readPlainFile ( File f ) throws IOException { BufferedReader in = new BufferedReader ( new FileReader ( f ) ) ; StringBuffer strbuffer = new StringBuffer ( ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { strbuffer . append ( line + "-" ) ; } return strbuffer ; } \n', 0.371641789617302)

+('private String readFileInPlain ( String input ) throws IOException { StringBuilder contents = new StringBuilder ( ) ; FileInputStream fstream = new FileInputStream ( input ) ; DataInputStream in = new DataInputStream ( fstream ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = "" ; try { while ( ( line = br . readLine ( ) ) != null ) { if ( ! line . isEmpty ( ) ) { contents . append ( line ) ; } } } finally { br . close ( ) ; in . close ( ) ; } return contents . toString ( ) . replace ( "-" , "" ) ; } \n', 0.3698517464942621)

-('public PlainTextFileDataReader ( File f ) throws IOException { if ( f . getName ( ) . endsWith ( ".gz" ) ) { input = new BufferedReader ( new InputStreamReader ( new BufferedInputStream ( new GZIPInputStream ( new BufferedInputStream ( new FileInputStream ( f ) ) ) ) ) ) ; } else { input = new BufferedReader ( new InputStreamReader ( new BufferedInputStream ( new FileInputStream ( f ) ) ) ) ; } } \n', 0.36915375843376325)

-('public static void extractPlainText ( File file , StringBuilder stringBuilder ) throws IOException , SAXException , ParserConfigurationException { InputStream inputStream = new BufferedInputStream ( new FileInputStream ( file ) ) ; extractPlainText ( inputStream , stringBuilder ) ; } \n', 0.3598470434557829)

+('public static void processPlainTextFile ( String url , @ Nonnull BiConsumer < Integer , String > processLine ) throws IOException { BufferedReader in = getPlainTextFile ( url ) ; int line = 0 ; String string ; while ( ( string = in . readLine ( ) ) != null ) { processLine . accept ( line , string ) ; line ++ ; } in . close ( ) ; } \n', 0.35877525517076797)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 6

########################## 30 #################################
-('private < U , V > Iterator < ? > createIteratorForCascadedValue ( ValueContext < U , V > context , Type type , Object value ) { Iterator < ? > iter ; if ( ReflectionHelper . isIterable ( type ) ) { iter = ( ( Iterable < ? > ) value ) . iterator ( ) ; context . markCurrentPropertyAsIterable ( ) ; } else if ( ReflectionHelper . isMap ( type ) ) { Map < ? , ? > map = ( Map < ? , ? > ) value ; iter = map . entrySet ( ) . iterator ( ) ; context . markCurrentPropertyAsIterable ( ) ; } else if ( TypeUtils . isArray ( type ) ) { List < ? > arrayList = Arrays . asList ( ( Object [ ] ) value ) ; iter = arrayList . iterator ( ) ; context . markCurrentPropertyAsIterable ( ) ; } else { List < Object > list = new ArrayList < Object > ( ) ; list . add ( value ) ; iter = list . iterator ( ) ; } return iter ; } \n', 0.34114182121102476)

-('public IdentityHashtable collectAndPrepareObjectsForCommit ( ) { IdentityHashtable changedObjects = new IdentityHashtable ( 1 + getCloneMapping ( ) . size ( ) ) ; if ( ! getProject ( ) . isPureCMP2Project ( ) ) { assignSequenceNumbers ( ) ; } for ( Enumeration clonesEnum = getCloneMapping ( ) . keys ( ) ; clonesEnum . hasMoreElements ( ) ; ) { Object clone = clonesEnum . nextElement ( ) ; changedObjects . put ( clone , clone ) ; } for ( Enumeration unregisteredNewObjectsEnum = getUnregisteredNewObjects ( ) . keys ( ) ; unregisteredNewObjectsEnum . hasMoreElements ( ) ; ) { Object newObject = unregisteredNewObjectsEnum . nextElement ( ) ; changedObjects . put ( newObject , newObject ) ; } return changedObjects ; } \n', 0.3401552940914782)

-('Iterator getIteratorForIterable ( Object iterateOverMe ) { Iterator it = null ; try { Class c = Class . forName ( "java.lang.Iterable" ) ; if ( c . isInstance ( iterateOverMe ) ) { try { Method m = c . getMethod ( "iterator" , new Class [ 0 ] ) ; it = ( Iterator ) m . invoke ( iterateOverMe , new Object [ 0 ] ) ; } catch ( Exception e ) { throw new InterpreterError ( "Unexpected-problem-calling-" + ""iterator()"-on-instance-of-java.lang.Iterable." + e ) ; } } } catch ( ClassNotFoundException cnfe ) { } return it ; } \n', 0.33771358694659687)

+('protected boolean _acceptJsonFormatVisitorForEnum ( JsonFormatVisitorWrapper visitor , JavaType typeHint , Class < ? > enumType ) throws JsonMappingException { JsonStringFormatVisitor stringVisitor = visitor . expectStringFormat ( typeHint ) ; if ( stringVisitor != null ) { Set < String > enums = new LinkedHashSet < String > ( ) ; for ( Object en : enumType . getEnumConstants ( ) ) { try { enums . add ( String . valueOf ( _accessorMethod . invoke ( en ) ) ) ; } catch ( Exception e ) { Throwable t = e ; while ( t instanceof InvocationTargetException && t . getCause ( ) != null ) { t = t . getCause ( ) ; } if ( t instanceof Error ) { throw ( Error ) t ; } throw JsonMappingException . wrapWithPath ( t , en , _accessorMethod . getName ( ) + "()" ) ; } } stringVisitor . enumTypes ( enums ) ; } return true ; } \n', 0.3328698093681087)

-('public IdentityHashtable collectAndPrepareObjectsForNestedMerge ( ) { IdentityHashtable changedObjects = new IdentityHashtable ( 1 + getCloneMapping ( ) . size ( ) ) ; discoverAllUnregisteredNewObjects ( ) ; for ( Enumeration clonesEnum = getCloneMapping ( ) . keys ( ) ; clonesEnum . hasMoreElements ( ) ; ) { Object clone = clonesEnum . nextElement ( ) ; changedObjects . put ( clone , clone ) ; } for ( Enumeration unregisteredNewObjectsEnum = getUnregisteredNewObjects ( ) . keys ( ) ; unregisteredNewObjectsEnum . hasMoreElements ( ) ; ) { Object newObject = unregisteredNewObjectsEnum . nextElement ( ) ; changedObjects . put ( newObject , newObject ) ; } return changedObjects ; } \n', 0.3318936336316881)

-('public Collection < Stmt > targetsOfLoopExit ( Stmt loopExit ) { assert getLoopExits ( ) . contains ( loopExit ) ; List < Unit > succs = g . getSuccsOf ( loopExit ) ; Collection < Stmt > res = new HashSet < Stmt > ( ) ; for ( Unit u : succs ) { Stmt s = ( Stmt ) u ; res . add ( s ) ; } res . removeAll ( loopStatements ) ; return res ; } \n', 0.32473910961756125)

-('public static < E > void forAllDo ( Iterable < E > iterable , Closure < ? super E > closure ) { if ( iterable != null && closure != null ) { for ( Iterator < E > it = iterable . iterator ( ) ; it . hasNext ( ) ; ) { closure . execute ( it . next ( ) ) ; } } } \n', 0.32361818518589225)

-('public List < LoopInfo > collectPossibleLoopsInfo ( ) { LinkedList < LoopInfo > loopInfos = new LinkedList < LoopInfo > ( ) ; List < LoopInfo > list ; for ( Map . Entry < Object , CaseEntry > entry : caseMap . entrySet ( ) ) { if ( ( list = StatementUtil . collectPossibleLoopsInfo ( entry . getValue ( ) . body ) ) != null ) { loopInfos . addAll ( list ) ; } } LoopInfo loopInfo ; for ( Iterator < LoopInfo > it = loopInfos . iterator ( ) ; it . hasNext ( ) ; ) { if ( ( loopInfo = it . next ( ) ) . matchLabel ( this . label ) && loopInfo . type == LoopInfo . BREAK ) { it . remove ( ) ; } } return loopInfos . isEmpty ( ) ? null : loopInfos ; } \n', 0.31991061173836927)

-('protected void forEachMember ( boolean withTreeLock , final Iter iter ) { Runnable r = new Runnable ( ) { public void run ( ) { for ( Iterator < PollableElement > it = getMembers ( ) . iterator ( ) ; it . hasNext ( ) ; ) { PollableElement element = it . next ( ) ; iter . forEachElement ( element ) ; } } } ; if ( withTreeLock ) { withTreeLock ( r ) ; } else { r . run ( ) ; } } \n', 0.312698851709297)

-('public void detectDependencyLoop ( Set nodes ) throws DependencyLoopException { Set availableNodes = new HashSet ( nodes ) ; while ( ! availableNodes . isEmpty ( ) ) { DependentNode leafNode = findLeafNode ( availableNodes ) ; if ( leafNode != null ) { availableNodes . remove ( leafNode ) ; continue ; } throw new DependencyLoopException ( DependencyLoopException . getMessage ( availableNodes ) ) ; } } \n', 0.31169839832330604)

FRank: 4  | P@1: 0  | P@5: 1  | P@10: 1

########################## 31 #################################
-('public static void checkLoaded ( ) { if ( LOAD_ERROR != null ) { throw LOAD_ERROR ; } BigInteger two = BigInteger . valueOf ( 2 ) ; BigInteger three = BigInteger . valueOf ( 3 ) ; BigInteger five = BigInteger . valueOf ( 5 ) ; BigInteger answer ; answer = modPowInsecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowInsecure-returned-the-wrong-answer" ) ; } answer = modPowSecure ( two , three , five ) ; if ( ! three . equals ( answer ) ) { throw new AssertionError ( "libgmp-is-loaded-but-modPowSecure-returned-the-wrong-answer" ) ; } } \n', 0.3468051299255108)

-('public static boolean arePercentagesHeavy ( int [ ] weekOne , int [ ] weekTwo , int [ ] weekThree , int [ ] weekFour ) { return Arrays . equals ( weekOne , WendlerConstants . HEAVY_PERCENTAGES_W_1 ) && Arrays . equals ( weekTwo , WendlerConstants . HEAVY_PERCENTAGES_W_2 ) && Arrays . equals ( weekThree , WendlerConstants . HEAVY_PERCENTAGES_W_3 ) && Arrays . equals ( weekFour , WendlerConstants . HEAVY_PERCENTAGES_W_4 ) ; } \n', 0.3403453909461178)

-('protected boolean determineShouldBeAtLeastGrayChecked ( Object treeElement ) { List < Object > checked = fCheckedStateStore . get ( treeElement ) ; if ( checked != null && ( ! checked . isEmpty ( ) ) ) return true ; Object [ ] children = getTreeChildren ( treeElement ) ; for ( int i = 0 ; i < children . length ; ++ i ) { if ( fCheckedStateStore . containsKey ( children [ i ] ) ) return true ; } return false ; } \n', 0.33678344797618776)

-('public static boolean arePercentagesFresh ( int [ ] weekOne , int [ ] weekTwo , int [ ] weekThree , int [ ] weekFour ) { return Arrays . equals ( weekOne , WendlerConstants . FRESH_PERCENTAGES_W_1 ) && Arrays . equals ( weekTwo , WendlerConstants . FRESH_PERCENTAGES_W_2 ) && Arrays . equals ( weekThree , WendlerConstants . FRESH_PERCENTAGES_W_3 ) && Arrays . equals ( weekFour , WendlerConstants . FRESH_PERCENTAGES_W_4 ) ; } \n', 0.3306122289402752)

-('public static boolean isThreeJosa ( String josa ) { return ( JOSA_THREE . get ( josa ) != null ) ; } \n', 0.31910898473178245)

-('private void checkThreeOfKind ( int currentPlayer ) { int score = 0 ; if ( ones . size ( ) >= 3 || twos . size ( ) >= 3 || threes . size ( ) >= 3 || fours . size ( ) >= 3 || fives . size ( ) >= 3 || sixes . size ( ) >= 3 ) { for ( int i = 0 ; i < N_DICE ; i ++ ) { score += allDices [ i ] ; } } eachCategoryScore [ currentPlayer ] [ category ] = score ; } \n', 0.31145353746588295)

-('public static boolean isProbablePrime ( BigInteger n ) { if ( n . compareTo ( ZERO ) <= 0 ) return false ; if ( n . equals ( ONE ) ) return false ; if ( n . equals ( TWO ) ) return true ; if ( n . equals ( THREE ) ) return true ; if ( n . mod ( TWO ) . equals ( ZERO ) ) return false ; for ( int i = 0 ; i < ITERATIONS ; i ++ ) { BigInteger a ; do { a = new BigInteger ( n . bitLength ( ) , rand ) ; } while ( a . compareTo ( ONE ) <= 0 || a . compareTo ( n . subtract ( ONE ) ) >= 0 ) ; if ( isWitness ( a , n ) ) return false ; } return true ; } \n', 0.3090957167293948)

-('public static boolean validateTimeSlot ( String slot ) { if ( slot . equals ( timeSlotOne ) || slot . equals ( timeSlotTwo ) || slot . equals ( timeSlotThree ) || slot . equals ( timeSlotFour ) || slot . equals ( timeSlotFive ) ) { return true ; } return false ; } \n', 0.30770490678510015)

-('public void testReplacementAfterExchange ( ) throws InterruptedException { final Exchanger e = new Exchanger ( ) ; Thread t1 = new Thread ( new CheckedInterruptedRunnable ( ) { public void realRun ( ) throws InterruptedException { assertSame ( two , e . exchange ( one ) ) ; e . exchange ( two ) ; } } ) ; Thread t2 = new Thread ( new CheckedRunnable ( ) { public void realRun ( ) throws InterruptedException { assertSame ( one , e . exchange ( two ) ) ; Thread . sleep ( SMALL_DELAY_MS ) ; assertSame ( three , e . exchange ( one ) ) ; } } ) ; Thread t3 = new Thread ( new CheckedRunnable ( ) { public void realRun ( ) throws InterruptedException { Thread . sleep ( SMALL_DELAY_MS ) ; assertSame ( one , e . exchange ( three ) ) ; } } ) ; t1 . start ( ) ; t2 . start ( ) ; t3 . start ( ) ; Thread . sleep ( SHORT_DELAY_MS ) ; t1 . interrupt ( ) ; t1 . join ( ) ; t2 . join ( ) ; t3 . join ( ) ; } \n', 0.306359013249274)

-('public static void checkLiteralCountValidity ( Character CurrentLiteral ) { if ( checkIfLiteralPresent ( NonRepeatingRomanNumerals , CurrentLiteral ) ) { NonRepeatableLiteralsCount . put ( CurrentLiteral , NonRepeatableLiteralsCount . get ( CurrentLiteral ) + 1 ) ; if ( NonRepeatableLiteralsCount . containsValue ( 3 ) ) { System . err . println ( "Error-:-Roman-Numeral-V,L,D-cannot-be-repeated." ) ; System . exit ( 0 ) ; } } else if ( checkIfLiteralPresent ( RepeatingRomanNumerals , CurrentLiteral ) ) { Character keyForValueContainingThree = getKeyForValueContainingThree ( ) ; if ( keyForValueContainingThree != \'|0\' ) { if ( CurrentLiteral . equals ( keyForValueContainingThree ) ) { System . err . println ( "Error-:-Roman-Numeral-" + CurrentLiteral + "-cannot-repeat-4-times-successively" ) ; System . exit ( 0 ) ; } else if ( CurrentLiteralSmallerThanPrevious ( CurrentLiteral , keyForValueContainingThree ) ) { RepeatableLiteralsCount . put ( CurrentLiteral , RepeatableLiteralsCount . get ( CurrentLiteral ) + 1 ) ; RepeatableLiteralsCount . put ( keyForValueContainingThree , 0 ) ; } } else { RepeatableLiteralsCount . put ( CurrentLiteral , RepeatableLiteralsCount . get ( CurrentLiteral ) + 1 ) ; } } } \n', 0.3044451355819777)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 32 #################################
-('@ Deprecated public static int intFromParseableIntegerString ( String s ) { try { int x = Integer . parseInt ( s ) ; return x ; } catch ( NumberFormatException e ) { return 0 ; } } \n', 0.4116725342758478)

-('public Byte fromString ( String value ) throws ConstrettoConversionException { try { return Byte . parseByte ( value ) ; } catch ( NumberFormatException e ) { throw new ConstrettoConversionException ( value , Byte . class , e ) ; } } \n', 0.402083883317469)

-('@ Override public void fromString ( String s ) throws IOException { value = Short . parseShort ( s ) ; } \n', 0.3982040043273728)

+('protected synchronized String convertIntegerToCompatibleString ( Long integer ) throws KettleValueException { if ( integer == null ) { return null ; } return Long . toString ( integer ) ; } \n', 0.38881819720642374)

-('@ Override public void fromString ( String s ) throws IOException { value = Byte . valueOf ( s ) ; } \n', 0.3873750021404095)

-('public Short fromString ( String value ) throws ConstrettoConversionException { try { return Short . parseShort ( value ) ; } catch ( NumberFormatException e ) { throw new ConstrettoConversionException ( value , Short . class , e ) ; } } \n', 0.38713867070831465)

-('public Token fromString ( String string ) { try { return new LongToken ( Long . parseLong ( string ) ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( String . format ( "Invalid-token-for-Murmur3Partitioner.-Got-%s-but-expected-a-long-value-(unsigned-8-bytes-integer)." , string ) ) ; } } \n', 0.3782404816394195)

-('private int convertToInt ( String s ) throws IOException { byte [ ] b = s . getBytes ( "UTF-16BE" ) ; int value = 0 ; for ( int i = 0 ; i < b . length - 1 ; i ++ ) { value += b [ i ] & 0xff ; value <<= 8 ; } value += b [ b . length - 1 ] & 0xff ; return value ; } \n', 0.37822569717556054)

-('public static int getIntFromString ( String stringVal ) throws SQLException { if ( StringUtils . isBlank ( stringVal ) ) { return 0 ; } try { int decimalIndex = stringVal . indexOf ( "." ) ; if ( decimalIndex != - 1 ) { double valueAsDouble = Double . parseDouble ( stringVal ) ; return ( int ) valueAsDouble ; } return Integer . parseInt ( stringVal ) ; } catch ( NumberFormatException e ) { throw new SQLException ( "Parse-integer-error:" + stringVal ) ; } } \n', 0.37713834762503756)

-('public static short getShortFromString ( String stringVal ) throws SQLException { if ( StringUtils . isBlank ( stringVal ) ) { return 0 ; } try { int decimalIndex = stringVal . indexOf ( "." ) ; if ( decimalIndex != - 1 ) { double valueAsDouble = Double . parseDouble ( stringVal ) ; return ( short ) valueAsDouble ; } return Short . parseShort ( stringVal ) ; } catch ( NumberFormatException e ) { throw new SQLException ( "Parse-integer-error:" + stringVal ) ; } } \n', 0.37678920647340597)

FRank: 4  | P@1: 0  | P@5: 1  | P@10: 1

########################## 33 #################################
-('protected Character [ ] convertObjectToCharacterArray ( Object sourceObject ) throws ConversionException { String stringValue = convertObjectToString ( sourceObject ) ; Character [ ] chars = new Character [ stringValue . length ( ) ] ; for ( int index = 0 ; index < stringValue . length ( ) ; index ++ ) { chars [ index ] = Character . valueOf ( stringValue . charAt ( index ) ) ; } return chars ; } \n', 0.38405123188509505)

-('static char [ ] toCharArray ( CharSequence cs ) { if ( cs instanceof String ) { return ( ( String ) cs ) . toCharArray ( ) ; } else { int sz = cs . length ( ) ; char [ ] array = new char [ cs . length ( ) ] ; for ( int i = 0 ; i < sz ; i ++ ) { array [ i ] = cs . charAt ( i ) ; } return array ; } } \n', 0.37185795232026186)

-('static char [ ] toCharArray ( final CharSequence cs ) { if ( cs instanceof String ) { return ( ( String ) cs ) . toCharArray ( ) ; } final int sz = cs . length ( ) ; final char [ ] array = new char [ cs . length ( ) ] ; for ( int i = 0 ; i < sz ; i ++ ) { array [ i ] = cs . charAt ( i ) ; } return array ; } \n', 0.37185795232026186)

-('private static char [ ] toCharArray ( CharSequence cs ) { if ( cs instanceof String ) { return ( ( String ) cs ) . toCharArray ( ) ; } else { int sz = cs . length ( ) ; char [ ] array = new char [ cs . length ( ) ] ; for ( int i = 0 ; i < sz ; i ++ ) { array [ i ] = cs . charAt ( i ) ; } return array ; } } \n', 0.37185795232026186)

-('public char [ ] toChars ( String key , byte [ ] value ) { if ( value == null ) return nullValueChars ; if ( value . length == 0 ) return new char [ 0 ] ; if ( outputEncoding == null ) return new String ( value ) . toCharArray ( ) ; try { return new String ( value , outputEncoding ) . toCharArray ( ) ; } catch ( UnsupportedEncodingException e ) { return new String ( value ) . toCharArray ( ) ; } } \n', 0.37098510426640485)

-('public static char [ ] unpackEncodedStringToUnsignedChars ( String encodedString ) { int size = 0 ; for ( int i = 0 ; i < encodedString . length ( ) ; i += 2 ) { size += encodedString . charAt ( i ) ; } char [ ] data = new char [ size ] ; int di = 0 ; for ( int i = 0 ; i < encodedString . length ( ) ; i += 2 ) { char n = encodedString . charAt ( i ) ; char v = encodedString . charAt ( i + 1 ) ; for ( int j = 1 ; j <= n ; j ++ ) { data [ di ++ ] = v ; } } return data ; } \n', 0.3697423762265639)

+('public static String convertCharToIdentifier_NonFirstChar ( char ch , Boolean_Mutable have_Modified_Char ) { if ( Character . isLetter ( ch ) || Character . isDigit ( ch ) ) { return Character . toString ( ch ) ; } else if ( ch == \'.\' ) { return "_" ; } else { String retString = \'$\' + Integer . toString ( ch ) + \'$\' ; if ( have_Modified_Char != null ) have_Modified_Char . value = true ; return retString ; } } \n', 0.3647164022420535)

-('private String reverseString ( final String s ) { final int len = s . length ( ) ; char [ ] chars = new char [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { chars [ i ] = s . charAt ( len - i - 1 ) ; } return new String ( chars ) ; } \n', 0.3630840112772182)

-('private static char [ ] convertToCharArray ( String s ) { return s == null ? null : s . toCharArray ( ) ; } \n', 0.3626616655382805)

-('@ Deprecated public static char [ ] convertToCharArray ( Object a ) { char [ ] ans = null ; if ( a instanceof char [ ] ) { ans = ( char [ ] ) a ; } else { Object [ ] ia = ( Object [ ] ) a ; ans = new char [ ia . length ] ; for ( int i = 0 ; i < ia . length ; i ++ ) { if ( ia [ i ] == null ) { continue ; } ans [ i ] = ( ( Character ) ia [ i ] ) . charValue ( ) ; } } return ans ; } \n', 0.36265497050923323)

FRank: 7  | P@1: 0  | P@5: 0  | P@10: 1

########################## 34 #################################
+('private void checkIfLocalFileExistsAndCanRead ( ) throws FileTransferException { if ( ! localFile . exists ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , new FileNotFoundException ( localFile . getAbsolutePath ( ) ) , true ) ; } if ( ! localFile . canRead ( ) ) { throw new FileTransferException ( localFile . getAbsolutePath ( ) , "File-exists-but-cannot-be-read" , true ) ; } } \n', 0.4041461995914023)

+('static public boolean areOnSameFileStore ( File a , File b ) throws RolloverFailure { if ( ! a . exists ( ) ) { throw new IllegalArgumentException ( "File-[" + a + "]-does-not-exist." ) ; } if ( ! b . exists ( ) ) { throw new IllegalArgumentException ( "File-[" + b + "]-does-not-exist." ) ; } try { Class < ? > pathClass = Class . forName ( PATH_CLASS_STR ) ; Class < ? > filesClass = Class . forName ( FILES_CLASS_STR ) ; Method toPath = File . class . getMethod ( "toPath" ) ; Method getFileStoreMethod = filesClass . getMethod ( "getFileStore" , pathClass ) ; Object pathA = toPath . invoke ( a ) ; Object pathB = toPath . invoke ( b ) ; Object fileStoreA = getFileStoreMethod . invoke ( null , pathA ) ; Object fileStoreB = getFileStoreMethod . invoke ( null , pathB ) ; return fileStoreA . equals ( fileStoreB ) ; } catch ( Exception e ) { throw new RolloverFailure ( "Failed-to-check-file-store-equality-for-[" + a + "]-and-[" + b + "]" , e ) ; } } \n', 0.3780558417616405)

+('private void checkFileValidity ( File image ) throws TwitterException { if ( ! image . exists ( ) ) { throw new TwitterException ( new FileNotFoundException ( image + "-is-not-found." ) ) ; } if ( ! image . isFile ( ) ) { throw new TwitterException ( new IOException ( image + "-is-not-a-file." ) ) ; } } \n', 0.37623559032537424)

+('public static void checkFileValidity ( File file ) throws JavaGitException { if ( ! file . exists ( ) ) { throw new JavaGitException ( JavaGitException . FILE_ERROR , ExceptionMessageMap . getMessage ( "020001" ) + "-{-filename=[" + file . getName ( ) + "]-}" ) ; } } \n', 0.3729327629498267)

+('public static void checkFileValidity ( File file ) throws IOException { if ( ! file . exists ( ) ) { throw new IOException ( ExceptionMessageMap . getMessage ( "020001" ) + "-{-filename=[" + file . getName ( ) + "]-}" ) ; } } \n', 0.37091245231291753)

+('private void verifyFilesExist ( File [ ] files ) { for ( File file : files ) { if ( ! file . exists ( ) ) { throw new ResourceNotFoundException ( String . format ( Utility . messageBD ( pool , "SourceFileNotFound" , vars . getLanguage ( ) ) , file . getPath ( ) ) ) ; } } } \n', 0.36762623117693793)

+('public static String verifyFileExists ( String file ) throws PatchException { File f = new File ( file ) ; if ( f . isFile ( ) && f . exists ( ) && f . canRead ( ) && f . canWrite ( ) ) { return f . getAbsolutePath ( ) ; } throw new PatchException ( "File-" + file + "-is-not-available-(cannot-read/write-or-not-a-file.)" ) ; } \n', 0.3665360464076728)

+('public static boolean DoesSystemFileExist ( String filename ) { return ( new File ( filename ) ) . exists ( ) ; } \n', 0.35963537552407265)

+('public static boolean doesDictionaryFileExist ( Dictionary dictionary ) { return Files . exists ( Paths . get ( dictionary . getFileName ( ) ) ) ; } \n', 0.35335916235357145)

+('public static void checkFileValidity ( String filename ) throws JavaGitException { File file = new File ( filename ) ; if ( ! file . exists ( ) ) { throw new JavaGitException ( JavaGitException . FILE_ERROR , ExceptionMessageMap . getMessage ( "020001" ) + "-{-filename=[" + filename + "]-}" ) ; } } \n', 0.35184521146595227)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 35 #################################
+('public static String dateStringToShortLocaleString ( String dateString , String formatString ) throws ParseException { SimpleDateFormat defaultSdf = new SimpleDateFormat ( UtilDateTime . getDateTimeFormat ( Locale . getDefault ( ) ) ) ; SimpleDateFormat sdf = new SimpleDateFormat ( formatString ) ; return defaultSdf . format ( sdf . parse ( dateString ) ) ; } \n', 0.429811752769706)

+('@ Koan public void usingDateFormatToParseDates ( ) throws ParseException { DateFormat dateFormat = new SimpleDateFormat ( "MM-dd-yyyy" ) ; Date date2 = dateFormat . parse ( "01-01-2000" ) ; assertEquals ( date2 . toString ( ) , __ ) ; } \n', 0.42556282134148515)

-('public static String formatDateWithTimezone ( final Date date , final String pattern , final Object timezone ) { return Dates . formatDate ( date , pattern , ( timezone instanceof TimeZone ) ? ( ( TimeZone ) timezone ) : TimeZone . getTimeZone ( String . valueOf ( timezone ) ) ) ; } \n', 0.4204590505682978)

-('public static String convertDateToDateString ( Date date ) { if ( date == null ) { return null ; } else { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd\'Z\'" ) ; df . setTimeZone ( TimeZone . getTimeZone ( "UTC" ) ) ; return df . format ( date ) ; } } \n', 0.41872302676353884)

-('public static List < String > convertDatesToString ( List < DateTime > dates , DateTimeFormatter formatter ) { List < String > dateString = new ArrayList < > ( ) ; formatter . withZoneUTC ( ) ; for ( DateTime date : dates ) { dateString . add ( formatter . print ( date ) ) ; } return dateString ; } \n', 0.41768728144833595)

+('public Date convertDateAndTimeStringToDate ( String kickoff , String time ) { DateTimeFormatter formatter = DateTimeFormat . forPattern ( "MM/dd/yyyy-HH:mm" ) ; DateTime dt = formatter . parseDateTime ( kickoff + "-" + time ) ; return dt . toDate ( ) ; } \n', 0.41149082371598705)

+('long dateToSqlDate ( String date ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( "yyyy-MM-dd" , Locale . getDefault ( ) ) ; Date resultDate = new Date ( dateFormat . format ( date ) ) ; return resultDate . getTime ( ) ; } \n', 0.4101510409016422)

-('public static String formatDateAsShortDateLocalTime ( Date moonDate , TimeZone tz ) { DateFormat sdf = SimpleDateFormat . getDateInstance ( SHORT ) ; sdf . setTimeZone ( tz ) ; ( ( SimpleDateFormat ) sdf ) . applyPattern ( "yyyy-MM-dd" ) ; return sdf . format ( moonDate ) ; } \n', 0.40837191075059137)

+('public static java . util . Date stringDateToJavaDate ( String newDate ) { if ( newDate == null || newDate . equals ( "" ) ) { return null ; } String [ ] parts = newDate . split ( "-" ) ; String [ ] date = parts [ 0 ] . split ( "-" ) ; String [ ] time = null ; if ( parts . length > 1 ) { time = parts [ 1 ] . split ( ":" ) ; time [ 2 ] = time [ 2 ] . replaceAll ( "|.0" , "" ) ; } else { time = "00:00:00" . split ( ":" ) ; } GregorianCalendar cal = ( GregorianCalendar ) Calendar . getInstance ( ) ; cal . clear ( ) ; cal . set ( new Integer ( date [ 0 ] ) . intValue ( ) , ( new Integer ( date [ 1 ] ) . intValue ( ) - 1 ) , new Integer ( date [ 2 ] ) . intValue ( ) , new Integer ( time [ 0 ] ) . intValue ( ) , new Integer ( time [ 1 ] ) . intValue ( ) , new Integer ( time [ 2 ] ) . intValue ( ) ) ; return cal . getTime ( ) ; } \n', 0.40725082876363206)

-('public static String [ ] dateArrayTOStringArray ( Date [ ] dates ) { if ( dates == null ) { return null ; } SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd-HH:mm:ss" ) ; String [ ] dates_s = new String [ dates . length ] ; for ( int i = 0 ; i < dates . length ; i ++ ) { dates_s [ i ] = format . format ( dates [ i ] ) ; } return dates_s ; } \n', 0.4070449269819163)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 5

########################## 36 #################################
+('@ Converter public static byte [ ] convertToByteArray ( StreamCache cache , Exchange exchange ) throws IOException { ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; cache . writeTo ( os ) ; return os . toByteArray ( ) ; } \n', 0.39872405219597484)

-('public static ByteArrayOutputStream convertToByteArrayOutputStream ( final String str ) { final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; try { stream . write ( str . getBytes ( CHARACTER_ENCODING ) ) ; } catch ( final UnsupportedEncodingException e ) { if ( LOGGER . isWarnEnabled ( ) ) { LOGGER . warn ( "Error-on-writing-to-stream." ) ; } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( "Error-on-writing-to-stream." , e ) ; } } catch ( final IOException e ) { if ( LOGGER . isWarnEnabled ( ) ) { LOGGER . warn ( "Error-on-writing-to-stream." ) ; } if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( "Error-on-writing-to-stream." , e ) ; } } return stream ; } \n', 0.39707325736022314)

+('public static byte [ ] convertToByteArray ( InputStream inputStream ) throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; FileCopyUtils . copy ( inputStream , out ) ; return out . toByteArray ( ) ; } \n', 0.39225606519718825)

+('public static byte [ ] convertToByteArray ( final InputStream is , int length ) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; write ( out , is , length ) ; return out . toByteArray ( ) ; } \n', 0.38880788876088657)

+('private static byte [ ] convertInputStreamToByteArray ( InputStream inputStream ) throws IOException { byte [ ] bytes = null ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; byte data [ ] = new byte [ 1024 ] ; int count ; while ( ( count = inputStream . read ( data ) ) != - 1 ) { bos . write ( data , 0 , count ) ; } bos . flush ( ) ; bos . close ( ) ; inputStream . close ( ) ; bytes = bos . toByteArray ( ) ; return bytes ; } \n', 0.3794936401326825)

+('public byte [ ] convertClassToByteArray ( Object obj ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( obj ) ; oos . flush ( ) ; oos . close ( ) ; bos . close ( ) ; byte [ ] thisConvertedByteArray = bos . toByteArray ( ) ; return thisConvertedByteArray ; } \n', 0.37822805007335913)

+('public static byte [ ] convertDataHandlerToBytes ( DataHandler dh ) { if ( dh != null ) { ByteArrayOutputStream bos = new ByteArrayOutputStream ( INITIAL_SIZE ) ; InputStream in ; try { in = dh . getInputStream ( ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead ; while ( ( bytesRead = in . read ( buffer ) ) >= 0 ) { bos . write ( buffer , 0 , bytesRead ) ; } return bos . toByteArray ( ) ; } catch ( IOException e ) { return null ; } } else return null ; } \n', 0.373758066447678)

+('public static byte [ ] intArrayToByteArray ( final int [ ] integer ) throws IOException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; DataOutputStream dos = new DataOutputStream ( bos ) ; for ( int i = 0 ; i < integer . length ; i ++ ) { dos . writeInt ( integer [ i ] ) ; } byte [ ] out = bos . toByteArray ( ) ; dos . close ( ) ; bos . close ( ) ; return out ; } \n', 0.36841159167595866)

-('private static byte [ ] convertIntToByteArray ( int inLength ) { return ByteBuffer . allocate ( 4 ) . putInt ( inLength ) . array ( ) ; } \n', 0.36838436278874054)

+('public static byte [ ] convertFrhedToByteArray ( String sInput ) throws Exception { ByteArrayOutputStream oBAOS = new ByteArrayOutputStream ( ) ; StringReader oSR = new StringReader ( sInput ) ; int iChar ; while ( ( iChar = oSR . read ( ) ) != - 1 ) { char c = ( char ) iChar ; if ( c == \'|\' ) { iChar = oSR . read ( ) ; oBAOS . write ( iChar ) ; } else if ( c == \'<\' ) { StringBuffer sbEncoding = new StringBuffer ( ) ; while ( ( iChar = oSR . read ( ) ) != \':\' ) { sbEncoding . append ( ( char ) iChar ) ; } String sEncoding = sbEncoding . toString ( ) ; if ( sEncoding . equals ( "bh" ) ) { StringBuffer sbValue = new StringBuffer ( ) ; while ( ( iChar = oSR . read ( ) ) != \'>\' ) { sbValue . append ( ( char ) iChar ) ; } String sValue = sbValue . toString ( ) ; oBAOS . write ( Integer . parseInt ( sValue , 16 ) ) ; } else { throw new Exception ( "Unknown-encoding-type:-" + sEncoding ) ; } } else { oBAOS . write ( iChar ) ; } } return oBAOS . toByteArray ( ) ; } \n', 0.36667826098850836)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 8

########################## 37 #################################
+('public static boolean isValidDecimal ( String data ) { boolean retval = true ; String temp = "" ; String tempWhole = "" ; String tempDecimal = "" ; do { if ( ( data . charAt ( 0 ) == \'-\' ) || ( data . charAt ( 0 ) == \'+\' ) ) { temp = new String ( data . substring ( 1 ) ) ; } else { temp = new String ( data ) ; } int k = data . indexOf ( "." ) ; if ( k == 0 ) { retval = false ; break ; } if ( k < 0 ) { tempWhole = new String ( temp ) ; } else { tempWhole = new String ( temp . substring ( 0 , k ) ) ; tempDecimal = new String ( temp . substring ( k ) ) ; } retval = isValidNumeric ( tempWhole ) ; if ( retval == false ) { break ; } if ( tempDecimal . length ( ) == 0 ) { break ; } if ( tempDecimal . length ( ) == 1 ) { retval = false ; break ; } retval = isValidNumeric ( tempDecimal . substring ( 1 ) ) ; } while ( false ) ; return retval ; } \n', 0.3896454069943445)

+('private boolean validDecimal ( String str , String currentText ) { if ( decimalAllowed ) { boolean strOnlyDecimal = str . equals ( "." ) ; boolean firstDecimal = strOnlyDecimal && currentText . length ( ) == 0 ; boolean numTextTrailingDecimal = isNumeric ( currentText ) && strOnlyDecimal ; boolean negTrailingDecimal = currentText . equals ( "-" ) && strOnlyDecimal ; return firstDecimal || numTextTrailingDecimal || negTrailingDecimal ; } return false ; } \n', 0.3667540256221967)

-('public static boolean isNumeric ( TypeMirror type ) { switch ( type . getKind ( ) ) { case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return true ; default : return false ; } } \n', 0.3408254984597696)

-("static boolean isPrimitiveZero ( String desc , Object value ) { if ( value != null && desc != null && desc . length ( ) > 0 ) { switch ( desc . charAt ( 0 ) ) { case 'Z' : return ( ( Boolean ) value ) . booleanValue ( ) == false ; case 'C' : return ( ( Character ) value ) . charValue ( ) == ( char ) 0 ; case 'B' : return ( ( Byte ) value ) . byteValue ( ) == 0 ; case 'S' : return ( ( Short ) value ) . shortValue ( ) == 0 ; case 'I' : return ( ( Integer ) value ) . intValue ( ) == 0 ; case 'F' : return ( ( Float ) value ) . floatValue ( ) == 0f ; case 'J' : return ( ( Long ) value ) . longValue ( ) == 0L ; case 'D' : return ( ( Double ) value ) . doubleValue ( ) == 0.0 ; } } return false ; } \n", 0.334051665431429)

-('public static final boolean isNumericType ( String type ) { if ( type . equals ( DOUBLE ) || type . equals ( FLOAT ) || type . equals ( INTEGER ) || type . equals ( LONG ) || type . equals ( NUMBER ) || type . equals ( SHORT ) ) { return true ; } return false ; } \n', 0.3308386755208791)

+('public static boolean isNumeric ( String str , Class < ? extends Number > clazz ) { try { if ( clazz . equals ( Byte . class ) ) { Byte . parseByte ( str ) ; } else if ( clazz . equals ( Double . class ) ) { Double . parseDouble ( str ) ; } else if ( clazz . equals ( Float . class ) ) { Float . parseFloat ( str ) ; } else if ( clazz . equals ( Integer . class ) ) { Integer . parseInt ( str ) ; } else if ( clazz . equals ( Long . class ) ) { Long . parseLong ( str ) ; } else if ( clazz . equals ( Short . class ) ) { Short . parseShort ( str ) ; } } catch ( NumberFormatException nfe ) { return false ; } return true ; } \n', 0.32294820296247995)

-('public static boolean isNumeric ( Object val ) { if ( val == null ) return false ; Class clz ; if ( val instanceof Class ) { clz = ( Class ) val ; } else { clz = val . getClass ( ) ; } return clz == int . class || clz == long . class || clz == short . class || clz == double . class || clz == float . class || Number . class . isAssignableFrom ( clz ) ; } \n', 0.3137949425524466)

-('private boolean isPrimitiveOrString ( Object o ) { if ( o instanceof Byte ) { return true ; } else if ( o instanceof Character ) { return true ; } else if ( o instanceof Boolean ) { return true ; } else if ( o instanceof Long ) { return true ; } else if ( o instanceof Double ) { return true ; } else if ( o instanceof Integer ) { return true ; } else if ( o instanceof Short ) { return true ; } else if ( o instanceof Float ) { return true ; } else if ( o instanceof String ) { return true ; } return false ; } \n', 0.3084773437513624)

-('private boolean isStringOrPrimitive ( Object key ) { return key instanceof String || key instanceof Integer || key instanceof Long || key instanceof Float || key instanceof Double || key instanceof Boolean || key instanceof Short || key instanceof Byte || key instanceof Character || key instanceof UUID || key instanceof byte [ ] ; } \n', 0.2943485151526573)

-('public void validate ( Object value , ValidationMessageList list ) { String errorFormat = null ; try { if ( type . equals ( INT ) ) { errorFormat = "message.error.int" ; Integer . parseInt ( String . valueOf ( value ) ) ; } else if ( type . equals ( LONG ) ) { errorFormat = "message.error.long" ; Long . parseLong ( String . valueOf ( value ) ) ; } else if ( type . equals ( SHORT ) ) { errorFormat = "message.error.short" ; Short . parseShort ( String . valueOf ( value ) ) ; } else if ( type . equals ( BYTE ) ) { errorFormat = "message.error.byte" ; Byte . parseByte ( String . valueOf ( value ) ) ; } else if ( type . equals ( DOUBLE ) ) { errorFormat = "message.error.double" ; Double . parseDouble ( String . valueOf ( value ) ) ; } else if ( type . equals ( FLOAT ) ) { errorFormat = "message.error.float" ; Float . parseFloat ( String . valueOf ( value ) ) ; } else { throw new BuildException ( "Unexpected-type:-{0}" + type ) ; } } catch ( NumberFormatException e ) { list . add ( new ValidationMessage ( getProperty ( ) , getMessageForFormat ( errorFormat , getLabel ( ) ) ) ) ; } } \n', 0.2942855866559133)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 3

########################## 38 #################################
-('public static java . lang . Object copyObject ( java . lang . Object object , ORB orb ) throws RemoteException { return delegate . copyObject ( object , orb ) ; } \n', 0.42300040608965517)

-('public static Object copyObject ( Object obj , ORB orb ) throws RemoteException { if ( utilDelegate != null ) { return utilDelegate . copyObject ( obj , orb ) ; } return null ; } \n', 0.42099723112247606)

+('public Object copyObject ( Object object ) { Helper . checkObjectNotNull ( object , "object-in-ObjectUtil#copyObject" ) ; Object copyObject = new ObjectImpl ( ) ; if ( object . getClassifier ( ) != null ) { copyObject . setClassifier ( object . getClassifier ( ) ) ; copyObject . getClassifier ( ) . addInstance ( copyObject ) ; } Helper . copyBasicAttributes ( object , copyObject ) ; return copyObject ; } \n', 0.41357773382248036)

+('private Serializable copyObject ( Serializable o ) throws RemoteException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; ObjectOutputStream oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( o ) ; oos . flush ( ) ; oos . close ( ) ; byte [ ] ba = bos . toByteArray ( ) ; Method m = IxcRegistryImpl . getIxcClassLoader ( importer ) . getDeserializeMethod ( ) ; return ( Serializable ) m . invoke ( null , new Object [ ] { ba } ) ; } catch ( RemoteException ex ) { throw ex ; } catch ( Exception ex ) { throw new RemoteException ( "Cannot-copy-object" , ex ) ; } } \n', 0.40537060398417707)

+('@ SuppressWarnings ( { "unchecked" } ) private static < T extends Serializable > T copyInstanceBySerialization ( final @ NotNull T instance ) { try { final byte [ ] data ; final ByteArrayOutputStream byteOut = new ByteArrayOutputStream ( ) ; try { final ObjectOutputStream outStream = new ObjectOutputStream ( byteOut ) ; try { outStream . writeObject ( instance ) ; outStream . flush ( ) ; byteOut . flush ( ) ; data = byteOut . toByteArray ( ) ; } finally { outStream . close ( ) ; } } finally { byteOut . close ( ) ; } final ByteArrayInputStream byteIn = new ByteArrayInputStream ( data ) ; try { final ObjectInputStream inStream = new ObjectInputStream ( byteIn ) ; try { return ( T ) inStream . readObject ( ) ; } finally { inStream . close ( ) ; } } finally { byteIn . close ( ) ; } } catch ( IOException e ) { throw new IllegalArgumentException ( e ) ; } catch ( ClassNotFoundException cne ) { throw new IllegalArgumentException ( cne ) ; } } \n', 0.3912787418089517)

+('public static Object copy ( final Object src , final Class < ? > dstClass ) { Field [ ] srcFields = src . getClass ( ) . getFields ( ) ; Object dst = null ; try { dst = dstClass . newInstance ( ) ; for ( Field srcField : srcFields ) { try { Object value = srcField . get ( src ) ; if ( value == null ) { continue ; } String name = srcField . getName ( ) ; Class < ? > srcType = srcField . getType ( ) ; Field dstField = dstClass . getField ( name ) ; Class < ? > dstType = dstField . getType ( ) ; if ( srcType . equals ( String . class ) ) { String valueString = ( String ) value ; if ( dstType . equals ( int . class ) ) { dstField . setInt ( dst , Integer . parseInt ( valueString ) ) ; } else { dstField . set ( dst , value ) ; } } else { dstField . set ( dst , value ) ; } } catch ( Exception e ) { Log . v ( "fastroid" , "Failed-to-set-field-value:-" + srcField . getName ( ) + ":-" + e . getMessage ( ) ) ; } } } catch ( Exception e ) { Log . v ( "fastroid" , e . getMessage ( ) ) ; } return dst ; } \n', 0.3891173244905516)

+('public static Object cloneObject ( Object toClone , final ClassLoader classLoader ) { if ( null == toClone ) { return null ; } else { try { ByteArrayOutputStream bOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream oOut = new ObjectOutputStream ( bOut ) ; oOut . writeObject ( toClone ) ; oOut . close ( ) ; ByteArrayInputStream bIn = new ByteArrayInputStream ( bOut . toByteArray ( ) ) ; bOut . close ( ) ; ObjectInputStream oIn = new ObjectInputStream ( bIn ) { protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { return Class . forName ( desc . getName ( ) , false , classLoader ) ; } } ; bIn . close ( ) ; Object copy = oIn . readObject ( ) ; oIn . close ( ) ; return copy ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } \n', 0.38873267421525404)

+('public static Object deepCopy ( Object src ) throws InstantiationException , IllegalAccessException { Class < ? > clazz = src . getClass ( ) ; if ( Modifier . isFinal ( clazz . getModifiers ( ) ) ) { return src ; } Object dst = clazz . newInstance ( ) ; if ( src instanceof Calendar ) { ( ( Calendar ) dst ) . setTimeInMillis ( ( ( Calendar ) src ) . getTimeInMillis ( ) ) ; return dst ; } Field [ ] fields = clazz . getFields ( ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { Object fObj = fields [ i ] . get ( src ) ; if ( fObj == null ) { continue ; } Class < ? > fRealType = fObj . getClass ( ) ; if ( ( ! fRealType . isPrimitive ( ) ) || ( ! fRealType . isEnum ( ) ) || fRealType . getPackage ( ) != JAVA_LANG_PKG ) { if ( fRealType . isArray ( ) ) { Object [ ] items = ( Object [ ] ) fObj ; fObj = Array . newInstance ( fRealType . getComponentType ( ) , items . length ) ; for ( int j = 0 ; j < items . length ; j ++ ) { Array . set ( fObj , j , deepCopy ( items [ j ] ) ) ; } } else { fObj = deepCopy ( fObj ) ; } } fields [ i ] . set ( dst , fObj ) ; } return dst ; } \n', 0.3884000434864907)

-('public Object copyToNDJavaArray ( ) { Object javaArray ; try { javaArray = java . lang . reflect . Array . newInstance ( getElementType ( ) , getShape ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } IndexIterator iter = getIndexIterator ( ) ; reflectArrayCopyOut ( javaArray , this , iter ) ; return javaArray ; } \n', 0.3871508605741164)

-('public Object copyObject ( Object sourceObject , Object templateObject ) throws TokenException { long sourceObjectHandle = sourceObject . getObjectHandle ( ) ; CK_ATTRIBUTE [ ] ckAttributes = Object . getSetAttributes ( templateObject ) ; long newObjectHandle = pkcs11Module_ . C_CopyObject ( sessionHandle_ , sourceObjectHandle , ckAttributes , useUtf8Encoding_ ) ; return Object . getInstance ( this , newObjectHandle ) ; } \n', 0.38590838290429297)

FRank: 3  | P@1: 0  | P@5: 3  | P@10: 6

########################## 39 #################################
+('public long timeOperationNanos ( Runnable f ) { long startNanos = System . nanoTime ( ) ; f . run ( ) ; return System . nanoTime ( ) - startNanos ; } \n', 0.34964021911427234)

-('public long getExecutionTimeMillis ( ) { return result . getExecutionTimeMillis ( ) ; } \n', 0.3491162998252478)

+('public long scheduledExecutionTime ( ) { synchronized ( lock ) { switch ( executionType ) { case FIXED_RATE : return System . currentTimeMillis ( ) + rate ; case FIXED_DELAY : return nextExecutionTime + rate ; case FIXED_DELAY_POST_EXECUTION : return nextExecutionTime + rate ; } return ( rate < 0 ? nextExecutionTime + rate : nextExecutionTime - rate ) ; } } \n', 0.3455840684646044)

-('protected void setStepTime ( int nStepTime ) { stepTime = nStepTime ; if ( isRunning ) { this . halt ( ) ; this . run ( ) ; } } \n', 0.34148199832528336)

-('public long scheduledExecutionTime ( ) { if ( expired ) { return - 1 ; } else { return time . getTime ( ) ; } } \n', 0.3408927086401689)

-('public static String getTimeZone ( Connection conn ) throws SQLException { if ( log . isDebugEnabled ( ) ) log . debug ( "[SQLConnector:getTimeZone]" ) ; Statement stmt = conn . createStatement ( ) ; String query = "SELECT-@@global.time_zone,-@@session.time_zone;" ; ResultSet rs = stmt . executeQuery ( query ) ; while ( rs . next ( ) ) { String globalMySQLTimeZone = rs . getString ( "@@global.time_zone" ) ; String sessionMySQLTimeZone = rs . getString ( "@@session.time_zone" ) ; String mySQLTimeZone = globalMySQLTimeZone ; if ( ! globalMySQLTimeZone . equals ( sessionMySQLTimeZone ) ) { mySQLTimeZone = sessionMySQLTimeZone ; } if ( log . isDebugEnabled ( ) ) log . debug ( "[SQLConnector:getTimeZone]-mySQLTimeZone-extracted-=-" + mySQLTimeZone ) ; return getTimeZoneFromMySQLFormat ( mySQLTimeZone ) ; } if ( log . isWarnEnabled ( ) ) log . warn ( "[SQLConnector:getTimeZone]-Impossible-to-read-timezone-from-database.-Timezone-of-current-system-selected." ) ; return timeZoneToStr ( TimeZone . getTimeZone ( "UTC" ) ) ; } \n', 0.3394797650513154)

-('public long getExecutionTime ( TimeUnit unit ) { return unit . convert ( executionNanos , TimeUnit . NANOSECONDS ) ; } \n', 0.3386946954794139)

-('public String getExecutionTime ( ) { return result . getExecutionTime ( ) ; } \n', 0.33792865755999557)

-('private void doTimedObjectProcessing ( Class ejbClass , EjbDescriptor ejbDesc ) { MethodDescriptor timeoutMethodDesc = null ; Class nextClass = ejbClass ; while ( ( nextClass != Object . class ) && ( nextClass != null ) && ( timeoutMethodDesc == null ) ) { Method [ ] methods = nextClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( ( m . getAnnotation ( Timeout . class ) != null ) ) { timeoutMethodDesc = new MethodDescriptor ( m , MethodDescriptor . TIMER_METHOD ) ; break ; } } nextClass = nextClass . getSuperclass ( ) ; } if ( ( timeoutMethodDesc == null ) && javax . ejb . TimedObject . class . isAssignableFrom ( ejbClass ) ) { timeoutMethodDesc = new MethodDescriptor ( "ejbTimeout" , "@Timeout-method" , new String [ ] { "javax.ejb.Timer" } , MethodDescriptor . TIMER_METHOD ) ; } if ( timeoutMethodDesc != null ) { ejbDesc . setEjbTimeoutMethod ( timeoutMethodDesc ) ; } return ; } \n', 0.3357506067777899)

+('public static void timeMethod ( int i , int [ ] A ) { long startTime = System . currentTimeMillis ( ) ; int [ ] B = Sort . callMethod ( i , A ) ; long endTime = System . currentTimeMillis ( ) ; System . out . print ( "method" + i + "-time-in-millisecs:-" ) ; System . out . print ( endTime - startTime ) ; System . out . println ( ",-method" + i + "-count:-" + Sort . getMethodCount ( i ) ) ; isSorted ( B ) ; } \n', 0.33572189486305193)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 3

########################## 40 #################################
+('protected void readALineFromFile ( ) throws EOFException { try { if ( useStandardIO ) { if ( eofFlag ) { throw new EOFException ( ) ; } lineBuffer = f . readLine ( ) ; if ( lineBuffer != null ) { if ( lineBuffer . indexOf ( \'|032\' ) != - 1 ) { lineBuffer = lineBuffer . substring ( 0 , lineBuffer . indexOf ( \'|032\' ) ) ; if ( lineBuffer . length ( ) == 0 ) { lineBuffer = null ; } eofFlag = true ; } else if ( lineBuffer . indexOf ( \'|004\' ) != - 1 ) { lineBuffer = lineBuffer . substring ( 0 , lineBuffer . indexOf ( \'|004\' ) ) ; if ( lineBuffer . length ( ) == 0 ) { lineBuffer = null ; } eofFlag = true ; } } } else { lineBuffer = f . readLine ( ) ; } if ( lineBuffer == null ) { throw ( new EOFException ( ) ) ; } lineBuffer = lineBuffer + "-" ; lineBufferPtr = 0 ; } catch ( IOException e ) { if ( e instanceof EOFException ) { throw ( new EOFException ( ) ) ; } else { new FatalError ( "Read-on-"" + fileName + ""-failed:-" + e ) ; } } } \n', 0.4257178555163986)

+('public synchronized String readLine ( String filename , boolean recycle , boolean firstLineIsNames ) throws IOException { FileEntry fileEntry = files . get ( filename ) ; if ( fileEntry != null ) { if ( fileEntry . inputOutputObject == null ) { fileEntry . inputOutputObject = createBufferedReader ( fileEntry ) ; } else if ( ! ( fileEntry . inputOutputObject instanceof Reader ) ) { throw new IOException ( "File-" + filename + "-already-in-use" ) ; } BufferedReader reader = ( BufferedReader ) fileEntry . inputOutputObject ; String line = reader . readLine ( ) ; if ( line == null && recycle ) { reader . close ( ) ; reader = createBufferedReader ( fileEntry ) ; fileEntry . inputOutputObject = reader ; if ( firstLineIsNames ) { reader . readLine ( ) ; } line = reader . readLine ( ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Read:" + line ) ; } return line ; } throw new IOException ( "File-never-reserved:-" + filename ) ; } \n', 0.41930846919018117)

-('public String readLineOfText ( ) { String lineOfText = null ; try { lineOfText = inFile . readLine ( ) ; } catch ( Exception err ) { try { throw ( err ) ; } catch ( Exception e ) { } } return ( lineOfText ) ; } \n', 0.4169343667775761)

+('public static final String readLinesFile ( final File inFile , final int prefixMode , final String prefix , int maxLinesRead ) throws IOException { final StringBuffer resultBuffer = new StringBuffer ( 128 ) ; final FileInputStream stream = new FileInputStream ( inFile ) ; final BufferedReader reader = new BufferedReader ( new InputStreamReader ( stream ) ) ; try { String data = "" ; int lineNumber = 1 ; boolean maxReached = false ; do { maxReached = ( maxLinesRead == - 1 ) ? false : ( lineNumber >= maxLinesRead ) ; data = reader . readLine ( ) ; if ( data != null ) { final String curPrefix = prefix == null ? "" : prefix ; resultBuffer . append ( curPrefix ) . append ( lineNumber ) . append ( \':\' ) ; resultBuffer . append ( inFile . getAbsolutePath ( ) ) . append ( \':\' ) ; resultBuffer . append ( data ) . append ( \'|n\' ) ; } lineNumber ++ ; } while ( ( data != null ) && ! maxReached ) ; if ( maxReached ) { resultBuffer . append ( "...-" ) ; resultBuffer . append ( "Max-of-" ) . append ( lineNumber - 1 ) . append ( "-lines-reached-for-" ) ; resultBuffer . append ( inFile . getAbsolutePath ( ) ) ; resultBuffer . append ( data ) . append ( \'|n\' ) ; } } finally { if ( reader != null ) { try { reader . close ( ) ; } catch ( IOException e ) { ; } } } return resultBuffer . toString ( ) ; } \n', 0.41285418366375104)

+('public static String readTextFileFromSystem ( String path ) throws IOException { String contents = "" ; try { BufferedReader in = new BufferedReader ( new FileReader ( path ) ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { contents = contents + line ; } in . close ( ) ; } catch ( IOException e ) { String detail = "IOException-when-reading-in-text-file-from-path:-" + path ; IOException ee = new IOException ( detail , e ) ; Logger . getLogger ( Util . class . getName ( ) ) . throwing ( "Util" , "readTextFileFromSystem" , ee ) ; throw ee ; } return contents ; } \n', 0.39791848567298505)

+('private void parseTextLogFile ( String filePath ) throws IOException { mParser = new EventLogParser ( ) ; String tagFile = filePath + TAG_FILE_EXT ; if ( mParser . init ( tagFile ) == false ) { if ( mAlternateTagFile != null ) { if ( mParser . init ( mAlternateTagFile ) == false ) { printAndExit ( "Failed-to-get-event-tags-from-" + mAlternateTagFile , false ) ; } } else { printAndExit ( "Failed-to-get-event-tags-from-" + tagFile , false ) ; } } BufferedReader reader = new BufferedReader ( new InputStreamReader ( new FileInputStream ( filePath ) ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { processEvent ( mParser . parse ( line ) ) ; } } \n', 0.3951670136559205)

+('private static String readFirstLine ( Path file ) throws IOException { try ( InputStream input = Files . newInputStream ( file ) ) { LineNumberReader reader = new LineNumberReader ( new InputStreamReader ( input , DEFAULT_CHARSET ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( ! line . isEmpty ( ) ) { return line ; } line = reader . readLine ( ) ; } } return null ; } \n', 0.3935842125839052)

+('static String readFirstLineFromFileWithFinallyBlock ( String path ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( path ) ) ; try { return br . readLine ( ) ; } finally { if ( br != null ) br . close ( ) ; } } \n', 0.39262515735857384)

+('public static String [ ] readFileByLine ( String fileName ) { try { FileInputStream fis = new FileInputStream ( fileName ) ; DataInputStream dis = new DataInputStream ( fis ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( dis ) ) ; String strLine ; List < String > resultList = new ArrayList < String > ( ) ; while ( ( strLine = br . readLine ( ) ) != null ) { resultList . add ( strLine ) ; } dis . close ( ) ; return resultList . toArray ( new String [ resultList . size ( ) ] ) ; } catch ( Exception ex ) { System . err . println ( "File-error:-" + ex . getMessage ( ) ) ; return null ; } } \n', 0.392239849808241)

+('public synchronized LinkedList < String > readFileLines ( File f ) throws GeneralException { BufferedReader br = null ; LinkedList < String > results = new LinkedList < String > ( ) ; try { br = new BufferedReader ( new InputStreamReader ( new FileInputStream ( f ) , "UTF-8" ) ) ; while ( true ) { String line = br . readLine ( ) ; if ( line == null ) break ; results . addLast ( line ) ; } return results ; } catch ( IOException ioe ) { throw new GeneralException ( "Failed-to-load-log-file" , ioe ) ; } finally { try { if ( br != null ) { br . close ( ) ; } } catch ( IOException ioe ) { } } } \n', 0.39085859060049444)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 9

########################## 41 #################################
+('static < T > List < T > makeAbstractColumnList ( T [ ] array ) { List < T > result = Lists . newArrayListWithExpectedSize ( array . length ) ; result . addAll ( Arrays . asList ( array ) ) ; return result ; } \n', 0.3689043307455845)

+('private List < FlockDto > makeFlockList ( ResultSet resultSet ) throws SQLException { List < FlockDto > flocks = new ArrayList < FlockDto > ( ) ; while ( resultSet . next ( ) ) { flocks . add ( makeFlock ( resultSet ) ) ; } return flocks ; } \n', 0.3648948154835041)

+('private List < CellinkDto > makeCellinkList ( ResultSet rs ) throws SQLException { List < CellinkDto > cellinks = new ArrayList < CellinkDto > ( ) ; while ( rs . next ( ) ) { cellinks . add ( makeCellink ( rs ) ) ; } return cellinks ; } \n', 0.3608559507203771)

+('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final Collection < ? extends T > collection ) { return Util . makeArrayList ( collection ) ; } \n', 0.3594768898867737)

+('private List < ControllerDto > makeControllerList ( ResultSet rs ) throws SQLException { List < ControllerDto > controllers = new ArrayList < ControllerDto > ( ) ; while ( rs . next ( ) ) { controllers . add ( makeController ( rs ) ) ; } return controllers ; } \n', 0.3587234018088347)

+('@ Deprecated public static < T > ArrayList < T > makeArrayList ( final int initialCapacity ) { return Util . makeArrayList ( initialCapacity ) ; } \n', 0.3559348638973285)

+('public static List < Control > createShortCircuitControlList ( int resultCode , String section ) { ArrayList < Control > controlList = new ArrayList < Control > ( 1 ) ; controlList . add ( createShortCircuitControl ( resultCode , section ) ) ; return controlList ; } \n', 0.3557420729032127)

+('private static ArrayList < String > constructList ( ResultSet rs ) throws SQLException { ArrayList < String > list = new ArrayList < String > ( ) ; while ( rs . next ( ) ) { if ( ! list . contains ( rs . getString ( 1 ) ) ) list . add ( rs . getString ( 1 ) ) ; } return list ; } \n', 0.3552338391219594)

+('private static Iterable < VCSRepository > createListItemDTOs ( Iterable < VCSRepository > repositories ) { List < VCSRepository > dtos = new ArrayList < > ( ) ; for ( VCSRepository repository : repositories ) { dtos . add ( createListItemDTO ( repository ) ) ; } return dtos ; } \n', 0.35387130485532614)

+('private List constructSpecimenObjList ( List specimenIdList , DAO dao ) throws BizLogicException { final List specimensObjList = new ArrayList ( ) ; try { final Iterator itr = specimenIdList . iterator ( ) ; while ( itr . hasNext ( ) ) { final Long specimenId = ( Long ) itr . next ( ) ; final Object object = dao . retrieveById ( Specimen . class . getName ( ) , specimenId ) ; specimensObjList . add ( object ) ; } } catch ( final DAOException excep ) { this . logger . error ( excep . getMessage ( ) , excep ) ; throw new BizLogicException ( excep ) ; } return specimensObjList ; } \n', 0.35165927872526614)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 10

########################## 42 #################################
+('public static void appendToTextFile ( String fileName , String content ) throws IOException { Files . append ( content , new File ( fileName ) , Charset . defaultCharset ( ) ) ; } \n', 0.42733940959034317)

+('public static void AppendTextToFile ( String filePath , String text ) throws Exception { PrintWriter out = new PrintWriter ( new BufferedWriter ( new FileWriter ( filePath , true ) ) ) ; out . write ( text ) ; out . close ( ) ; } \n', 0.4060239352322367)

+('public static void appendToTextFile ( final String fileName , final String text ) throws IOException { FileWriter writer = null ; try { writer = new FileWriter ( fileName , true ) ; writer . append ( text ) ; writer . flush ( ) ; } finally { if ( writer != null ) { writer . close ( ) ; } } } \n', 0.4009150872516225)

+('public static void append ( File file , Object text , String charset ) throws IOException { Writer writer = null ; try { FileOutputStream out = new FileOutputStream ( file , true ) ; if ( ! file . exists ( ) ) { writeUTF16BomIfRequired ( charset , out ) ; } writer = new OutputStreamWriter ( out , charset ) ; InvokerHelper . write ( writer , text ) ; writer . flush ( ) ; Writer temp = writer ; writer = null ; temp . close ( ) ; } finally { closeWithWarning ( writer ) ; } } \n', 0.3898946036800077)

+('protected void writeTextInto ( String text , String file ) { try { File aFile = new File ( file ) ; boolean exist = aFile . exists ( ) ; FileWriter out = new FileWriter ( aFile , true ) ; if ( ! exist ) { out . write ( ";AVERAGE;;;;;;;;;;;;;" ) ; out . write ( "-" ) ; out . write ( "instance;solutionCount;buildingTime(ms);initTime(ms);initPropag(ms);resolutionTime(ms);totalTime(s);objective;nodes;backtracks;fails;restarts;fineProp;coarseProp;" ) ; out . write ( "-" ) ; } out . write ( text ) ; out . flush ( ) ; out . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } \n', 0.38302103011733735)

+('public static void appendTextToFile ( File file , String text , int maxAttempts , int timeToWaitBetweenAttempts ) throws IOException { int attempt = 0 ; if ( maxAttempts <= 0 ) { maxAttempts = DEFAULT_MAX_ATTEMPTS ; } if ( timeToWaitBetweenAttempts <= 0 ) { timeToWaitBetweenAttempts = DEFAULT_MAX_ATTEMPTS ; } while ( true ) { attempt ++ ; BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( file , true ) ) ; writer . write ( text ) ; break ; } catch ( IOException e ) { if ( attempt < maxAttempts ) { try { Thread . sleep ( timeToWaitBetweenAttempts ) ; } catch ( InterruptedException e1 ) { throw new IOException ( "Failed-to-append-text-to-file:" + file . getAbsolutePath ( ) + "-as-thread-was-interrupted.-Has-tried-" + attempt + "-attempt(s)" , e1 ) ; } } else { throw new IOException ( "Failed-to-append-text-to-file:" + file . getAbsolutePath ( ) + "-after-" + attempt + "-attempt(s)" ) ; } } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( IOException e ) { throw e ; } } } } ; } \n', 0.3691072602565503)

-('private void appendFilesTo ( File directory , Writer writer , URI base ) throws IOException { for ( File file : directory . listFiles ( ) ) { if ( file . isDirectory ( ) ) { appendFilesTo ( file , writer , base ) ; } else { writer . write ( \'/\' ) ; writer . write ( base . relativize ( file . toURI ( ) ) . getPath ( ) ) ; writer . write ( "-" ) ; } } } \n', 0.3340172873939847)

+('public boolean appendMailIndex ( String directory , String appendText ) { try { File indexLocation = new File ( directory ) ; if ( ! indexLocation . exists ( ) ) indexLocation . mkdirs ( ) ; File indexFile = new File ( indexLocation , "index.bsm" ) ; FileWriter index ; if ( indexFile . exists ( ) ) { index = new FileWriter ( indexFile ) ; index . append ( appendText + "-" ) ; } else { indexFile . createNewFile ( ) ; index = new FileWriter ( indexFile ) ; index . write ( appendText + "-" ) ; } index . close ( ) ; return true ; } catch ( IOException e ) { System . err . println ( "[BookSuite]-Error-report:-BookSuiteFileManager.appendMailIndex:-" + e ) ; e . printStackTrace ( ) ; System . err . println ( "[BookSuite]-End-error-report." ) ; return false ; } } \n', 0.32592534332207096)

+('public static void appendRequiredLog ( String prefix , String text ) { File logFile = new File ( getLogFileName ( prefix ) ) ; String log = getLogLine ( text ) ; if ( ! logFile . exists ( ) ) { try { logFile . createNewFile ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } try { BufferedWriter buf = new BufferedWriter ( new FileWriter ( logFile , true ) ) ; buf . append ( log ) ; buf . newLine ( ) ; buf . close ( ) ; } catch ( IOException e ) { } } \n', 0.31867703465931935)

+('public static void copyTextFile ( File source , File dest ) throws IOException { BufferedReader reader = new BufferedReader ( new FileReader ( source ) ) ; if ( ! dest . exists ( ) ) { dest . createNewFile ( ) ; } BufferedWriter writer = new BufferedWriter ( new FileWriter ( dest ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { writer . write ( line + "-" ) ; line = reader . readLine ( ) ; } writer . close ( ) ; reader . close ( ) ; } \n', 0.3172058654087915)

FRank: 1  | P@1: 1  | P@5: 5  | P@10: 9

########################## 43 #################################
+('private Date isoStringToDate ( String target ) throws ParseException { SimpleDateFormat formatter = new SimpleDateFormat ( "yyyy-MM-dd\'T\'HH:mm:ss" ) ; formatter . setTimeZone ( TimeZone . getTimeZone ( "GMT" ) ) ; return formatter . parse ( target ) ; } \n', 0.44250340696245494)

+('static Date toIsoDateOrNull ( String s ) throws ParseException { if ( s == null ) return null ; return ISO_TIMESTAMP_FORMAT . parse ( s ) ; } \n', 0.43555092857521654)

+('static public Date convertISOStringToDate ( String isoDateString ) throws java . text . ParseException { DateTime isoDateTime = DateTime . parse ( isoDateString ) ; return isoDateTime . toDate ( ) ; } \n', 0.43398906574851803)

-('private String ISOStringToString ( String iso ) { if ( ! iso . equals ( "null" ) ) { DateTimeFormatter parser = ISODateTimeFormat . dateTimeNoMillis ( ) ; DateTime dt = parser . parseDateTime ( iso ) ; DateTimeFormatter formatter = DateTimeFormat . shortDateTime ( ) ; return formatter . print ( dt ) ; } return "null" ; } \n', 0.43304699260911217)

-('@ NotNull public static String dateToIsoDateString ( @ Nullable Date date , @ NotNull DateFallback fallback ) throws IllegalArgumentException { if ( date != null ) { return new SimpleDateFormat ( "yyyy-MM-dd-HH:mm" ) . format ( date ) ; } else if ( fallback == DateFallback . EARLIEST ) { return getEarliestDateString ( ) ; } throw new IllegalArgumentException ( "date-is-null-and-fallback-parameter-is-invalid!" ) ; } \n', 0.4321622421507477)

+('public static Date convertISODateString ( String date ) { if ( date != null ) { DateFormat df = new SimpleDateFormat ( "yyyy-MM-dd" ) ; try { return df . parse ( date ) ; } catch ( ParseException e ) { } } return null ; } \n', 0.43075864249313045)

+('public static Date isoToDate ( String iso ) throws ParseException { if ( iso == null || iso . length ( ) == 0 ) { throw new ParseException ( "Cannot-unserialize-an-empty-ISO-string" , 0 ) ; } isoFormatter . setCalendar ( new GregorianCalendar ( ) ) ; return isoFormatter . parse ( iso ) ; } \n', 0.42976163263751843)

+('public static Date isoNoMillisToDate ( final String iso ) { Date result = null ; if ( iso != null ) { final String part1 = iso . substring ( 0 , 19 ) ; final String part2 = iso . substring ( 19 ) ; final StringBuffer buf = new StringBuffer ( ) ; buf . append ( part1 ) ; buf . append ( ".000" ) ; if ( ! part2 . contains ( "GMT" ) ) { buf . append ( "GMT" ) ; } buf . append ( part2 ) ; result = isoFormat . parse ( buf . toString ( ) ) ; } return result ; } \n', 0.42815274473433734)

+('public static Date ISOStringToDate ( String date ) { try { int pointIndex = date . indexOf ( \'.\' ) ; if ( pointIndex > 0 ) { if ( date . endsWith ( ZULU ) ) { date = date . substring ( 0 , pointIndex ) + "+0000" ; } else { int plusIndex = date . indexOf ( \'+\' , pointIndex ) ; if ( plusIndex < 0 ) { LOGGER . error ( "Invalid-date-string." ) ; return null ; } date = date . substring ( 0 , pointIndex ) + date . substring ( plusIndex ) ; } } else if ( date . endsWith ( ZULU ) ) { date = date . substring ( 0 , date . length ( ) - 1 ) + "+0000" ; } return ISO_DATE . get ( ) . parse ( date ) ; } catch ( ParseException ex ) { LOGGER . error ( ex , ex ) ; return null ; } } \n', 0.42551750029678337)

-('public String dateToISOString ( Date date ) { return new SimpleDateFormat ( WebConstants . DATE_FORMAT_ISO ) . format ( date ) ; } \n', 0.4253090781331762)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 7

########################## 44 #################################
+('@ Override @ SuppressWarnings ( "unchecked" ) public < T extends TextNode > List < T > getChildrenAtLevelIntersectingRange ( final Class < T > levelClass , final TextRange range ) { if ( levelClass . isAssignableFrom ( this . childType ) ) { return ( List < T > ) Collections . unmodifiableList ( this . children . stream ( ) . filter ( c -> c . getRange ( ) . intersects ( range ) ) . collect ( Collectors . toList ( ) ) ) ; } else { return Collections . unmodifiableList ( this . children . stream ( ) . flatMap ( child -> child . getChildrenAtLevelIntersectingRange ( levelClass , range ) . stream ( ) ) . collect ( Collectors . toList ( ) ) ) ; } } \n', 0.33801340487268056)

-('@ Override public Collection < IQmlRegistration > access ( IIndex index ) throws CoreException { Collection < IQmlRegistration > types = null ; for ( IIndexBinding binding : index . findBindings ( QmlTypeNameRegex , false , QtLinkageFilter , null ) ) { IQmlRegistration qml = QmlRegistration . create ( QtIndexImpl . this , binding ) ; if ( qml != null ) { if ( types == null ) types = new ArrayList < IQmlRegistration > ( ) ; types . add ( qml ) ; } } return types == null ? Collections . < IQmlRegistration > emptyList ( ) : types ; } \n', 0.3321842385307101)

+('public Collection < TaskAttributes > getUpcoming ( ) { return getAll ( ) . stream ( ) . filter ( TaskAttributes :: isUpcoming ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; } \n', 0.33069233907465523)

-('public static < T > List < T > getContextualReferences ( Class < T > type , boolean optional , boolean includeDefaultScopedBeans ) { BeanManager beanManager = getBeanManager ( ) ; Set < Bean < ? >> beans = beanManager . getBeans ( type , new AnyLiteral ( ) ) ; if ( beans == null || beans . isEmpty ( ) ) { if ( optional ) { return Collections . emptyList ( ) ; } throw new IllegalStateException ( "Could-not-find-beans-for-Type=" + type ) ; } if ( ! includeDefaultScopedBeans ) { beans = filterDefaultScopedBeans ( beans ) ; } List < T > result = new ArrayList < T > ( beans . size ( ) ) ; for ( Bean < ? > bean : beans ) { result . add ( getContextualReference ( type , beanManager , new HashSet < Bean < ? >> ( ( Collection ) Arrays . asList ( bean ) ) ) ) ; } return result ; } \n', 0.33004481462051477)

-('public Collection < IProductTypeQuickListFilterFactory > getProductQuickListFilterFactories ( ) throws EPProcessorException { checkProcessing ( ) ; List < IProductTypeQuickListFilterFactory > result = new ArrayList < IProductTypeQuickListFilterFactory > ( factories . values ( ) ) ; Collections . sort ( result , new Comparator < IProductTypeQuickListFilterFactory > ( ) { public int compare ( IProductTypeQuickListFilterFactory o1 , IProductTypeQuickListFilterFactory o2 ) { return Integer . valueOf ( o1 . getIndex ( ) ) . compareTo ( o2 . getIndex ( ) ) ; } } ) ; return result ; } \n', 0.3296734211890714)

+('private List < Integer > findTgtMatches ( Sequence < TK > targetPhrase ) { return wordToPosition . getOrDefault ( targetPhrase . get ( 0 ) , Collections . emptyList ( ) ) . stream ( ) . filter ( pIdx -> { for ( int i = 0 , sz = targetPhrase . size ( ) , psz = prefix . size ( ) ; i < sz && pIdx + i < psz ; ++ i ) { if ( ! targetPhrase . get ( i ) . equals ( prefix . get ( pIdx + i ) ) ) { return false ; } } return true ; } ) . collect ( Collectors . toList ( ) ) ; } \n', 0.3285471465281966)

+('public Collection < TaskAttributes > getOverdue ( ) { return getAll ( ) . stream ( ) . filter ( TaskAttributes :: isOverdue ) . collect ( Collectors . toCollection ( ArrayList :: new ) ) ; } \n', 0.32579259016950857)

-('public Collection < Trade > getFilteredTradeBySymbol ( final String stockSymbol , final int pastMinutes ) { Predicate < Trade > datePredicate = new Predicate < Trade > ( ) { public boolean apply ( Trade trade ) { Calendar cal = Calendar . getInstance ( ) ; cal . add ( Calendar . MINUTE , - pastMinutes ) ; if ( pastMinutes == 0 ) return true ; return trade . getTimestamp ( ) . after ( cal . getTime ( ) ) || trade . getTimestamp ( ) . equals ( cal . getTime ( ) ) ; } } ; Collection < Trade > p = trades . get ( stockSymbol ) ; return Collections2 . filter ( trades . get ( stockSymbol ) , datePredicate ) ; } \n', 0.32543171497128326)

-('public static DependencyFilter classpathFilter ( Collection < String > classpathTypes ) { Collection < String > types = new HashSet < String > ( ) ; if ( classpathTypes != null ) { for ( String classpathType : classpathTypes ) { String [ ] tokens = classpathType . split ( "[+,]" ) ; for ( String token : tokens ) { token = token . trim ( ) ; if ( token . length ( ) > 0 ) { types . add ( token ) ; } } } } Collection < String > included = new HashSet < String > ( ) ; for ( String type : types ) { if ( JavaScopes . COMPILE . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM ) ; } else if ( JavaScopes . RUNTIME . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . RUNTIME ) ; } else if ( JavaScopes . TEST . equals ( type ) ) { Collections . addAll ( included , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM , JavaScopes . RUNTIME , JavaScopes . TEST ) ; } else { included . add ( type ) ; } } Collection < String > excluded = new HashSet < String > ( ) ; Collections . addAll ( excluded , JavaScopes . COMPILE , JavaScopes . PROVIDED , JavaScopes . SYSTEM , JavaScopes . RUNTIME , JavaScopes . TEST ) ; excluded . removeAll ( included ) ; return new ScopeDependencyFilter ( null , excluded ) ; } \n', 0.32432553094411315)

+('default Set < String > getTransitiveAreas ( Predicate < String > predicate ) { return getTransitiveAreas ( ) . stream ( ) . filter ( predicate ) . collect ( Collectors . toCollection ( TreeSet :: new ) ) ; } \n', 0.3238975844672655)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 5

########################## 45 #################################
-('public static String trimSpacesBeginEnd ( String input , String charsToBeRemoved ) { String output = new String ( ) ; int begin = 0 ; int end = input . length ( ) - 1 ; boolean charFound = false ; boolean ok = true ; for ( int index = begin ; ( index < input . length ( ) ) && ok ; index ++ ) { charFound = false ; for ( int charsCount = 0 ; charsCount < charsToBeRemoved . length ( ) ; charsCount ++ ) if ( charsToBeRemoved . charAt ( charsCount ) == input . charAt ( index ) ) charFound = true ; if ( ! ( ( Character . isWhitespace ( input . charAt ( index ) ) ) || ( Character . isSpaceChar ( input . charAt ( index ) ) ) || ( charFound ) ) ) { begin = index ; ok = false ; } } ok = true ; for ( int index = end ; ( index >= 0 ) && ok ; index -- ) { charFound = false ; for ( int charsCount = 0 ; charsCount < charsToBeRemoved . length ( ) ; charsCount ++ ) if ( charsToBeRemoved . charAt ( charsCount ) == input . charAt ( index ) ) charFound = true ; if ( ! ( ( Character . isWhitespace ( input . charAt ( index ) ) ) || ( Character . isSpaceChar ( input . charAt ( index ) ) ) || ( charFound ) ) ) { end = index ; ok = false ; } } output = input . substring ( begin , end + 1 ) ; return output ; } \n', 0.3971601314996935)

-('protected void popShouldStripWhitespace ( ) { if ( null != m_shouldStripWhitespaceStack ) m_shouldStripWS = m_shouldStripWhitespaceStack . popAndTop ( ) ; } \n', 0.3867258015952437)

+('public static String trimSpaces ( String input , String charsToBeRemoved ) { StringBuffer output = new StringBuffer ( ) ; boolean charFound = false ; for ( int index = 0 ; index < input . length ( ) ; index ++ ) { charFound = false ; for ( int charsCount = 0 ; charsCount < charsToBeRemoved . length ( ) ; charsCount ++ ) if ( charsToBeRemoved . charAt ( charsCount ) == input . charAt ( index ) ) charFound = true ; if ( ! ( ( Character . isWhitespace ( input . charAt ( index ) ) ) || ( Character . isSpaceChar ( input . charAt ( index ) ) ) || ( charFound ) ) ) output . append ( input . charAt ( index ) ) ; } return output . toString ( ) ; } \n', 0.34606881976050574)

+("private String stripWhiteSpaces ( String one ) { StringBuilder stripped = new StringBuilder ( ) ; boolean previousWhiteSpace = false ; for ( char c : one . toCharArray ( ) ) { if ( Character . isWhitespace ( c ) ) { if ( ! previousWhiteSpace ) { stripped . append ( '-' ) ; } previousWhiteSpace = true ; } else { if ( c == '(' || c == ')' || c == '|' || c == '-' || c == '+' || c == '/' || c == '*' || c == '{' || c == '}' || c == ',' ) { int lastIndex = stripped . length ( ) - 1 ; if ( stripped . charAt ( lastIndex ) == '-' ) { stripped . deleteCharAt ( lastIndex ) ; } previousWhiteSpace = true ; } else { previousWhiteSpace = false ; } stripped . append ( c ) ; } } if ( stripped . length ( ) > 0 && Character . isWhitespace ( stripped . charAt ( 0 ) ) ) { stripped . deleteCharAt ( 0 ) ; } if ( stripped . length ( ) > 0 && Character . isWhitespace ( stripped . charAt ( stripped . length ( ) - 1 ) ) ) { stripped . deleteCharAt ( stripped . length ( ) - 1 ) ; } return stripped . toString ( ) ; } \n", 0.3452157438703749)

+("private static String removeDuplicatedSpaces ( String text ) { char [ ] array = StringUtil . trimNotInCriterion ( text , new StringUtil . CharacterCriterion ( ) { @ Override public boolean is ( char c ) { return ( ! Character . isSpaceChar ( c ) ) && ( ! Character . isIdentifierIgnorable ( c ) ) ; } } ) . toCharArray ( ) ; char [ ] removed = new char [ array . length + 1 ] ; boolean lastWasSpace = false ; int removedIndex = 0 ; for ( int index = 0 ; index < array . length ; ++ index ) { char c = array [ index ] ; if ( Character . isWhitespace ( c ) || Character . isIdentifierIgnorable ( c ) ) { if ( ! lastWasSpace ) { removed [ removedIndex ] = '-' ; ++ removedIndex ; } lastWasSpace = true ; } else { removed [ removedIndex ] = c ; ++ removedIndex ; lastWasSpace = false ; } } return new String ( removed , 0 , removedIndex ) ; } \n", 0.32170803349457866)

-('public static String removeDecimalDigitsFromString ( String s ) { return removeDecimalDigitsFromStringPattern . matcher ( s ) . replaceAll ( "" ) ; } \n', 0.32105740599653887)

+("public String stripSpace ( String toBeStripped ) { final StringBuilder result = new StringBuilder ( ) ; boolean lastWasSpace = true ; for ( int i = 0 ; i < toBeStripped . length ( ) ; i ++ ) { char c = toBeStripped . charAt ( i ) ; if ( isWhitespace ( c ) ) { if ( ! lastWasSpace ) { result . append ( '-' ) ; } lastWasSpace = true ; } else { result . append ( c ) ; lastWasSpace = false ; } } return result . toString ( ) . trim ( ) ; } \n", 0.30731021141588255)

-('public static TrimmedInput trim ( final String input , final boolean retainLineSeparator ) { if ( input != null ) { String inputCopy = input ; StringBuffer output = new StringBuffer ( ) ; inputCopy = StringUtils . trimTrailingWhitespace ( inputCopy ) ; while ( Pattern . matches ( "^(.*)(|s-+)$" , inputCopy ) ) { inputCopy = StringUtils . removeSuffix ( inputCopy , SyntaxConstants . SHORT_OPTION_SPECIFIER ) ; inputCopy = StringUtils . trimTrailingWhitespace ( inputCopy ) ; } int noOfSpacesRemoved = 0 ; { int length = inputCopy . length ( ) ; inputCopy = inputCopy . trim ( ) ; noOfSpacesRemoved += length - inputCopy . length ( ) ; } StringBuffer buffer = new StringBuffer ( ) ; boolean startWhiteSpace = false ; for ( int i = 0 ; i < inputCopy . length ( ) ; i ++ ) { char ch = inputCopy . charAt ( i ) ; buffer . append ( ch ) ; if ( PreprocessorUtils . isWhitespace ( ch ) ) { if ( PreprocessorUtils . isSyntaxValid ( buffer . toString ( ) ) ) { if ( startWhiteSpace ) { noOfSpacesRemoved ++ ; } else { startWhiteSpace = true ; if ( ch == \'|n\' ) { if ( retainLineSeparator ) { output . append ( "-" ) ; } } else { output . append ( "-" ) ; } } buffer . delete ( 0 , buffer . length ( ) ) ; } else { output . append ( ch ) ; } } else { startWhiteSpace = false ; output . append ( ch ) ; } } return new TrimmedInput ( output . toString ( ) , noOfSpacesRemoved ) ; } else { return null ; } } \n', 0.29987372205925755)

-('public static void restoreComboFromString ( Combo combo , String text ) { try { int endFirstEntry = text . indexOf ( ";" ) ; if ( endFirstEntry > 0 ) { String selectedString = text . substring ( 0 , endFirstEntry ) ; int selectedIndex = Integer . parseInt ( selectedString ) ; String [ ] entryList = text . substring ( endFirstEntry + 1 , text . length ( ) ) . split ( ";" ) ; combo . setItems ( entryList ) ; combo . select ( selectedIndex ) ; } } catch ( NumberFormatException e ) { } } \n', 0.2957839145483406)

-('public static void stripWhitespaceNodes ( Node element ) { Node node , child ; for ( child = element . getFirstChild ( ) ; child != null ; child = node ) { node = child . getNextSibling ( ) ; stripWhitespaceNodes ( child ) ; } if ( element . getNodeType ( ) == Node . TEXT_NODE && element . getNodeValue ( ) . trim ( ) . length ( ) == 0 ) { element . getParentNode ( ) . removeChild ( element ) ; } } \n', 0.29125531819194106)

FRank: 3  | P@1: 0  | P@5: 3  | P@10: 4

########################## 46 #################################
+("public static int splitWhitespace ( String aString , String [ ] tokens ) { int maxTokens = tokens . length ; int nTokens = 0 ; int start = 0 ; int tabEnd = aString . indexOf ( '|t' ) ; int spaceEnd = aString . indexOf ( '-' ) ; int end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; while ( ( end > 0 ) && ( nTokens < maxTokens ) ) { tokens [ nTokens ++ ] = aString . substring ( start , end ) ; start = end + 1 ; while ( start < aString . length ( ) && aString . charAt ( start ) == '-' ) { start ++ ; } tabEnd = aString . indexOf ( '|t' , start ) ; spaceEnd = aString . indexOf ( '-' , start ) ; end = tabEnd < 0 ? spaceEnd : spaceEnd < 0 ? tabEnd : Math . min ( spaceEnd , tabEnd ) ; } if ( nTokens < maxTokens ) { String trailingString = aString . substring ( start ) . trim ( ) ; tokens [ nTokens ++ ] = trailingString ; } return nTokens ; } \n", 0.41397926654013606)

+('public static List < String > splitInWhiteSpaces ( String string ) { ArrayList < String > ret = new ArrayList < String > ( ) ; int len = string . length ( ) ; int last = 0 ; char c = 0 ; for ( int i = 0 ; i < len ; i ++ ) { c = string . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( last != i ) { ret . add ( string . substring ( last , i ) ) ; } while ( Character . isWhitespace ( c ) && i < len - 1 ) { i ++ ; c = string . charAt ( i ) ; } last = i ; } } if ( ! Character . isWhitespace ( c ) ) { if ( last == 0 && len > 0 ) { ret . add ( string ) ; } else if ( last < len ) { ret . add ( string . substring ( last , len ) ) ; } } return ret ; } \n', 0.3819820947099641)

-('public static String [ ] splitBySpace ( String str ) { return splitBySpace . split ( str ) ; } \n', 0.3798027063893294)

-('public static String [ ] whitespaceSplit ( String string ) throws Exception { String [ ] array = string . split ( "|s" ) ; ArrayList < String > list = new ArrayList < String > ( ) ; for ( int i = 0 ; i < array . length ; i ++ ) { String element = array [ i ] . trim ( ) ; if ( element . length ( ) > 0 ) { list . add ( element ) ; } } array = list . toArray ( array ) ; return array ; } \n', 0.3731117792417293)

-('public static String [ ] whiteSpaceTokenize ( String text ) { return WHITESPACE_PATTERN . split ( text ) ; } \n', 0.37211294071769796)

+('public static final LinkedList splitWordsL ( String s , boolean splitOnWs , char [ ] delimiters ) { if ( s == null ) return null ; int cstart = - 1 , len = s . length ( ) ; LinkedList l = new LinkedList ( ) ; for ( int pos = 0 ; pos < len ; pos ++ ) { char ch = s . charAt ( pos ) ; if ( cstart < 0 ) { if ( splitOnWs && ( ch == 0x0a || Character . isSpaceChar ( ch ) ) ) continue ; if ( delimiters != null && Arrays . binarySearch ( delimiters , ch ) > - 1 ) continue ; cstart = pos ; } else { boolean endOfWord = false ; if ( splitOnWs && ( ( ch == 0x0a || Character . isSpaceChar ( ch ) ) ) ) { endOfWord = true ; } if ( delimiters != null && Arrays . binarySearch ( delimiters , ch ) > - 1 ) { endOfWord = true ; } if ( ! endOfWord ) { continue ; } l . add ( s . substring ( cstart , pos ) ) ; cstart = - 1 ; } } if ( cstart >= 0 ) l . add ( s . substring ( cstart ) ) ; return l ; } \n', 0.36207339767489155)

+('protected static String [ ] splitString ( final String s ) { final char [ ] chars = s . trim ( ) . toCharArray ( ) ; int num_substrings = 0 ; boolean last_was_space = true ; for ( final char x : chars ) { if ( Character . isWhitespace ( x ) ) last_was_space = true ; else { if ( last_was_space ) num_substrings ++ ; last_was_space = false ; } } final String [ ] result = new String [ num_substrings ] ; final int len = chars . length ; int start = 0 ; int pos = 0 ; int i = 0 ; last_was_space = true ; for ( ; pos < len ; pos ++ ) { if ( Character . isWhitespace ( chars [ pos ] ) ) { if ( ! last_was_space ) result [ i ++ ] = new String ( chars , start , pos - start ) ; last_was_space = true ; } else { if ( last_was_space ) start = pos ; last_was_space = false ; } } if ( ! last_was_space ) result [ i ] = new String ( chars , start , pos - start ) ; return result ; } \n', 0.35663452239376514)

-('public static String collapseWhiteSpaces ( String str ) { String result = null ; if ( str != null ) { StringBuffer buffer = new StringBuffer ( ) ; boolean isInWhiteSpace = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { isInWhiteSpace = true ; } else { if ( isInWhiteSpace ) buffer . append ( "-" ) ; isInWhiteSpace = false ; buffer . append ( c ) ; } } result = buffer . toString ( ) ; } return result ; } \n', 0.354893610020522)

-('private String [ ] splitString ( String toSplit ) { assert ( toSplit != null ) ; assert ( ! toSplit . isEmpty ( ) ) ; String whiteSpace = "|s+" ; String noEndWhitespace = toSplit . trim ( ) ; String [ ] dividedString = noEndWhitespace . split ( whiteSpace ) ; return dividedString ; } \n', 0.353412546032052)

-('public static String collapseWhiteSpace ( String string ) { if ( string == null ) { return null ; } String replaced = replaceWhiteSpace ( string ) ; char [ ] chars = replaced . toCharArray ( ) ; StringBuilder result = new StringBuilder ( replaced . length ( ) ) ; boolean needSpace = false ; for ( char c : chars ) { if ( c == SPACE ) { if ( result . length ( ) != 0 ) { needSpace = true ; } } else { if ( needSpace ) { needSpace = false ; result . append ( SPACE ) ; } result . append ( c ) ; } } return result . toString ( ) ; } \n', 0.35193981076222136)

FRank: 1  | P@1: 1  | P@5: 2  | P@10: 4

########################## 47 #################################
-('public static int countOfObjectsMatchingValues ( EOEditingContext context , Object ... keysAndValues ) { if ( keysAndValues . length % 2 != 0 ) { throw new IllegalArgumentException ( "There-should-a-value-" + "corresponding-to-every-key-that-was-passed.-Args-=-" + java . util . Arrays . toString ( keysAndValues ) ) ; } NSMutableDictionary < String , Object > valueDictionary = new NSMutableDictionary < String , Object > ( ) ; for ( int i = 0 ; i < keysAndValues . length ; i += 2 ) { Object key = keysAndValues [ i ] ; Object value = keysAndValues [ i + 1 ] ; if ( key == null ) { throw new IllegalArgumentException ( "Found-null-where-a-String-key-was-expected,-arguments-=-" + java . util . Arrays . toString ( keysAndValues ) ) ; } else if ( ! ( key instanceof String ) ) { throw new IllegalArgumentException ( "Found-a-" + key . getClass ( ) . getName ( ) + "-[" + key + "]" + "-where-a-String-key-was-expected,-arguments-=-" + java . util . Arrays . toString ( keysAndValues ) ) ; } valueDictionary . setObjectForKey ( value , ( String ) key ) ; } return countOfObjectsMatchingValues ( context , valueDictionary ) ; } \n', 0.28187622469694085)

-('private int getNumberOfHits ( String page , String marker , Pattern pattern ) throws IOException { int ind = page . indexOf ( marker ) ; if ( ind < 0 ) { System . out . println ( page ) ; throw new IOException ( Globals . lang ( "Could-not-parse-number-of-hits" ) ) ; } String substring = page . substring ( ind , Math . min ( ind + 42 , page . length ( ) ) ) ; Matcher m = pattern . matcher ( substring ) ; if ( ! m . find ( ) ) { System . out . println ( "Unmatched!" ) ; System . out . println ( substring ) ; } else { try { String number = m . group ( 1 ) ; number = number . replaceAll ( "," , "" ) ; return Integer . parseInt ( number ) ; } catch ( NumberFormatException ex ) { throw new IOException ( Globals . lang ( "Could-not-parse-number-of-hits" ) ) ; } catch ( IllegalStateException e ) { throw new IOException ( Globals . lang ( "Could-not-parse-number-of-hits" ) ) ; } } throw new IOException ( Globals . lang ( "Could-not-parse-number-of-hits" ) ) ; } \n', 0.27691554866917845)

-('int indexOfTrgObjectIfExist ( Object trgObj ) { if ( hashing ) { Integer ind = trgObjectIndex . get ( trgObj ) ; if ( ind == null ) return - 1 ; else return ind . intValue ( ) ; } else return trgObjects . indexOf ( trgObj ) ; } \n', 0.2655241696931243)

-('public static int getNumberOfChunks ( File file ) throws FileTransferException { FileInputStream fileInputStream = null ; try { fileInputStream = new FileInputStream ( file ) ; return ( int ) Math . ceil ( fileInputStream . available ( ) / ( float ) CHUNK_SIZE ) ; } catch ( FileNotFoundException e ) { throw new FileTransferException ( COULD_NOT_FIND_THE_FILE , e ) ; } catch ( IOException e ) { throw new FileTransferException ( COULD_NOT_READ_THE_FILE , e ) ; } finally { try { fileInputStream . close ( ) ; } catch ( IOException e ) { throw new FileTransferException ( COULD_NOT_CLOSE_THE_FILE , e ) ; } } } \n', 0.25211458293375844)

-('public void setNumOfSplits ( final int numOfSplits ) { _numOfSplits = Math . min ( Math . max ( _MIN_SPLITS , numOfSplits ) , _MAX_SPLITS ) ; _reinitSplitsDirty = true ; if ( _numOfSplits != numOfSplits ) { logger . warning ( "Valid-range-for-number-of-splits-is-" + _MIN_SPLITS + "-to-" + _MAX_SPLITS + ".-Tried-to-set-it-to-" + numOfSplits ) ; } } \n', 0.23839084128988927)

-('protected int getHighestNumberOfVariants ( ) { int maxNumberOfVariants = 0 ; for ( Sentence sentence : sentences ) { List < VariantSentence > sentenceVariants = sentence . getVariants ( ) ; maxNumberOfVariants = Math . max ( maxNumberOfVariants , sentenceVariants . size ( ) ) ; } return maxNumberOfVariants ; } \n', 0.23724225384280334)

-('private int calcNumberOfColumns ( ) { int result = 0 ; if ( fields != null ) { Iterator e = fields . iterator ( ) ; while ( e . hasNext ( ) ) { FieldEditor pe = ( FieldEditor ) e . next ( ) ; result = Math . max ( result , pe . getNumberOfControls ( ) ) ; } } return result ; } \n', 0.22960480350448698)

-('private int calcNumberOfColumns ( final List < FieldEditor > tabFields ) { int result = 0 ; if ( tabFields != null ) { final Iterator < FieldEditor > e = tabFields . iterator ( ) ; while ( e . hasNext ( ) ) { final FieldEditor pe = e . next ( ) ; result = Math . max ( result , pe . getNumberOfControls ( ) ) ; } } return result ; } \n', 0.22863105993319766)

-('int indexOfSrcObjectIfExist ( Object srcObj ) { if ( hashing ) { Integer ind = srcObjectIndex . get ( srcObj ) ; if ( ind == null ) return - 1 ; else return ind . intValue ( ) ; } else return srcObjects . indexOf ( srcObj ) ; } \n', 0.22539590209829474)

-('protected int evaluateNumberOfServersForNextInterval ( Statistics statistics ) { assert statistics . totalNumberOfActiveServers != 0 ; assert statistics . requestCompletions != 0 ; double d = statistics . averageUtilisation / statistics . requestCompletions ; double u_lign = Math . max ( statistics . requestArrivals , statistics . requestCompletions ) * d ; int newNumberOfServers = ( int ) Math . ceil ( u_lign * statistics . totalNumberOfActiveServers / targetUtilisation ) ; return Math . max ( 1 , newNumberOfServers ) - statistics . totalNumberOfActiveServers ; } \n', 0.22372597162753854)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 48 #################################
+('public Object invokeMethodByName ( String methodName , Object ... args ) { Class < ? extends ResourceManager > thisClass = this . getClass ( ) ; Method [ ] methods = thisClass . getDeclaredMethods ( ) ; for ( Method m : methods ) { if ( m . getName ( ) . equals ( methodName ) ) { try { return ( Object ) m . invoke ( this , args ) ; } catch ( IllegalAccessException | IllegalArgumentException | InvocationTargetException e ) { Trace . error ( e . getMessage ( ) ) ; } } } return null ; } \n', 0.3422176104928403)

+('public static Object invokeMethodByName ( Object o , String methodName , Object ... args ) throws MethodNotFoundException { assert o != null ; assert methodName != null ; for ( Method m : o . getClass ( ) . getMethods ( ) ) { if ( methodName . equals ( m . getName ( ) ) ) { try { return m . invoke ( o , args ) ; } catch ( IllegalArgumentException e ) { assertMethodArgs ( m , args ) ; throw e ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( e ) ; } } } throw new MethodNotFoundException ( String . format ( "Method-%s-not-found-in-class-%s" , methodName , o . getClass ( ) ) ) ; } \n', 0.3404126629350881)

-("private Object invokeJavaObjectMethod ( InvocationHandler handler , Method method , Object [ ] args ) throws RuntimeException { Object returnValue = null ; switch ( method . getName ( ) . charAt ( 0 ) ) { case 'e' : Object other = Proxy . isProxyClass ( args [ 0 ] . getClass ( ) ) ? Proxy . getInvocationHandler ( args [ 0 ] ) : args [ 0 ] ; returnValue = Boolean . valueOf ( handler . equals ( other ) ) ; break ; case 'h' : returnValue = Integer . valueOf ( handler . hashCode ( ) ) ; break ; case 't' : returnValue = handler . toString ( ) ; break ; default : throw new RuntimeException ( method . getName ( ) ) ; } return returnValue ; } \n", 0.3305938957383466)

+('private static Object invokeByName ( Object o , String methodName , boolean setAccessibilityIfNeeded , Object ... args ) throws IllegalArgumentException , RuntimeException , MethodNotFoundException { assert o != null ; assert methodName != null ; Method [ ] methods = setAccessibilityIfNeeded ? o . getClass ( ) . getDeclaredMethods ( ) : o . getClass ( ) . getMethods ( ) ; for ( Method m : methods ) { if ( methodName . equals ( m . getName ( ) ) ) { try { if ( setAccessibilityIfNeeded ) { m . setAccessible ( true ) ; } return m . invoke ( o , args ) ; } catch ( IllegalArgumentException e ) { assertMethodArgs ( m , args ) ; throw e ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( e ) ; } catch ( InvocationTargetException e ) { throw new WrapperException ( e . getCause ( ) ) ; } } } throw new MethodNotFoundException ( String . format ( "Method-%s-not-found-in-class-%s" , methodName , o . getClass ( ) . getName ( ) ) ) ; } \n', 0.317071891356824)

+('public static Object invokeGetter ( Object entity , String propertyName ) throws Exception { Object result = null ; if ( propertyName != null && entity != null ) { propertyName = propertyName . replaceAll ( "/" , "." ) ; Object o = entity ; String pty = propertyName ; int index = propertyName . indexOf ( "." ) ; if ( index != - 1 ) { o = invokeGetter ( entity , propertyName . substring ( 0 , index ) ) ; pty = propertyName . substring ( index + 1 ) ; result = invokeGetter ( o , pty ) ; } else { String getterName = null ; char firstLetter = propertyName . charAt ( 0 ) ; if ( Character . isLowerCase ( firstLetter ) ) { getterName = "get" + Character . toUpperCase ( firstLetter ) + pty . substring ( 1 ) ; } else { getterName = "get" + pty ; } Method getter = null ; Method method ; for ( int i = 0 ; ( getter == null ) && ( i < entity . getClass ( ) . getDeclaredMethods ( ) . length ) ; i ++ ) { method = entity . getClass ( ) . getDeclaredMethods ( ) [ i ] ; if ( method . getName ( ) . equals ( getterName ) ) { getter = method ; } } if ( getter != null ) { result = getter . invoke ( o ) ; } } } return result ; } \n', 0.3098699162937461)

-('public static Object invokeMethod ( Object aObj , String aMethodNm , Object aArg ) { try { Method method = getMethod ( aObj , aMethodNm , false ) ; if ( method == null ) { logger . debug ( "ë©�?ì†Œë“œ-ì—†ì?Œ-:-" + aMethodNm ) ; return new String ( ) ; } else { if ( aArg != null ) { return method . invoke ( aObj , aArg ) ; } return null ; } } catch ( Exception se ) { logger . debug ( "invokeMethod-!!!-->-" + aMethodNm ) ; } return null ; } \n', 0.3042057934804825)

+('public static < T > T invokeMethodWithString ( T object , Map < String , String > properties ) { Class < ? > clazz = object . getClass ( ) ; for ( Entry < String , String > entry : properties . entrySet ( ) ) { try { Method method = clazz . getDeclaredMethod ( entry . getKey ( ) , String . class ) ; method . invoke ( object , entry . getValue ( ) ) ; } catch ( Exception e ) { log . error ( "Error-invoking-method-named-" + entry . getKey ( ) + "-with-value-" + entry . getValue ( ) , e ) ; return null ; } } return object ; } \n', 0.3031221563901568)

+('public static Object invokeGetterMethod ( Object object , String propertyName ) { String getterMethodName = "get" + propertyName . substring ( 0 , 1 ) . toUpperCase ( ) + propertyName . substring ( 1 ) ; try { return object . getClass ( ) . getMethod ( getterMethodName , new Class [ ] { } ) . invoke ( object , new Object [ ] { } ) ; } catch ( Exception e ) { LOG . error ( "Error-while-invoking-getter-method-\'" + getterMethodName + "\'-on-object-" + object , e ) ; return null ; } } \n', 0.3023638110635201)

+('public static Object invokeGetter ( Object entity , String propertyName ) throws Exception { Object result = null ; if ( propertyName != null && entity != null ) { propertyName = propertyName . replaceAll ( "/" , "." ) ; Object o = entity ; String pty = propertyName ; int index = propertyName . indexOf ( "." ) ; if ( index != - 1 ) { o = invokeGetter ( entity , propertyName . substring ( 0 , index ) ) ; pty = propertyName . substring ( index + 1 ) ; result = invokeGetter ( o , pty ) ; } else { String getterName = null ; char firstLetter = propertyName . charAt ( 0 ) ; if ( Character . isLowerCase ( firstLetter ) ) { getterName = "get" + Character . toUpperCase ( firstLetter ) + pty . substring ( 1 ) ; } else { getterName = "get" + pty ; } Method getter = null ; Method method ; for ( int i = 0 ; ( getter == null ) && ( i < entity . getClass ( ) . getDeclaredMethods ( ) . length ) ; i ++ ) { method = entity . getClass ( ) . getDeclaredMethods ( ) [ i ] ; if ( method . getName ( ) . equals ( getterName ) ) { getter = method ; } } if ( getter != null ) { result = getter . invoke ( o ) ; } } } return result ; } \n', 0.2998541906172957)

+('public String invokePrivateMethods ( Object object ) { if ( object == null ) { return "" ; } StringBuilder stringBuilder = new StringBuilder ( ) ; for ( Method method : object . getClass ( ) . getDeclaredMethods ( ) ) { if ( Modifier . isPrivate ( method . getModifiers ( ) ) ) { stringBuilder . append ( "invoke:" ) . append ( method . getName ( ) ) ; method . setAccessible ( true ) ; try { method . invoke ( object ) ; stringBuilder . append ( "---OK-" ) ; } catch ( ReflectiveOperationException e ) { stringBuilder . append ( "---Reflective-Exception-" ) ; LOGGER . log ( Level . SEVERE , "Unable-to-invoke-method-whit-reflection" , e ) ; } } } return stringBuilder . toString ( ) . trim ( ) ; } \n', 0.2966356924091025)

FRank: 1  | P@1: 1  | P@5: 4  | P@10: 8

########################## 49 #################################
-('public String [ ] getPlatformFontDirs ( ) { if ( platformFontDirs == null ) { String path = getPlatformFontPath ( noType1Font ) ; StringTokenizer parser = new StringTokenizer ( path , File . pathSeparator ) ; ; ArrayList < String > pathList = new ArrayList < String > ( ) ; try { while ( parser . hasMoreTokens ( ) ) { pathList . add ( parser . nextToken ( ) ) ; } } catch ( NoSuchElementException e ) { } platformFontDirs = pathList . toArray ( new String [ 0 ] ) ; } return platformFontDirs ; } \n', 0.28403220914885874)

-('public static int getApiLevelFromPlatform ( String platform ) { int apiLevel = - 1 ; platform = Util . fixEmptyAndTrim ( platform ) ; if ( platform == null ) { return apiLevel ; } Matcher matcher = Pattern . compile ( "[-:]([0-9]{1,2})$" ) . matcher ( platform ) ; if ( matcher . find ( ) ) { String end = matcher . group ( 1 ) ; try { apiLevel = Integer . parseInt ( end ) ; } catch ( NumberFormatException e ) { } } return apiLevel ; } \n', 0.27871862825927)

-('public static Platform getPlatform ( ) { String os = System . getProperty ( "os.name" ) . toLowerCase ( Locale . ENGLISH ) ; if ( os . indexOf ( "win" ) >= 0 ) { return Platform . WINDOWS ; } else if ( os . indexOf ( "mac" ) >= 0 ) { return Platform . MAC_OS ; } else { return Platform . UNIX ; } } \n', 0.2713141581349573)

-('private String getHelpPlatform ( TypeInfo info ) { String [ ] platforms ; String platform = HELP_PLATFORM_ALL ; if ( info . getType ( ) == TypeInfo . TYPE_PLATFORM ) { platforms = new String [ 0 ] ; } else { platforms = info . getPlatformTypes ( ) ; } if ( platforms . length == 1 ) { platform = platforms [ 0 ] ; } return platform ; } \n', 0.26991564616666)

-('public static String getPathFromPlatform ( String platformStr ) { String pathStr = platformStr ; String rootLocation ; rootLocation = PLATFORM_ROOT ; if ( platformStr . startsWith ( rootLocation ) ) pathStr = platformStr . substring ( rootLocation . length ( ) ) ; return pathStr ; } \n', 0.2679147609144168)

-('public String getClientPlatformCharset ( Vector charsetVector , String clientType ) { if ( debug . messageEnabled ( ) ) { debug . message ( "platform-charset-:-" + platformCharset ) ; } String platformClientCharset = getClientCharsets ( clientType ) ; if ( ( platformClientCharset != null ) && ( platformClientCharset . length ( ) > 0 ) ) { return platformClientCharset ; } String plCharSet = null ; try { if ( charsetVector . contains ( platformCharset ) ) { plCharSet = platformCharset ; } } catch ( Exception ee ) { if ( debug . warningEnabled ( ) ) { debug . warning ( "Exception:-getClientPlatformCharset-:" , ee ) ; } } if ( ( plCharSet != null ) && ( plCharSet . length ( ) > 0 ) ) { return plCharSet ; } try { plCharSet = ( String ) charsetVector . firstElement ( ) ; if ( debug . messageEnabled ( ) ) { debug . message ( "Platform-CharSet-is..-:" + plCharSet ) ; } } catch ( Exception ie ) { if ( debug . warningEnabled ( ) ) { debug . warning ( "Exception:getPlatformCharsets-:" , ie ) ; } } if ( ( plCharSet != null ) && ( plCharSet . length ( ) > 0 ) ) { return plCharSet ; } return platformCharset ; } \n', 0.26411343294485745)

-('@ Override public Collidable makePlatform ( String str , Integer x , Integer y ) { Scanner scan = new Scanner ( str . substring ( 1 , str . length ( ) - 1 ) ) ; scan . useDelimiter ( "-" ) ; String axis = scan . next ( ) ; String direction = scan . next ( ) ; double speed = scan . nextDouble ( ) ; if ( axis . matches ( horizontalRegex ) ) { if ( direction . matches ( rightRegex ) ) { scan . close ( ) ; return new MovingPlatform ( x , y , Direction . RIGHT , speed ) ; } if ( direction . matches ( leftRegex ) ) { scan . close ( ) ; return new MovingPlatform ( x , y , Direction . LEFT , speed ) ; } } if ( axis . matches ( verticalRegex ) ) { if ( direction . matches ( upRegex ) ) { scan . close ( ) ; return new MovingPlatform ( x , y , Direction . UP , speed ) ; } if ( direction . matches ( downRegex ) ) { scan . close ( ) ; return new MovingPlatform ( x , y , Direction . DOWN , speed ) ; } } scan . close ( ) ; return null ; } \n', 0.26273264333362706)

-('public static Collidable getPlatform ( String token , int x , int y ) { Platform objToUse = null ; for ( Pattern p : types . keySet ( ) ) { if ( p . matcher ( token ) . matches ( ) ) { objToUse = types . get ( p ) ; break ; } } if ( objToUse == null ) { return null ; } return objToUse . makePlatform ( token , x , y ) ; } \n', 0.2614230433530792)

-('private String getPlatformSpecificPath ( final String path ) { String platformPath = null ; switch ( File . separatorChar ) { case BACKWARD_SLASH : platformPath = path . replace ( FORWARD_SLASH , BACKWARD_SLASH ) ; break ; case FORWARD_SLASH : platformPath = path . replace ( BACKWARD_SLASH , FORWARD_SLASH ) ; break ; default : platformPath = path . replaceAll ( "[||/]" , File . separator ) ; } return platformPath ; } \n', 0.26135634717314227)

-('private static String getPlatform ( ) { String platform = "unknown" ; File platformFile = new File ( LC . zimbra_home . value ( ) , ".platform" ) ; if ( platformFile . exists ( ) ) { BufferedReader reader = null ; try { reader = new BufferedReader ( new FileReader ( platformFile ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { if ( line . length ( ) > 0 ) { platform = line ; break ; } } } catch ( IOException e ) { System . err . println ( "Unable-to-determine-platform." ) ; e . printStackTrace ( System . err ) ; } finally { ByteUtil . closeReader ( reader ) ; } } else { System . err . format ( "Unable-to-determine-platform-because-%s-does-not-exist.-" , platformFile ) ; } return platform ; } \n', 0.26123369055429024)

FRank: NG  | P@1: 0  | P@5: 0  | P@10: 0

########################## 50 #################################
+('public static < K , T > List < T > convertMapToList ( Map < K , T > map ) { if ( map == null ) return null ; return new ArrayList < T > ( map . values ( ) ) ; } \n', 0.44691073869822795)

-('public static List < ReplicationDestinationRs > listMapToObject ( List < Map < String , String >> maps ) throws Exception { List < ReplicationDestinationRs > replicationDestinations = new ArrayList < ReplicationDestinationRs > ( ) ; if ( maps != null && maps . size ( ) > 0 ) { for ( Map < String , String > map : maps ) { ReplicationDestinationRs replicationDestination = mapToObject ( map ) ; replicationDestinations . add ( replicationDestination ) ; } } return replicationDestinations ; } \n', 0.4357610784892097)

+('@ Override public < T > List < T > convertListOfMapsToObjects ( List < Map > list , Class < T > componentType ) { List < Object > newList = new ArrayList < > ( list . size ( ) ) ; for ( Object obj : list ) { if ( obj instanceof Value ) { obj = ( ( Value ) obj ) . toValue ( ) ; } if ( obj instanceof Map ) { Map map = ( Map ) obj ; if ( map instanceof ValueMapImpl ) { newList . add ( fromValueMap ( ( Map < String , Value > ) map , componentType ) ) ; } else { newList . add ( fromMap ( map , componentType ) ) ; } } else { newList . add ( Conversions . coerce ( componentType , obj ) ) ; } } return ( List < T > ) newList ; } \n', 0.43184688676906285)

-('public static List < ReplicationSourceRs > listMapToObject ( List < Map < String , String >> maps ) throws Exception { List < ReplicationSourceRs > replicationSources = new ArrayList < ReplicationSourceRs > ( ) ; if ( maps != null && maps . size ( ) > 0 ) { for ( Map < String , String > map : maps ) { ReplicationSourceRs replicationSource = mapToObject ( map ) ; replicationSources . add ( replicationSource ) ; } } return replicationSources ; } \n', 0.43073237184866064)

+('public static List < String [ ] > convertMapToList ( final Map < String , String > map ) { List < String [ ] > result = new ArrayList < > ( ) ; for ( Entry < String , String > entry : map . entrySet ( ) ) { String [ ] newEntry = new String [ ] { entry . getKey ( ) , entry . getValue ( ) } ; result . add ( newEntry ) ; } return result ; } \n', 0.42671487165619143)

-('public static List < Map < String , Object >> objectListToMapList ( List < ? > objectList ) { if ( objectList == null ) { return null ; } try { List < Map < String , Object >> mapList = new ArrayList < Map < String , Object >> ( ) ; if ( objectList . isEmpty ( ) ) { return mapList ; } Class < ? > clazz = objectList . get ( 0 ) . getClass ( ) ; Method method = clazz . getMethod ( "toMap" , new Class [ 0 ] ) ; for ( Object object : objectList ) { mapList . add ( ( Map < String , Object > ) method . invoke ( object , new Object [ 0 ] ) ) ; } return mapList ; } catch ( Exception e ) { return null ; } } \n', 0.42379090128214936)

-('public static < V > Map < V , V > convertListToMap ( List < V > list ) { Map < V , V > map = new HashMap < V , V > ( ) ; if ( list . size ( ) % 2 != 0 ) throw new VoldemortException ( "Failed-to-convert-list-to-map." ) ; for ( int i = 0 ; i < list . size ( ) ; i += 2 ) { map . put ( list . get ( i ) , list . get ( i + 1 ) ) ; } return map ; } \n', 0.42339464895946893)

-('public static Map convertListToMap ( List list ) { Map map = new LinkedHashMap ( ) ; for ( Iterator it = list . iterator ( ) ; it . hasNext ( ) ; ) { LabelValue option = ( LabelValue ) it . next ( ) ; map . put ( option . getLabel ( ) , option . getValue ( ) ) ; } return map ; } \n', 0.42196354940068215)

-('public static List < ProxyRs > listMapToObject ( List < Map < String , String >> maps ) throws Exception { List < ProxyRs > proxys = new ArrayList < ProxyRs > ( ) ; if ( maps != null && maps . size ( ) > 0 ) { for ( Map < String , String > map : maps ) { ProxyRs prox = mapToObject ( map ) ; proxys . add ( prox ) ; } } return proxys ; } \n', 0.4212033772678281)

-('protected Map < String , Object > convertNamedListToMap ( NamedList < ? > args ) { Map < String , Object > argsMap = new LinkedHashMap < > ( ) ; if ( args != null ) { for ( Map . Entry < String , ? > entry : args ) { argsMap . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return argsMap ; } \n', 0.4211146463032429)

FRank: 1  | P@1: 1  | P@5: 3  | P@10: 3

Mean sims: 0.3593