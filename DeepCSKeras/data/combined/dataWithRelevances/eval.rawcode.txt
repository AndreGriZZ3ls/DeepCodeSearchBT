private Cookie createCookie ( String str ) throws UnsupportedEncodingException { if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( "Cookie name = " + AUTH_COOKIE + " value = " + str ) ; } Cookie cookie = new Cookie ( AUTH_COOKIE , str ) ; cookie . setMaxAge ( cookieMaxAge ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( cookiePath != null ) { cookie . setPath ( cookiePath ) ; } cookie . setSecure ( isCookieSecure ) ; return cookie ; }
public static Properties readPropertiesFromFile ( String _fileName , Properties _props ) { Properties props = _props == null ? new Properties ( ) : _props ; LOGGER . debug ( "Trying to read properties from file: " + _fileName ) ; Properties newProperties = readProperties ( new File ( _fileName ) ) ; if ( newProperties != null ) { LOGGER . debug ( "Successfully read properties from file: " + _fileName ) ; props . putAll ( newProperties ) ; } return props ; }
public static Builder running ( File executable ) { checkArgument ( executable . isFile ( ) , "file not found: %s" , executable ) ; checkArgument ( executable . canExecute ( ) , "executable.canExecute" ) ; return running ( executable . getPath ( ) ) ; }
public void completeGroup ( ) { // Copy initial set to allow permutations to grow List < List < Integer >> gens = new ArrayList < List < Integer > > ( permutations ) ; // Keep HashSet version of permutations for fast lookup. Set < List < Integer > > known = new HashSet < List < Integer > > ( permutations ) ; //breadth-first search through the map of all members List < List < Integer > > currentLevel = new ArrayList < List < Integer > > ( permutations ) ; while ( currentLevel . size ( ) > 0 ) { List < List < Integer >> nextLevel = new ArrayList < List < Integer > > ( ) ; for ( List < Integer > p : currentLevel ) { for ( List < Integer > gen : gens ) { List < Integer > y = combine ( p , gen ) ; if ( ! known . contains ( y ) ) { nextLevel . add ( y ) ; //bypass addPermutation(y) for performance permutations . add ( y ) ; known . add ( y ) ; } } } currentLevel = nextLevel ; } }
public static Date dateStringToDate ( String dateString ) { SimpleDateFormat sdf = new SimpleDateFormat ( DateTimeKit . FULL_DATE_24HR_STYLE ) ; Date date = null ; try { date = sdf . parse ( dateString ) ; } catch ( ParseException e ) { } return date ; }
public void uncheckCheckboxInCell ( int row , int column ) { String checkboxLocator = getXPathBase ( ) + "tr[" + row + "]/td[" + column + "]/input" ; CheckBox cb = new CheckBox ( checkboxLocator ) ; cb . uncheck ( ) ; }
public static < T extends Comparable < ? super T > > int [ ] sort ( T [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }
private String formatDate ( Date value ) { return ( value == null ? null : m_formats . getDateFormat ( ) . format ( value ) ) ; }
@ NonNull public static String getNowDateTime ( @ NonNull String format ) { SimpleDateFormat formatter = new SimpleDateFormat ( format , Locale . ENGLISH ) ; Date curDate = new Date ( System . currentTimeMillis ( ) ) ; return formatter . format ( curDate ) ; }
public static < T > T pickRandom ( List < T > values , T skip , Random r ) { int size = values . size ( ) ; if ( size < 2 ) { throw new IllegalArgumentException ( "Must have at least two elements [size=" + size + "]" ) ; } int pick = r . nextInt ( size - 1 ) ; for ( int ii = 0 ; ii < size ; ii ++ ) { T val = values . get ( ii ) ; if ( ( val != skip ) && ( pick -- == 0 ) ) { return val ; } } return null ; }
public static < T > T deserialize ( byte [ ] input , Class < T > classType ) throws JsonParseException , JsonMappingException , IOException { return mapper . readValue ( input , classType ) ; }
public static void copyToClipboard ( String text ) { final StringSelection stringSelection = new StringSelection ( text ) ; final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( stringSelection , stringSelection ) ; }
public Matrix multiply ( Matrix B ) { Matrix C = new DenseMatrix ( this . rows ( ) , B . cols ( ) ) ; multiply ( B , C ) ; return C ; }
public static String sort ( String list , String sortType , String sortOrder , String delimiter ) throws PageException { return _sort ( toStringArray ( listToArray ( list , delimiter ) ) , sortType , sortOrder , delimiter ) ; }
public static byte [ ] fromHex ( String hex ) { try { return Hex . decodeHex ( hex . toCharArray ( ) ) ; } catch ( DecoderException e ) { return null ; } }
public List < Permutation > all ( ) { final List < Permutation > permutations = new ArrayList < Permutation > ( ) ; Backtracker counter = new Backtracker ( ) { @ Override public void applyTo ( Permutation p ) { permutations . add ( p ) ; } @ Override public boolean isFinished ( ) { return false ; } } ; this . apply ( counter ) ; return permutations ; }
protected String getJavaExecutablePath ( ) { String executableName = isWindows ( ) ? "bin/java.exe" : "bin/java" ; return PROPERTIES . getJavaHome ( ) . resolve ( executableName ) . toAbsolutePath ( ) . toString ( ) ; }
private void handleContextMenu ( JTree tree , int x , int y ) { TreePath path = tree . getPathForLocation ( x , y ) ; tree . setSelectionPath ( path ) ; DefaultMutableTreeNode node = ( DefaultMutableTreeNode ) tree . getLastSelectedPathComponent ( ) ; if ( node == null ) return ; if ( ! node . isLeaf ( ) ) { tree . setSelectionPath ( null ) ; return ; } final AppInfo info = ( AppInfo ) node . getUserObject ( ) ; JMenuItem copyname = new JMenuItem ( "Copy Name" ) ; copyname . addActionListener ( e -> { Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( info . app . getSimpleName ( ) ) , null ) ; } ) ; JMenuItem copypath = new JMenuItem ( "Copy Path" ) ; copypath . addActionListener ( e -> { String path1 = UtilIO . getSourcePath ( info . app . getPackage ( ) . getName ( ) , info . app . getSimpleName ( ) ) ; Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new StringSelection ( path1 ) , null ) ; } ) ; JMenuItem github = new JMenuItem ( "Go to Github" ) ; github . addActionListener ( e -> openInGitHub ( info ) ) ; JPopupMenu submenu = new JPopupMenu ( ) ; submenu . add ( copyname ) ; submenu . add ( copypath ) ; submenu . add ( github ) ; submenu . show ( tree , x , y ) ; }
public static String stringToString ( String dateString , String desfmt ) { // ISO_DATE_FORMAT = "yyyyMMdd"; if ( dateString . trim ( ) . length ( ) == 8 ) { return stringToString ( dateString , ISO_DATE_FORMAT , desfmt ) ; } else if ( dateString . trim ( ) . length ( ) == 10 ) { // ISO_EXPANDED_DATE_FORMAT = "yyyy-MM-dd"; return stringToString ( dateString , ISO_EXPANDED_DATE_FORMAT , desfmt ) ; } else if ( dateString . trim ( ) . length ( ) == 19 ) { // DATETIME_PATTERN = "yyyy-MM-dd hh:mm:ss"; return stringToString ( dateString . substring ( 0 , 10 ) , ISO_EXPANDED_DATE_FORMAT , desfmt ) ; } else if ( dateString . trim ( ) . length ( ) == 11 ) { // CHINESE_EXPANDED_DATE_FORMAT = "yyyy\u5e74MM\u6708dd\u65e5"; return stringToString ( dateString , CHINESE_EXPANDED_DATE_FORMAT , desfmt ) ; } return null ; }
private void parseCommandLineArgs ( String [ ] args ) throws ConfigurationException { if ( args == null || args . length == 0 ) { return ; } logger . info ( "Parsing command line arguments" ) ; m_commandLineArgs = args ; try { for ( int inx = 0 ; inx < args . length ; inx ++ ) { String arg = args [ inx ] ; if ( arg . equals ( "-?" ) || arg . equalsIgnoreCase ( "-h" ) || arg . equalsIgnoreCase ( "-help" ) ) { System . out . println ( "See documentation and doradus.yaml for help." ) ; System . exit ( 0 ) ; } Utils . require ( arg . charAt ( 0 ) == ' ' , "Unrecognized argument: %s" , arg ) ; Utils . require ( inx + 1 < args . length , "A value is expected after: %s" , arg ) ; String name = arg . substring ( 1 ) ; String value = args [ ++ inx ] ; setCommandLineParam ( name , value ) ; } } catch ( Exception e ) { logger . error ( "Failed to parse command line arguments" , e ) ; throw new ConfigurationException ( "Failed to parse command line arguments" , e ) ; } }
public static String getEnumName ( Enum [ ] e , int value ) { if ( e != null ) { int toCompareValue ; for ( Enum en : e ) { if ( en instanceof EnumReadable ) { toCompareValue = ( ( EnumReadable ) en ) . value ( ) ; } else { toCompareValue = en . ordinal ( ) ; } if ( value == toCompareValue ) { return en . name ( ) ; } } } return "" ; }
public void exportObjects2Excel ( List < ? > data , Class clazz , boolean isWriteHeader , String sheetName , boolean isXSSF , String targetPath ) throws Excel4JException , IOException { try ( FileOutputStream fos = new FileOutputStream ( targetPath ) ; Workbook workbook = exportExcelNoTemplateHandler ( data , clazz , isWriteHeader , sheetName , isXSSF ) ) { workbook . write ( fos ) ; } }
public static CheckBox newCheckBox ( final String id , final IModel < Boolean > model ) { final CheckBox checkBox = new CheckBox ( id , model ) ; checkBox . setOutputMarkupId ( true ) ; return checkBox ; }
public void setWorkingDirectory ( String path ) { if ( path != null ) { File dir = new File ( path ) ; checkWorkingDir ( dir ) ; workingDir = dir ; } else { workingDir = null ; } }
public static String getStatusDescription ( int status ) { String description = "" ; Integer statusKey = new Integer ( status ) ; if ( statusDescriptions . containsKey ( statusKey ) ) { description = statusDescriptions . get ( statusKey ) ; } return String . format ( "%s %d %s" , WebDavConst . HTTPVER , status , description ) ; }
public CloseableHttpResponse postJson ( String url , String json , Map < String , String > reqHeaders ) throws IOException { CloseableHttpClient req = getClient ( ) ; CloseableHttpResponse resp = null ; HttpPost post = new HttpPost ( url ) ; addHeaders ( post , reqHeaders ) ; post . setHeader ( json , url ) ; StringEntity input = new StringEntity ( json , ContentType . APPLICATION_JSON ) ; post . setEntity ( input ) ; resp = req . execute ( post ) ; return resp ; }
public void connectToPostgreSQLDatabase ( String database , String host , String port , String user , String password , Boolean secure , String ca , String crt , String key ) throws SQLException { if ( port . startsWith ( "[" ) ) { port = port . substring ( 1 , port . length ( ) - 1 ) ; } if ( ! secure ) { if ( password == null ) { password = "stratio" ; } try { myConnection = DriverManager . getConnection ( "jdbc:postgresql://" + host + ":" + port + "/" + database , user , password ) ; } catch ( SQLException se ) { // log the exception this . getLogger ( ) . error ( se . getMessage ( ) ) ; // re-throw the exception throw se ; } } else { Properties props = new Properties ( ) ; if ( user != null ) { props . setProperty ( "user" , user ) ; } if ( ca != null ) { props . setProperty ( "sslrootcert" , ca ) ; } if ( crt != null ) { props . setProperty ( "sslcert" , crt ) ; } if ( key != null ) { props . setProperty ( "sslkey" , key ) ; } props . setProperty ( "password" , "null" ) ; props . setProperty ( "ssl" , "true" ) ; props . setProperty ( "sslmode" , "verify-full" ) ; try { myConnection = DriverManager . getConnection ( "jdbc:postgresql://" + host + ":" + port + "/" + database , props ) ; } catch ( SQLException se ) { // log the exception this . getLogger ( ) . error ( se . getMessage ( ) ) ; // re-throw the exception throw se ; } } }
public void copySingleFile ( File asset ) { try { if ( ! asset . isDirectory ( ) ) { String targetPath = config . getDestinationFolder ( ) . getCanonicalPath ( ) + File . separatorChar + assetSubPath ( asset ) ; LOGGER . info ( "Copying single asset file to [{}]" , targetPath ) ; copyFile ( asset , new File ( targetPath ) ) ; } else { LOGGER . info ( "Skip copying single asset file [{}]. Is a directory." , asset . getPath ( ) ) ; } } catch ( IOException io ) { LOGGER . error ( "Failed to copy the asset file." , io ) ; } }
public static String getText ( Reader reader ) throws IOException { BufferedReader bufferedReader = new BufferedReader ( reader ) ; return getText ( bufferedReader ) ; }
public long getElapsedHours ( ) { long elapsed ; if ( running ) { elapsed = ( System . nanoTime ( ) - startTime ) ; } else { elapsed = ( stopTime - startTime ) ; } return elapsed / nsPerHh ; }
public static String reverse ( final String string ) { return isEmpty ( string ) ? string : new StringBuilder ( string ) . reverse ( ) . toString ( ) ; }
public void setWorkingDirectory ( Path dir ) throws IOException { ensureState ( JobState . DEFINE ) ; conf . setWorkingDirectory ( dir ) ; }
public String extract ( String html , CETR . Parameters parameters ) { html = clearText ( html ) ; //preprocess the Document by removing irrelevant HTML tags and empty lines and break the document to its lines List < String > rows = extractRows ( html ) ; // List < Integer > selectedRowIds = selectRows ( rows , parameters ) ; StringBuilder sb = new StringBuilder ( html . length ( ) ) ; for ( Integer rowId : selectedRowIds ) { String row = rows . get ( rowId ) ; //extract the clear text from the selected row row = StringCleaner . removeExtraSpaces ( HTMLParser . extractText ( row ) ) ; if ( row . isEmpty ( ) ) { continue ; } sb . append ( row ) . append ( " " ) ; } return sb . toString ( ) . trim ( ) ; }
public static HtmlPage toHtmlPage ( WebDriver webDriver ) { try { return HTMLParser . parseHtml ( new StringWebResponse ( webDriver . getPageSource ( ) , new URL ( webDriver . getCurrentUrl ( ) ) ) , new WebClient ( ) . getCurrentWindow ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error creating HtmlPage from WebDriver." , e ) ; } }
public void printHtmlFooter ( PrintWriter out , ResourceBundle reg ) { String strHTML = reg . getString ( "htmlFooter" ) ; if ( ( strHTML == null ) || ( strHTML . length ( ) == 0 ) ) strHTML = "</body>\\n</html>" ; out . println ( strHTML ) ; out . flush ( ) ; }
public static IPAddressType getAddressType ( String ipAddress ) { if ( IPAddressUtil . isIPv4LiteralAddress ( ipAddress ) ) return IPAddressType . IPV4 ; if ( IPAddressUtil . isIPv6LiteralAddress ( ipAddress ) ) return IPAddressType . IPV6 ; return IPAddressType . INVALID ; }
public static double similarity ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) return 1.0 ; // ensure that s1 is shorter than or same length as s2 if ( s1 . length ( ) > s2 . length ( ) ) { String tmp = s2 ; s2 = s1 ; s1 = tmp ; } /*\n     * this list of Boolean values is used for avoiding duplicated count of\n     * common characters in S2\n     */ List < Boolean > isCommonCharInS2 = new ArrayList < Boolean > ( ) ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { isCommonCharInS2 . add ( false ) ; } // (1) find the number of characters the two strings have in common. // note that matching characters can only be half the length of the // longer string apart. int maxdist = ( int ) Math . floor ( s2 . length ( ) / 2 ) ; int c = 0 ; // count of common characters int t = 0 ; // count of transpositions int prevpos = - 1 ; for ( int ix = 0 ; ix < s1 . length ( ) ; ix ++ ) { char ch = s1 . charAt ( ix ) ; // now try to find it in s2 for ( int ix2 = Math . max ( 0 , ix - maxdist ) ; ix2 < Math . min ( s2 . length ( ) , ix + maxdist ) ; ix2 ++ ) { if ( ch == s2 . charAt ( ix2 ) && ! isCommonCharInS2 . get ( ix2 ) ) { c ++ ; // we found a common character isCommonCharInS2 . set ( ix2 , true ) ; if ( prevpos != - 1 && ix2 < prevpos ) t ++ ; // moved back before earlier prevpos = ix2 ; break ; } } } // we don't divide t by 2 because as far as we can tell, the above // code counts transpositions directly. // System.out.println("c: " + c); // System.out.println("t: " + t); // System.out.println("c/m: " + (c / (double) s1.length())); // System.out.println("c/n: " + (c / (double) s2.length())); // System.out.println("(c-t)/c: " + ((c - t) / (double) c)); // we might have to give up right here if ( c == 0 ) return 0.0 ; // first compute the score double score = ( ( c / ( double ) s1 . length ( ) ) + ( c / ( double ) s2 . length ( ) ) + ( ( c - t ) / ( double ) c ) ) / 3.0 ; // (2) common prefix modification int p = 0 ; // length of prefix int last = Math . min ( 4 , s1 . length ( ) ) ; for ( ; p < last && s1 . charAt ( p ) == s2 . charAt ( p ) ; p ++ ) ; score = score + ( ( p * ( 1 - score ) ) / 10 ) ; // (3) longer string adjustment // I'm confused about this part. Winkler's original source code includes // it, and Yancey's 2005 paper describes it. However, Winkler's list of // test cases in his 2006 paper does not include this modification. So // is this part of Jaro-Winkler, or is it not? Hard to say. // //   if (s1.length() >= 5 && // both strings at least 5 characters long //       c - p >= 2 && // at least two common characters besides prefix //       c - p >= ((s1.length() - p) / 2)) // fairly rich in common chars //     { //     System.out.println("ADJUSTED!"); //     score = score + ((1 - score) * ((c - (p + 1)) / //                                     ((double) ((s1.length() + s2.length()) //                                                - (2 * (p - 1)))))); // } // (4) similar characters adjustment // the same holds for this as for (3) above. return score ; }
public static long binCoeff ( int n , int k ) { if ( k > n ) { return 0 ; } if ( k == 0 || k == n ) { return 1 ; } long result = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { result *= ( n - i + 1 ) / i ; } return result ; }
public void post ( String jsonBody , Integer expectedResponseCode ) throws IOException { HttpURLConnection conn = getUrlConnection ( ) ; try { // send post request with json body for the topology if ( ! NetworkUtils . sendHttpPostRequest ( conn , NetworkUtils . JSON_TYPE , jsonBody . getBytes ( ) ) ) { throw new IOException ( "Failed to send POST to " + endpointURI ) ; } // check the response if ( ! NetworkUtils . checkHttpResponseCode ( conn , expectedResponseCode ) ) { byte [ ] bytes = NetworkUtils . readHttpResponse ( conn ) ; LOG . log ( Level . SEVERE , "Failed to send POST request to endpoint" ) ; LOG . log ( Level . SEVERE , new String ( bytes ) ) ; throw new IOException ( "Unexpected response from connection. Expected " + expectedResponseCode + " but received " + conn . getResponseCode ( ) ) ; } } finally { conn . disconnect ( ) ; } }
private void readPropertiesFiles ( ) { if ( this . messageFileWildcard . isEmpty ( ) || ! CoreParameters . LOG_RESOLUTION . get ( ) ) { // Skip configuration loading\r LOGGER . info ( JRebirthMarkers . MESSAGE , "Messages Loading is skipped" ) ; } else { // Assemble the regex pattern\r final Pattern filePattern = Pattern . compile ( this . messageFileWildcard + "\\\\.properties" ) ; // Retrieve all resources from default classpath\r final Collection < String > list = ClasspathUtility . getClasspathResources ( filePattern ) ; LOGGER . info ( JRebirthMarkers . MESSAGE , "{} Messages file{} found." , list . size ( ) , list . size ( ) > 1 ? "s" : "" ) ; for ( final String rbFilename : list ) { readPropertiesFile ( rbFilename ) ; } } }
private static byte [ ] writeCsv ( String [ ] columnHeaders , String [ ] [ ] rows ) throws IOException { try ( ByteArrayOutputStream csvStream = new ByteArrayOutputStream ( ) ; OutputStreamWriter streamWriter = new OutputStreamWriter ( csvStream , Charset . forName ( "UTF-8" ) ) ) { CSVWriter csvWriter = new CSVWriter ( streamWriter , ' ' ) ; csvWriter . writeNext ( columnHeaders ) ; for ( String [ ] row : rows ) { csvWriter . writeNext ( row ) ; } csvWriter . close ( ) ; return csvStream . toByteArray ( ) ; } }
public void check ( ) { getDispatcher ( ) . beforeCheck ( this ) ; RemoteWebElement e = ( RemoteWebElement ) getElement ( ) ; while ( ! e . isSelected ( ) ) { e . click ( ) ; } if ( Config . getBoolConfigProperty ( ConfigProperty . ENABLE_GUI_LOGGING ) ) { logUIAction ( UIActions . CHECKED ) ; } getDispatcher ( ) . afterCheck ( this ) ; }
CommandLine parse ( DefaultCommandLine cl , String [ ] args ) { parseInternal ( cl , args , true ) ; return cl ; }
private void cut ( XYChartLabel label , double maxWidth , double maxHeight , double rotation ) { String text = label . getLabel ( ) . getText ( ) ; // Cut text. cutLabelText ( label , maxWidth - 5 , maxHeight - 5 , rotation ) ; String cutText = label . getLabel ( ) . getText ( ) ; // If text is cut, add suffix characters. if ( text . length ( ) != cutText . length ( ) ) { label . getLabel ( ) . setText ( label . getLabel ( ) . getText ( ) + "..." ) ; } // TODO: Animate. // animate(label, text, cutText, originalRotation); // Move label to top. label . getLabelContainer ( ) . moveToTop ( ) ; }
protected static Number stringToNumber ( final String val ) throws NumberFormatException { char initial = val . charAt ( 0 ) ; if ( ( initial >= ' ' && initial <= ' ' ) || initial == ' ' ) { // decimal representation if ( isDecimalNotation ( val ) ) { // quick dirty way to see if we need a BigDecimal instead of a Double // this only handles some cases of overflow or underflow if ( val . length ( ) > 14 ) { return new BigDecimal ( val ) ; } final Double d = Double . valueOf ( val ) ; if ( d . isInfinite ( ) || d . isNaN ( ) ) { // if we can't parse it as a double, go up to BigDecimal // this is probably due to underflow like 4.32e-678 // or overflow like 4.65e5324. The size of the string is small // but can't be held in a Double. return new BigDecimal ( val ) ; } return d ; } // integer representation. // This will narrow any values to the smallest reasonable Object representation // (Integer, Long, or BigInteger) // string version // The compare string length method reduces GC, // but leads to smaller integers being placed in larger wrappers even though not // needed. i.e. 1,000,000,000 -> Long even though it's an Integer // 1,000,000,000,000,000,000 -> BigInteger even though it's a Long //if(val.length()<=9){ //    return Integer.valueOf(val); //} //if(val.length()<=18){ //    return Long.valueOf(val); //} //return new BigInteger(val); // BigInteger version: We use a similar bitLenth compare as // BigInteger#intValueExact uses. Increases GC, but objects hold // only what they need. i.e. Less runtime overhead if the value is // long lived. Which is the better tradeoff? This is closer to what's // in stringToValue. BigInteger bi = new BigInteger ( val ) ; if ( bi . bitLength ( ) <= 31 ) { return Integer . valueOf ( bi . intValue ( ) ) ; } if ( bi . bitLength ( ) <= 63 ) { return Long . valueOf ( bi . longValue ( ) ) ; } return bi ; } throw new NumberFormatException ( "val [" + val + "] is not a valid number." ) ; }
public void save ( File file ) throws IOException { try ( FileOutputStream fout = new FileOutputStream ( file ) ) { save ( fout ) ; } }
public static String readTextFile ( File file ) throws IOException { //create reader to file (with default encoding) InputStream inputStream = new FileInputStream ( file ) ; Reader reader = IOHelper . createReader ( inputStream , null ) ; //read text String text = IOHelper . readTextStream ( reader ) ; return text ; }
@ Override public void sortAtomContainers ( final Comparator < IAtomContainer > comparator ) { // need to use boxed primitives as we can't customise sorting of int primitives Integer [ ] indexes = new Integer [ atomContainerCount ] ; for ( int i = 0 ; i < indexes . length ; i ++ ) indexes [ i ] = i ; // proxy the index comparison to the atom container comparator Arrays . sort ( indexes , new Comparator < Integer > ( ) { @ Override public int compare ( Integer o1 , Integer o2 ) { return comparator . compare ( atomContainers [ o1 ] , atomContainers [ o2 ] ) ; } } ) ; // copy the original arrays (we could modify in place with swaps but this is cleaner) IAtomContainer [ ] containersTmp = Arrays . copyOf ( atomContainers , indexes . length ) ; Double [ ] multipliersTmp = Arrays . copyOf ( multipliers , indexes . length ) ; // order the arrays based on the order of the indices for ( int i = 0 ; i < indexes . length ; i ++ ) { atomContainers [ i ] = containersTmp [ indexes [ i ] ] ; multipliers [ i ] = multipliersTmp [ indexes [ i ] ] ; } }
public static void concatenate ( List < File > files , File concatenatedFile ) { BufferedWriter writer ; try { writer = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( concatenatedFile . getAbsoluteFile ( ) , false ) , DataUtilDefaults . charSet ) ) ; FileInputStream inputStream ; for ( File input : files ) { inputStream = new FileInputStream ( input ) ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream , "UTF-8" ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { writer . write ( line + DataUtilDefaults . lineTerminator ) ; } inputStream . close ( ) ; } writer . flush ( ) ; writer . close ( ) ; } catch ( UnsupportedEncodingException e ) { throw new DataUtilException ( e ) ; } catch ( FileNotFoundException e ) { throw new DataUtilException ( e ) ; } catch ( IOException e ) { throw new DataUtilException ( e ) ; } }
public boolean verifyChecked ( final By checkboxBy ) { WebElement element = driver . findElement ( checkboxBy ) ; if ( element . isSelected ( ) ) { LOG . info ( "Checkbox: " + element + " is checked!" ) ; return true ; } LOG . info ( "Checkbox: " + element + " is NOT checked!" ) ; return false ; }
public static double binomial ( int k , double p , int n ) { if ( k < 0 || p < 0 || n < 1 ) { throw new IllegalArgumentException ( "All the parameters must be positive and n larger than 1." ) ; } k = Math . min ( k , n ) ; /*\n        //Slow and can't handle large numbers\n        $probability=StatsUtilities::combination($n,$k)*pow($p,$k)*pow(1-$p,$n-$k);\n        */ //fast and can handle large numbers //Cdf(k)-Cdf(k-1) double probability = approxBinomialCdf ( k , p , n ) ; if ( k > 0 ) { probability -= approxBinomialCdf ( k - 1 , p , n ) ; } return probability ; }
private List decodeSort ( String value ) { ArrayList sorts = new ArrayList ( ) ; String [ ] nameAndSorts = value . split ( DELIM_GRID_NAME ) ; if ( nameAndSorts . length != 2 ) return null ; String namespace = nameAndSorts [ 0 ] ; String [ ] sortStrings = nameAndSorts [ 1 ] . split ( DELIM_SORT_TERM ) ; // find the list of sorted columns // two columns of the bugs grid would be sorted as: // // netui_sort=bugs~id,-priority for ( int i = 0 ; i < sortStrings . length ; i ++ ) { String sort = sortStrings [ i ] ; SortDirection sortDirection = SortDirection . NONE ; if ( sort . startsWith ( "-" ) ) sortDirection = SortDirection . DESCENDING ; else sortDirection = SortDirection . ASCENDING ; String sortExpression = ( sortDirection == SortDirection . DESCENDING ? sort . substring ( 1 ) : sort ) ; Sort gridSort = _config . createSort ( ) ; gridSort . setSortExpression ( sortExpression ) ; gridSort . setDirection ( sortDirection ) ; sorts . add ( gridSort ) ; } return sorts ; }
private void readPropertyFile ( ) { java . util . Properties props = new java . util . Properties ( ) ; try { File propertyFile = new File ( propertyFilePath + File . separator + PROPERTYFILENAME ) ; if ( propertyFile . exists ( ) ) { java . io . FileInputStream fis = null ; try { fis = new java . io . FileInputStream ( propertyFile ) ; props . load ( fis ) ; } finally { if ( fis != null ) try { fis . close ( ) ; } catch ( IOException ex ) { Log . error ( "IGNORED" , ex ) ; } } } searchPath = props . getProperty ( PROPERTY_SEARCHPATH , Helpers . HOMEDIR ) ; exportPath = props . getProperty ( PROPERTY_EXPORTPATH , Helpers . HOMEDIR ) ; uiClassName = props . getProperty ( PROPERTY_LOOKANDFEEL , javax . swing . UIManager . getSystemLookAndFeelClassName ( ) ) ; useSystemTray = Boolean . parseBoolean ( props . getProperty ( PROPERTY_SYSTEMTRAY , "FALSE" ) ) ; currentVolume = Float . parseFloat ( props . getProperty ( PROPERTY_VOLUME_VALUE , "1.0" ) ) ; currentBalance = Float . parseFloat ( props . getProperty ( PROPERTY_BALANCE_VALUE , "0.0" ) ) ; lastLoaded = new ArrayList < URL > ( PROPERTY_LASTLOADED_MAXENTRIES ) ; for ( int i = 0 ; i < PROPERTY_LASTLOADED_MAXENTRIES ; i ++ ) { String url = props . getProperty ( PROPERTY_LASTLOADED + ' ' + i , null ) ; if ( url != null ) lastLoaded . add ( new URL ( url ) ) ; else lastLoaded . add ( null ) ; } setDSPEnabled ( Boolean . parseBoolean ( props . getProperty ( PROPERTY_EFFECTS_PASSTHROUGH , "FALSE" ) ) ) ; mainDialogLocation = Helpers . getPointFromString ( props . getProperty ( PROPERTY_MAINDIALOG_POS , "-1x-1" ) ) ; mainDialogSize = Helpers . getDimensionFromString ( props . getProperty ( PROPERTY_MAINDIALOG_SIZE , "320x410" ) ) ; playerSetUpDialogLocation = Helpers . getPointFromString ( props . getProperty ( PROPERTY_SETUPDIALOG_POS , "-1x-1" ) ) ; playerSetUpDialogSize = Helpers . getDimensionFromString ( props . getProperty ( PROPERTY_SETUPDIALOG_SIZE , "720x230" ) ) ; playerSetUpDialogVisable = Boolean . parseBoolean ( props . getProperty ( PROPERTY_SETUPDIALOG_VISABLE , "false" ) ) ; modInfoDialogLocation = Helpers . getPointFromString ( props . getProperty ( PROPERTY_PROPERTIESDIALOG_POS , "-1x-1" ) ) ; modInfoDialogSize = Helpers . getDimensionFromString ( props . getProperty ( PROPERTY_PROPERTIESDIALOG_SIZE , "520x630" ) ) ; modInfoDialogVisable = Boolean . parseBoolean ( props . getProperty ( PROPERTY_PROPERTIESDIALOG_VISABLE , "false" ) ) ; playlistDialogLocation = Helpers . getPointFromString ( props . getProperty ( PROPERTY_PLAYLISTDIALOG_POS , "-1x-1" ) ) ; playlistDialogSize = Helpers . getDimensionFromString ( props . getProperty ( PROPERTY_PLAYLISTDIALOG_SIZE , "400x400" ) ) ; playlistDialogVisable = Boolean . parseBoolean ( props . getProperty ( PROPERTY_PLAYLIST_VISABLE , "false" ) ) ; effectsDialogLocation = Helpers . getPointFromString ( props . getProperty ( PROPERTY_EFFECTDIALOG_POS , "-1x-1" ) ) ; effectsDialogSize = Helpers . getDimensionFromString ( props . getProperty ( PROPERTY_EFFECTDIALOG_SIZE , "560x470" ) ) ; effectDialogVisable = Boolean . parseBoolean ( props . getProperty ( PROPERTY_EFFECT_VISABLE , "false" ) ) ; if ( currentEqualizer != null ) { boolean isActive = Boolean . parseBoolean ( props . getProperty ( PROPERTY_EQUALIZER_ISACTIVE , "FALSE" ) ) ; currentEqualizer . setIsActive ( isActive ) ; float preAmpValueDB = Float . parseFloat ( props . getProperty ( PROPERTY_EQUALIZER_PREAMP , "0.0" ) ) ; currentEqualizer . setPreAmp ( preAmpValueDB ) ; for ( int i = 0 ; i < currentEqualizer . getBandCount ( ) ; i ++ ) { float bandValueDB = Float . parseFloat ( props . getProperty ( PROPERTY_EQUALIZER_BAND_PREFIX + Integer . toString ( i ) , "0.0" ) ) ; currentEqualizer . setBand ( i , bandValueDB ) ; } } if ( currentPitchShift != null ) { boolean isActive = Boolean . parseBoolean ( props . getProperty ( PROPERTY_PITCHSHIFT_ISACTIVE , "FALSE" ) ) ; currentPitchShift . setIsActive ( isActive ) ; float pitchValue = Float . parseFloat ( props . getProperty ( PROPERTY_PITCHSHIFT_PITCH , "1.0" ) ) ; currentPitchShift . setPitchScale ( pitchValue ) ; float scaleValue = Float . parseFloat ( props . getProperty ( PROPERTY_PITCHSHIFT_SAMPLESCALE , "1.0" ) ) ; currentPitchShift . setSampleScale ( scaleValue ) ; int overSampling = Integer . parseInt ( props . getProperty ( PROPERTY_PITCHSHIFT_OVERSAMPLING , "32" ) ) ; currentPitchShift . setFFTOversampling ( overSampling ) ; int frameSize = Integer . parseInt ( props . getProperty ( PROPERTY_PITCHSHIFT_FRAMESIZE , "8192" ) ) ; currentPitchShift . setFFTFrameSize ( frameSize ) ; } MultimediaContainerManager . configureContainer ( props ) ; } catch ( Throwable ex ) { Log . error ( "[MainForm]" , ex ) ; } }
@ SuppressWarnings ( "unchecked" ) public static Map < String , String > parseCommandLineArguments ( String [ ] args ) { return ( Map ) parseCommandLineArguments ( args , false ) ; }
public final void fileCopy ( File in , File out ) throws IOException { assert in != null ; assert out != null ; getLog ( ) . debug ( "Copying file: " + in . toString ( ) + " into " + out . toString ( ) ) ; //$NON-NLS-1$ //$NON-NLS-2$ try ( FileInputStream fis = new FileInputStream ( in ) ) { try ( FileChannel inChannel = fis . getChannel ( ) ) { try ( FileOutputStream fos = new FileOutputStream ( out ) ) { try ( FileChannel outChannel = fos . getChannel ( ) ) { inChannel . transferTo ( 0 , inChannel . size ( ) , outChannel ) ; } } } } finally { getBuildContext ( ) . refresh ( out ) ; } }
public boolean replaceStringsInFile ( String filePath , Map < String , String > replaceValues ) { return replaceStringsInFile ( filePath , replaceValues , null ) ; }
public static PlotCanvas plot ( String id , double [ ] [ ] data , int [ ] y , char [ ] legend , Color [ ] palette ) { if ( data [ 0 ] . length != 2 && data [ 0 ] . length != 3 ) { throw new IllegalArgumentException ( "Invalid data dimension: " + data [ 0 ] . length ) ; } double [ ] lowerBound = Math . colMin ( data ) ; double [ ] upperBound = Math . colMax ( data ) ; PlotCanvas canvas = new PlotCanvas ( lowerBound , upperBound ) ; ScatterPlot plot = new ScatterPlot ( data , y , legend , palette ) ; plot . setID ( id ) ; canvas . add ( plot ) ; return canvas ; }
public static Properties readPropertiesFromFile ( File file ) throws IOException { try ( FileInputStream fis = new FileInputStream ( file ) ) { Properties prop = new Properties ( ) ; prop . load ( fis ) ; return prop ; } }
public static void extractZip ( File file ) throws FileNotFoundException , IOException { final String originalPath = file . getPath ( ) ; final File zip = new File ( originalPath + ".zip" ) ; if ( zip . isFile ( ) && ! zip . delete ( ) ) { LOGGER . debug ( "Failed to delete initial temporary file when extracting 'zip' {}" , zip . toString ( ) ) ; zip . deleteOnExit ( ) ; } if ( ! file . renameTo ( zip ) ) { throw new IOException ( "Unable to rename '" + file . getPath ( ) + "'" ) ; } final File newFile = new File ( originalPath ) ; try ( FileInputStream fis = new FileInputStream ( zip ) ; ZipInputStream cin = new ZipInputStream ( fis ) ; FileOutputStream out = new FileOutputStream ( newFile ) ) { cin . getNextEntry ( ) ; IOUtils . copy ( cin , out ) ; } finally { if ( zip . isFile ( ) && ! org . apache . commons . io . FileUtils . deleteQuietly ( zip ) ) { LOGGER . debug ( "Failed to delete temporary file when extracting 'zip' {}" , zip . toString ( ) ) ; zip . deleteOnExit ( ) ; } } }
public static String reverse ( final String str ) { if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse ( ) . toString ( ) ; }
public static DocumentContext parse ( File json , Configuration configuration ) throws IOException { return new ParseContextImpl ( configuration ) . parse ( json ) ; }
public HtmlElement findHtmlElementById ( String elementId ) { try { return htmlPage . getHtmlElementById ( elementId ) ; } catch ( ElementNotFoundException e ) { return null ; } }
public static BufferedReader newReader ( Path self ) throws IOException { return Files . newBufferedReader ( self , Charset . defaultCharset ( ) ) ; }
public void writeExcelFile ( ) throws IOException , WriteException { WritableWorkbook excelWrkBook = null ; int curDsPointer = 0 ; try { final String [ ] columnNames = ds . getColumns ( ) ; final List < String > exportOnlyColumnsList = getExportOnlyColumns ( ) != null ? Arrays . asList ( exportOnlyColumns ) : null ; final List < String > excludeFromExportColumnsList = getExcludeFromExportColumns ( ) != null ? Arrays . asList ( excludeFromExportColumns ) : null ; final List < String > numericColumnList = getNumericColumns ( ) != null ? Arrays . asList ( getNumericColumns ( ) ) : new ArrayList < > ( ) ; // get the current position of the DataSet. We have to go to the top\r // to do this write,\r // and we will put the pionter back where it was after we are done\r curDsPointer = ds . getIndex ( ) ; ds . goTop ( ) ; excelWrkBook = Workbook . createWorkbook ( xlsFile ) ; final WritableSheet wrkSheet = excelWrkBook . createSheet ( "results" , 0 ) ; final WritableFont times10ptBold = new WritableFont ( WritableFont . TIMES , 10 , WritableFont . BOLD ) ; final WritableFont times10pt = new WritableFont ( WritableFont . TIMES , 10 , WritableFont . NO_BOLD ) ; // write the column headings in the spreadsheet\r WritableCellFormat cellFormat = new WritableCellFormat ( times10ptBold ) ; int colOffset = 0 ; for ( int i = 0 ; i < columnNames . length ; i ++ ) { if ( exportOnlyColumnsList != null && ! exportOnlyColumnsList . contains ( columnNames [ i ] ) || excludeFromExportColumnsList != null && excludeFromExportColumnsList . contains ( columnNames [ i ] ) ) { colOffset ++ ; continue ; } final Label xlsTextLbl = new Label ( i - colOffset , 0 , columnNames [ i ] , cellFormat ) ; wrkSheet . addCell ( xlsTextLbl ) ; } cellFormat = new WritableCellFormat ( times10pt ) ; int row = 1 ; while ( ds . next ( ) ) { if ( ! ds . isRecordID ( FPConstants . DETAIL_ID ) ) { continue ; } colOffset = 0 ; for ( int i = 0 ; i < columnNames . length ; i ++ ) { if ( exportOnlyColumnsList != null && ! exportOnlyColumnsList . contains ( columnNames [ i ] ) || excludeFromExportColumnsList != null && excludeFromExportColumnsList . contains ( columnNames [ i ] ) ) { colOffset ++ ; continue ; } WritableCell wc = null ; if ( numericColumnList . contains ( columnNames [ i ] ) ) { wc = new Number ( i - colOffset , row , ds . getDouble ( columnNames [ i ] ) , cellFormat ) ; } else { wc = new Label ( i - colOffset , row , ds . getString ( columnNames [ i ] ) , cellFormat ) ; } wrkSheet . addCell ( wc ) ; } row ++ ; } excelWrkBook . write ( ) ; } finally { if ( curDsPointer > - 1 ) { ds . absolute ( curDsPointer ) ; } if ( excelWrkBook != null ) { excelWrkBook . close ( ) ; } } }
public Matrix multiply ( Matrix B , ExecutorService threadPool ) { Matrix C = new DenseMatrix ( this . rows ( ) , B . cols ( ) ) ; multiply ( B , C , threadPool ) ; return C ; }
public static IntStreamEx of ( Random random , int randomNumberOrigin , int randomNumberBound ) { return seq ( random . ints ( randomNumberOrigin , randomNumberBound ) ) ; }
public static double quantile ( double x , double mu , double sigma ) { return FastMath . exp ( mu + sigma * NormalDistribution . standardNormalQuantile ( x ) ) ; }
public String getCsv ( ) { StringWriter writer = new StringWriter ( ) ; try ( CSVWriter csv = new CSVWriter ( writer ) ) { List < String > headers = new ArrayList < > ( ) ; for ( String col : m_columns ) { headers . add ( col ) ; } csv . writeNext ( headers . toArray ( new String [ ] { } ) ) ; for ( List < Object > row : m_data ) { List < String > colCsv = new ArrayList < > ( ) ; for ( Object col : row ) { colCsv . add ( String . valueOf ( col ) ) ; } csv . writeNext ( colCsv . toArray ( new String [ ] { } ) ) ; } return writer . toString ( ) ; } catch ( IOException e ) { return null ; } }
protected Socket acceptSocket ( int timeout ) { try { Socket s = null ; if ( _listen != null ) { if ( _soTimeOut != timeout ) { _soTimeOut = timeout ; _listen . setSoTimeout ( _soTimeOut ) ; } s = _listen . accept ( ) ; try { if ( getMaxIdleTimeMs ( ) >= 0 ) s . setSoTimeout ( getMaxIdleTimeMs ( ) ) ; if ( _lingerTimeSecs >= 0 ) s . setSoLinger ( true , _lingerTimeSecs ) ; else s . setSoLinger ( false , 0 ) ; } catch ( Exception e ) { LogSupport . ignore ( log , e ) ; } } return s ; } catch ( java . net . SocketException e ) { // TODO - this is caught and ignored due strange // exception from linux java1.2.v1a LogSupport . ignore ( log , e ) ; } catch ( InterruptedIOException e ) { LogSupport . ignore ( log , e ) ; } catch ( IOException e ) { log . warn ( LogSupport . EXCEPTION , e ) ; } return null ; }
public static InputStream decompress ( final InputStream in , final String fileName ) throws IOException { if ( fileName . endsWith ( GZ_SUFFIX ) ) { return gzipInputStream ( in ) ; } else if ( fileName . endsWith ( BZ2_SUFFIX ) ) { return new BZip2CompressorInputStream ( in , true ) ; } else if ( fileName . endsWith ( XZ_SUFFIX ) ) { return new XZCompressorInputStream ( in , true ) ; } else if ( fileName . endsWith ( SNAPPY_SUFFIX ) ) { return new FramedSnappyCompressorInputStream ( in ) ; } else if ( fileName . endsWith ( ZSTD_SUFFIX ) ) { return new ZstdCompressorInputStream ( in ) ; } else if ( fileName . endsWith ( ZIP_SUFFIX ) ) { // This reads the first file in the archive. final ZipInputStream zipIn = new ZipInputStream ( in , StandardCharsets . UTF_8 ) ; try { final ZipEntry nextEntry = zipIn . getNextEntry ( ) ; if ( nextEntry == null ) { zipIn . close ( ) ; // No files in the archive - return an empty stream. return new ByteArrayInputStream ( new byte [ 0 ] ) ; } return zipIn ; } catch ( IOException e ) { try { zipIn . close ( ) ; } catch ( IOException e2 ) { e . addSuppressed ( e2 ) ; } throw e ; } } else { return in ; } }
public void addScatterPlot ( String scatterID , String xAxisLabel , String yAxisLabel ) throws ShanksException { if ( ! this . timeCharts . containsKey ( scatterID ) ) { ScatterPlotGenerator scatter = new ScatterPlotGenerator ( ) ; scatter . setTitle ( scatterID ) ; scatter . setXAxisLabel ( xAxisLabel ) ; scatter . setYAxisLabel ( yAxisLabel ) ; this . scatterPlots . put ( scatterID , scatter ) ; } else { throw new DuplicatedChartIDException ( scatterID ) ; } }
public static void main ( String [ ] args ) throws IOException { Arguments arguments = new Arguments ( ) . parse ( args ) ; if ( arguments . isUseCommonsLang3 ( ) ) { System . err . println ( "--commons-lang3 is deprecated. Please remove the argument from your command-line arguments." ) ; } Jsonschema2Pojo . generate ( arguments ) ; }
private void extract ( String htmlDoc ) { //now extract the contents of <body>... int bodyStart = htmlDoc . indexOf ( BODY_BEGIN ) + BODY_BEGIN . length ( ) ; //scan for end of the <body> start tag (beginning of body content) char quote = NOT_IN_QUOTE ; for ( int body = bodyStart ; body < htmlDoc . length ( ) ; body ++ ) { final char c = htmlDoc . charAt ( body ) ; if ( isQuoteChar ( c ) ) { if ( quote == NOT_IN_QUOTE ) quote = c ; else if ( quote == c ) quote = NOT_IN_QUOTE ; } if ( ' ' == c && NOT_IN_QUOTE == quote ) { bodyStart = body + 1 ; break ; } } int bodyEnd = htmlDoc . indexOf ( BODY_END , bodyStart ) ; //if there was no body tag, just embed whatever was rendered directly if ( - 1 == bodyEnd ) { EmbeddedRespond . this . body = htmlDoc ; } else EmbeddedRespond . this . body = htmlDoc . substring ( bodyStart , bodyEnd ) ; }
public long getElapsedMinutes ( ) { long elapsed ; if ( running ) { elapsed = ( System . nanoTime ( ) - startTime ) ; } else { elapsed = ( stopTime - startTime ) ; } return elapsed / nsPerMm ; }
synchronized int size ( int priority ) { if ( priority < 0 || priority >= LEVEL ) { throw new IllegalArgumentException ( "Unsupported priority: " + priority ) ; } return priorityQueues . get ( priority ) . size ( ) ; }
public static Clustering kMeans_gta ( int k , Clustering clustering , Clustering gtClustering ) { ArrayList < CFCluster > microclusters = new ArrayList < CFCluster > ( ) ; for ( int i = 0 ; i < clustering . size ( ) ; i ++ ) { if ( clustering . get ( i ) instanceof CFCluster ) { microclusters . add ( ( CFCluster ) clustering . get ( i ) ) ; } else { System . out . println ( "Unsupported Cluster Type:" + clustering . get ( i ) . getClass ( ) + ". Cluster needs to extend moa.cluster.CFCluster" ) ; } } int n = microclusters . size ( ) ; assert ( k <= n ) ; /* k-means */ Random random = new Random ( 0 ) ; Cluster [ ] centers = new Cluster [ k ] ; int K = gtClustering . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( i < K ) { // GT-aided centers [ i ] = new SphereCluster ( gtClustering . get ( i ) . getCenter ( ) , 0 ) ; } else { // Randomized int rid = random . nextInt ( n ) ; centers [ i ] = new SphereCluster ( microclusters . get ( rid ) . getCenter ( ) , 0 ) ; } } return cleanUpKMeans ( kMeans ( k , centers , microclusters ) , microclusters ) ; }
protected int getCurrentProcessID ( ) throws ProcessHandlerException { int pid ; // Not ideal but using JNA failed on RHEL5. RuntimeMXBean runtime = ManagementFactory . getRuntimeMXBean ( ) ; Field jvm = null ; try { jvm = runtime . getClass ( ) . getDeclaredField ( "jvm" ) ; jvm . setAccessible ( true ) ; VMManagement mgmt = ( VMManagement ) jvm . get ( runtime ) ; Method pid_method = mgmt . getClass ( ) . getDeclaredMethod ( "getProcessId" ) ; pid_method . setAccessible ( true ) ; pid = ( Integer ) pid_method . invoke ( mgmt ) ; } catch ( NoSuchFieldException | NoSuchMethodException | IllegalAccessException | InvocationTargetException e ) { throw new ProcessHandlerException ( e ) ; } return pid ; }
public void setBinomialDistribution ( BinomialDistributionType newBinomialDistribution ) { ( ( FeatureMap . Internal ) getMixed ( ) ) . set ( BpsimPackage . Literals . DOCUMENT_ROOT__BINOMIAL_DISTRIBUTION , newBinomialDistribution ) ; }
private ByteBuffer recv ( int attempt ) throws IOException , SocketException , SocketTimeoutException { int timeout = UDP_BASE_TIMEOUT_SECONDS * ( int ) Math . pow ( 2 , attempt ) ; logger . trace ( "Setting receive timeout to {}s for attempt {}..." , timeout , attempt ) ; this . socket . setSoTimeout ( timeout * 1000 ) ; try { DatagramPacket p = new DatagramPacket ( new byte [ UDP_PACKET_LENGTH ] , UDP_PACKET_LENGTH ) ; this . socket . receive ( p ) ; return ByteBuffer . wrap ( p . getData ( ) , 0 , p . getLength ( ) ) ; } catch ( SocketTimeoutException ste ) { throw ste ; } }
public JsonResponse apiPost ( ApiParams data , ApiFileParams fileParams ) throws IOException { return httpRequestJson ( HttpRequestMethod . POST , data , fileParams ) ; }
protected void selectCheckbox ( PageElement element , String valueKeyOrKey , Map < String , Boolean > values ) throws TechnicalException , FailureException { final String valueKey = Context . getValue ( valueKeyOrKey ) != null ? Context . getValue ( valueKeyOrKey ) : valueKeyOrKey ; try { final WebElement webElement = Context . waitUntil ( ExpectedConditions . elementToBeClickable ( Utilities . getLocator ( element ) ) ) ; Boolean checkboxValue = values . get ( valueKey ) ; if ( checkboxValue == null ) { checkboxValue = values . get ( "Default" ) ; } if ( webElement . isSelected ( ) != checkboxValue . booleanValue ( ) ) { webElement . click ( ) ; } } catch ( final Exception e ) { new Result . Failure < > ( e . getMessage ( ) , Messages . format ( Messages . getMessage ( Messages . FAIL_MESSAGE_UNABLE_TO_CHECK_ELEMENT ) , element , element . getPage ( ) . getApplication ( ) ) , true , element . getPage ( ) . getCallBack ( ) ) ; } }
public synchronized static void write ( int fd , ByteBuffer ... data ) throws IOException { // write each byte buffer to the serial port for ( ByteBuffer single : data ) { // read the byte buffer from the current position up to the limit byte [ ] payload = new byte [ single . remaining ( ) ] ; single . get ( payload ) ; // write the data contents to the serial port via JNI native method write ( fd , payload , payload . length ) ; } }
public static void extractZip ( File zip , File toDir ) throws IOException { if ( ! toDir . exists ( ) ) { throw new IOException ( "Directory '" + toDir + "' does not exist." ) ; } try ( ZipFile zipFile = new ZipFile ( zip ) ) { Enumeration < ? extends ZipEntry > entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { ZipEntry entry = entries . nextElement ( ) ; File target = new File ( toDir , entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { // Assume directories are stored parents first then children. //logger.info("Extracting directory: " + entry.getName()); // This is not robust, just for demonstration purposes. if ( ! target . mkdirs ( ) ) { logger . warning ( "Could not create directory " + target ) ; } continue ; } // zips can contain nested files in sub-dirs without separate entries for the directories if ( ! target . getParentFile ( ) . exists ( ) && ! target . getParentFile ( ) . mkdirs ( ) ) { logger . warning ( "Could not create directory " + target . getParentFile ( ) ) ; } //logger.info("Extracting file: " + entry.getName()); try ( InputStream inputStream = zipFile . getInputStream ( entry ) ) { try ( BufferedOutputStream outputStream = new BufferedOutputStream ( new FileOutputStream ( target ) ) ) { IOUtils . copy ( inputStream , outputStream ) ; } } } } catch ( FileNotFoundException | NoSuchFileException e ) { throw e ; } catch ( IOException e ) { throw new IOException ( "While extracting file " + zip + " to " + toDir , e ) ; } }
public Matrix multiply ( double k ) { double pv [ ] [ ] = new double [ nRows ] [ nCols ] ; // product values // Compute values of the product. for ( int r = 0 ; r < nRows ; ++ r ) { for ( int c = 0 ; c < nCols ; ++ c ) { pv [ r ] [ c ] = k * values [ r ] [ c ] ; } } return new Matrix ( pv ) ; }
public long getElapsedTicks ( ) { long elapsed ; if ( running ) { elapsed = ( System . nanoTime ( ) - startTime ) ; } else { elapsed = ( stopTime - startTime ) ; } return elapsed / nsPerTick ; }
public void connectToPostgreSQLDatabase ( String database , String host , String port , String user , String password , Boolean secure , String ca , String crt , String key ) throws SQLException { if ( port . startsWith ( "[" ) ) { port = port . substring ( 1 , port . length ( ) - 1 ) ; } if ( ! secure ) { if ( password == null ) { password = "stratio" ; } try { myConnection = DriverManager . getConnection ( "jdbc:postgresql://" + host + ":" + port + "/" + database , user , password ) ; } catch ( SQLException se ) { // log the exception this . getLogger ( ) . error ( se . getMessage ( ) ) ; // re-throw the exception throw se ; } } else { Properties props = new Properties ( ) ; if ( user != null ) { props . setProperty ( "user" , user ) ; } if ( ca != null ) { props . setProperty ( "sslrootcert" , ca ) ; } if ( crt != null ) { props . setProperty ( "sslcert" , crt ) ; } if ( key != null ) { props . setProperty ( "sslkey" , key ) ; } props . setProperty ( "password" , "null" ) ; props . setProperty ( "ssl" , "true" ) ; props . setProperty ( "sslmode" , "verify-full" ) ; try { myConnection = DriverManager . getConnection ( "jdbc:postgresql://" + host + ":" + port + "/" + database , props ) ; } catch ( SQLException se ) { // log the exception this . getLogger ( ) . error ( se . getMessage ( ) ) ; // re-throw the exception throw se ; } } }
public Closure < V > memoizeAtMost ( final int maxCacheSize ) { if ( maxCacheSize < 0 ) throw new IllegalArgumentException ( "A non-negative number is required as the maxCacheSize parameter for memoizeAtMost." ) ; return Memoize . buildMemoizeFunction ( new LRUCache ( maxCacheSize ) , this ) ; }
public static void unzip ( File file , File destDir ) throws IOException { if ( ! destDir . exists ( ) ) { destDir . mkdir ( ) ; } ZipInputStream zipIn = new ZipInputStream ( new FileInputStream ( file ) ) ; ZipEntry entry = zipIn . getNextEntry ( ) ; // iterates over entries in the zip file while ( entry != null ) { File entryFile = new File ( destDir , entry . getName ( ) ) ; if ( ! entry . isDirectory ( ) ) { // if the entry is a file, extracts it extractFile ( zipIn , entryFile ) ; } else { // if the entry is a directory, make the directory entryFile . mkdir ( ) ; } zipIn . closeEntry ( ) ; entry = zipIn . getNextEntry ( ) ; } zipIn . close ( ) ; }
public long getElapsedSeconds ( ) { long elapsed ; if ( running ) { elapsed = ( System . nanoTime ( ) - startTime ) ; } else { elapsed = ( stopTime - startTime ) ; } return elapsed / nsPerSs ; }
public static void writeCsv ( List < String [ ] > csvData , String fileName ) throws IOException { Preconditions . checkNotNull ( csvData , "Null CSV data" ) ; Preconditions . checkNotNull ( fileName , "Null file name" ) ; CSVWriter writer = null ; try { writer = new CSVWriter ( Files . newWriter ( new File ( fileName ) , StandardCharsets . UTF_8 ) ) ; for ( String [ ] line : csvData ) { writer . writeNext ( line ) ; } } finally { if ( writer != null ) { writer . close ( ) ; } } }
private void linkToEmitter ( String name , LinearInterpolator interpol ) { // put to value map\r valueMap . put ( name , interpol ) ; // now update the checkbox to represent the state of the given\r // interpolator\r boolean checked = interpol . isActive ( ) ; JCheckBox enableControl = ( JCheckBox ) valueNameToControl . get ( name ) ; enableControl . setSelected ( false ) ; if ( checked ) enableControl . setSelected ( checked ) ; }
public static int indexOfIgnoreCase ( String text , String str , int startIndex ) { Matcher m = Pattern . compile ( Pattern . quote ( str ) , Pattern . CASE_INSENSITIVE ) . matcher ( text ) ; return m . find ( startIndex ) ? m . start ( ) : - 1 ; }
public static double cdf ( double x , double mu , double sigma ) { if ( x <= 0. ) { return 0. ; } return .5 * ( 1 + NormalDistribution . erf ( ( FastMath . log ( x ) - mu ) / ( MathUtil . SQRT2 * sigma ) ) ) ; }
public S animate ( Timer timer ) { long elapsed = timer . elapsedTime ( ) - Timer . tickToTime ( delay ) ; started = elapsed > transform . getDelay ( ) ; finished = elapsed > transform . totalDuration ( ) && transform . getLoops ( ) != - 1 ; if ( ! started && ! renderBefore ) return null ; if ( finished && ! renderAfter ) return null ; transform . transform ( transformable , elapsed ) ; return transformable ; }
protected Widget addMarker ( String text ) { Label label = new Label ( text ) ; label . addStyleName ( CSS . marker ( ) ) ; getListItemWidget ( ) . addButton ( label ) ; return label ; }
public static Date formatToStartOfDay ( final Date date ) { try { SimpleDateFormat dateFormat = buildDateFormat ( DEFAULT_DATE_SIMPLE_PATTERN ) ; String formattedDate = dateFormat . format ( date ) ; return dateFormat . parse ( formattedDate ) ; } catch ( ParseException pe ) { throw new DateException ( "Unparseable date specified." , pe ) ; } }
public static int levenshteinDistance ( CharSequence s , CharSequence t ) { // degenerate cases          s if ( s == null || "" . equals ( s ) ) { return t == null || "" . equals ( t ) ? 0 : t . length ( ) ; } else if ( t == null || "" . equals ( t ) ) { return s . length ( ) ; } // create two work vectors of integer distances int [ ] v0 = new int [ t . length ( ) + 1 ] ; int [ ] v1 = new int [ t . length ( ) + 1 ] ; // initialize v0 (the previous row of distances) // this row is A[0][i]: edit distance for an empty s // the distance is just the number of characters to delete from t for ( int i = 0 ; i < v0 . length ; i ++ ) { v0 [ i ] = i ; } int sLen = s . length ( ) ; int tLen = t . length ( ) ; for ( int i = 0 ; i < sLen ; i ++ ) { // calculate v1 (current row distances) from the previous row v0 // first element of v1 is A[i+1][0] //   edit distance is delete (i+1) chars from s to match empty t v1 [ 0 ] = i + 1 ; // use formula to fill in the rest of the row for ( int j = 0 ; j < tLen ; j ++ ) { int cost = ( s . charAt ( i ) == t . charAt ( j ) ) ? 0 : 1 ; v1 [ j + 1 ] = ( int ) MathUtilities . minimum ( v1 [ j ] + 1 , v0 [ j + 1 ] + 1 , v0 [ j ] + cost ) ; } // copy v1 (current row) to v0 (previous row) for next iteration System . arraycopy ( v1 , 0 , v0 , 0 , v0 . length ) ; } return v1 [ t . length ( ) ] ; }
public static HtmlPage toHtmlPage ( String string ) { try { URL url = new URL ( "http://bitvunit.codescape.de/some_page.html" ) ; return HTMLParser . parseHtml ( new StringWebResponse ( string , url ) , new WebClient ( ) . getCurrentWindow ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( "Error creating HtmlPage from String." , e ) ; } }
public byte [ ] getHardwareAddress ( ) { if ( CurrentTime . isTest ( ) || System . getProperty ( "test.mac" ) != null ) { return new byte [ ] { 10 , 0 , 0 , 0 , 0 , 10 } ; } for ( NetworkInterfaceBase nic : getNetworkInterfaces ( ) ) { if ( ! nic . isLoopback ( ) ) { return nic . getHardwareAddress ( ) ; } } try { InetAddress localHost = InetAddress . getLocalHost ( ) ; return localHost . getAddress ( ) ; } catch ( Exception e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } return new byte [ 0 ] ; }
public static < T > T median ( List < ? extends T > data , Comparator < ? super T > comparator ) { return median ( data , comparator , 0 , data . size ( ) ) ; }
public static int [ ] sort ( double [ ] arr ) { int [ ] order = new int [ arr . length ] ; for ( int i = 0 ; i < order . length ; i ++ ) { order [ i ] = i ; } sort ( arr , order ) ; return order ; }
InputStream getInputStream ( ) throws IOException { switch ( filetype ) { case GZ : LOG . debug ( "Decompressing .gz file" ) ; return new GzipCompressorInputStream ( new FileInputStream ( compressedFile ) ) ; case BZ2 : LOG . debug ( "Decompressing .bz2 file" ) ; return new BZip2CompressorInputStream ( new FileInputStream ( compressedFile ) ) ; } return null ; }
@ SuppressWarnings ( "unchecked" ) public static < T > T [ ] filter ( T [ ] array , Filter < T > filter ) { Assert . notNull ( array , "Array is required" ) ; Assert . notNull ( filter , "Filter is required" ) ; List < T > arrayList = stream ( array ) . filter ( filter :: accept ) . collect ( Collectors . toList ( ) ) ; return arrayList . toArray ( ( T [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , arrayList . size ( ) ) ) ; }
public < T > List < T > randomElements ( List < T > elements , int count ) { if ( elements . size ( ) >= count ) { return extractRandomList ( elements , count ) ; } else { List < T > randomElements = new ArrayList < T > ( ) ; randomElements . addAll ( extractRandomList ( elements , count % elements . size ( ) ) ) ; do { randomElements . addAll ( extractRandomList ( elements , elements . size ( ) ) ) ; } while ( randomElements . size ( ) < count ) ; return randomElements ; } }
public void doAESEncryption ( ) throws Exception { if ( ! initAESDone ) initAES ( ) ; cipher = Cipher . getInstance ( "AES/CBC/PKCS5Padding" ) ; //System.out.println(secretKey.getEncoded()); cipher . init ( Cipher . ENCRYPT_MODE , secretKey ) ; AlgorithmParameters params = cipher . getParameters ( ) ; iv = params . getParameterSpec ( IvParameterSpec . class ) . getIV ( ) ; secretCipher = cipher . doFinal ( secretPlain ) ; clearPlain ( ) ; }
public static Map < String , List < String > > extractHTMLheaders ( String html ) { Map < String , List < String > > hxtagsMap = new HashMap < > ( ) ; for ( int i = 1 ; i <= 6 ; ++ i ) { hxtagsMap . put ( "H" + i , new ArrayList < > ( ) ) ; } Matcher m = HX_PATTERN . matcher ( html ) ; while ( m . find ( ) ) { if ( m . groupCount ( ) == 2 ) { String tagType = m . group ( 1 ) . toUpperCase ( Locale . ENGLISH ) ; String content = m . group ( 2 ) ; hxtagsMap . get ( tagType ) . add ( clear ( content ) ) ; } } return hxtagsMap ; }
public UniqueModel unique ( ) { checkReadOnly ( ) ; UniqueModel unique = new UniqueModel ( ) ; unique . setTableModel ( this ) ; getUniqueConsts ( ) . add ( unique ) ; return unique ; }
protected static Clustering cleanUpKMeans ( Clustering kMeansResult , ArrayList < CFCluster > microclusters ) { /* Convert k-means result to CFClusters */ int k = kMeansResult . size ( ) ; CFCluster [ ] converted = new CFCluster [ k ] ; for ( CFCluster mc : microclusters ) { // Find closest kMeans cluster double minDistance = Double . MAX_VALUE ; int closestCluster = 0 ; for ( int i = 0 ; i < k ; i ++ ) { double distance = distance ( kMeansResult . get ( i ) . getCenter ( ) , mc . getCenter ( ) ) ; if ( distance < minDistance ) { closestCluster = i ; minDistance = distance ; } } // Add to cluster if ( converted [ closestCluster ] == null ) { converted [ closestCluster ] = ( CFCluster ) mc . copy ( ) ; } else { converted [ closestCluster ] . add ( mc ) ; } } // Clean up int count = 0 ; for ( int i = 0 ; i < converted . length ; i ++ ) { if ( converted [ i ] != null ) count ++ ; } CFCluster [ ] cleaned = new CFCluster [ count ] ; count = 0 ; for ( int i = 0 ; i < converted . length ; i ++ ) { if ( converted [ i ] != null ) cleaned [ count ++ ] = converted [ i ] ; } return new Clustering ( cleaned ) ; }
public static ConfusionMatrix createCumulativeMatrix ( ConfusionMatrix ... matrices ) { ConfusionMatrix result = new ConfusionMatrix ( ) ; for ( ConfusionMatrix matrix : matrices ) { for ( Map . Entry < String , Map < String , Integer > > gold : matrix . map . entrySet ( ) ) { for ( Map . Entry < String , Integer > actual : gold . getValue ( ) . entrySet ( ) ) { result . increaseValue ( gold . getKey ( ) , actual . getKey ( ) , actual . getValue ( ) ) ; } } } return result ; }
public Matrix multiply ( Matrix m ) throws MatrixException { // Validate m's dimensions. if ( nCols != m . nRows ) { throw new MatrixException ( MatrixException . INVALID_DIMENSIONS ) ; } double pv [ ] [ ] = new double [ nRows ] [ m . nCols ] ; // product values // Compute values of the product. for ( int r = 0 ; r < nRows ; ++ r ) { for ( int c = 0 ; c < m . nCols ; ++ c ) { double dot = 0 ; for ( int k = 0 ; k < nCols ; ++ k ) { dot += values [ r ] [ k ] * m . values [ k ] [ c ] ; } pv [ r ] [ c ] = dot ; } } return new Matrix ( pv ) ; }
public static String reverseString ( String str ) { StringBuilder stringBuffer = new StringBuilder ( str ) ; return stringBuffer . reverse ( ) . toString ( ) ; }
public static double kMeans ( List < double [ ] > centroids , List < double [ ] > input ) { int k = centroids . size ( ) ; assert ( k > 0 ) ; int d = centroids . get ( 0 ) . length ; int size = input . size ( ) ; double [ ] [ ] center = new double [ k ] [  ] ; Iterator < double [ ] > iIter = centroids . iterator ( ) ; for ( int i = 0 ; i < k ; i ++ ) { center [ i ] = iIter . next ( ) ; } double [ ] [ ] newCenter = new double [ k ] [ d ] ; double [ ] newCenterWeight = new double [ k ] ; int [ ] nearestCluster = new int [ size ] ; boolean converged ; do { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < d ; j ++ ) { newCenter [ i ] [ j ] = 0.0 ; } newCenterWeight [ i ] = 0.0 ; } Iterator < double [ ] > lIter = input . iterator ( ) ; for ( int l = 0 ; l < size ; l ++ ) { // Calculates the distance from all points to all centroids double [ ] point = lIter . next ( ) ; assert ( d == point . length - 1 ) ; double minDistance = Double . POSITIVE_INFINITY ; int closestCluster = - 1 ; for ( int i = 0 ; i < k ; i ++ ) { double distance = Metric . distance ( center [ i ] , point , 1 ) ; if ( distance < minDistance ) { closestCluster = i ; minDistance = distance ; } } // Sums up all points for the new centroids assert ( closestCluster >= 0 && closestCluster < k ) ; for ( int j = 0 ; j < d ; j ++ ) { newCenter [ closestCluster ] [ j ] += point [ 0 ] * point [ j + 1 ] ; } newCenterWeight [ closestCluster ] += point [ 0 ] ; nearestCluster [ l ] = closestCluster ; } // Calculates the new centroids converged = true ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < d ; j ++ ) { if ( newCenterWeight [ i ] != 0.0 ) { double newValue = newCenter [ i ] [ j ] / newCenterWeight [ i ] ; if ( newValue != center [ i ] [ j ] ) { converged = false ; } center [ i ] [ j ] = newValue ; } } } } while ( ! converged ) ; // Replaces the old centroids with the new ones for ( int i = 0 ; i < k ; i ++ ) { centroids . set ( i , center [ i ] ) ; } // Calculates the costs of the solution double costs = 0.0 ; Iterator < double [ ] > lIter = input . iterator ( ) ; for ( int l = 0 ; l < size ; l ++ ) { double [ ] point = lIter . next ( ) ; costs += point [ 0 ] * Metric . distanceSquared ( center [ nearestCluster [ l ] ] , point , 1 ) ; } return costs ; }
public ExtractResult extract ( String content , String selector , int amount ) { List < Element > extracted = extractElements ( content , selector , amount ) ; if ( extracted . size ( ) > 1 ) { // first element is the remaining body, the rest are extracted Element body = extracted . get ( 0 ) ; List < Element > elements = extracted . subList ( 1 , extracted . size ( ) ) ; // convert to HTML List < String > elementStr = new ArrayList < String > ( ) ; for ( Element el : elements ) { elementStr . add ( el . outerHtml ( ) ) ; } return new DefaultExtractResult ( elementStr , body . html ( ) ) ; } else { // nothing to extract return new DefaultExtractResult ( Collections . < String > emptyList ( ) , content ) ; } }
@ Override public String getRequestValue ( final Request request ) { if ( isPresent ( request ) ) { // User entered a valid date String dateParam = request . getParameter ( getId ( ) + "-date" ) ; if ( dateParam == null ) { return null ; } // Validate Transfer Date Format - YYYY-MM-DD if ( dateParam . length ( ) != INTERNAL_DATE_TOTAL_CHARS || dateParam . charAt ( INTERNAL_DASH1_POS ) != ' ' || dateParam . charAt ( INTERNAL_DASH2_POS ) != ' ' ) { LOG . warn ( "Date parameter is not in the format yyyy-MM-dd (" + dateParam + ") and will be treated as null." ) ; return null ; } // Transform YYYY-MM-DD to YYYYMMDD StringBuffer buf = new StringBuffer ( DATE_TOTAL_CHARS ) ; buf . append ( dateParam . substring ( INTERNAL_YEAR_START , INTERNAL_YEAR_END ) ) ; buf . append ( dateParam . substring ( INTERNAL_MONTH_START , INTERNAL_MONTH_END ) ) ; buf . append ( dateParam . substring ( INTERNAL_DAY_START , INTERNAL_DAY_END ) ) ; String dateFormat = buf . toString ( ) ; // Validate the date if ( ! isValidPartialDateStringFormat ( dateFormat , THEME_PADDING_CHAR ) ) { LOG . warn ( "Date parameter (" + dateParam + ") could not be transformed from YYYY-MM-DD to the format YYYYMMDD and will be treated as null." ) ; return null ; } // Convert from Theme padding character to the correct padding character return dateFormat . replace ( THEME_PADDING_CHAR , getPaddingChar ( ) ) ; } else { return getValue ( ) ; } }
static public double probability ( ContinuousDistribution distribution , Number x ) { if ( distribution instanceof GaussianDistribution ) { return probability ( ( GaussianDistribution ) distribution , x ) ; } else if ( distribution instanceof PoissonDistribution ) { return probability ( ( PoissonDistribution ) distribution , x ) ; } throw new UnsupportedElementException ( distribution ) ; }
public static String htmlDecode ( final String encodedHtml ) { validate ( encodedHtml , NULL_STRING_PREDICATE , NULL_STRING_MSG_SUPPLIER ) ; String [ ] entities = encodedHtml . split ( "&\\\\W+;" ) ; return Arrays . stream ( entities ) . map ( e -> HtmlEntities . decodedEntities . get ( e ) ) . collect ( joining ( ) ) ; }
private Date toDate ( final String pStringDate ) { // weird manipulation to parse the date... remove ':' from the timezone // before: 2011-07-12T22:42:40.000+02:00 // after: 2011-07-12T22:42:40.000+0200 final StringBuilder _date = new StringBuilder ( ) ; _date . append ( pStringDate . substring ( 0 , pStringDate . length ( ) - 3 ) ) ; _date . append ( pStringDate . substring ( pStringDate . length ( ) - 2 ) ) ; try { return new SimpleDateFormat ( RFC_339_DATE_FORMAT ) . parse ( _date . toString ( ) ) ; } catch ( final ParseException e ) { throw new IllegalArgumentException ( "The given spreadsheet ListEntry usercrashdate field value is malformed" , e ) ; } }
public String jsonToXml ( String json ) { String xml = "" ; // \u8655\u7406\u76f4\u63a5\u4ee5\u9663\u5217\u958b\u982d\u7684JSON\uff0c\u4e26\u6307\u5b9a\u7d66\u4e88 row \u7684 tag if ( "[" . equals ( json . substring ( 0 , 1 ) ) ) { xml = XML . toString ( new JSONArray ( json ) , "row" ) ; } else { xml = XML . toString ( new JSONObject ( json ) ) ; } return xml ; }
public void csv ( String file ) throws IOException { CsvWriteOptions options = CsvWriteOptions . builder ( file ) . build ( ) ; new CsvWriter ( ) . write ( table , options ) ; }
static String urlencode ( final String s ) { try { return URLEncoder . encode ( s , CHARSET_NAME ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }
public static String getHttpStatusCodeText ( int sc ) { HttpStatusCode sCode = HttpStatusCode . fromNumStatusCode ( sc ) ; if ( sCode == null ) { return sc + " <unknown status code>" ; } else { return sCode . toString ( ) ; } }
protected PlotCanvas paintOnCanvas ( double [ ] [ ] data , int [ ] label ) { PlotCanvas canvas = ScatterPlot . plot ( data , pointLegend ) ; for ( int i = 0 ; i < data . length ; i ++ ) { canvas . point ( pointLegend , Palette . COLORS [ label [ i ] ] , data [ i ] ) ; } return canvas ; }
@ SuppressWarnings ( "unchecked" ) public final T [ ] filter ( final T [ ] objects ) { final Collection < T > filtered = filter ( Arrays . asList ( objects ) ) ; try { return filtered . toArray ( ( T [ ] ) Array . newInstance ( objects . getClass ( ) , filtered . size ( ) ) ) ; } catch ( ArrayStoreException ase ) { Logger log = LoggerFactory . getLogger ( Filter . class ) ; log . warn ( "Error converting to array - using default approach" , ase ) ; } return ( T [ ] ) filtered . toArray ( ) ; }
public static String replaceHtmlEntities ( String content , Map < String , Character > map ) { for ( Entry < String , Character > entry : escapeStrings . entrySet ( ) ) { if ( content . indexOf ( entry . getKey ( ) ) != - 1 ) { content = content . replace ( entry . getKey ( ) , String . valueOf ( entry . getValue ( ) ) ) ; } } return content ; }
public static void extractZip ( InputStream zip , final File toDir ) throws IOException { if ( ! toDir . exists ( ) ) { throw new IOException ( "Directory '" + toDir + "' does not exist." ) ; } // Use the ZipFileVisitor to walk all the entries in the Zip-Stream and create // directories and files accordingly new ZipFileVisitor ( ) { @ Override public void visit ( ZipEntry entry , InputStream data ) throws IOException { File target = new File ( toDir , entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { // Assume directories are stored parents first then children. //logger.info("Extracting directory: " + entry.getName() + " to " + target); // This is not robust, just for demonstration purposes. if ( ! target . mkdirs ( ) ) { logger . warning ( "Could not create directory " + target ) ; } return ; } // zips can contain nested files in sub-dirs without separate entries for the directories if ( ! target . getParentFile ( ) . exists ( ) && ! target . getParentFile ( ) . mkdirs ( ) ) { logger . warning ( "Could not create directory " + target . getParentFile ( ) ) ; } // it seems we cannot use IOUtils/FileUtils to copy as they close the stream int size ; byte [ ] buffer = new byte [ 2048 ] ; try ( OutputStream fout = new BufferedOutputStream ( new FileOutputStream ( target ) , buffer . length ) ) { while ( ( size = data . read ( buffer , 0 , buffer . length ) ) != - 1 ) { fout . write ( buffer , 0 , size ) ; } } } } . walk ( zip ) ; }
public static String getClipboardText ( final Context context ) { final ClipboardManager clipboard = ( ClipboardManager ) context . getSystemService ( Context . CLIPBOARD_SERVICE ) ; final ClipData clipData = clipboard . getPrimaryClip ( ) ; if ( clipData != null && clipData . getItemCount ( ) > 0 ) { final CharSequence clipboardText = clipData . getItemAt ( 0 ) . getText ( ) ; if ( clipboardText != null ) { return clipboardText . toString ( ) ; } } return null ; }
public static void zipCompress ( String filename ) throws IOException { FileOutputStream fos = new FileOutputStream ( filename + COMPRESSION_SUFFIX ) ; CheckedOutputStream csum = new CheckedOutputStream ( fos , new CRC32 ( ) ) ; ZipOutputStream out = new ZipOutputStream ( new BufferedOutputStream ( csum ) ) ; out . setComment ( "Failmon records." ) ; BufferedReader in = new BufferedReader ( new FileReader ( filename ) ) ; out . putNextEntry ( new ZipEntry ( new File ( filename ) . getName ( ) ) ) ; int c ; while ( ( c = in . read ( ) ) != - 1 ) out . write ( c ) ; in . close ( ) ; out . finish ( ) ; out . close ( ) ; }
private void updateCoordinates ( ) { // Top-left of heat map. int x = margin + axisThickness + yAxisLabelSize . height ; x += ( yValuesHorizontal ? yAxisValuesWidthMax : yAxisValuesHeight ) ; int y = titleSize . height + margin ; heatMapTL = new Point ( x , y ) ; // Top-right of heat map. x = heatMapTL . x + heatMapSize . width ; y = heatMapTL . y + heatMapSize . height ; heatMapBR = new Point ( x , y ) ; // Centre of heat map. x = heatMapTL . x + ( heatMapSize . width / 2 ) ; y = heatMapTL . y + ( heatMapSize . height / 2 ) ; heatMapC = new Point ( x , y ) ; }
public static String reverse ( String string ) { if ( string != null ) { return new StringBuilder ( string ) . reverse ( ) . toString ( ) ; } return null ; }
public static < T > List < T > randomSample ( Collection < T > collection , int n ) { List < T > list = new ArrayList < T > ( collection ) ; List < T > sample = new ArrayList < T > ( n ) ; Random random = new Random ( ) ; while ( n > 0 && ! list . isEmpty ( ) ) { int index = random . nextInt ( list . size ( ) ) ; sample . add ( list . get ( index ) ) ; int indexLast = list . size ( ) - 1 ; T last = list . remove ( indexLast ) ; if ( index < indexLast ) { list . set ( index , last ) ; } n -- ; } return sample ; }
public static < V extends NumberVector > double logLikelihoodZhao ( Relation < V > relation , Clustering < ? extends MeanModel > clustering , NumberVectorDistanceFunction < ? super V > distanceFunction ) { List < ? extends Cluster < ? extends MeanModel > > clusters = clustering . getAllClusters ( ) ; // number of clusters final int m = clusters . size ( ) ; // number of objects in the clustering int n = 0 ; // cluster sizes int [ ] n_i = new int [ m ] ; // variances double [ ] d_i = new double [ m ] ; // Iterate over clusters: Iterator < ? extends Cluster < ? extends MeanModel > > it = clusters . iterator ( ) ; for ( int i = 0 ; it . hasNext ( ) ; ++ i ) { Cluster < ? extends MeanModel > cluster = it . next ( ) ; n += n_i [ i ] = cluster . size ( ) ; // Note: the paper used 1/(n-m) but that is probably a typo // as it will cause divisions by zero. d_i [ i ] = varianceOfCluster ( cluster , distanceFunction , relation ) / ( double ) n_i [ i ] ; } final int dim = RelationUtil . dimensionality ( relation ) ; // log likelihood of this clustering double logLikelihood = 0. ; // Aggregate for ( int i = 0 ; i < m ; i ++ ) { logLikelihood += n_i [ i ] * FastMath . log ( n_i [ i ] / ( double ) n ) // ni log ni/n - n_i [ i ] * dim * .5 * MathUtil . LOGTWOPI // ni*d/2 log2pi - n_i [ i ] * .5 * FastMath . log ( d_i [ i ] ) // ni/2 log sigma_i - ( n_i [ i ] - m ) * .5 ; // (ni-m)/2 } return logLikelihood ; }
private List < File > unzipCorpus ( File outDir , ZipFile zip ) { List < File > rootDirs = new ArrayList < > ( ) ; Enumeration < ? extends ZipEntry > zipEnum = zip . entries ( ) ; while ( zipEnum . hasMoreElements ( ) ) { ZipEntry e = zipEnum . nextElement ( ) ; File outFile = new File ( outDir , e . getName ( ) . replaceAll ( "\\\\/" , "/" ) ) ; if ( e . isDirectory ( ) ) { if ( ! outFile . mkdirs ( ) ) { log . warn ( "Could not create output directory " + outFile . getAbsolutePath ( ) ) ; } } // end if directory else { if ( "corpus.tab" . equals ( outFile . getName ( ) ) || "corpus.annis" . equals ( outFile . getName ( ) ) ) { rootDirs . add ( outFile . getParentFile ( ) ) ; } if ( ! outFile . getParentFile ( ) . isDirectory ( ) ) { if ( ! outFile . getParentFile ( ) . mkdirs ( ) ) { { log . warn ( "Could not create output directory for file " + outFile . getAbsolutePath ( ) ) ; } } } try ( FileOutputStream outStream = new FileOutputStream ( outFile ) ; ) { ByteStreams . copy ( zip . getInputStream ( e ) , outStream ) ; } catch ( FileNotFoundException ex ) { log . error ( null , ex ) ; } catch ( IOException ex ) { log . error ( null , ex ) ; } } // end else is file } // end for each entry in zip file return rootDirs ; }
public static < T > T [ ] filter ( T array [ ] , Filter < T > filter ) { List < T > filteredList = new ArrayList < T > ( array . length ) ; for ( T element : array ) { if ( filter . select ( element ) ) filteredList . add ( element ) ; } @ SuppressWarnings ( "unchecked" ) T filteredArray [ ] = ( T [ ] ) Array . newInstance ( array . getClass ( ) . getComponentType ( ) , filteredList . size ( ) ) ; return filteredList . toArray ( filteredArray ) ; }
public T deserialize ( JsonReader reader , JsonDeserializationContext ctx ) throws JsonDeserializationException { return deserialize ( reader , ctx , JsonDeserializerParameters . DEFAULT ) ; }
public static File getExecutableLocation ( final String exeName ) { // // must add current working directory to the // from of the path from the "path" environment variable final File currentDir = new File ( System . getProperty ( "user.dir" ) ) ; if ( new File ( currentDir , exeName ) . exists ( ) ) { return currentDir ; } final File [ ] envPath = CUtil . getPathFromEnvironment ( "PATH" , File . pathSeparator ) ; for ( final File element : envPath ) { if ( new File ( element , exeName ) . exists ( ) ) { return element ; } } return null ; }
public void parse ( File file ) throws UpdateException { LOGGER . debug ( "Parsing " + file . getName ( ) ) ; try ( InputStream fin = new FileInputStream ( file ) ; InputStream in = new GZIPInputStream ( fin ) ; InputStreamReader isr = new InputStreamReader ( in , UTF_8 ) ; JsonReader reader = new JsonReader ( isr ) ) { final Gson gson = new GsonBuilder ( ) . create ( ) ; reader . beginObject ( ) ; while ( reader . hasNext ( ) && ! JsonToken . BEGIN_ARRAY . equals ( reader . peek ( ) ) ) { reader . skipValue ( ) ; } reader . beginArray ( ) ; while ( reader . hasNext ( ) ) { final DefCveItem cve = gson . fromJson ( reader , DefCveItem . class ) ; //cve.getCve().getCVEDataMeta().getSTATE(); if ( testCveCpeStartWithFilter ( cve ) ) { cveDB . updateVulnerability ( cve ) ; } } } catch ( FileNotFoundException ex ) { LOGGER . error ( ex . getMessage ( ) ) ; throw new UpdateException ( "Unable to find the NVD CPE file, `" + file + "`, to parse" , ex ) ; } catch ( IOException ex ) { LOGGER . error ( "Error reading NVD JSON data: {}" , file ) ; LOGGER . debug ( "Error extracting the NVD JSON data from: " + file . toString ( ) , ex ) ; throw new UpdateException ( "Unable to find the NVD CPE file to parse" , ex ) ; } }
public String generateBsn ( ) { String Result1 = "" ; int Nr9 = randomUtil . random ( 3 ) ; int Nr8 = randomUtil . random ( 10 ) ; int Nr7 = randomUtil . random ( 10 ) ; int Nr6 = randomUtil . random ( 10 ) ; int Nr5 = randomUtil . random ( 10 ) ; int Nr4 = randomUtil . random ( 10 ) ; int Nr3 = randomUtil . random ( 10 ) ; int Nr2 = randomUtil . random ( 10 ) ; int Nr1 = 0 ; int SofiNr = 0 ; if ( ( Nr9 == 0 ) && ( Nr8 == 0 ) && ( Nr7 == 0 ) ) { Nr8 = 1 ; } SofiNr = 9 * Nr9 + 8 * Nr8 + 7 * Nr7 + 6 * Nr6 + 5 * Nr5 + 4 * Nr4 + 3 * Nr3 + 2 * Nr2 ; Nr1 = floor ( SofiNr - ( floor ( SofiNr / 11 ) ) * 11 ) ; if ( Nr1 > 9 ) { if ( Nr2 > 0 ) { Nr2 -= 1 ; Nr1 = 8 ; } else { Nr2 += 1 ; Nr1 = 1 ; } } Result1 += Nr9 ; Result1 += Nr8 ; Result1 += Nr7 ; Result1 += Nr6 ; Result1 += Nr5 ; Result1 += Nr4 ; Result1 += Nr3 ; Result1 += Nr2 ; Result1 += Nr1 ; return Result1 ; }
@ Override public EventRequest deserialize ( JsonElement json , Type typeOfT , JsonDeserializationContext context ) throws JsonParseException { Gson gson = new GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . create ( ) ; // API versions 2017-05-25 and earlier render `request` as a string // instead of a JSON object if ( json . isJsonPrimitive ( ) ) { EventRequest request = new EventRequest ( ) ; request . setId ( json . getAsString ( ) ) ; return request ; } else { return gson . fromJson ( json , typeOfT ) ; } }
private static String coerceToEpoch ( String s ) { Long epoch = parseEpochSecond ( s ) ; if ( epoch != null ) { return String . valueOf ( epoch ) ; } SimpleDateFormat format = new SimpleDateFormat ( "yyyy-MM-dd'T'HH:mm:ssZ" ) ; try { return String . valueOf ( format . parse ( s ) . getTime ( ) ) ; } catch ( ParseException ex ) { return s ; } }
private static String getHttpOnlyCookieHeader ( Cookie cookie ) { NewCookie newCookie = new NewCookie ( cookie . getName ( ) , cookie . getValue ( ) , cookie . getPath ( ) , cookie . getDomain ( ) , cookie . getVersion ( ) , cookie . getComment ( ) , cookie . getMaxAge ( ) , cookie . getSecure ( ) ) ; return newCookie + "; HttpOnly" ; }
static public double probability ( ContinuousDistribution distribution , Number x ) { if ( distribution instanceof GaussianDistribution ) { return probability ( ( GaussianDistribution ) distribution , x ) ; } else if ( distribution instanceof PoissonDistribution ) { return probability ( ( PoissonDistribution ) distribution , x ) ; } throw new UnsupportedElementException ( distribution ) ; }
public static < T > Observable < T > map ( Observable < ? > fromObservable , final T toValue ) { if ( fromObservable != null ) { return fromObservable . subscribeOn ( Schedulers . io ( ) ) . map ( new RXMapper < T > ( toValue ) ) ; } else { return Observable . empty ( ) ; } }
public boolean isCheckBoxChecked ( String text ) { if ( config . commandLogging ) { Log . d ( config . commandLoggingTag , "isCheckBoxChecked(\\"" + text + "\\")" ) ; } return checker . isButtonChecked ( CheckBox . class , text ) ; }
public boolean copyTopicsToClipboard ( final boolean cut , @ Nonnull @ MustNotContainNull final Topic ... topics ) { boolean result = false ; if ( this . lockIfNotDisposed ( ) ) { try { if ( topics . length > 0 ) { final Clipboard clipboard = Toolkit . getDefaultToolkit ( ) . getSystemClipboard ( ) ; clipboard . setContents ( new MMDTopicsTransferable ( topics ) , this ) ; if ( cut ) { deleteTopics ( true , ensureNoRootInArray ( topics ) ) ; } result = true ; } } finally { this . unlock ( ) ; } } return result ; }
public StringBuffer append ( Reader source , StringBuffer buffer ) throws IOException { BufferedReader _bufferedReader = new BufferedReader ( source ) ; char [ ] _buffer = new char [ getBufferSize ( ) ] ; // load by chunk of 4 ko try { for ( int _countReadChars = 0 ; _countReadChars >= 0 ; ) { buffer . append ( _buffer , 0 , _countReadChars ) ; _countReadChars = _bufferedReader . read ( _buffer ) ; } } finally { _bufferedReader . close ( ) ; } return buffer ; }
@ Override public void write ( byte [ ] data , int offset , int length ) throws IllegalStateException , IOException { // validate state if ( isClosed ( ) ) { throw new IllegalStateException ( "Serial connection is not open; cannot 'write()'." ) ; } // write serial data to transmit buffer com . pi4j . jni . Serial . write ( fileDescriptor , data , offset , length ) ; }
public static < T > Collection < List < T > > permutations ( Collection < T > elements ) { Collection < List < T >> result = new ArrayList < > ( ) ; if ( elements . isEmpty ( ) ) { result . add ( new LinkedList < > ( ) ) ; return result ; } List < T > rest = new LinkedList < > ( elements ) ; T head = rest . remove ( 0 ) ; for ( List < T > permutations : permutations ( rest ) ) { List < List < T >> subLists = new ArrayList < > ( ) ; for ( int i = 0 ; i <= permutations . size ( ) ; i ++ ) { List < T > subList = new ArrayList < > ( ) ; subList . addAll ( permutations ) ; subList . add ( i , head ) ; subLists . add ( subList ) ; } result . addAll ( subLists ) ; } return result ; }
private void replaceInFile ( String oldText , String newText ) { StringBuilder oldContent = new StringBuilder ( ) ; try ( FileReader fr = new FileReader ( file ) ; BufferedReader reader = new BufferedReader ( fr ) ) { String line ; while ( ( line = reader . readLine ( ) ) != null ) { oldContent . append ( line ) ; oldContent . append ( "\\r\\n" ) ; } } catch ( IOException e ) { log . error ( e ) ; } // replace a word in a file String newContent = oldContent . toString ( ) . replaceAll ( oldText , newText ) ; try ( FileWriter writer = new FileWriter ( file ) ) { writer . write ( newContent ) ; } catch ( IOException ioe ) { log . error ( ioe ) ; } }
public static Date getDay ( String string ) { if ( string == null ) { return null ; } Date date = null ; try { date = ( new SimpleDateFormat ( "dd-MMM-yyyy" ) . parse ( string ) ) ; } catch ( ParseException ex ) { return null ; } return date ; }
public void exportObjects2Excel ( List < ? > data , List < String > header , String sheetName , boolean isXSSF , OutputStream os ) throws IOException { try ( Workbook workbook = exportExcelBySimpleHandler ( data , header , sheetName , isXSSF ) ) { workbook . write ( os ) ; } }
private CommandLine parseArgs ( String [ ] args ) throws ParseException { final CommandLineParser parser = new DefaultParser ( ) ; final Options options = createCommandLineOptions ( ) ; return parser . parse ( options , args ) ; }
private CFile parseCFile ( JSONObject jObj ) { CFile cfile ; if ( jObj . optBoolean ( "is_dir" , false ) ) { cfile = new CFolder ( new CPath ( jObj . getString ( "path" ) ) ) ; } else { cfile = new CBlob ( new CPath ( jObj . getString ( "path" ) ) , jObj . getLong ( "bytes" ) , jObj . getString ( "mime_type" ) ) ; String stringDate = jObj . getString ( "modified" ) ; try { // stringDate looks like: "Fri, 07 Mar 2014 17:47:55 +0000" SimpleDateFormat sdf = new SimpleDateFormat ( "EEE, dd MMM yyyy HH:mm:ss Z" , Locale . US ) ; Date modified = sdf . parse ( stringDate ) ; cfile . setModificationDate ( modified ) ; } catch ( ParseException ex ) { throw new CStorageException ( "Can't parse date modified: " + stringDate + " (" + ex . getMessage ( ) + ")" , ex ) ; } } return cfile ; }
private static void summarizeNBModel ( ModelSummary summary , hex . nb . NBModel model ) { // add generic fields such as column names summarizeModelCommonFields ( summary , model ) ; summary . model_algorithm = "Naive Bayes" ; JsonObject all_params = ( model . get_params ( ) ) . toJSON ( ) ; summary . critical_parameters = whitelistJsonObject ( all_params , NB_critical_params ) ; summary . secondary_parameters = whitelistJsonObject ( all_params , NB_secondary_params ) ; summary . expert_parameters = whitelistJsonObject ( all_params , NB_expert_params ) ; }
private static JSONObject doPostRequest ( HttpPost httpPost , HashMap < String , String > params ) throws JSONException { JSONObject json = null ; HttpClient postClient = HttpClientBuilder . create ( ) . build ( ) ; HttpResponse response ; try { response = postClient . execute ( httpPost ) ; if ( response . getStatusLine ( ) . getStatusCode ( ) == 200 ) { HttpEntity entity = response . getEntity ( ) ; if ( entity != null ) { InputStream instream = entity . getContent ( ) ; String result = convertStreamToString ( instream ) ; instream . close ( ) ; json = new JSONObject ( result ) ; } } else { json = UpworkRestClient . genError ( response ) ; } } catch ( ClientProtocolException e ) { json = UpworkRestClient . genError ( HTTP_RESPONSE_503 , "Exception: ClientProtocolException" ) ; } catch ( IOException e ) { json = UpworkRestClient . genError ( HTTP_RESPONSE_503 , "Exception: IOException" ) ; } catch ( JSONException e ) { json = UpworkRestClient . genError ( HTTP_RESPONSE_503 , "Exception: JSONException" ) ; } catch ( Exception e ) { json = UpworkRestClient . genError ( HTTP_RESPONSE_503 , "Exception: Exception " + e . toString ( ) ) ; } finally { httpPost . abort ( ) ; } return json ; }
public static Object deserialize ( String json , TypeReference < ? > typeReference ) throws SerializationException { try { logger . debug ( "Json string to deserialize {} " , json ) ; return mapper . readValue ( json , typeReference ) ; } catch ( IOException e ) { logger . error ( "SerializationException {}" , e . getMessage ( ) ) ; SerializationException serializationException = new SerializationException ( e ) ; throw serializationException ; } }
public ScatterPlot points ( String id , double [ ] [ ] data , Color color ) { if ( data [ 0 ] . length != base . dimension ) { throw new IllegalArgumentException ( "Invalid data dimension: " + data [ 0 ] . length ) ; } double [ ] lowerBound = Math . colMin ( data ) ; double [ ] upperBound = Math . colMax ( data ) ; extendBound ( lowerBound , upperBound ) ; ScatterPlot plot = new ScatterPlot ( data ) ; plot . setID ( id ) ; plot . setColor ( color ) ; add ( plot ) ; return plot ; }
private static String reverseString ( String in ) { StringBuilder out = new StringBuilder ( in ) . reverse ( ) ; return out . toString ( ) ; }
public synchronized void save ( ) { if ( BulkChange . contains ( this ) ) { return ; } File file = getConfigFile ( ) ; try { List < String > allSignatures = new ArrayList < > ( whitelistSignaturesFromUserControlledList ) ; blacklistSignaturesFromUserControlledList . stream ( ) . map ( signature -> "!" + signature ) . forEach ( allSignatures :: add ) ; FileUtils . writeLines ( file , allSignatures ) ; } catch ( IOException e ) { LOGGER . log ( Level . WARNING , "Failed to save " + file . getAbsolutePath ( ) , e ) ; } }
public static HttpRequest head ( final CharSequence baseUrl , final Map < ? , ? > params , final boolean encode ) { String url = append ( baseUrl , params ) ; return head ( encode ? encode ( url ) : url ) ; }
public static void copy ( Path sourcePath , Path targetPath , boolean executable ) throws IOException { // we unwrap the file system to get raw streams without safety net FileSystem sFS = FileSystem . getUnguardedFileSystem ( sourcePath . toUri ( ) ) ; FileSystem tFS = FileSystem . getUnguardedFileSystem ( targetPath . toUri ( ) ) ; if ( ! tFS . exists ( targetPath ) ) { if ( sFS . getFileStatus ( sourcePath ) . isDir ( ) ) { internalCopyDirectory ( sourcePath , targetPath , executable , sFS , tFS ) ; } else { internalCopyFile ( sourcePath , targetPath , executable , sFS , tFS ) ; } } }
public static double similarLevenshtein ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) { return 1.0 ; } // Make sure s1 is the longest string if ( s1 . length ( ) < s2 . length ( ) ) { String swap = s1 ; s1 = s2 ; s2 = swap ; } int bigLength = s1 . length ( ) ; return ( bigLength - StringUtils . getLevenshteinDistance ( s2 , s1 ) ) / ( double ) bigLength ; }
private byte [ ] recv ( Socket socket , int flags ) { Utils . checkArgument ( socket != null , "socket parameter must not be null" ) ; data = socket . recv ( flags ) ; more = socket . hasReceiveMore ( ) ; return data ; }
private Date toDate ( final String pStringDate ) { // weird manipulation to parse the date... remove ':' from the timezone // before: 2011-07-12T22:42:40.000+02:00 // after: 2011-07-12T22:42:40.000+0200 final StringBuilder _date = new StringBuilder ( ) ; _date . append ( pStringDate . substring ( 0 , pStringDate . length ( ) - 3 ) ) ; _date . append ( pStringDate . substring ( pStringDate . length ( ) - 2 ) ) ; try { return new SimpleDateFormat ( RFC_339_DATE_FORMAT ) . parse ( _date . toString ( ) ) ; } catch ( final ParseException e ) { throw new IllegalArgumentException ( "The given spreadsheet ListEntry usercrashdate field value is malformed" , e ) ; } }
public TernaryVector generate ( ) { HashSet < Integer > pos = new HashSet < Integer > ( ) ; HashSet < Integer > neg = new HashSet < Integer > ( ) ; // Randomly decide how many bits to set in the index vector based on the // variance. int bitsToSet = numVectorValues + ( int ) ( RANDOM . nextDouble ( ) * variance * ( ( RANDOM . nextDouble ( ) > .5 ) ? 1 : - 1 ) ) ; for ( int i = 0 ; i < bitsToSet ; ++ i ) { boolean picked = false ; // loop to ensure we actually pick the full number of bits while ( ! picked ) { // pick some random index int index = RANDOM . nextInt ( indexVectorLength ) ; // check that we haven't already added this index if ( pos . contains ( index ) || neg . contains ( index ) ) continue ; // decide positive or negative ( ( RANDOM . nextDouble ( ) > .5 ) ? pos : neg ) . add ( index ) ; picked = true ; } } int [ ] positive = new int [ pos . size ( ) ] ; int [ ] negative = new int [ neg . size ( ) ] ; Iterator < Integer > it = pos . iterator ( ) ; for ( int i = 0 ; i < positive . length ; ++ i ) positive [ i ] = it . next ( ) ; it = neg . iterator ( ) ; for ( int i = 0 ; i < negative . length ; ++ i ) negative [ i ] = it . next ( ) ; // sort so we can use a binary search in getValue() Arrays . sort ( positive ) ; Arrays . sort ( negative ) ; return new TernaryVector ( indexVectorLength , positive , negative ) ; }
protected static Clustering kMeans ( int k , Cluster [ ] centers , List < ? extends Cluster > data ) { assert ( centers . length == k ) ; assert ( k > 0 ) ; int dimensions = centers [ 0 ] . getCenter ( ) . length ; ArrayList < ArrayList < Cluster > > clustering = new ArrayList < ArrayList < Cluster > > ( ) ; for ( int i = 0 ; i < k ; i ++ ) { clustering . add ( new ArrayList < Cluster > ( ) ) ; } while ( true ) { // Assign points to clusters for ( Cluster point : data ) { double minDistance = distance ( point . getCenter ( ) , centers [ 0 ] . getCenter ( ) ) ; int closestCluster = 0 ; for ( int i = 1 ; i < k ; i ++ ) { double distance = distance ( point . getCenter ( ) , centers [ i ] . getCenter ( ) ) ; if ( distance < minDistance ) { closestCluster = i ; minDistance = distance ; } } clustering . get ( closestCluster ) . add ( point ) ; } // Calculate new centers and clear clustering lists SphereCluster [ ] newCenters = new SphereCluster [ centers . length ] ; for ( int i = 0 ; i < k ; i ++ ) { newCenters [ i ] = calculateCenter ( clustering . get ( i ) , dimensions ) ; clustering . get ( i ) . clear ( ) ; } // Convergence check boolean converged = true ; for ( int i = 0 ; i < k ; i ++ ) { if ( ! Arrays . equals ( centers [ i ] . getCenter ( ) , newCenters [ i ] . getCenter ( ) ) ) { converged = false ; break ; } } if ( converged ) { break ; } else { centers = newCenters ; } } return new Clustering ( centers ) ; }
public static double [ ] linearReg ( double [ ] xData , double [ ] yData ) { sameArrayLen ( xData , yData ) ; double sumYValue = 0 ; double meanYValue = 0 ; double sumXValue = 0 ; double meanXValue = 0 ; double sumX = 0 ; double sumY = 0 ; double prod = 0 ; double NODATA = - 9999 ; int nstat = xData . length ; double [ ] regCoef = new double [ 3 ] ; //(intercept, gradient, r?) int counter = 0 ; //calculating sums for ( int i = 0 ; i < nstat ; i ++ ) { if ( ( yData [ i ] != NODATA ) && ( xData [ i ] != NODATA ) ) { sumYValue += yData [ i ] ; sumXValue += xData [ i ] ; counter ++ ; } } //calculating means meanYValue = sumYValue / counter ; meanXValue = sumXValue / counter ; //calculating regression coefficients for ( int i = 0 ; i < nstat ; i ++ ) { if ( ( yData [ i ] != NODATA ) && ( xData [ i ] != NODATA ) ) { sumX += Math . pow ( ( xData [ i ] - meanXValue ) , 2 ) ; sumY += Math . pow ( ( yData [ i ] - meanYValue ) , 2 ) ; prod += ( ( xData [ i ] - meanXValue ) * ( yData [ i ] - meanYValue ) ) ; } } if ( sumX > 0 && sumY > 0 ) { regCoef [ 1 ] = prod / sumX ; //gradient regCoef [ 0 ] = meanYValue - regCoef [ 1 ] * meanXValue ; //intercept regCoef [ 2 ] = Math . pow ( ( prod / Math . sqrt ( sumX * sumY ) ) , 2 ) ; //r? } else { regCoef [ 1 ] = 0 ; regCoef [ 0 ] = 0 ; regCoef [ 2 ] = 0 ; } return regCoef ; }
public static Date getDateWithPrevDays ( int noOfDays ) throws ParseException { Calendar currentDate = Calendar . getInstance ( ) ; currentDate . add ( Calendar . DATE , - noOfDays ) ; SimpleDateFormat formatter = new SimpleDateFormat ( DATE_yyyyMMddTHHmmssSSSZ ) ; String dateNow = formatter . format ( currentDate . getTime ( ) ) ; return getDateFromString ( dateNow ) ; }
public static Cookie createCookie ( String cookieName , @ Sensitive String cookieValue , HttpServletRequest req ) { return createCookie ( cookieName , cookieValue , - 1 , req ) ; }
public static void copyToClipboard ( String string ) { ClipboardContent content = new ClipboardContent ( ) ; content . putString ( string ) ; Clipboard . getSystemClipboard ( ) . setContent ( content ) ; logger . info ( "copy '" + string + "' to clipboard" ) ; }
public static double similarDamerauLevenshtein ( String s1 , String s2 ) { if ( s1 . equals ( s2 ) ) { return 1.0 ; } // Make sure s1 is the longest string if ( s1 . length ( ) < s2 . length ( ) ) { String swap = s1 ; s1 = s2 ; s2 = swap ; } int bigLength = s1 . length ( ) ; return ( bigLength - getDamerauLevenshteinDistance ( s2 , s1 ) ) / ( double ) bigLength ; }
private Properties readPropertyFile ( String file ) throws IOException { String fileName = file . startsWith ( "/" ) ? file : "/" + file ; LOGGER . info ( "Reading properties from: " + fileName + ". Will try classpath, then file system." ) ; return Util . readProperties ( fileName ) ; }
public static byte [ ] decryptAES ( SecretKey key , byte [ ] iv , byte [ ] encryptedBytes ) throws NoSuchPaddingException , NoSuchAlgorithmException , InvalidAlgorithmParameterException , InvalidKeyException , BadPaddingException , IllegalBlockSizeException { Cipher aesCipher = Cipher . getInstance ( "AES/CBC/PKCS5Padding" ) ; IvParameterSpec ivParameter = new IvParameterSpec ( iv ) ; // see http://stackoverflow.com/a/11506343 Key encryptionKey = new SecretKeySpec ( key . getEncoded ( ) , "AES" ) ; aesCipher . init ( Cipher . DECRYPT_MODE , encryptionKey , ivParameter ) ; return aesCipher . doFinal ( encryptedBytes ) ; }
private void generatePdf ( ) { File pdfFile = new File ( directory , filename + ".pdf" ) ; try ( OutputStream os = new FileOutputStream ( pdfFile ) ) { PdfRendererBuilder builder = new PdfRendererBuilder ( ) ; builder . withHtmlContent ( getHtmlForPDFConversion ( ) , "file://" + pdfFile . getAbsolutePath ( ) . replaceAll ( " " , "%20" ) ) ; builder . toStream ( os ) ; builder . run ( ) ; } catch ( Exception e ) { log . error ( e ) ; } }
void section ( int nclusters ) { if ( size ( ) < nclusters ) return ; sectioned_clusters_ = new ArrayList < Cluster < K > > ( nclusters ) ; List < Document > centroids = new ArrayList < Document > ( nclusters ) ; // choose_randomly(nclusters, centroids); choose_smartly ( nclusters , centroids ) ; for ( int i = 0 ; i < centroids . size ( ) ; i ++ ) { Cluster < K > cluster = new Cluster < K > ( ) ; sectioned_clusters_ . add ( cluster ) ; } for ( Document < K > d : documents_ ) { double max_similarity = - 1.0 ; int max_index = 0 ; for ( int j = 0 ; j < centroids . size ( ) ; j ++ ) { double similarity = SparseVector . inner_product ( d . feature ( ) , centroids . get ( j ) . feature ( ) ) ; if ( max_similarity < similarity ) { max_similarity = similarity ; max_index = j ; } } sectioned_clusters_ . get ( max_index ) . add_document ( d ) ; } }
public static Date getCurrentDateTime ( ) throws ParseException { Calendar currentDate = Calendar . getInstance ( ) ; SimpleDateFormat formatter = new SimpleDateFormat ( DATE_yyyyMMddTHHmmssSSSZ ) ; String dateNow = formatter . format ( currentDate . getTime ( ) ) ; return getDateFromString ( dateNow ) ; }
private void postGetConnectionHandling ( Connection conn ) throws SQLException { helper . doConnectionSetup ( conn ) ; String [ ] sqlCommands = dsConfig . get ( ) . onConnect ; if ( sqlCommands != null && sqlCommands . length > 0 ) onConnect ( conn , sqlCommands ) ; // Log the database and driver versions on first getConnection. if ( ! wasUsedToGetAConnection ) { // Wait until after the connection succeeds to set the indicator. // This accounts for the scenario where the first connection attempt is bad. // The information needs to be read again on the second attempt. helper . gatherAndDisplayMetaDataInfo ( conn , this ) ; wasUsedToGetAConnection = true ; } }
public static String reverse ( String str ) { if ( str == null ) { return null ; } return new StringBuffer ( str ) . reverse ( ) . toString ( ) ; }